#!/usr/bin/env node
import {
  __commonJS,
  __require
} from "./chunk-2TUXWMP5.js";

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports2, module2) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module2.exports = EventEmitter;
    module2.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve2, reject2) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject2(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve2([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports2, module2) {
    module2.exports = require_events().EventEmitter;
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports2) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer2;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require_buffer();
    var Buffer2 = _require.Buffer;
    var _require2 = require_util();
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0) this.tail.next = entry;
          else this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;
          else this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0) return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0) return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length) ret += str;
            else ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options2) {
          return inspect(this, _objectSpread(_objectSpread({}, options2), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose) return;
      if (self2._readableState && !self2._readableState.emitClose) return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream2, err) {
      var rState = stream2._readableState;
      var wState = stream2._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream2.destroy(err);
      else stream2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/readable-stream/errors-browser.js"(exports2, module2) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options2, isDuplex, duplexKey) {
      return options2.highWaterMark != null ? options2.highWaterMark : isDuplex ? options2[duplexKey] : null;
    }
    function getHighWaterMark(state, options2, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options2, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/util-deprecate/browser.js
var require_browser = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports2, module2) {
    module2.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!global.localStorage) return false;
      } catch (_) {
        return false;
      }
      var val = global.localStorage[name];
      if (null == val) return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options2, stream2, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options2 = options2 || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options2.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options2, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options2.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream2, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options2.emitClose !== false;
      this.autoDestroy = !!options2.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options2) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options2);
      this._writableState = new WritableState(options2, this, isDuplex);
      this.writable = true;
      if (options2) {
        if (typeof options2.write === "function") this._write = options2.write;
        if (typeof options2.writev === "function") this._writev = options2.writev;
        if (typeof options2.destroy === "function") this._destroy = options2.destroy;
        if (typeof options2.final === "function") this._final = options2.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream2, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream2, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream2, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream2, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ending) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream2, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream2, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream2, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream2._writev(chunk, state.onwrite);
      else stream2._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream2, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream2, state);
        stream2._writableState.errorEmitted = true;
        errorOrDestroy(stream2, er);
      } else {
        cb(er);
        stream2._writableState.errorEmitted = true;
        errorOrDestroy(stream2, er);
        finishMaybe(stream2, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream2, er) {
      var state = stream2._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er) onwriteError(stream2, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream2.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream2, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream2, state, finished, cb);
        } else {
          afterWrite(stream2, state, finished, cb);
        }
      }
    }
    function afterWrite(stream2, state, finished, cb) {
      if (!finished) onwriteDrain(stream2, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream2, state);
    }
    function onwriteDrain(stream2, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream2.emit("drain");
      }
    }
    function clearBuffer(stream2, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream2._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream2, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream2, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream2, state) {
      stream2._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream2, err);
        }
        state.prefinished = true;
        stream2.emit("prefinish");
        finishMaybe(stream2, state);
      });
    }
    function prefinish(stream2, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream2._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream2, state);
        } else {
          state.prefinished = true;
          stream2.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream2, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream2, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream2.emit("finish");
          if (state.autoDestroy) {
            var rState = stream2._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream2.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream2, state, cb) {
      state.ending = true;
      finishMaybe(stream2, state);
      if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream2.once("finish", cb);
      }
      state.ended = true;
      stream2.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits_browser()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options2) {
      if (!(this instanceof Duplex)) return new Duplex(options2);
      Readable.call(this, options2);
      Writable.call(this, options2);
      this.allowHalfOpen = true;
      if (options2) {
        if (options2.readable === false) this.readable = false;
        if (options2.writable === false) this.writable = false;
        if (options2.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended) return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "�";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "�";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "�";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "�";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream2) {
      return stream2.setHeader && typeof stream2.abort === "function";
    }
    function eos(stream2, opts, callback) {
      if (typeof opts === "function") return eos(stream2, null, opts);
      if (!opts) opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream2.readable;
      var writable = opts.writable || opts.writable !== false && stream2.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream2.writable) onfinish();
      };
      var writableEnded = stream2._writableState && stream2._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream2);
      };
      var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream2);
      };
      var onerror = function onerror2(err) {
        callback.call(stream2, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream2._readableState || !stream2._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream2, err);
        }
        if (writable && !writableEnded) {
          if (!stream2._writableState || !stream2._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream2, err);
        }
      };
      var onrequest = function onrequest2() {
        stream2.req.on("finish", onfinish);
      };
      if (isRequest(stream2)) {
        stream2.on("complete", onfinish);
        stream2.on("abort", onclose);
        if (stream2.req) onrequest();
        else stream2.on("request", onrequest);
      } else if (writable && !stream2._writableState) {
        stream2.on("end", onlegacyfinish);
        stream2.on("close", onlegacyfinish);
      }
      stream2.on("end", onend);
      stream2.on("finish", onfinish);
      if (opts.error !== false) stream2.on("error", onerror);
      stream2.on("close", onclose);
      return function() {
        stream2.removeListener("complete", onfinish);
        stream2.removeListener("abort", onclose);
        stream2.removeListener("request", onrequest);
        if (stream2.req) stream2.req.removeListener("finish", onfinish);
        stream2.removeListener("end", onlegacyfinish);
        stream2.removeListener("close", onlegacyfinish);
        stream2.removeListener("finish", onfinish);
        stream2.removeListener("end", onend);
        stream2.removeListener("error", onerror);
        stream2.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve2 = iter[kLastResolve];
      if (resolve2 !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve2(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve2, reject2) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve2(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve2, reject2);
        }, reject2);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve2, reject2) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject2(_this[kError]);
              } else {
                resolve2(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve2, reject2) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject2(err);
            return;
          }
          resolve2(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream2) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream2,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream2._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve2, reject2) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve2;
            iterator[kLastReject] = reject2;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream2, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject2 = iterator[kLastReject];
          if (reject2 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject2(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve2 = iterator[kLastResolve];
        if (resolve2 !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve2(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream2.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports2, module2) {
    module2.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options2, stream2, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options2 = options2 || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options2.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options2, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options2.emitClose !== false;
      this.autoDestroy = !!options2.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options2.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options2.encoding);
        this.encoding = options2.encoding;
      }
    }
    function Readable(options2) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable)) return new Readable(options2);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options2, this, isDuplex);
      this.readable = true;
      if (options2) {
        if (typeof options2.read === "function") this._read = options2.read;
        if (typeof options2.destroy === "function") this._destroy = options2.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream2._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream2, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream2, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) errorOrDestroy(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else addChunk(stream2, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream2, state, chunk, false);
              else maybeReadMore(stream2, state);
            } else {
              addChunk(stream2, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream2, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream2, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream2.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream2);
      }
      maybeReadMore(stream2, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "") this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream2, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream2);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream2);
        }
      }
    }
    function emitReadable(stream2) {
      var state = stream2._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream2);
      }
    }
    function emitReadable_(stream2) {
      var state = stream2._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream2.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream2);
    }
    function maybeReadMore(stream2, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream2, state);
      }
    }
    function maybeReadMore_(stream2, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream2.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream2, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream2, state);
      }
    }
    function resume_(stream2, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream2.read(0);
      }
      state.resumeScheduled = false;
      stream2.emit("resume");
      flow(stream2);
      if (state.flowing && !state.reading) stream2.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream2) {
      var state = stream2._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream2.read() !== null) ;
    }
    Readable.prototype.wrap = function(stream2) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream2.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream2.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream2.pause();
        }
      });
      for (var i in stream2) {
        if (this[i] === void 0 && typeof stream2[i] === "function") {
          this[i] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream2[method].apply(stream2, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream2.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream2) {
      var state = stream2._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream2);
      }
    }
    function endReadableNT(state, stream2) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream2.readable = false;
        stream2.emit("end");
        if (state.autoDestroy) {
          var wState = stream2._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream2.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from_browser();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options2) {
      if (!(this instanceof Transform)) return new Transform(options2);
      Duplex.call(this, options2);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options2) {
        if (typeof options2.transform === "function") this._transform = options2.transform;
        if (typeof options2.flush === "function") this._flush = options2.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream2, er, data) {
      if (er) return stream2.emit("error", er);
      if (data != null)
        stream2.push(data);
      if (stream2._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream2._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream2.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options2) {
      if (!(this instanceof PassThrough)) return new PassThrough(options2);
      Transform.call(this, options2);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err) throw err;
    }
    function isRequest(stream2) {
      return stream2.setHeader && typeof stream2.abort === "function";
    }
    function destroyer(stream2, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream2.on("close", function() {
        closed = true;
      });
      if (eos === void 0) eos = require_end_of_stream();
      eos(stream2, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isRequest(stream2)) return stream2.abort();
        if (typeof stream2.destroy === "function") return stream2.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length) return noop;
      if (typeof streams[streams.length - 1] !== "function") return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream2, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream2, reading, writing, function(err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/readable-stream/readable-browser.js"(exports2, module2) {
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
    exports2.finished = require_end_of_stream();
    exports2.pipeline = require_pipeline();
  }
});

// node_modules/buffer-from/index.js
var require_buffer_from = __commonJS({
  "node_modules/buffer-from/index.js"(exports2, module2) {
    var toString = Object.prototype.toString;
    var isModern = typeof Buffer !== "undefined" && typeof Buffer.alloc === "function" && typeof Buffer.allocUnsafe === "function" && typeof Buffer.from === "function";
    function isArrayBuffer(input) {
      return toString.call(input).slice(8, -1) === "ArrayBuffer";
    }
    function fromArrayBuffer(obj, byteOffset, length) {
      byteOffset >>>= 0;
      var maxLength = obj.byteLength - byteOffset;
      if (maxLength < 0) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (length === void 0) {
        length = maxLength;
      } else {
        length >>>= 0;
        if (length > maxLength) {
          throw new RangeError("'length' is out of bounds");
        }
      }
      return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
    }
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
      }
      return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
    }
    function bufferFrom(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (isArrayBuffer(value)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      return isModern ? Buffer.from(value) : new Buffer(value);
    }
    module2.exports = bufferFrom;
  }
});

// node_modules/typedarray/index.js
var require_typedarray = __commonJS({
  "node_modules/typedarray/index.js"(exports2) {
    var undefined2 = void 0;
    var MAX_ARRAY_LENGTH = 1e5;
    var ECMAScript = /* @__PURE__ */ function() {
      var opts = Object.prototype.toString, ophop = Object.prototype.hasOwnProperty;
      return {
        // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
        Class: function(v) {
          return opts.call(v).replace(/^\[object *|\]$/g, "");
        },
        HasProperty: function(o, p) {
          return p in o;
        },
        HasOwnProperty: function(o, p) {
          return ophop.call(o, p);
        },
        IsCallable: function(o) {
          return typeof o === "function";
        },
        ToInt32: function(v) {
          return v >> 0;
        },
        ToUint32: function(v) {
          return v >>> 0;
        }
      };
    }();
    var LN2 = Math.LN2;
    var abs = Math.abs;
    var floor = Math.floor;
    var log = Math.log;
    var min = Math.min;
    var pow = Math.pow;
    var round = Math.round;
    function configureProperties(obj) {
      if (getOwnPropNames && defineProp) {
        var props = getOwnPropNames(obj), i;
        for (i = 0; i < props.length; i += 1) {
          defineProp(obj, props[i], {
            value: obj[props[i]],
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
      }
    }
    var defineProp;
    if (Object.defineProperty && function() {
      try {
        Object.defineProperty({}, "x", {});
        return true;
      } catch (e) {
        return false;
      }
    }()) {
      defineProp = Object.defineProperty;
    } else {
      defineProp = function(o, p, desc) {
        if (!o === Object(o)) throw new TypeError("Object.defineProperty called on non-object");
        if (ECMAScript.HasProperty(desc, "get") && Object.prototype.__defineGetter__) {
          Object.prototype.__defineGetter__.call(o, p, desc.get);
        }
        if (ECMAScript.HasProperty(desc, "set") && Object.prototype.__defineSetter__) {
          Object.prototype.__defineSetter__.call(o, p, desc.set);
        }
        if (ECMAScript.HasProperty(desc, "value")) {
          o[p] = desc.value;
        }
        return o;
      };
    }
    var getOwnPropNames = Object.getOwnPropertyNames || function(o) {
      if (o !== Object(o)) throw new TypeError("Object.getOwnPropertyNames called on non-object");
      var props = [], p;
      for (p in o) {
        if (ECMAScript.HasOwnProperty(o, p)) {
          props.push(p);
        }
      }
      return props;
    };
    function makeArrayAccessors(obj) {
      if (!defineProp) {
        return;
      }
      if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError("Array too large for polyfill");
      function makeArrayAccessor(index) {
        defineProp(obj, index, {
          "get": function() {
            return obj._getter(index);
          },
          "set": function(v) {
            obj._setter(index, v);
          },
          enumerable: true,
          configurable: false
        });
      }
      var i;
      for (i = 0; i < obj.length; i += 1) {
        makeArrayAccessor(i);
      }
    }
    function as_signed(value, bits) {
      var s = 32 - bits;
      return value << s >> s;
    }
    function as_unsigned(value, bits) {
      var s = 32 - bits;
      return value << s >>> s;
    }
    function packI8(n) {
      return [n & 255];
    }
    function unpackI8(bytes) {
      return as_signed(bytes[0], 8);
    }
    function packU8(n) {
      return [n & 255];
    }
    function unpackU8(bytes) {
      return as_unsigned(bytes[0], 8);
    }
    function packU8Clamped(n) {
      n = round(Number(n));
      return [n < 0 ? 0 : n > 255 ? 255 : n & 255];
    }
    function packI16(n) {
      return [n >> 8 & 255, n & 255];
    }
    function unpackI16(bytes) {
      return as_signed(bytes[0] << 8 | bytes[1], 16);
    }
    function packU16(n) {
      return [n >> 8 & 255, n & 255];
    }
    function unpackU16(bytes) {
      return as_unsigned(bytes[0] << 8 | bytes[1], 16);
    }
    function packI32(n) {
      return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
    }
    function unpackI32(bytes) {
      return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
    }
    function packU32(n) {
      return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
    }
    function unpackU32(bytes) {
      return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
    }
    function packIEEE754(v, ebits, fbits) {
      var bias = (1 << ebits - 1) - 1, s, e, f, ln, i, bits, str, bytes;
      function roundToEven(n) {
        var w = floor(n), f2 = n - w;
        if (f2 < 0.5)
          return w;
        if (f2 > 0.5)
          return w + 1;
        return w % 2 ? w + 1 : w;
      }
      if (v !== v) {
        e = (1 << ebits) - 1;
        f = pow(2, fbits - 1);
        s = 0;
      } else if (v === Infinity || v === -Infinity) {
        e = (1 << ebits) - 1;
        f = 0;
        s = v < 0 ? 1 : 0;
      } else if (v === 0) {
        e = 0;
        f = 0;
        s = 1 / v === -Infinity ? 1 : 0;
      } else {
        s = v < 0;
        v = abs(v);
        if (v >= pow(2, 1 - bias)) {
          e = min(floor(log(v) / LN2), 1023);
          f = roundToEven(v / pow(2, e) * pow(2, fbits));
          if (f / pow(2, fbits) >= 2) {
            e = e + 1;
            f = 1;
          }
          if (e > bias) {
            e = (1 << ebits) - 1;
            f = 0;
          } else {
            e = e + bias;
            f = f - pow(2, fbits);
          }
        } else {
          e = 0;
          f = roundToEven(v / pow(2, 1 - bias - fbits));
        }
      }
      bits = [];
      for (i = fbits; i; i -= 1) {
        bits.push(f % 2 ? 1 : 0);
        f = floor(f / 2);
      }
      for (i = ebits; i; i -= 1) {
        bits.push(e % 2 ? 1 : 0);
        e = floor(e / 2);
      }
      bits.push(s ? 1 : 0);
      bits.reverse();
      str = bits.join("");
      bytes = [];
      while (str.length) {
        bytes.push(parseInt(str.substring(0, 8), 2));
        str = str.substring(8);
      }
      return bytes;
    }
    function unpackIEEE754(bytes, ebits, fbits) {
      var bits = [], i, j, b, str, bias, s, e, f;
      for (i = bytes.length; i; i -= 1) {
        b = bytes[i - 1];
        for (j = 8; j; j -= 1) {
          bits.push(b % 2 ? 1 : 0);
          b = b >> 1;
        }
      }
      bits.reverse();
      str = bits.join("");
      bias = (1 << ebits - 1) - 1;
      s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
      e = parseInt(str.substring(1, 1 + ebits), 2);
      f = parseInt(str.substring(1 + ebits), 2);
      if (e === (1 << ebits) - 1) {
        return f !== 0 ? NaN : s * Infinity;
      } else if (e > 0) {
        return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
      } else if (f !== 0) {
        return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
      } else {
        return s < 0 ? -0 : 0;
      }
    }
    function unpackF64(b) {
      return unpackIEEE754(b, 11, 52);
    }
    function packF64(v) {
      return packIEEE754(v, 11, 52);
    }
    function unpackF32(b) {
      return unpackIEEE754(b, 8, 23);
    }
    function packF32(v) {
      return packIEEE754(v, 8, 23);
    }
    (function() {
      var ArrayBuffer2 = function ArrayBuffer3(length) {
        length = ECMAScript.ToInt32(length);
        if (length < 0) throw new RangeError("ArrayBuffer size is not a small enough positive integer");
        this.byteLength = length;
        this._bytes = [];
        this._bytes.length = length;
        var i;
        for (i = 0; i < this.byteLength; i += 1) {
          this._bytes[i] = 0;
        }
        configureProperties(this);
      };
      exports2.ArrayBuffer = exports2.ArrayBuffer || ArrayBuffer2;
      var ArrayBufferView = function ArrayBufferView2() {
      };
      function makeConstructor(bytesPerElement, pack, unpack) {
        var ctor;
        ctor = function(buffer, byteOffset, length) {
          var array, sequence, i, s;
          if (!arguments.length || typeof arguments[0] === "number") {
            this.length = ECMAScript.ToInt32(arguments[0]);
            if (length < 0) throw new RangeError("ArrayBufferView size is not a small enough positive integer");
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
          } else if (typeof arguments[0] === "object" && arguments[0].constructor === ctor) {
            array = arguments[0];
            this.length = array.length;
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
            for (i = 0; i < this.length; i += 1) {
              this._setter(i, array._getter(i));
            }
          } else if (typeof arguments[0] === "object" && !(arguments[0] instanceof ArrayBuffer2 || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
            sequence = arguments[0];
            this.length = ECMAScript.ToUint32(sequence.length);
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
            for (i = 0; i < this.length; i += 1) {
              s = sequence[i];
              this._setter(i, Number(s));
            }
          } else if (typeof arguments[0] === "object" && (arguments[0] instanceof ArrayBuffer2 || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
            this.buffer = buffer;
            this.byteOffset = ECMAScript.ToUint32(byteOffset);
            if (this.byteOffset > this.buffer.byteLength) {
              throw new RangeError("byteOffset out of range");
            }
            if (this.byteOffset % this.BYTES_PER_ELEMENT) {
              throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
            }
            if (arguments.length < 3) {
              this.byteLength = this.buffer.byteLength - this.byteOffset;
              if (this.byteLength % this.BYTES_PER_ELEMENT) {
                throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
              }
              this.length = this.byteLength / this.BYTES_PER_ELEMENT;
            } else {
              this.length = ECMAScript.ToUint32(length);
              this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            }
            if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
              throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
          this.constructor = ctor;
          configureProperties(this);
          makeArrayAccessors(this);
        };
        ctor.prototype = new ArrayBufferView();
        ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
        ctor.prototype._pack = pack;
        ctor.prototype._unpack = unpack;
        ctor.BYTES_PER_ELEMENT = bytesPerElement;
        ctor.prototype._getter = function(index) {
          if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
          index = ECMAScript.ToUint32(index);
          if (index >= this.length) {
            return undefined2;
          }
          var bytes = [], i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1) {
            bytes.push(this.buffer._bytes[o]);
          }
          return this._unpack(bytes);
        };
        ctor.prototype.get = ctor.prototype._getter;
        ctor.prototype._setter = function(index, value) {
          if (arguments.length < 2) throw new SyntaxError("Not enough arguments");
          index = ECMAScript.ToUint32(index);
          if (index >= this.length) {
            return undefined2;
          }
          var bytes = this._pack(value), i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1) {
            this.buffer._bytes[o] = bytes[i];
          }
        };
        ctor.prototype.set = function(index, value) {
          if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
          var array, sequence, offset, len, i, s, d, byteOffset, byteLength, tmp;
          if (typeof arguments[0] === "object" && arguments[0].constructor === this.constructor) {
            array = arguments[0];
            offset = ECMAScript.ToUint32(arguments[1]);
            if (offset + array.length > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
            byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
            byteLength = array.length * this.BYTES_PER_ELEMENT;
            if (array.buffer === this.buffer) {
              tmp = [];
              for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
                tmp[i] = array.buffer._bytes[s];
              }
              for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
                this.buffer._bytes[d] = tmp[i];
              }
            } else {
              for (i = 0, s = array.byteOffset, d = byteOffset; i < byteLength; i += 1, s += 1, d += 1) {
                this.buffer._bytes[d] = array.buffer._bytes[s];
              }
            }
          } else if (typeof arguments[0] === "object" && typeof arguments[0].length !== "undefined") {
            sequence = arguments[0];
            len = ECMAScript.ToUint32(sequence.length);
            offset = ECMAScript.ToUint32(arguments[1]);
            if (offset + len > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
            for (i = 0; i < len; i += 1) {
              s = sequence[i];
              this._setter(offset + i, Number(s));
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
        };
        ctor.prototype.subarray = function(start, end) {
          function clamp(v, min2, max) {
            return v < min2 ? min2 : v > max ? max : v;
          }
          start = ECMAScript.ToInt32(start);
          end = ECMAScript.ToInt32(end);
          if (arguments.length < 1) {
            start = 0;
          }
          if (arguments.length < 2) {
            end = this.length;
          }
          if (start < 0) {
            start = this.length + start;
          }
          if (end < 0) {
            end = this.length + end;
          }
          start = clamp(start, 0, this.length);
          end = clamp(end, 0, this.length);
          var len = end - start;
          if (len < 0) {
            len = 0;
          }
          return new this.constructor(
            this.buffer,
            this.byteOffset + start * this.BYTES_PER_ELEMENT,
            len
          );
        };
        return ctor;
      }
      var Int8Array2 = makeConstructor(1, packI8, unpackI8);
      var Uint8Array2 = makeConstructor(1, packU8, unpackU8);
      var Uint8ClampedArray2 = makeConstructor(1, packU8Clamped, unpackU8);
      var Int16Array2 = makeConstructor(2, packI16, unpackI16);
      var Uint16Array2 = makeConstructor(2, packU16, unpackU16);
      var Int32Array2 = makeConstructor(4, packI32, unpackI32);
      var Uint32Array2 = makeConstructor(4, packU32, unpackU32);
      var Float32Array2 = makeConstructor(4, packF32, unpackF32);
      var Float64Array2 = makeConstructor(8, packF64, unpackF64);
      exports2.Int8Array = exports2.Int8Array || Int8Array2;
      exports2.Uint8Array = exports2.Uint8Array || Uint8Array2;
      exports2.Uint8ClampedArray = exports2.Uint8ClampedArray || Uint8ClampedArray2;
      exports2.Int16Array = exports2.Int16Array || Int16Array2;
      exports2.Uint16Array = exports2.Uint16Array || Uint16Array2;
      exports2.Int32Array = exports2.Int32Array || Int32Array2;
      exports2.Uint32Array = exports2.Uint32Array || Uint32Array2;
      exports2.Float32Array = exports2.Float32Array || Float32Array2;
      exports2.Float64Array = exports2.Float64Array || Float64Array2;
    })();
    (function() {
      function r(array, index) {
        return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
      }
      var IS_BIG_ENDIAN = function() {
        var u16array = new exports2.Uint16Array([4660]), u8array = new exports2.Uint8Array(u16array.buffer);
        return r(u8array, 0) === 18;
      }();
      var DataView2 = function DataView3(buffer, byteOffset, byteLength) {
        if (arguments.length === 0) {
          buffer = new exports2.ArrayBuffer(0);
        } else if (!(buffer instanceof exports2.ArrayBuffer || ECMAScript.Class(buffer) === "ArrayBuffer")) {
          throw new TypeError("TypeError");
        }
        this.buffer = buffer || new exports2.ArrayBuffer(0);
        this.byteOffset = ECMAScript.ToUint32(byteOffset);
        if (this.byteOffset > this.buffer.byteLength) {
          throw new RangeError("byteOffset out of range");
        }
        if (arguments.length < 3) {
          this.byteLength = this.buffer.byteLength - this.byteOffset;
        } else {
          this.byteLength = ECMAScript.ToUint32(byteLength);
        }
        if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
        }
        configureProperties(this);
      };
      function makeGetter(arrayType) {
        return function(byteOffset, littleEndian) {
          byteOffset = ECMAScript.ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
          byteOffset += this.byteOffset;
          var uint8Array = new exports2.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT), bytes = [], i;
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes.push(r(uint8Array, i));
          }
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes.reverse();
          }
          return r(new arrayType(new exports2.Uint8Array(bytes).buffer), 0);
        };
      }
      DataView2.prototype.getUint8 = makeGetter(exports2.Uint8Array);
      DataView2.prototype.getInt8 = makeGetter(exports2.Int8Array);
      DataView2.prototype.getUint16 = makeGetter(exports2.Uint16Array);
      DataView2.prototype.getInt16 = makeGetter(exports2.Int16Array);
      DataView2.prototype.getUint32 = makeGetter(exports2.Uint32Array);
      DataView2.prototype.getInt32 = makeGetter(exports2.Int32Array);
      DataView2.prototype.getFloat32 = makeGetter(exports2.Float32Array);
      DataView2.prototype.getFloat64 = makeGetter(exports2.Float64Array);
      function makeSetter(arrayType) {
        return function(byteOffset, value, littleEndian) {
          byteOffset = ECMAScript.ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
          var typeArray = new arrayType([value]), byteArray = new exports2.Uint8Array(typeArray.buffer), bytes = [], i, byteView;
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes.push(r(byteArray, i));
          }
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes.reverse();
          }
          byteView = new exports2.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
          byteView.set(bytes);
        };
      }
      DataView2.prototype.setUint8 = makeSetter(exports2.Uint8Array);
      DataView2.prototype.setInt8 = makeSetter(exports2.Int8Array);
      DataView2.prototype.setUint16 = makeSetter(exports2.Uint16Array);
      DataView2.prototype.setInt16 = makeSetter(exports2.Int16Array);
      DataView2.prototype.setUint32 = makeSetter(exports2.Uint32Array);
      DataView2.prototype.setInt32 = makeSetter(exports2.Int32Array);
      DataView2.prototype.setFloat32 = makeSetter(exports2.Float32Array);
      DataView2.prototype.setFloat64 = makeSetter(exports2.Float64Array);
      exports2.DataView = exports2.DataView || DataView2;
    })();
  }
});

// node_modules/concat-stream/index.js
var require_concat_stream = __commonJS({
  "node_modules/concat-stream/index.js"(exports2, module2) {
    var Writable = require_readable_browser().Writable;
    var inherits = require_inherits_browser();
    var bufferFrom = require_buffer_from();
    if (typeof Uint8Array === "undefined") {
      U8 = require_typedarray().Uint8Array;
    } else {
      U8 = Uint8Array;
    }
    var U8;
    function ConcatStream(opts, cb) {
      if (!(this instanceof ConcatStream)) return new ConcatStream(opts, cb);
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      if (!opts) opts = {};
      var encoding = opts.encoding;
      var shouldInferEncoding = false;
      if (!encoding) {
        shouldInferEncoding = true;
      } else {
        encoding = String(encoding).toLowerCase();
        if (encoding === "u8" || encoding === "uint8") {
          encoding = "uint8array";
        }
      }
      Writable.call(this, { objectMode: true });
      this.encoding = encoding;
      this.shouldInferEncoding = shouldInferEncoding;
      if (cb) this.on("finish", function() {
        cb(this.getBody());
      });
      this.body = [];
    }
    module2.exports = ConcatStream;
    inherits(ConcatStream, Writable);
    ConcatStream.prototype._write = function(chunk, enc, next) {
      this.body.push(chunk);
      next();
    };
    ConcatStream.prototype.inferEncoding = function(buff) {
      var firstBuffer = buff === void 0 ? this.body[0] : buff;
      if (Buffer.isBuffer(firstBuffer)) return "buffer";
      if (typeof Uint8Array !== "undefined" && firstBuffer instanceof Uint8Array) return "uint8array";
      if (Array.isArray(firstBuffer)) return "array";
      if (typeof firstBuffer === "string") return "string";
      if (Object.prototype.toString.call(firstBuffer) === "[object Object]") return "object";
      return "buffer";
    };
    ConcatStream.prototype.getBody = function() {
      if (!this.encoding && this.body.length === 0) return [];
      if (this.shouldInferEncoding) this.encoding = this.inferEncoding();
      if (this.encoding === "array") return arrayConcat(this.body);
      if (this.encoding === "string") return stringConcat(this.body);
      if (this.encoding === "buffer") return bufferConcat(this.body);
      if (this.encoding === "uint8array") return u8Concat(this.body);
      return this.body;
    };
    var isArray = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) == "[object Array]";
    };
    function isArrayish(arr) {
      return /Array\]$/.test(Object.prototype.toString.call(arr));
    }
    function isBufferish(p) {
      return typeof p === "string" || isArrayish(p) || p && typeof p.subarray === "function";
    }
    function stringConcat(parts) {
      var strings = [];
      var needsToString = false;
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i];
        if (typeof p === "string") {
          strings.push(p);
        } else if (Buffer.isBuffer(p)) {
          strings.push(p);
        } else if (isBufferish(p)) {
          strings.push(bufferFrom(p));
        } else {
          strings.push(bufferFrom(String(p)));
        }
      }
      if (Buffer.isBuffer(parts[0])) {
        strings = Buffer.concat(strings);
        strings = strings.toString("utf8");
      } else {
        strings = strings.join("");
      }
      return strings;
    }
    function bufferConcat(parts) {
      var bufs = [];
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i];
        if (Buffer.isBuffer(p)) {
          bufs.push(p);
        } else if (isBufferish(p)) {
          bufs.push(bufferFrom(p));
        } else {
          bufs.push(bufferFrom(String(p)));
        }
      }
      return Buffer.concat(bufs);
    }
    function arrayConcat(parts) {
      var res = [];
      for (var i = 0; i < parts.length; i++) {
        res.push.apply(res, parts[i]);
      }
      return res;
    }
    function u8Concat(parts) {
      var len = 0;
      for (var i = 0; i < parts.length; i++) {
        if (typeof parts[i] === "string") {
          parts[i] = bufferFrom(parts[i]);
        }
        len += parts[i].length;
      }
      var u8 = new U8(len);
      for (var i = 0, offset = 0; i < parts.length; i++) {
        var part = parts[i];
        for (var j = 0; j < part.length; j++) {
          u8[offset++] = part[j];
        }
      }
      return u8;
    }
  }
});

// node_modules/@xmldom/xmldom/lib/conventions.js
var require_conventions = __commonJS({
  "node_modules/@xmldom/xmldom/lib/conventions.js"(exports2) {
    "use strict";
    function find(list, predicate, ac) {
      if (ac === void 0) {
        ac = Array.prototype;
      }
      if (list && typeof ac.find === "function") {
        return ac.find.call(list, predicate);
      }
      for (var i = 0; i < list.length; i++) {
        if (Object.prototype.hasOwnProperty.call(list, i)) {
          var item = list[i];
          if (predicate.call(void 0, item, i, list)) {
            return item;
          }
        }
      }
    }
    function freeze(object, oc) {
      if (oc === void 0) {
        oc = Object;
      }
      return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
    }
    function assign(target, source) {
      if (target === null || typeof target !== "object") {
        throw new TypeError("target is not an object");
      }
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
      return target;
    }
    var MIME_TYPE = freeze({
      /**
       * `text/html`, the only mime type that triggers treating an XML document as HTML.
       *
       * @see DOMParser.SupportedType.isHTML
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
       */
      HTML: "text/html",
      /**
       * Helper method to check a mime type if it indicates an HTML document
       *
       * @param {string} [value]
       * @returns {boolean}
       *
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
      isHTML: function(value) {
        return value === MIME_TYPE.HTML;
      },
      /**
       * `application/xml`, the standard mime type for XML documents.
       *
       * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
       * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_APPLICATION: "application/xml",
      /**
       * `text/html`, an alias for `application/xml`.
       *
       * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
       * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_TEXT: "text/xml",
      /**
       * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
       * but is parsed as an XML document.
       *
       * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
       * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
       */
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      /**
       * `image/svg+xml`,
       *
       * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
       * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
       * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
       */
      XML_SVG_IMAGE: "image/svg+xml"
    });
    var NAMESPACE = freeze({
      /**
       * The XHTML namespace.
       *
       * @see http://www.w3.org/1999/xhtml
       */
      HTML: "http://www.w3.org/1999/xhtml",
      /**
       * Checks if `uri` equals `NAMESPACE.HTML`.
       *
       * @param {string} [uri]
       *
       * @see NAMESPACE.HTML
       */
      isHTML: function(uri) {
        return uri === NAMESPACE.HTML;
      },
      /**
       * The SVG namespace.
       *
       * @see http://www.w3.org/2000/svg
       */
      SVG: "http://www.w3.org/2000/svg",
      /**
       * The `xml:` namespace.
       *
       * @see http://www.w3.org/XML/1998/namespace
       */
      XML: "http://www.w3.org/XML/1998/namespace",
      /**
       * The `xmlns:` namespace
       *
       * @see https://www.w3.org/2000/xmlns/
       */
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    exports2.assign = assign;
    exports2.find = find;
    exports2.freeze = freeze;
    exports2.MIME_TYPE = MIME_TYPE;
    exports2.NAMESPACE = NAMESPACE;
  }
});

// node_modules/@xmldom/xmldom/lib/dom.js
var require_dom = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom.js"(exports2) {
    var conventions = require_conventions();
    var find = conventions.find;
    var NAMESPACE = conventions.NAMESPACE;
    function notEmptyString(input) {
      return input !== "";
    }
    function splitOnASCIIWhitespace(input) {
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }
    function orderedSetReducer(current, element) {
      if (!current.hasOwnProperty(element)) {
        current[element] = true;
      }
      return current;
    }
    function toOrderedSet(input) {
      if (!input) return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }
    function arrayIncludes(list) {
      return function(element) {
        return list && list.indexOf(element) !== -1;
      };
    }
    function copy(src, dest) {
      for (var p in src) {
        if (Object.prototype.hasOwnProperty.call(src, p)) {
          dest[p] = src[p];
        }
      }
    }
    function _extends(Class, Super) {
      var pt = Class.prototype;
      if (!(pt instanceof Super)) {
        let t2 = function() {
        };
        var t = t2;
        ;
        t2.prototype = Super.prototype;
        t2 = new t2();
        copy(pt, t2);
        Class.prototype = pt = t2;
      }
      if (pt.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt.constructor = Class;
      }
    }
    var NodeType = {};
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var ExceptionCode = {};
    var ExceptionMessage = {};
    var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
    var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
    var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
    var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
    var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
    var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
    var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
    var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
    var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
    var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
    var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
    var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
    function DOMException(code, message) {
      if (message instanceof Error) {
        var error = message;
      } else {
        error = this;
        Error.call(this, ExceptionMessage[code]);
        this.message = ExceptionMessage[code];
        if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
      }
      error.code = code;
      if (message) this.message = this.message + ": " + message;
      return error;
    }
    DOMException.prototype = Error.prototype;
    copy(ExceptionCode, DOMException);
    function NodeList() {
    }
    NodeList.prototype = {
      /**
       * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
       * @standard level1
       */
      length: 0,
      /**
       * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
       * @standard level1
       * @param index  unsigned long
       *   Index into the collection.
       * @return Node
       * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
       */
      item: function(index) {
        return index >= 0 && index < this.length ? this[index] : null;
      },
      toString: function(isHTML, nodeFilter) {
        for (var buf = [], i = 0; i < this.length; i++) {
          serializeToString(this[i], buf, isHTML, nodeFilter);
        }
        return buf.join("");
      },
      /**
       * @private
       * @param {function (Node):boolean} predicate
       * @returns {Node[]}
       */
      filter: function(predicate) {
        return Array.prototype.filter.call(this, predicate);
      },
      /**
       * @private
       * @param {Node} item
       * @returns {number}
       */
      indexOf: function(item) {
        return Array.prototype.indexOf.call(this, item);
      }
    };
    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc !== inc) {
        var ls = list._refresh(list._node);
        __set__(list, "length", ls.length);
        if (!list.$$length || ls.length < list.$$length) {
          for (var i = ls.length; i in list; i++) {
            if (Object.prototype.hasOwnProperty.call(list, i)) {
              delete list[i];
            }
          }
        }
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function(i) {
      _updateLiveList(this);
      return this[i] || null;
    };
    _extends(LiveNodeList, NodeList);
    function NamedNodeMap() {
    }
    function _findNodeIndex(list, node) {
      var i = list.length;
      while (i--) {
        if (list[i] === node) {
          return i;
        }
      }
    }
    function _addNamedNode(el, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length++] = newAttr;
      }
      if (el) {
        newAttr.ownerElement = el;
        var doc = el.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el, oldAttr);
          _onAddAttribute(doc, el, newAttr);
        }
      }
    }
    function _removeNamedNode(el, list, attr) {
      var i = _findNodeIndex(list, attr);
      if (i >= 0) {
        var lastIndex = list.length - 1;
        while (i < lastIndex) {
          list[i] = list[++i];
        }
        list.length = lastIndex;
        if (el) {
          var doc = el.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el, attr);
            attr.ownerElement = null;
          }
        }
      } else {
        throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      getNamedItem: function(key) {
        var i = this.length;
        while (i--) {
          var attr = this[i];
          if (attr.nodeName == key) {
            return attr;
          }
        }
      },
      setNamedItem: function(attr) {
        var el = attr.ownerElement;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItem(attr.nodeName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      setNamedItemNS: function(attr) {
        var el = attr.ownerElement, oldAttr;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      removeNamedItem: function(key) {
        var attr = this.getNamedItem(key);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
      //for level2
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      getNamedItemNS: function(namespaceURI, localName) {
        var i = this.length;
        while (i--) {
          var node = this[i];
          if (node.localName == localName && node.namespaceURI == namespaceURI) {
            return node;
          }
        }
        return null;
      }
    };
    function DOMImplementation() {
    }
    DOMImplementation.prototype = {
      /**
       * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
       * The different implementations fairly diverged in what kind of features were reported.
       * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
       *
       * @deprecated It is deprecated and modern browsers return true in all cases.
       *
       * @param {string} feature
       * @param {string} [version]
       * @returns {boolean} always true
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
       * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
       */
      hasFeature: function(feature, version) {
        return true;
      },
      /**
       * Creates an XML Document object of the specified type with its document element.
       *
       * __It behaves slightly different from the description in the living standard__:
       * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
       * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string|null} namespaceURI
       * @param {string} qualifiedName
       * @param {DocumentType=null} doctype
       * @returns {Document}
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var doc = new Document();
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root);
        }
        return doc;
      },
      /**
       * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
       *
       * __This behavior is slightly different from the in the specs__:
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string} qualifiedName
       * @param {string} [publicId]
       * @param {string} [systemId]
       * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
       * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocumentType: function(qualifiedName, publicId, systemId) {
        var node = new DocumentType();
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId || "";
        node.systemId = systemId || "";
        return node;
      }
    };
    function Node() {
    }
    Node.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      // Modified in DOM Level 2:
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      // Modified in DOM Level 2:
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      // Introduced in DOM Level 2:
      isSupported: function(feature, version) {
        return this.ownerDocument.implementation.hasFeature(feature, version);
      },
      // Introduced in DOM Level 2:
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      /**
       * Look up the prefix associated to the given namespace URI, starting from this node.
       * **The default namespace declarations are ignored by this method.**
       * See Namespace Prefix Lookup for details on the algorithm used by this method.
       *
       * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
       *
       * @param {string | null} namespaceURI
       * @returns {string | null}
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
       * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
       * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
       * @see https://github.com/xmldom/xmldom/issues/322
       */
      lookupPrefix: function(namespaceURI) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            for (var n in map) {
              if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
                return n;
              }
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      lookupNamespaceURI: function(prefix) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            if (Object.prototype.hasOwnProperty.call(map, prefix)) {
              return map[prefix];
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      isDefaultNamespace: function(namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      }
    };
    function _xmlEncoder(c) {
      return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
    }
    copy(NodeType, Node);
    copy(NodeType, Node.prototype);
    function _visitNode(node, callback) {
      if (callback(node)) {
        return true;
      }
      if (node = node.firstChild) {
        do {
          if (_visitNode(node, callback)) {
            return true;
          }
        } while (node = node.nextSibling);
      }
    }
    function Document() {
      this.ownerDocument = this;
    }
    function _onAddAttribute(doc, el, newAttr) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }
    function _onRemoveAttribute(doc, el, newAttr, remove) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }
    function _onUpdateChild(doc, el, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var cs = el.childNodes;
        if (newChild) {
          cs[cs.length++] = newChild;
        } else {
          var child = el.firstChild;
          var i = 0;
          while (child) {
            cs[i++] = child;
            child = child.nextSibling;
          }
          cs.length = i;
          delete cs[cs.length];
        }
      }
    }
    function _removeChild(parentNode, child) {
      var previous = child.previousSibling;
      var next = child.nextSibling;
      if (previous) {
        previous.nextSibling = next;
      } else {
        parentNode.firstChild = next;
      }
      if (next) {
        next.previousSibling = previous;
      } else {
        parentNode.lastChild = previous;
      }
      child.parentNode = null;
      child.previousSibling = null;
      child.nextSibling = null;
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      return child;
    }
    function hasValidParentNodeType(node) {
      return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
    }
    function hasInsertableNodeType(node) {
      return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
    }
    function isDocTypeNode(node) {
      return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
    }
    function isElementNode(node) {
      return node && node.nodeType === Node.ELEMENT_NODE;
    }
    function isTextNode(node) {
      return node && node.nodeType === Node.TEXT_NODE;
    }
    function isElementInsertionPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function isElementReplacementPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      function hasElementChildThatIsNotChild(node) {
        return isElementNode(node) && node !== child;
      }
      if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function assertPreInsertionValidity1to5(parent, node, child) {
      if (!hasValidParentNodeType(parent)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
      }
      if (child && child.parentNode !== parent) {
        throw new DOMException(NOT_FOUND_ERR, "child not in parent");
      }
      if (
        // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
        !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
        // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
        // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
        // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
        isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE
      ) {
        throw new DOMException(
          HIERARCHY_REQUEST_ERR,
          "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType
        );
      }
    }
    function assertPreInsertionValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        if (find(parentChildNodes, isDocTypeNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
        if (!child && parentElementChild) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
        }
      }
    }
    function assertPreReplacementValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        let hasDoctypeChildThatIsNotChild2 = function(node2) {
          return isDocTypeNode(node2) && node2 !== child;
        };
        var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
        if (find(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
      }
    }
    function _insertBefore(parent, node, child, _inDocumentAssertion) {
      assertPreInsertionValidity1to5(parent, node, child);
      if (parent.nodeType === Node.DOCUMENT_NODE) {
        (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
      }
      var cp = node.parentNode;
      if (cp) {
        cp.removeChild(node);
      }
      if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = node.firstChild;
        if (newFirst == null) {
          return node;
        }
        var newLast = node.lastChild;
      } else {
        newFirst = newLast = node;
      }
      var pre = child ? child.previousSibling : parent.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = child;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parent.firstChild = newFirst;
      }
      if (child == null) {
        parent.lastChild = newLast;
      } else {
        child.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parent;
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parent.ownerDocument || parent, parent);
      if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
        node.firstChild = node.lastChild = null;
      }
      return node;
    }
    function _appendSingleChild(parentNode, newChild) {
      if (newChild.parentNode) {
        newChild.parentNode.removeChild(newChild);
      }
      newChild.parentNode = parentNode;
      newChild.previousSibling = parentNode.lastChild;
      newChild.nextSibling = null;
      if (newChild.previousSibling) {
        newChild.previousSibling.nextSibling = newChild;
      } else {
        parentNode.firstChild = newChild;
      }
      parentNode.lastChild = newChild;
      _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
      return newChild;
    }
    Document.prototype = {
      //implementation : null,
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      /**
       * The DocumentType node of the document.
       *
       * @readonly
       * @type DocumentType
       */
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        _insertBefore(this, newChild, refChild);
        newChild.ownerDocument = this;
        if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
          this.documentElement = newChild;
        }
        return newChild;
      },
      removeChild: function(oldChild) {
        if (this.documentElement == oldChild) {
          this.documentElement = null;
        }
        return _removeChild(this, oldChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        newChild.ownerDocument = this;
        if (oldChild) {
          this.removeChild(oldChild);
        }
        if (isElementNode(newChild)) {
          this.documentElement = newChild;
        }
      },
      // Introduced in DOM Level 2:
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      // Introduced in DOM Level 2:
      getElementById: function(id) {
        var rtv = null;
        _visitNode(this.documentElement, function(node) {
          if (node.nodeType == ELEMENT_NODE) {
            if (node.getAttribute("id") == id) {
              rtv = node;
              return true;
            }
          }
        });
        return rtv;
      },
      /**
       * The `getElementsByClassName` method of `Document` interface returns an array-like object
       * of all child elements which have **all** of the given class name(s).
       *
       * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
       *
       *
       * Warning: This is a live LiveNodeList.
       * Changes in the DOM will reflect in the array as the changes occur.
       * If an element selected by this array no longer qualifies for the selector,
       * it will automatically be removed. Be aware of this for iteration purposes.
       *
       * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
       */
      getElementsByClassName: function(classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function(base) {
          var ls = [];
          if (classNamesSet.length > 0) {
            _visitNode(base.documentElement, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node.getAttribute("class");
                if (nodeClassNames) {
                  var matches = classNames === nodeClassNames;
                  if (!matches) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                  }
                  if (matches) {
                    ls.push(node);
                  }
                }
              }
            });
          }
          return ls;
        });
      },
      //document factory method:
      createElement: function(tagName) {
        var node = new Element2();
        node.ownerDocument = this;
        node.nodeName = tagName;
        node.tagName = tagName;
        node.localName = tagName;
        node.childNodes = new NodeList();
        var attrs = node.attributes = new NamedNodeMap();
        attrs._ownerElement = node;
        return node;
      },
      createDocumentFragment: function() {
        var node = new DocumentFragment();
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      createTextNode: function(data) {
        var node = new Text();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createComment: function(data) {
        var node = new Comment();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createCDATASection: function(data) {
        var node = new CDATASection();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createProcessingInstruction: function(target, data) {
        var node = new ProcessingInstruction();
        node.ownerDocument = this;
        node.tagName = node.nodeName = node.target = target;
        node.nodeValue = node.data = data;
        return node;
      },
      createAttribute: function(name) {
        var node = new Attr();
        node.ownerDocument = this;
        node.name = name;
        node.nodeName = name;
        node.localName = name;
        node.specified = true;
        return node;
      },
      createEntityReference: function(name) {
        var node = new EntityReference();
        node.ownerDocument = this;
        node.nodeName = name;
        return node;
      },
      // Introduced in DOM Level 2:
      createElementNS: function(namespaceURI, qualifiedName) {
        var node = new Element2();
        var pl = qualifiedName.split(":");
        var attrs = node.attributes = new NamedNodeMap();
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = namespaceURI;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        attrs._ownerElement = node;
        return node;
      },
      // Introduced in DOM Level 2:
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var node = new Attr();
        var pl = qualifiedName.split(":");
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.namespaceURI = namespaceURI;
        node.specified = true;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        return node;
      }
    };
    _extends(Document, Node);
    function Element2() {
      this._nsMap = {};
    }
    Element2.prototype = {
      nodeType: ELEMENT_NODE,
      hasAttribute: function(name) {
        return this.getAttributeNode(name) != null;
      },
      getAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        return attr && attr.value || "";
      },
      getAttributeNode: function(name) {
        return this.attributes.getNamedItem(name);
      },
      setAttribute: function(name, value) {
        var attr = this.ownerDocument.createAttribute(name);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      removeAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        attr && this.removeAttributeNode(attr);
      },
      //four real opeartion method
      appendChild: function(newChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return this.insertBefore(newChild, null);
        } else {
          return _appendSingleChild(this, newChild);
        }
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      //get real attribute name,and remove it by removeAttributeNode
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr && attr.value || "";
      },
      setAttributeNS: function(namespaceURI, qualifiedName, value) {
        var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      getElementsByTagName: function(tagName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      }
    };
    Document.prototype.getElementsByTagName = Element2.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element2.prototype.getElementsByTagNameNS;
    _extends(Element2, Node);
    function Attr() {
    }
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends(Attr, Node);
    function CharacterData() {
    }
    CharacterData.prototype = {
      data: "",
      substringData: function(offset, count) {
        return this.data.substring(offset, offset + count);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      appendChild: function(newChild) {
        throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
      },
      deleteData: function(offset, count) {
        this.replaceData(offset, count, "");
      },
      replaceData: function(offset, count, text) {
        var start = this.data.substring(0, offset);
        var end = this.data.substring(offset + count);
        text = start + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    };
    _extends(CharacterData, Node);
    function Text() {
    }
    Text.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    };
    _extends(Text, CharacterData);
    function Comment() {
    }
    Comment.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    };
    _extends(Comment, CharacterData);
    function CDATASection() {
    }
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    };
    _extends(CDATASection, CharacterData);
    function DocumentType() {
    }
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends(DocumentType, Node);
    function Notation() {
    }
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends(Notation, Node);
    function Entity() {
    }
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends(Entity, Node);
    function EntityReference() {
    }
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends(EntityReference, Node);
    function DocumentFragment() {
    }
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends(DocumentFragment, Node);
    function ProcessingInstruction() {
    }
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends(ProcessingInstruction, Node);
    function XMLSerializer() {
    }
    XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
      return nodeSerializeToString.call(node, isHtml, nodeFilter);
    };
    Node.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(isHtml, nodeFilter) {
      var buf = [];
      var refNode = this.nodeType == 9 && this.documentElement || this;
      var prefix = refNode.prefix;
      var uri = refNode.namespaceURI;
      if (uri && prefix == null) {
        var prefix = refNode.lookupPrefix(uri);
        if (prefix == null) {
          var visibleNamespaces = [
            { namespace: uri, prefix: null }
            //{namespace:uri,prefix:''}
          ];
        }
      }
      serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
      return buf.join("");
    }
    function needNamespaceDefine(node, isHTML, visibleNamespaces) {
      var prefix = node.prefix || "";
      var uri = node.namespaceURI;
      if (!uri) {
        return false;
      }
      if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
        return false;
      }
      var i = visibleNamespaces.length;
      while (i--) {
        var ns = visibleNamespaces[i];
        if (ns.prefix === prefix) {
          return ns.namespace !== uri;
        }
      }
      return true;
    }
    function addSerializedAttribute(buf, qualifiedName, value) {
      buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
    }
    function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }
      if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
          if (typeof node == "string") {
            buf.push(node);
            return;
          }
        } else {
          return;
        }
      }
      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;
          isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
          var prefixedNodeName = nodeName;
          if (!isHTML && !node.prefix && node.namespaceURI) {
            var defaultNS;
            for (var ai = 0; ai < attrs.length; ai++) {
              if (attrs.item(ai).name === "xmlns") {
                defaultNS = attrs.item(ai).value;
                break;
              }
            }
            if (!defaultNS) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }
          buf.push("<", prefixedNodeName);
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({ prefix: "", namespace: attr.value });
            }
          }
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
          }
          if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
            buf.push(">");
            if (isHTML && /^script$/i.test(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          } else {
            buf.push("/>");
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node.name, node.value);
        case TEXT_NODE:
          return buf.push(
            node.data.replace(/[<&>]/g, _xmlEncoder)
          );
        case CDATA_SECTION_NODE:
          return buf.push("<![CDATA[", node.data, "]]>");
        case COMMENT_NODE:
          return buf.push("<!--", node.data, "-->");
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push("<!DOCTYPE ", node.name);
          if (pubid) {
            buf.push(" PUBLIC ", pubid);
            if (sysid && sysid != ".") {
              buf.push(" ", sysid);
            }
            buf.push(">");
          } else if (sysid && sysid != ".") {
            buf.push(" SYSTEM ", sysid, ">");
          } else {
            var sub = node.internalSubset;
            if (sub) {
              buf.push(" [", sub, "]");
            }
            buf.push(">");
          }
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node.nodeName, ";");
        //case ENTITY_NODE:
        //case NOTATION_NODE:
        default:
          buf.push("??", node.nodeName);
      }
    }
    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        //var attrs = node2.attributes;
        //var len = attrs.length;
        //for(var i=0;i<len;i++){
        //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
        //}
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node2) {
        node2 = node.cloneNode(false);
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor();
      for (var n in node) {
        if (Object.prototype.hasOwnProperty.call(node, n)) {
          var v = node[n];
          if (typeof v != "object") {
            if (v != node2[n]) {
              node2[n] = v;
            }
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = node2.attributes = new NamedNodeMap();
          var len = attrs.length;
          attrs2._ownerElement = node2;
          for (var i = 0; i < len; i++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
          }
          break;
          ;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function __set__(object, key, value) {
      object[key] = value;
    }
    try {
      if (Object.defineProperty) {
        let getTextContent2 = function(node) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent2(node));
                }
                node = node.nextSibling;
              }
              return buf.join("");
            default:
              return node.nodeValue;
          }
        };
        getTextContent = getTextContent2;
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node.prototype, "textContent", {
          get: function() {
            return getTextContent2(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          }
        });
        __set__ = function(object, key, value) {
          object["$$" + key] = value;
        };
      }
    } catch (e) {
    }
    var getTextContent;
    exports2.DocumentType = DocumentType;
    exports2.DOMException = DOMException;
    exports2.DOMImplementation = DOMImplementation;
    exports2.Element = Element2;
    exports2.Node = Node;
    exports2.NodeList = NodeList;
    exports2.XMLSerializer = XMLSerializer;
  }
});

// node_modules/@xmldom/xmldom/lib/entities.js
var require_entities = __commonJS({
  "node_modules/@xmldom/xmldom/lib/entities.js"(exports2) {
    "use strict";
    var freeze = require_conventions().freeze;
    exports2.XML_ENTITIES = freeze({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    });
    exports2.HTML_ENTITIES = freeze({
      Aacute: "Á",
      aacute: "á",
      Abreve: "Ă",
      abreve: "ă",
      ac: "∾",
      acd: "∿",
      acE: "∾̳",
      Acirc: "Â",
      acirc: "â",
      acute: "´",
      Acy: "А",
      acy: "а",
      AElig: "Æ",
      aelig: "æ",
      af: "⁡",
      Afr: "𝔄",
      afr: "𝔞",
      Agrave: "À",
      agrave: "à",
      alefsym: "ℵ",
      aleph: "ℵ",
      Alpha: "Α",
      alpha: "α",
      Amacr: "Ā",
      amacr: "ā",
      amalg: "⨿",
      AMP: "&",
      amp: "&",
      And: "⩓",
      and: "∧",
      andand: "⩕",
      andd: "⩜",
      andslope: "⩘",
      andv: "⩚",
      ang: "∠",
      ange: "⦤",
      angle: "∠",
      angmsd: "∡",
      angmsdaa: "⦨",
      angmsdab: "⦩",
      angmsdac: "⦪",
      angmsdad: "⦫",
      angmsdae: "⦬",
      angmsdaf: "⦭",
      angmsdag: "⦮",
      angmsdah: "⦯",
      angrt: "∟",
      angrtvb: "⊾",
      angrtvbd: "⦝",
      angsph: "∢",
      angst: "Å",
      angzarr: "⍼",
      Aogon: "Ą",
      aogon: "ą",
      Aopf: "𝔸",
      aopf: "𝕒",
      ap: "≈",
      apacir: "⩯",
      apE: "⩰",
      ape: "≊",
      apid: "≋",
      apos: "'",
      ApplyFunction: "⁡",
      approx: "≈",
      approxeq: "≊",
      Aring: "Å",
      aring: "å",
      Ascr: "𝒜",
      ascr: "𝒶",
      Assign: "≔",
      ast: "*",
      asymp: "≈",
      asympeq: "≍",
      Atilde: "Ã",
      atilde: "ã",
      Auml: "Ä",
      auml: "ä",
      awconint: "∳",
      awint: "⨑",
      backcong: "≌",
      backepsilon: "϶",
      backprime: "‵",
      backsim: "∽",
      backsimeq: "⋍",
      Backslash: "∖",
      Barv: "⫧",
      barvee: "⊽",
      Barwed: "⌆",
      barwed: "⌅",
      barwedge: "⌅",
      bbrk: "⎵",
      bbrktbrk: "⎶",
      bcong: "≌",
      Bcy: "Б",
      bcy: "б",
      bdquo: "„",
      becaus: "∵",
      Because: "∵",
      because: "∵",
      bemptyv: "⦰",
      bepsi: "϶",
      bernou: "ℬ",
      Bernoullis: "ℬ",
      Beta: "Β",
      beta: "β",
      beth: "ℶ",
      between: "≬",
      Bfr: "𝔅",
      bfr: "𝔟",
      bigcap: "⋂",
      bigcirc: "◯",
      bigcup: "⋃",
      bigodot: "⨀",
      bigoplus: "⨁",
      bigotimes: "⨂",
      bigsqcup: "⨆",
      bigstar: "★",
      bigtriangledown: "▽",
      bigtriangleup: "△",
      biguplus: "⨄",
      bigvee: "⋁",
      bigwedge: "⋀",
      bkarow: "⤍",
      blacklozenge: "⧫",
      blacksquare: "▪",
      blacktriangle: "▴",
      blacktriangledown: "▾",
      blacktriangleleft: "◂",
      blacktriangleright: "▸",
      blank: "␣",
      blk12: "▒",
      blk14: "░",
      blk34: "▓",
      block: "█",
      bne: "=⃥",
      bnequiv: "≡⃥",
      bNot: "⫭",
      bnot: "⌐",
      Bopf: "𝔹",
      bopf: "𝕓",
      bot: "⊥",
      bottom: "⊥",
      bowtie: "⋈",
      boxbox: "⧉",
      boxDL: "╗",
      boxDl: "╖",
      boxdL: "╕",
      boxdl: "┐",
      boxDR: "╔",
      boxDr: "╓",
      boxdR: "╒",
      boxdr: "┌",
      boxH: "═",
      boxh: "─",
      boxHD: "╦",
      boxHd: "╤",
      boxhD: "╥",
      boxhd: "┬",
      boxHU: "╩",
      boxHu: "╧",
      boxhU: "╨",
      boxhu: "┴",
      boxminus: "⊟",
      boxplus: "⊞",
      boxtimes: "⊠",
      boxUL: "╝",
      boxUl: "╜",
      boxuL: "╛",
      boxul: "┘",
      boxUR: "╚",
      boxUr: "╙",
      boxuR: "╘",
      boxur: "└",
      boxV: "║",
      boxv: "│",
      boxVH: "╬",
      boxVh: "╫",
      boxvH: "╪",
      boxvh: "┼",
      boxVL: "╣",
      boxVl: "╢",
      boxvL: "╡",
      boxvl: "┤",
      boxVR: "╠",
      boxVr: "╟",
      boxvR: "╞",
      boxvr: "├",
      bprime: "‵",
      Breve: "˘",
      breve: "˘",
      brvbar: "¦",
      Bscr: "ℬ",
      bscr: "𝒷",
      bsemi: "⁏",
      bsim: "∽",
      bsime: "⋍",
      bsol: "\\",
      bsolb: "⧅",
      bsolhsub: "⟈",
      bull: "•",
      bullet: "•",
      bump: "≎",
      bumpE: "⪮",
      bumpe: "≏",
      Bumpeq: "≎",
      bumpeq: "≏",
      Cacute: "Ć",
      cacute: "ć",
      Cap: "⋒",
      cap: "∩",
      capand: "⩄",
      capbrcup: "⩉",
      capcap: "⩋",
      capcup: "⩇",
      capdot: "⩀",
      CapitalDifferentialD: "ⅅ",
      caps: "∩︀",
      caret: "⁁",
      caron: "ˇ",
      Cayleys: "ℭ",
      ccaps: "⩍",
      Ccaron: "Č",
      ccaron: "č",
      Ccedil: "Ç",
      ccedil: "ç",
      Ccirc: "Ĉ",
      ccirc: "ĉ",
      Cconint: "∰",
      ccups: "⩌",
      ccupssm: "⩐",
      Cdot: "Ċ",
      cdot: "ċ",
      cedil: "¸",
      Cedilla: "¸",
      cemptyv: "⦲",
      cent: "¢",
      CenterDot: "·",
      centerdot: "·",
      Cfr: "ℭ",
      cfr: "𝔠",
      CHcy: "Ч",
      chcy: "ч",
      check: "✓",
      checkmark: "✓",
      Chi: "Χ",
      chi: "χ",
      cir: "○",
      circ: "ˆ",
      circeq: "≗",
      circlearrowleft: "↺",
      circlearrowright: "↻",
      circledast: "⊛",
      circledcirc: "⊚",
      circleddash: "⊝",
      CircleDot: "⊙",
      circledR: "®",
      circledS: "Ⓢ",
      CircleMinus: "⊖",
      CirclePlus: "⊕",
      CircleTimes: "⊗",
      cirE: "⧃",
      cire: "≗",
      cirfnint: "⨐",
      cirmid: "⫯",
      cirscir: "⧂",
      ClockwiseContourIntegral: "∲",
      CloseCurlyDoubleQuote: "”",
      CloseCurlyQuote: "’",
      clubs: "♣",
      clubsuit: "♣",
      Colon: "∷",
      colon: ":",
      Colone: "⩴",
      colone: "≔",
      coloneq: "≔",
      comma: ",",
      commat: "@",
      comp: "∁",
      compfn: "∘",
      complement: "∁",
      complexes: "ℂ",
      cong: "≅",
      congdot: "⩭",
      Congruent: "≡",
      Conint: "∯",
      conint: "∮",
      ContourIntegral: "∮",
      Copf: "ℂ",
      copf: "𝕔",
      coprod: "∐",
      Coproduct: "∐",
      COPY: "©",
      copy: "©",
      copysr: "℗",
      CounterClockwiseContourIntegral: "∳",
      crarr: "↵",
      Cross: "⨯",
      cross: "✗",
      Cscr: "𝒞",
      cscr: "𝒸",
      csub: "⫏",
      csube: "⫑",
      csup: "⫐",
      csupe: "⫒",
      ctdot: "⋯",
      cudarrl: "⤸",
      cudarrr: "⤵",
      cuepr: "⋞",
      cuesc: "⋟",
      cularr: "↶",
      cularrp: "⤽",
      Cup: "⋓",
      cup: "∪",
      cupbrcap: "⩈",
      CupCap: "≍",
      cupcap: "⩆",
      cupcup: "⩊",
      cupdot: "⊍",
      cupor: "⩅",
      cups: "∪︀",
      curarr: "↷",
      curarrm: "⤼",
      curlyeqprec: "⋞",
      curlyeqsucc: "⋟",
      curlyvee: "⋎",
      curlywedge: "⋏",
      curren: "¤",
      curvearrowleft: "↶",
      curvearrowright: "↷",
      cuvee: "⋎",
      cuwed: "⋏",
      cwconint: "∲",
      cwint: "∱",
      cylcty: "⌭",
      Dagger: "‡",
      dagger: "†",
      daleth: "ℸ",
      Darr: "↡",
      dArr: "⇓",
      darr: "↓",
      dash: "‐",
      Dashv: "⫤",
      dashv: "⊣",
      dbkarow: "⤏",
      dblac: "˝",
      Dcaron: "Ď",
      dcaron: "ď",
      Dcy: "Д",
      dcy: "д",
      DD: "ⅅ",
      dd: "ⅆ",
      ddagger: "‡",
      ddarr: "⇊",
      DDotrahd: "⤑",
      ddotseq: "⩷",
      deg: "°",
      Del: "∇",
      Delta: "Δ",
      delta: "δ",
      demptyv: "⦱",
      dfisht: "⥿",
      Dfr: "𝔇",
      dfr: "𝔡",
      dHar: "⥥",
      dharl: "⇃",
      dharr: "⇂",
      DiacriticalAcute: "´",
      DiacriticalDot: "˙",
      DiacriticalDoubleAcute: "˝",
      DiacriticalGrave: "`",
      DiacriticalTilde: "˜",
      diam: "⋄",
      Diamond: "⋄",
      diamond: "⋄",
      diamondsuit: "♦",
      diams: "♦",
      die: "¨",
      DifferentialD: "ⅆ",
      digamma: "ϝ",
      disin: "⋲",
      div: "÷",
      divide: "÷",
      divideontimes: "⋇",
      divonx: "⋇",
      DJcy: "Ђ",
      djcy: "ђ",
      dlcorn: "⌞",
      dlcrop: "⌍",
      dollar: "$",
      Dopf: "𝔻",
      dopf: "𝕕",
      Dot: "¨",
      dot: "˙",
      DotDot: "⃜",
      doteq: "≐",
      doteqdot: "≑",
      DotEqual: "≐",
      dotminus: "∸",
      dotplus: "∔",
      dotsquare: "⊡",
      doublebarwedge: "⌆",
      DoubleContourIntegral: "∯",
      DoubleDot: "¨",
      DoubleDownArrow: "⇓",
      DoubleLeftArrow: "⇐",
      DoubleLeftRightArrow: "⇔",
      DoubleLeftTee: "⫤",
      DoubleLongLeftArrow: "⟸",
      DoubleLongLeftRightArrow: "⟺",
      DoubleLongRightArrow: "⟹",
      DoubleRightArrow: "⇒",
      DoubleRightTee: "⊨",
      DoubleUpArrow: "⇑",
      DoubleUpDownArrow: "⇕",
      DoubleVerticalBar: "∥",
      DownArrow: "↓",
      Downarrow: "⇓",
      downarrow: "↓",
      DownArrowBar: "⤓",
      DownArrowUpArrow: "⇵",
      DownBreve: "̑",
      downdownarrows: "⇊",
      downharpoonleft: "⇃",
      downharpoonright: "⇂",
      DownLeftRightVector: "⥐",
      DownLeftTeeVector: "⥞",
      DownLeftVector: "↽",
      DownLeftVectorBar: "⥖",
      DownRightTeeVector: "⥟",
      DownRightVector: "⇁",
      DownRightVectorBar: "⥗",
      DownTee: "⊤",
      DownTeeArrow: "↧",
      drbkarow: "⤐",
      drcorn: "⌟",
      drcrop: "⌌",
      Dscr: "𝒟",
      dscr: "𝒹",
      DScy: "Ѕ",
      dscy: "ѕ",
      dsol: "⧶",
      Dstrok: "Đ",
      dstrok: "đ",
      dtdot: "⋱",
      dtri: "▿",
      dtrif: "▾",
      duarr: "⇵",
      duhar: "⥯",
      dwangle: "⦦",
      DZcy: "Џ",
      dzcy: "џ",
      dzigrarr: "⟿",
      Eacute: "É",
      eacute: "é",
      easter: "⩮",
      Ecaron: "Ě",
      ecaron: "ě",
      ecir: "≖",
      Ecirc: "Ê",
      ecirc: "ê",
      ecolon: "≕",
      Ecy: "Э",
      ecy: "э",
      eDDot: "⩷",
      Edot: "Ė",
      eDot: "≑",
      edot: "ė",
      ee: "ⅇ",
      efDot: "≒",
      Efr: "𝔈",
      efr: "𝔢",
      eg: "⪚",
      Egrave: "È",
      egrave: "è",
      egs: "⪖",
      egsdot: "⪘",
      el: "⪙",
      Element: "∈",
      elinters: "⏧",
      ell: "ℓ",
      els: "⪕",
      elsdot: "⪗",
      Emacr: "Ē",
      emacr: "ē",
      empty: "∅",
      emptyset: "∅",
      EmptySmallSquare: "◻",
      emptyv: "∅",
      EmptyVerySmallSquare: "▫",
      emsp: " ",
      emsp13: " ",
      emsp14: " ",
      ENG: "Ŋ",
      eng: "ŋ",
      ensp: " ",
      Eogon: "Ę",
      eogon: "ę",
      Eopf: "𝔼",
      eopf: "𝕖",
      epar: "⋕",
      eparsl: "⧣",
      eplus: "⩱",
      epsi: "ε",
      Epsilon: "Ε",
      epsilon: "ε",
      epsiv: "ϵ",
      eqcirc: "≖",
      eqcolon: "≕",
      eqsim: "≂",
      eqslantgtr: "⪖",
      eqslantless: "⪕",
      Equal: "⩵",
      equals: "=",
      EqualTilde: "≂",
      equest: "≟",
      Equilibrium: "⇌",
      equiv: "≡",
      equivDD: "⩸",
      eqvparsl: "⧥",
      erarr: "⥱",
      erDot: "≓",
      Escr: "ℰ",
      escr: "ℯ",
      esdot: "≐",
      Esim: "⩳",
      esim: "≂",
      Eta: "Η",
      eta: "η",
      ETH: "Ð",
      eth: "ð",
      Euml: "Ë",
      euml: "ë",
      euro: "€",
      excl: "!",
      exist: "∃",
      Exists: "∃",
      expectation: "ℰ",
      ExponentialE: "ⅇ",
      exponentiale: "ⅇ",
      fallingdotseq: "≒",
      Fcy: "Ф",
      fcy: "ф",
      female: "♀",
      ffilig: "ﬃ",
      fflig: "ﬀ",
      ffllig: "ﬄ",
      Ffr: "𝔉",
      ffr: "𝔣",
      filig: "ﬁ",
      FilledSmallSquare: "◼",
      FilledVerySmallSquare: "▪",
      fjlig: "fj",
      flat: "♭",
      fllig: "ﬂ",
      fltns: "▱",
      fnof: "ƒ",
      Fopf: "𝔽",
      fopf: "𝕗",
      ForAll: "∀",
      forall: "∀",
      fork: "⋔",
      forkv: "⫙",
      Fouriertrf: "ℱ",
      fpartint: "⨍",
      frac12: "½",
      frac13: "⅓",
      frac14: "¼",
      frac15: "⅕",
      frac16: "⅙",
      frac18: "⅛",
      frac23: "⅔",
      frac25: "⅖",
      frac34: "¾",
      frac35: "⅗",
      frac38: "⅜",
      frac45: "⅘",
      frac56: "⅚",
      frac58: "⅝",
      frac78: "⅞",
      frasl: "⁄",
      frown: "⌢",
      Fscr: "ℱ",
      fscr: "𝒻",
      gacute: "ǵ",
      Gamma: "Γ",
      gamma: "γ",
      Gammad: "Ϝ",
      gammad: "ϝ",
      gap: "⪆",
      Gbreve: "Ğ",
      gbreve: "ğ",
      Gcedil: "Ģ",
      Gcirc: "Ĝ",
      gcirc: "ĝ",
      Gcy: "Г",
      gcy: "г",
      Gdot: "Ġ",
      gdot: "ġ",
      gE: "≧",
      ge: "≥",
      gEl: "⪌",
      gel: "⋛",
      geq: "≥",
      geqq: "≧",
      geqslant: "⩾",
      ges: "⩾",
      gescc: "⪩",
      gesdot: "⪀",
      gesdoto: "⪂",
      gesdotol: "⪄",
      gesl: "⋛︀",
      gesles: "⪔",
      Gfr: "𝔊",
      gfr: "𝔤",
      Gg: "⋙",
      gg: "≫",
      ggg: "⋙",
      gimel: "ℷ",
      GJcy: "Ѓ",
      gjcy: "ѓ",
      gl: "≷",
      gla: "⪥",
      glE: "⪒",
      glj: "⪤",
      gnap: "⪊",
      gnapprox: "⪊",
      gnE: "≩",
      gne: "⪈",
      gneq: "⪈",
      gneqq: "≩",
      gnsim: "⋧",
      Gopf: "𝔾",
      gopf: "𝕘",
      grave: "`",
      GreaterEqual: "≥",
      GreaterEqualLess: "⋛",
      GreaterFullEqual: "≧",
      GreaterGreater: "⪢",
      GreaterLess: "≷",
      GreaterSlantEqual: "⩾",
      GreaterTilde: "≳",
      Gscr: "𝒢",
      gscr: "ℊ",
      gsim: "≳",
      gsime: "⪎",
      gsiml: "⪐",
      Gt: "≫",
      GT: ">",
      gt: ">",
      gtcc: "⪧",
      gtcir: "⩺",
      gtdot: "⋗",
      gtlPar: "⦕",
      gtquest: "⩼",
      gtrapprox: "⪆",
      gtrarr: "⥸",
      gtrdot: "⋗",
      gtreqless: "⋛",
      gtreqqless: "⪌",
      gtrless: "≷",
      gtrsim: "≳",
      gvertneqq: "≩︀",
      gvnE: "≩︀",
      Hacek: "ˇ",
      hairsp: " ",
      half: "½",
      hamilt: "ℋ",
      HARDcy: "Ъ",
      hardcy: "ъ",
      hArr: "⇔",
      harr: "↔",
      harrcir: "⥈",
      harrw: "↭",
      Hat: "^",
      hbar: "ℏ",
      Hcirc: "Ĥ",
      hcirc: "ĥ",
      hearts: "♥",
      heartsuit: "♥",
      hellip: "…",
      hercon: "⊹",
      Hfr: "ℌ",
      hfr: "𝔥",
      HilbertSpace: "ℋ",
      hksearow: "⤥",
      hkswarow: "⤦",
      hoarr: "⇿",
      homtht: "∻",
      hookleftarrow: "↩",
      hookrightarrow: "↪",
      Hopf: "ℍ",
      hopf: "𝕙",
      horbar: "―",
      HorizontalLine: "─",
      Hscr: "ℋ",
      hscr: "𝒽",
      hslash: "ℏ",
      Hstrok: "Ħ",
      hstrok: "ħ",
      HumpDownHump: "≎",
      HumpEqual: "≏",
      hybull: "⁃",
      hyphen: "‐",
      Iacute: "Í",
      iacute: "í",
      ic: "⁣",
      Icirc: "Î",
      icirc: "î",
      Icy: "И",
      icy: "и",
      Idot: "İ",
      IEcy: "Е",
      iecy: "е",
      iexcl: "¡",
      iff: "⇔",
      Ifr: "ℑ",
      ifr: "𝔦",
      Igrave: "Ì",
      igrave: "ì",
      ii: "ⅈ",
      iiiint: "⨌",
      iiint: "∭",
      iinfin: "⧜",
      iiota: "℩",
      IJlig: "Ĳ",
      ijlig: "ĳ",
      Im: "ℑ",
      Imacr: "Ī",
      imacr: "ī",
      image: "ℑ",
      ImaginaryI: "ⅈ",
      imagline: "ℐ",
      imagpart: "ℑ",
      imath: "ı",
      imof: "⊷",
      imped: "Ƶ",
      Implies: "⇒",
      in: "∈",
      incare: "℅",
      infin: "∞",
      infintie: "⧝",
      inodot: "ı",
      Int: "∬",
      int: "∫",
      intcal: "⊺",
      integers: "ℤ",
      Integral: "∫",
      intercal: "⊺",
      Intersection: "⋂",
      intlarhk: "⨗",
      intprod: "⨼",
      InvisibleComma: "⁣",
      InvisibleTimes: "⁢",
      IOcy: "Ё",
      iocy: "ё",
      Iogon: "Į",
      iogon: "į",
      Iopf: "𝕀",
      iopf: "𝕚",
      Iota: "Ι",
      iota: "ι",
      iprod: "⨼",
      iquest: "¿",
      Iscr: "ℐ",
      iscr: "𝒾",
      isin: "∈",
      isindot: "⋵",
      isinE: "⋹",
      isins: "⋴",
      isinsv: "⋳",
      isinv: "∈",
      it: "⁢",
      Itilde: "Ĩ",
      itilde: "ĩ",
      Iukcy: "І",
      iukcy: "і",
      Iuml: "Ï",
      iuml: "ï",
      Jcirc: "Ĵ",
      jcirc: "ĵ",
      Jcy: "Й",
      jcy: "й",
      Jfr: "𝔍",
      jfr: "𝔧",
      jmath: "ȷ",
      Jopf: "𝕁",
      jopf: "𝕛",
      Jscr: "𝒥",
      jscr: "𝒿",
      Jsercy: "Ј",
      jsercy: "ј",
      Jukcy: "Є",
      jukcy: "є",
      Kappa: "Κ",
      kappa: "κ",
      kappav: "ϰ",
      Kcedil: "Ķ",
      kcedil: "ķ",
      Kcy: "К",
      kcy: "к",
      Kfr: "𝔎",
      kfr: "𝔨",
      kgreen: "ĸ",
      KHcy: "Х",
      khcy: "х",
      KJcy: "Ќ",
      kjcy: "ќ",
      Kopf: "𝕂",
      kopf: "𝕜",
      Kscr: "𝒦",
      kscr: "𝓀",
      lAarr: "⇚",
      Lacute: "Ĺ",
      lacute: "ĺ",
      laemptyv: "⦴",
      lagran: "ℒ",
      Lambda: "Λ",
      lambda: "λ",
      Lang: "⟪",
      lang: "⟨",
      langd: "⦑",
      langle: "⟨",
      lap: "⪅",
      Laplacetrf: "ℒ",
      laquo: "«",
      Larr: "↞",
      lArr: "⇐",
      larr: "←",
      larrb: "⇤",
      larrbfs: "⤟",
      larrfs: "⤝",
      larrhk: "↩",
      larrlp: "↫",
      larrpl: "⤹",
      larrsim: "⥳",
      larrtl: "↢",
      lat: "⪫",
      lAtail: "⤛",
      latail: "⤙",
      late: "⪭",
      lates: "⪭︀",
      lBarr: "⤎",
      lbarr: "⤌",
      lbbrk: "❲",
      lbrace: "{",
      lbrack: "[",
      lbrke: "⦋",
      lbrksld: "⦏",
      lbrkslu: "⦍",
      Lcaron: "Ľ",
      lcaron: "ľ",
      Lcedil: "Ļ",
      lcedil: "ļ",
      lceil: "⌈",
      lcub: "{",
      Lcy: "Л",
      lcy: "л",
      ldca: "⤶",
      ldquo: "“",
      ldquor: "„",
      ldrdhar: "⥧",
      ldrushar: "⥋",
      ldsh: "↲",
      lE: "≦",
      le: "≤",
      LeftAngleBracket: "⟨",
      LeftArrow: "←",
      Leftarrow: "⇐",
      leftarrow: "←",
      LeftArrowBar: "⇤",
      LeftArrowRightArrow: "⇆",
      leftarrowtail: "↢",
      LeftCeiling: "⌈",
      LeftDoubleBracket: "⟦",
      LeftDownTeeVector: "⥡",
      LeftDownVector: "⇃",
      LeftDownVectorBar: "⥙",
      LeftFloor: "⌊",
      leftharpoondown: "↽",
      leftharpoonup: "↼",
      leftleftarrows: "⇇",
      LeftRightArrow: "↔",
      Leftrightarrow: "⇔",
      leftrightarrow: "↔",
      leftrightarrows: "⇆",
      leftrightharpoons: "⇋",
      leftrightsquigarrow: "↭",
      LeftRightVector: "⥎",
      LeftTee: "⊣",
      LeftTeeArrow: "↤",
      LeftTeeVector: "⥚",
      leftthreetimes: "⋋",
      LeftTriangle: "⊲",
      LeftTriangleBar: "⧏",
      LeftTriangleEqual: "⊴",
      LeftUpDownVector: "⥑",
      LeftUpTeeVector: "⥠",
      LeftUpVector: "↿",
      LeftUpVectorBar: "⥘",
      LeftVector: "↼",
      LeftVectorBar: "⥒",
      lEg: "⪋",
      leg: "⋚",
      leq: "≤",
      leqq: "≦",
      leqslant: "⩽",
      les: "⩽",
      lescc: "⪨",
      lesdot: "⩿",
      lesdoto: "⪁",
      lesdotor: "⪃",
      lesg: "⋚︀",
      lesges: "⪓",
      lessapprox: "⪅",
      lessdot: "⋖",
      lesseqgtr: "⋚",
      lesseqqgtr: "⪋",
      LessEqualGreater: "⋚",
      LessFullEqual: "≦",
      LessGreater: "≶",
      lessgtr: "≶",
      LessLess: "⪡",
      lesssim: "≲",
      LessSlantEqual: "⩽",
      LessTilde: "≲",
      lfisht: "⥼",
      lfloor: "⌊",
      Lfr: "𝔏",
      lfr: "𝔩",
      lg: "≶",
      lgE: "⪑",
      lHar: "⥢",
      lhard: "↽",
      lharu: "↼",
      lharul: "⥪",
      lhblk: "▄",
      LJcy: "Љ",
      ljcy: "љ",
      Ll: "⋘",
      ll: "≪",
      llarr: "⇇",
      llcorner: "⌞",
      Lleftarrow: "⇚",
      llhard: "⥫",
      lltri: "◺",
      Lmidot: "Ŀ",
      lmidot: "ŀ",
      lmoust: "⎰",
      lmoustache: "⎰",
      lnap: "⪉",
      lnapprox: "⪉",
      lnE: "≨",
      lne: "⪇",
      lneq: "⪇",
      lneqq: "≨",
      lnsim: "⋦",
      loang: "⟬",
      loarr: "⇽",
      lobrk: "⟦",
      LongLeftArrow: "⟵",
      Longleftarrow: "⟸",
      longleftarrow: "⟵",
      LongLeftRightArrow: "⟷",
      Longleftrightarrow: "⟺",
      longleftrightarrow: "⟷",
      longmapsto: "⟼",
      LongRightArrow: "⟶",
      Longrightarrow: "⟹",
      longrightarrow: "⟶",
      looparrowleft: "↫",
      looparrowright: "↬",
      lopar: "⦅",
      Lopf: "𝕃",
      lopf: "𝕝",
      loplus: "⨭",
      lotimes: "⨴",
      lowast: "∗",
      lowbar: "_",
      LowerLeftArrow: "↙",
      LowerRightArrow: "↘",
      loz: "◊",
      lozenge: "◊",
      lozf: "⧫",
      lpar: "(",
      lparlt: "⦓",
      lrarr: "⇆",
      lrcorner: "⌟",
      lrhar: "⇋",
      lrhard: "⥭",
      lrm: "‎",
      lrtri: "⊿",
      lsaquo: "‹",
      Lscr: "ℒ",
      lscr: "𝓁",
      Lsh: "↰",
      lsh: "↰",
      lsim: "≲",
      lsime: "⪍",
      lsimg: "⪏",
      lsqb: "[",
      lsquo: "‘",
      lsquor: "‚",
      Lstrok: "Ł",
      lstrok: "ł",
      Lt: "≪",
      LT: "<",
      lt: "<",
      ltcc: "⪦",
      ltcir: "⩹",
      ltdot: "⋖",
      lthree: "⋋",
      ltimes: "⋉",
      ltlarr: "⥶",
      ltquest: "⩻",
      ltri: "◃",
      ltrie: "⊴",
      ltrif: "◂",
      ltrPar: "⦖",
      lurdshar: "⥊",
      luruhar: "⥦",
      lvertneqq: "≨︀",
      lvnE: "≨︀",
      macr: "¯",
      male: "♂",
      malt: "✠",
      maltese: "✠",
      Map: "⤅",
      map: "↦",
      mapsto: "↦",
      mapstodown: "↧",
      mapstoleft: "↤",
      mapstoup: "↥",
      marker: "▮",
      mcomma: "⨩",
      Mcy: "М",
      mcy: "м",
      mdash: "—",
      mDDot: "∺",
      measuredangle: "∡",
      MediumSpace: " ",
      Mellintrf: "ℳ",
      Mfr: "𝔐",
      mfr: "𝔪",
      mho: "℧",
      micro: "µ",
      mid: "∣",
      midast: "*",
      midcir: "⫰",
      middot: "·",
      minus: "−",
      minusb: "⊟",
      minusd: "∸",
      minusdu: "⨪",
      MinusPlus: "∓",
      mlcp: "⫛",
      mldr: "…",
      mnplus: "∓",
      models: "⊧",
      Mopf: "𝕄",
      mopf: "𝕞",
      mp: "∓",
      Mscr: "ℳ",
      mscr: "𝓂",
      mstpos: "∾",
      Mu: "Μ",
      mu: "μ",
      multimap: "⊸",
      mumap: "⊸",
      nabla: "∇",
      Nacute: "Ń",
      nacute: "ń",
      nang: "∠⃒",
      nap: "≉",
      napE: "⩰̸",
      napid: "≋̸",
      napos: "ŉ",
      napprox: "≉",
      natur: "♮",
      natural: "♮",
      naturals: "ℕ",
      nbsp: " ",
      nbump: "≎̸",
      nbumpe: "≏̸",
      ncap: "⩃",
      Ncaron: "Ň",
      ncaron: "ň",
      Ncedil: "Ņ",
      ncedil: "ņ",
      ncong: "≇",
      ncongdot: "⩭̸",
      ncup: "⩂",
      Ncy: "Н",
      ncy: "н",
      ndash: "–",
      ne: "≠",
      nearhk: "⤤",
      neArr: "⇗",
      nearr: "↗",
      nearrow: "↗",
      nedot: "≐̸",
      NegativeMediumSpace: "​",
      NegativeThickSpace: "​",
      NegativeThinSpace: "​",
      NegativeVeryThinSpace: "​",
      nequiv: "≢",
      nesear: "⤨",
      nesim: "≂̸",
      NestedGreaterGreater: "≫",
      NestedLessLess: "≪",
      NewLine: "\n",
      nexist: "∄",
      nexists: "∄",
      Nfr: "𝔑",
      nfr: "𝔫",
      ngE: "≧̸",
      nge: "≱",
      ngeq: "≱",
      ngeqq: "≧̸",
      ngeqslant: "⩾̸",
      nges: "⩾̸",
      nGg: "⋙̸",
      ngsim: "≵",
      nGt: "≫⃒",
      ngt: "≯",
      ngtr: "≯",
      nGtv: "≫̸",
      nhArr: "⇎",
      nharr: "↮",
      nhpar: "⫲",
      ni: "∋",
      nis: "⋼",
      nisd: "⋺",
      niv: "∋",
      NJcy: "Њ",
      njcy: "њ",
      nlArr: "⇍",
      nlarr: "↚",
      nldr: "‥",
      nlE: "≦̸",
      nle: "≰",
      nLeftarrow: "⇍",
      nleftarrow: "↚",
      nLeftrightarrow: "⇎",
      nleftrightarrow: "↮",
      nleq: "≰",
      nleqq: "≦̸",
      nleqslant: "⩽̸",
      nles: "⩽̸",
      nless: "≮",
      nLl: "⋘̸",
      nlsim: "≴",
      nLt: "≪⃒",
      nlt: "≮",
      nltri: "⋪",
      nltrie: "⋬",
      nLtv: "≪̸",
      nmid: "∤",
      NoBreak: "⁠",
      NonBreakingSpace: " ",
      Nopf: "ℕ",
      nopf: "𝕟",
      Not: "⫬",
      not: "¬",
      NotCongruent: "≢",
      NotCupCap: "≭",
      NotDoubleVerticalBar: "∦",
      NotElement: "∉",
      NotEqual: "≠",
      NotEqualTilde: "≂̸",
      NotExists: "∄",
      NotGreater: "≯",
      NotGreaterEqual: "≱",
      NotGreaterFullEqual: "≧̸",
      NotGreaterGreater: "≫̸",
      NotGreaterLess: "≹",
      NotGreaterSlantEqual: "⩾̸",
      NotGreaterTilde: "≵",
      NotHumpDownHump: "≎̸",
      NotHumpEqual: "≏̸",
      notin: "∉",
      notindot: "⋵̸",
      notinE: "⋹̸",
      notinva: "∉",
      notinvb: "⋷",
      notinvc: "⋶",
      NotLeftTriangle: "⋪",
      NotLeftTriangleBar: "⧏̸",
      NotLeftTriangleEqual: "⋬",
      NotLess: "≮",
      NotLessEqual: "≰",
      NotLessGreater: "≸",
      NotLessLess: "≪̸",
      NotLessSlantEqual: "⩽̸",
      NotLessTilde: "≴",
      NotNestedGreaterGreater: "⪢̸",
      NotNestedLessLess: "⪡̸",
      notni: "∌",
      notniva: "∌",
      notnivb: "⋾",
      notnivc: "⋽",
      NotPrecedes: "⊀",
      NotPrecedesEqual: "⪯̸",
      NotPrecedesSlantEqual: "⋠",
      NotReverseElement: "∌",
      NotRightTriangle: "⋫",
      NotRightTriangleBar: "⧐̸",
      NotRightTriangleEqual: "⋭",
      NotSquareSubset: "⊏̸",
      NotSquareSubsetEqual: "⋢",
      NotSquareSuperset: "⊐̸",
      NotSquareSupersetEqual: "⋣",
      NotSubset: "⊂⃒",
      NotSubsetEqual: "⊈",
      NotSucceeds: "⊁",
      NotSucceedsEqual: "⪰̸",
      NotSucceedsSlantEqual: "⋡",
      NotSucceedsTilde: "≿̸",
      NotSuperset: "⊃⃒",
      NotSupersetEqual: "⊉",
      NotTilde: "≁",
      NotTildeEqual: "≄",
      NotTildeFullEqual: "≇",
      NotTildeTilde: "≉",
      NotVerticalBar: "∤",
      npar: "∦",
      nparallel: "∦",
      nparsl: "⫽⃥",
      npart: "∂̸",
      npolint: "⨔",
      npr: "⊀",
      nprcue: "⋠",
      npre: "⪯̸",
      nprec: "⊀",
      npreceq: "⪯̸",
      nrArr: "⇏",
      nrarr: "↛",
      nrarrc: "⤳̸",
      nrarrw: "↝̸",
      nRightarrow: "⇏",
      nrightarrow: "↛",
      nrtri: "⋫",
      nrtrie: "⋭",
      nsc: "⊁",
      nsccue: "⋡",
      nsce: "⪰̸",
      Nscr: "𝒩",
      nscr: "𝓃",
      nshortmid: "∤",
      nshortparallel: "∦",
      nsim: "≁",
      nsime: "≄",
      nsimeq: "≄",
      nsmid: "∤",
      nspar: "∦",
      nsqsube: "⋢",
      nsqsupe: "⋣",
      nsub: "⊄",
      nsubE: "⫅̸",
      nsube: "⊈",
      nsubset: "⊂⃒",
      nsubseteq: "⊈",
      nsubseteqq: "⫅̸",
      nsucc: "⊁",
      nsucceq: "⪰̸",
      nsup: "⊅",
      nsupE: "⫆̸",
      nsupe: "⊉",
      nsupset: "⊃⃒",
      nsupseteq: "⊉",
      nsupseteqq: "⫆̸",
      ntgl: "≹",
      Ntilde: "Ñ",
      ntilde: "ñ",
      ntlg: "≸",
      ntriangleleft: "⋪",
      ntrianglelefteq: "⋬",
      ntriangleright: "⋫",
      ntrianglerighteq: "⋭",
      Nu: "Ν",
      nu: "ν",
      num: "#",
      numero: "№",
      numsp: " ",
      nvap: "≍⃒",
      nVDash: "⊯",
      nVdash: "⊮",
      nvDash: "⊭",
      nvdash: "⊬",
      nvge: "≥⃒",
      nvgt: ">⃒",
      nvHarr: "⤄",
      nvinfin: "⧞",
      nvlArr: "⤂",
      nvle: "≤⃒",
      nvlt: "<⃒",
      nvltrie: "⊴⃒",
      nvrArr: "⤃",
      nvrtrie: "⊵⃒",
      nvsim: "∼⃒",
      nwarhk: "⤣",
      nwArr: "⇖",
      nwarr: "↖",
      nwarrow: "↖",
      nwnear: "⤧",
      Oacute: "Ó",
      oacute: "ó",
      oast: "⊛",
      ocir: "⊚",
      Ocirc: "Ô",
      ocirc: "ô",
      Ocy: "О",
      ocy: "о",
      odash: "⊝",
      Odblac: "Ő",
      odblac: "ő",
      odiv: "⨸",
      odot: "⊙",
      odsold: "⦼",
      OElig: "Œ",
      oelig: "œ",
      ofcir: "⦿",
      Ofr: "𝔒",
      ofr: "𝔬",
      ogon: "˛",
      Ograve: "Ò",
      ograve: "ò",
      ogt: "⧁",
      ohbar: "⦵",
      ohm: "Ω",
      oint: "∮",
      olarr: "↺",
      olcir: "⦾",
      olcross: "⦻",
      oline: "‾",
      olt: "⧀",
      Omacr: "Ō",
      omacr: "ō",
      Omega: "Ω",
      omega: "ω",
      Omicron: "Ο",
      omicron: "ο",
      omid: "⦶",
      ominus: "⊖",
      Oopf: "𝕆",
      oopf: "𝕠",
      opar: "⦷",
      OpenCurlyDoubleQuote: "“",
      OpenCurlyQuote: "‘",
      operp: "⦹",
      oplus: "⊕",
      Or: "⩔",
      or: "∨",
      orarr: "↻",
      ord: "⩝",
      order: "ℴ",
      orderof: "ℴ",
      ordf: "ª",
      ordm: "º",
      origof: "⊶",
      oror: "⩖",
      orslope: "⩗",
      orv: "⩛",
      oS: "Ⓢ",
      Oscr: "𝒪",
      oscr: "ℴ",
      Oslash: "Ø",
      oslash: "ø",
      osol: "⊘",
      Otilde: "Õ",
      otilde: "õ",
      Otimes: "⨷",
      otimes: "⊗",
      otimesas: "⨶",
      Ouml: "Ö",
      ouml: "ö",
      ovbar: "⌽",
      OverBar: "‾",
      OverBrace: "⏞",
      OverBracket: "⎴",
      OverParenthesis: "⏜",
      par: "∥",
      para: "¶",
      parallel: "∥",
      parsim: "⫳",
      parsl: "⫽",
      part: "∂",
      PartialD: "∂",
      Pcy: "П",
      pcy: "п",
      percnt: "%",
      period: ".",
      permil: "‰",
      perp: "⊥",
      pertenk: "‱",
      Pfr: "𝔓",
      pfr: "𝔭",
      Phi: "Φ",
      phi: "φ",
      phiv: "ϕ",
      phmmat: "ℳ",
      phone: "☎",
      Pi: "Π",
      pi: "π",
      pitchfork: "⋔",
      piv: "ϖ",
      planck: "ℏ",
      planckh: "ℎ",
      plankv: "ℏ",
      plus: "+",
      plusacir: "⨣",
      plusb: "⊞",
      pluscir: "⨢",
      plusdo: "∔",
      plusdu: "⨥",
      pluse: "⩲",
      PlusMinus: "±",
      plusmn: "±",
      plussim: "⨦",
      plustwo: "⨧",
      pm: "±",
      Poincareplane: "ℌ",
      pointint: "⨕",
      Popf: "ℙ",
      popf: "𝕡",
      pound: "£",
      Pr: "⪻",
      pr: "≺",
      prap: "⪷",
      prcue: "≼",
      prE: "⪳",
      pre: "⪯",
      prec: "≺",
      precapprox: "⪷",
      preccurlyeq: "≼",
      Precedes: "≺",
      PrecedesEqual: "⪯",
      PrecedesSlantEqual: "≼",
      PrecedesTilde: "≾",
      preceq: "⪯",
      precnapprox: "⪹",
      precneqq: "⪵",
      precnsim: "⋨",
      precsim: "≾",
      Prime: "″",
      prime: "′",
      primes: "ℙ",
      prnap: "⪹",
      prnE: "⪵",
      prnsim: "⋨",
      prod: "∏",
      Product: "∏",
      profalar: "⌮",
      profline: "⌒",
      profsurf: "⌓",
      prop: "∝",
      Proportion: "∷",
      Proportional: "∝",
      propto: "∝",
      prsim: "≾",
      prurel: "⊰",
      Pscr: "𝒫",
      pscr: "𝓅",
      Psi: "Ψ",
      psi: "ψ",
      puncsp: " ",
      Qfr: "𝔔",
      qfr: "𝔮",
      qint: "⨌",
      Qopf: "ℚ",
      qopf: "𝕢",
      qprime: "⁗",
      Qscr: "𝒬",
      qscr: "𝓆",
      quaternions: "ℍ",
      quatint: "⨖",
      quest: "?",
      questeq: "≟",
      QUOT: '"',
      quot: '"',
      rAarr: "⇛",
      race: "∽̱",
      Racute: "Ŕ",
      racute: "ŕ",
      radic: "√",
      raemptyv: "⦳",
      Rang: "⟫",
      rang: "⟩",
      rangd: "⦒",
      range: "⦥",
      rangle: "⟩",
      raquo: "»",
      Rarr: "↠",
      rArr: "⇒",
      rarr: "→",
      rarrap: "⥵",
      rarrb: "⇥",
      rarrbfs: "⤠",
      rarrc: "⤳",
      rarrfs: "⤞",
      rarrhk: "↪",
      rarrlp: "↬",
      rarrpl: "⥅",
      rarrsim: "⥴",
      Rarrtl: "⤖",
      rarrtl: "↣",
      rarrw: "↝",
      rAtail: "⤜",
      ratail: "⤚",
      ratio: "∶",
      rationals: "ℚ",
      RBarr: "⤐",
      rBarr: "⤏",
      rbarr: "⤍",
      rbbrk: "❳",
      rbrace: "}",
      rbrack: "]",
      rbrke: "⦌",
      rbrksld: "⦎",
      rbrkslu: "⦐",
      Rcaron: "Ř",
      rcaron: "ř",
      Rcedil: "Ŗ",
      rcedil: "ŗ",
      rceil: "⌉",
      rcub: "}",
      Rcy: "Р",
      rcy: "р",
      rdca: "⤷",
      rdldhar: "⥩",
      rdquo: "”",
      rdquor: "”",
      rdsh: "↳",
      Re: "ℜ",
      real: "ℜ",
      realine: "ℛ",
      realpart: "ℜ",
      reals: "ℝ",
      rect: "▭",
      REG: "®",
      reg: "®",
      ReverseElement: "∋",
      ReverseEquilibrium: "⇋",
      ReverseUpEquilibrium: "⥯",
      rfisht: "⥽",
      rfloor: "⌋",
      Rfr: "ℜ",
      rfr: "𝔯",
      rHar: "⥤",
      rhard: "⇁",
      rharu: "⇀",
      rharul: "⥬",
      Rho: "Ρ",
      rho: "ρ",
      rhov: "ϱ",
      RightAngleBracket: "⟩",
      RightArrow: "→",
      Rightarrow: "⇒",
      rightarrow: "→",
      RightArrowBar: "⇥",
      RightArrowLeftArrow: "⇄",
      rightarrowtail: "↣",
      RightCeiling: "⌉",
      RightDoubleBracket: "⟧",
      RightDownTeeVector: "⥝",
      RightDownVector: "⇂",
      RightDownVectorBar: "⥕",
      RightFloor: "⌋",
      rightharpoondown: "⇁",
      rightharpoonup: "⇀",
      rightleftarrows: "⇄",
      rightleftharpoons: "⇌",
      rightrightarrows: "⇉",
      rightsquigarrow: "↝",
      RightTee: "⊢",
      RightTeeArrow: "↦",
      RightTeeVector: "⥛",
      rightthreetimes: "⋌",
      RightTriangle: "⊳",
      RightTriangleBar: "⧐",
      RightTriangleEqual: "⊵",
      RightUpDownVector: "⥏",
      RightUpTeeVector: "⥜",
      RightUpVector: "↾",
      RightUpVectorBar: "⥔",
      RightVector: "⇀",
      RightVectorBar: "⥓",
      ring: "˚",
      risingdotseq: "≓",
      rlarr: "⇄",
      rlhar: "⇌",
      rlm: "‏",
      rmoust: "⎱",
      rmoustache: "⎱",
      rnmid: "⫮",
      roang: "⟭",
      roarr: "⇾",
      robrk: "⟧",
      ropar: "⦆",
      Ropf: "ℝ",
      ropf: "𝕣",
      roplus: "⨮",
      rotimes: "⨵",
      RoundImplies: "⥰",
      rpar: ")",
      rpargt: "⦔",
      rppolint: "⨒",
      rrarr: "⇉",
      Rrightarrow: "⇛",
      rsaquo: "›",
      Rscr: "ℛ",
      rscr: "𝓇",
      Rsh: "↱",
      rsh: "↱",
      rsqb: "]",
      rsquo: "’",
      rsquor: "’",
      rthree: "⋌",
      rtimes: "⋊",
      rtri: "▹",
      rtrie: "⊵",
      rtrif: "▸",
      rtriltri: "⧎",
      RuleDelayed: "⧴",
      ruluhar: "⥨",
      rx: "℞",
      Sacute: "Ś",
      sacute: "ś",
      sbquo: "‚",
      Sc: "⪼",
      sc: "≻",
      scap: "⪸",
      Scaron: "Š",
      scaron: "š",
      sccue: "≽",
      scE: "⪴",
      sce: "⪰",
      Scedil: "Ş",
      scedil: "ş",
      Scirc: "Ŝ",
      scirc: "ŝ",
      scnap: "⪺",
      scnE: "⪶",
      scnsim: "⋩",
      scpolint: "⨓",
      scsim: "≿",
      Scy: "С",
      scy: "с",
      sdot: "⋅",
      sdotb: "⊡",
      sdote: "⩦",
      searhk: "⤥",
      seArr: "⇘",
      searr: "↘",
      searrow: "↘",
      sect: "§",
      semi: ";",
      seswar: "⤩",
      setminus: "∖",
      setmn: "∖",
      sext: "✶",
      Sfr: "𝔖",
      sfr: "𝔰",
      sfrown: "⌢",
      sharp: "♯",
      SHCHcy: "Щ",
      shchcy: "щ",
      SHcy: "Ш",
      shcy: "ш",
      ShortDownArrow: "↓",
      ShortLeftArrow: "←",
      shortmid: "∣",
      shortparallel: "∥",
      ShortRightArrow: "→",
      ShortUpArrow: "↑",
      shy: "­",
      Sigma: "Σ",
      sigma: "σ",
      sigmaf: "ς",
      sigmav: "ς",
      sim: "∼",
      simdot: "⩪",
      sime: "≃",
      simeq: "≃",
      simg: "⪞",
      simgE: "⪠",
      siml: "⪝",
      simlE: "⪟",
      simne: "≆",
      simplus: "⨤",
      simrarr: "⥲",
      slarr: "←",
      SmallCircle: "∘",
      smallsetminus: "∖",
      smashp: "⨳",
      smeparsl: "⧤",
      smid: "∣",
      smile: "⌣",
      smt: "⪪",
      smte: "⪬",
      smtes: "⪬︀",
      SOFTcy: "Ь",
      softcy: "ь",
      sol: "/",
      solb: "⧄",
      solbar: "⌿",
      Sopf: "𝕊",
      sopf: "𝕤",
      spades: "♠",
      spadesuit: "♠",
      spar: "∥",
      sqcap: "⊓",
      sqcaps: "⊓︀",
      sqcup: "⊔",
      sqcups: "⊔︀",
      Sqrt: "√",
      sqsub: "⊏",
      sqsube: "⊑",
      sqsubset: "⊏",
      sqsubseteq: "⊑",
      sqsup: "⊐",
      sqsupe: "⊒",
      sqsupset: "⊐",
      sqsupseteq: "⊒",
      squ: "□",
      Square: "□",
      square: "□",
      SquareIntersection: "⊓",
      SquareSubset: "⊏",
      SquareSubsetEqual: "⊑",
      SquareSuperset: "⊐",
      SquareSupersetEqual: "⊒",
      SquareUnion: "⊔",
      squarf: "▪",
      squf: "▪",
      srarr: "→",
      Sscr: "𝒮",
      sscr: "𝓈",
      ssetmn: "∖",
      ssmile: "⌣",
      sstarf: "⋆",
      Star: "⋆",
      star: "☆",
      starf: "★",
      straightepsilon: "ϵ",
      straightphi: "ϕ",
      strns: "¯",
      Sub: "⋐",
      sub: "⊂",
      subdot: "⪽",
      subE: "⫅",
      sube: "⊆",
      subedot: "⫃",
      submult: "⫁",
      subnE: "⫋",
      subne: "⊊",
      subplus: "⪿",
      subrarr: "⥹",
      Subset: "⋐",
      subset: "⊂",
      subseteq: "⊆",
      subseteqq: "⫅",
      SubsetEqual: "⊆",
      subsetneq: "⊊",
      subsetneqq: "⫋",
      subsim: "⫇",
      subsub: "⫕",
      subsup: "⫓",
      succ: "≻",
      succapprox: "⪸",
      succcurlyeq: "≽",
      Succeeds: "≻",
      SucceedsEqual: "⪰",
      SucceedsSlantEqual: "≽",
      SucceedsTilde: "≿",
      succeq: "⪰",
      succnapprox: "⪺",
      succneqq: "⪶",
      succnsim: "⋩",
      succsim: "≿",
      SuchThat: "∋",
      Sum: "∑",
      sum: "∑",
      sung: "♪",
      Sup: "⋑",
      sup: "⊃",
      sup1: "¹",
      sup2: "²",
      sup3: "³",
      supdot: "⪾",
      supdsub: "⫘",
      supE: "⫆",
      supe: "⊇",
      supedot: "⫄",
      Superset: "⊃",
      SupersetEqual: "⊇",
      suphsol: "⟉",
      suphsub: "⫗",
      suplarr: "⥻",
      supmult: "⫂",
      supnE: "⫌",
      supne: "⊋",
      supplus: "⫀",
      Supset: "⋑",
      supset: "⊃",
      supseteq: "⊇",
      supseteqq: "⫆",
      supsetneq: "⊋",
      supsetneqq: "⫌",
      supsim: "⫈",
      supsub: "⫔",
      supsup: "⫖",
      swarhk: "⤦",
      swArr: "⇙",
      swarr: "↙",
      swarrow: "↙",
      swnwar: "⤪",
      szlig: "ß",
      Tab: "	",
      target: "⌖",
      Tau: "Τ",
      tau: "τ",
      tbrk: "⎴",
      Tcaron: "Ť",
      tcaron: "ť",
      Tcedil: "Ţ",
      tcedil: "ţ",
      Tcy: "Т",
      tcy: "т",
      tdot: "⃛",
      telrec: "⌕",
      Tfr: "𝔗",
      tfr: "𝔱",
      there4: "∴",
      Therefore: "∴",
      therefore: "∴",
      Theta: "Θ",
      theta: "θ",
      thetasym: "ϑ",
      thetav: "ϑ",
      thickapprox: "≈",
      thicksim: "∼",
      ThickSpace: "  ",
      thinsp: " ",
      ThinSpace: " ",
      thkap: "≈",
      thksim: "∼",
      THORN: "Þ",
      thorn: "þ",
      Tilde: "∼",
      tilde: "˜",
      TildeEqual: "≃",
      TildeFullEqual: "≅",
      TildeTilde: "≈",
      times: "×",
      timesb: "⊠",
      timesbar: "⨱",
      timesd: "⨰",
      tint: "∭",
      toea: "⤨",
      top: "⊤",
      topbot: "⌶",
      topcir: "⫱",
      Topf: "𝕋",
      topf: "𝕥",
      topfork: "⫚",
      tosa: "⤩",
      tprime: "‴",
      TRADE: "™",
      trade: "™",
      triangle: "▵",
      triangledown: "▿",
      triangleleft: "◃",
      trianglelefteq: "⊴",
      triangleq: "≜",
      triangleright: "▹",
      trianglerighteq: "⊵",
      tridot: "◬",
      trie: "≜",
      triminus: "⨺",
      TripleDot: "⃛",
      triplus: "⨹",
      trisb: "⧍",
      tritime: "⨻",
      trpezium: "⏢",
      Tscr: "𝒯",
      tscr: "𝓉",
      TScy: "Ц",
      tscy: "ц",
      TSHcy: "Ћ",
      tshcy: "ћ",
      Tstrok: "Ŧ",
      tstrok: "ŧ",
      twixt: "≬",
      twoheadleftarrow: "↞",
      twoheadrightarrow: "↠",
      Uacute: "Ú",
      uacute: "ú",
      Uarr: "↟",
      uArr: "⇑",
      uarr: "↑",
      Uarrocir: "⥉",
      Ubrcy: "Ў",
      ubrcy: "ў",
      Ubreve: "Ŭ",
      ubreve: "ŭ",
      Ucirc: "Û",
      ucirc: "û",
      Ucy: "У",
      ucy: "у",
      udarr: "⇅",
      Udblac: "Ű",
      udblac: "ű",
      udhar: "⥮",
      ufisht: "⥾",
      Ufr: "𝔘",
      ufr: "𝔲",
      Ugrave: "Ù",
      ugrave: "ù",
      uHar: "⥣",
      uharl: "↿",
      uharr: "↾",
      uhblk: "▀",
      ulcorn: "⌜",
      ulcorner: "⌜",
      ulcrop: "⌏",
      ultri: "◸",
      Umacr: "Ū",
      umacr: "ū",
      uml: "¨",
      UnderBar: "_",
      UnderBrace: "⏟",
      UnderBracket: "⎵",
      UnderParenthesis: "⏝",
      Union: "⋃",
      UnionPlus: "⊎",
      Uogon: "Ų",
      uogon: "ų",
      Uopf: "𝕌",
      uopf: "𝕦",
      UpArrow: "↑",
      Uparrow: "⇑",
      uparrow: "↑",
      UpArrowBar: "⤒",
      UpArrowDownArrow: "⇅",
      UpDownArrow: "↕",
      Updownarrow: "⇕",
      updownarrow: "↕",
      UpEquilibrium: "⥮",
      upharpoonleft: "↿",
      upharpoonright: "↾",
      uplus: "⊎",
      UpperLeftArrow: "↖",
      UpperRightArrow: "↗",
      Upsi: "ϒ",
      upsi: "υ",
      upsih: "ϒ",
      Upsilon: "Υ",
      upsilon: "υ",
      UpTee: "⊥",
      UpTeeArrow: "↥",
      upuparrows: "⇈",
      urcorn: "⌝",
      urcorner: "⌝",
      urcrop: "⌎",
      Uring: "Ů",
      uring: "ů",
      urtri: "◹",
      Uscr: "𝒰",
      uscr: "𝓊",
      utdot: "⋰",
      Utilde: "Ũ",
      utilde: "ũ",
      utri: "▵",
      utrif: "▴",
      uuarr: "⇈",
      Uuml: "Ü",
      uuml: "ü",
      uwangle: "⦧",
      vangrt: "⦜",
      varepsilon: "ϵ",
      varkappa: "ϰ",
      varnothing: "∅",
      varphi: "ϕ",
      varpi: "ϖ",
      varpropto: "∝",
      vArr: "⇕",
      varr: "↕",
      varrho: "ϱ",
      varsigma: "ς",
      varsubsetneq: "⊊︀",
      varsubsetneqq: "⫋︀",
      varsupsetneq: "⊋︀",
      varsupsetneqq: "⫌︀",
      vartheta: "ϑ",
      vartriangleleft: "⊲",
      vartriangleright: "⊳",
      Vbar: "⫫",
      vBar: "⫨",
      vBarv: "⫩",
      Vcy: "В",
      vcy: "в",
      VDash: "⊫",
      Vdash: "⊩",
      vDash: "⊨",
      vdash: "⊢",
      Vdashl: "⫦",
      Vee: "⋁",
      vee: "∨",
      veebar: "⊻",
      veeeq: "≚",
      vellip: "⋮",
      Verbar: "‖",
      verbar: "|",
      Vert: "‖",
      vert: "|",
      VerticalBar: "∣",
      VerticalLine: "|",
      VerticalSeparator: "❘",
      VerticalTilde: "≀",
      VeryThinSpace: " ",
      Vfr: "𝔙",
      vfr: "𝔳",
      vltri: "⊲",
      vnsub: "⊂⃒",
      vnsup: "⊃⃒",
      Vopf: "𝕍",
      vopf: "𝕧",
      vprop: "∝",
      vrtri: "⊳",
      Vscr: "𝒱",
      vscr: "𝓋",
      vsubnE: "⫋︀",
      vsubne: "⊊︀",
      vsupnE: "⫌︀",
      vsupne: "⊋︀",
      Vvdash: "⊪",
      vzigzag: "⦚",
      Wcirc: "Ŵ",
      wcirc: "ŵ",
      wedbar: "⩟",
      Wedge: "⋀",
      wedge: "∧",
      wedgeq: "≙",
      weierp: "℘",
      Wfr: "𝔚",
      wfr: "𝔴",
      Wopf: "𝕎",
      wopf: "𝕨",
      wp: "℘",
      wr: "≀",
      wreath: "≀",
      Wscr: "𝒲",
      wscr: "𝓌",
      xcap: "⋂",
      xcirc: "◯",
      xcup: "⋃",
      xdtri: "▽",
      Xfr: "𝔛",
      xfr: "𝔵",
      xhArr: "⟺",
      xharr: "⟷",
      Xi: "Ξ",
      xi: "ξ",
      xlArr: "⟸",
      xlarr: "⟵",
      xmap: "⟼",
      xnis: "⋻",
      xodot: "⨀",
      Xopf: "𝕏",
      xopf: "𝕩",
      xoplus: "⨁",
      xotime: "⨂",
      xrArr: "⟹",
      xrarr: "⟶",
      Xscr: "𝒳",
      xscr: "𝓍",
      xsqcup: "⨆",
      xuplus: "⨄",
      xutri: "△",
      xvee: "⋁",
      xwedge: "⋀",
      Yacute: "Ý",
      yacute: "ý",
      YAcy: "Я",
      yacy: "я",
      Ycirc: "Ŷ",
      ycirc: "ŷ",
      Ycy: "Ы",
      ycy: "ы",
      yen: "¥",
      Yfr: "𝔜",
      yfr: "𝔶",
      YIcy: "Ї",
      yicy: "ї",
      Yopf: "𝕐",
      yopf: "𝕪",
      Yscr: "𝒴",
      yscr: "𝓎",
      YUcy: "Ю",
      yucy: "ю",
      Yuml: "Ÿ",
      yuml: "ÿ",
      Zacute: "Ź",
      zacute: "ź",
      Zcaron: "Ž",
      zcaron: "ž",
      Zcy: "З",
      zcy: "з",
      Zdot: "Ż",
      zdot: "ż",
      zeetrf: "ℨ",
      ZeroWidthSpace: "​",
      Zeta: "Ζ",
      zeta: "ζ",
      Zfr: "ℨ",
      zfr: "𝔷",
      ZHcy: "Ж",
      zhcy: "ж",
      zigrarr: "⇝",
      Zopf: "ℤ",
      zopf: "𝕫",
      Zscr: "𝒵",
      zscr: "𝓏",
      zwj: "‍",
      zwnj: "‌"
    });
    exports2.entityMap = exports2.HTML_ENTITIES;
  }
});

// node_modules/@xmldom/xmldom/lib/sax.js
var require_sax = __commonJS({
  "node_modules/@xmldom/xmldom/lib/sax.js"(exports2) {
    var NAMESPACE = require_conventions().NAMESPACE;
    var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
    var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_SPACE = 2;
    var S_EQ = 3;
    var S_ATTR_NOQUOT_VALUE = 4;
    var S_ATTR_END = 5;
    var S_TAG_SPACE = 6;
    var S_TAG_CLOSE = 7;
    function ParseError(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
    }
    ParseError.prototype = new Error();
    ParseError.prototype.name = ParseError.name;
    function XMLReader() {
    }
    XMLReader.prototype = {
      parse: function(source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = {});
        parse(
          source,
          defaultNSMap,
          entityMap,
          domBuilder,
          this.errorHandler
        );
        domBuilder.endDocument();
      }
    };
    function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      function fixedFromCharCode(code) {
        if (code > 65535) {
          code -= 65536;
          var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      function entityReplacer(a2) {
        var k = a2.slice(1, -1);
        if (Object.hasOwnProperty.call(entityMap, k)) {
          return entityMap[k];
        } else if (k.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a2);
          return a2;
        }
      }
      function appendText(end2) {
        if (end2 > start) {
          var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
          locator && position(start);
          domBuilder.characters(xt, 0, end2 - start);
          start = end2;
        }
      }
      function position(p, m) {
        while (p >= lineEnd && (m = linePattern.exec(source))) {
          lineStart = m.index;
          lineEnd = lineStart + m[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p - lineStart + 1;
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /.*(?:\r\n?|\n)|.*$/g;
      var locator = domBuilder.locator;
      var parseStack = [{ currentNSMap: defaultNSMapCopy }];
      var closeMap = {};
      var start = 0;
      while (true) {
        try {
          var tagStart = source.indexOf("<", start);
          if (tagStart < 0) {
            if (!source.substr(start).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source.substr(start));
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start) {
            appendText(tagStart);
          }
          switch (source.charAt(tagStart + 1)) {
            case "/":
              var end = source.indexOf(">", tagStart + 3);
              var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
              var config = parseStack.pop();
              if (end < 0) {
                tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
                end = tagStart + 1 + tagName.length;
              } else if (tagName.match(/\s</)) {
                tagName = tagName.replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " maybe not complete");
                end = tagStart + 1 + tagName.length;
              }
              var localNSMap = config.localNSMap;
              var endMatch = config.tagName == tagName;
              var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
              if (endIgnoreCaseMach) {
                domBuilder.endElement(config.uri, config.localName, tagName);
                if (localNSMap) {
                  for (var prefix in localNSMap) {
                    if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                      domBuilder.endPrefixMapping(prefix);
                    }
                  }
                }
                if (!endMatch) {
                  errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
                }
              } else {
                parseStack.push(config);
              }
              end++;
              break;
            // end elment
            case "?":
              locator && position(tagStart);
              end = parseInstruction(source, tagStart, domBuilder);
              break;
            case "!":
              locator && position(tagStart);
              end = parseDCC(source, tagStart, domBuilder, errorHandler);
              break;
            default:
              locator && position(tagStart);
              var el = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
              var len = el.length;
              if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                el.closed = true;
                if (!entityMap.nbsp) {
                  errorHandler.warning("unclosed xml attribute");
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                for (var i = 0; i < len; i++) {
                  var a = el[i];
                  position(a.offset);
                  a.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
              }
              if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
              } else {
                end++;
              }
          }
        } catch (e) {
          if (e instanceof ParseError) {
            throw e;
          }
          errorHandler.error("element parse error: " + e);
          end = -1;
        }
        if (end > start) {
          start = end;
        } else {
          appendText(Math.max(tagStart, start) + 1);
        }
      }
    }
    function copyLocator(f, t) {
      t.lineNumber = f.lineNumber;
      t.columnNumber = f.columnNumber;
      return t;
    }
    function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
      function addAttribute(qname, value2, startIndex) {
        if (el.attributeNames.hasOwnProperty(qname)) {
          errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        el.addValue(
          qname,
          // @see https://www.w3.org/TR/xml/#AVNormalize
          // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
          // - recursive replacement of (DTD) entity references
          // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
          value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
          startIndex
        );
      }
      var attrName;
      var value;
      var p = ++start;
      var s = S_TAG;
      while (true) {
        var c = source.charAt(p);
        switch (c) {
          case "=":
            if (s === S_ATTR) {
              attrName = source.slice(start, p);
              s = S_EQ;
            } else if (s === S_ATTR_SPACE) {
              s = S_EQ;
            } else {
              throw new Error("attribute equal must after attrName");
            }
            break;
          case "'":
          case '"':
            if (s === S_EQ || s === S_ATTR) {
              if (s === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source.slice(start, p);
              }
              start = p + 1;
              p = source.indexOf(c, start);
              if (p > 0) {
                value = source.slice(start, p);
                addAttribute(attrName, value, start - 1);
                s = S_ATTR_END;
              } else {
                throw new Error("attribute value no end '" + c + "' match");
              }
            } else if (s == S_ATTR_NOQUOT_VALUE) {
              value = source.slice(start, p);
              addAttribute(attrName, value, start);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
              start = p + 1;
              s = S_ATTR_END;
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case "/":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s = S_TAG_CLOSE;
                el.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                break;
              case S_ATTR_SPACE:
                el.closed = true;
                break;
              //case S_EQ:
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            errorHandler.error("unexpected end of input");
            if (s == S_TAG) {
              el.setTagName(source.slice(start, p));
            }
            return p;
          case ">":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break;
              //normal
              case S_ATTR_NOQUOT_VALUE:
              //Compatible state
              case S_ATTR:
                value = source.slice(start, p);
                if (value.slice(-1) === "/") {
                  el.closed = true;
                  value = value.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s === S_ATTR_SPACE) {
                  value = attrName;
                }
                if (s == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning('attribute "' + value + '" missed quot(")!');
                  addAttribute(attrName, value, start);
                } else {
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                  }
                  addAttribute(value, value, start);
                }
                break;
              case S_EQ:
                throw new Error("attribute value missed!!");
            }
            return p;
          /*xml space '\x20' | #x9 | #xD | #xA; */
          case "":
            c = " ";
          default:
            if (c <= " ") {
              switch (s) {
                case S_TAG:
                  el.setTagName(source.slice(start, p));
                  s = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source.slice(start, p);
                  s = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value = source.slice(start, p);
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  addAttribute(attrName, value, start);
                case S_ATTR_END:
                  s = S_TAG_SPACE;
                  break;
              }
            } else {
              switch (s) {
                //case S_TAG:void();break;
                //case S_ATTR:void();break;
                //case S_ATTR_NOQUOT_VALUE:void();break;
                case S_ATTR_SPACE:
                  var tagName = el.tagName;
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                  }
                  addAttribute(attrName, attrName, start);
                  start = p;
                  s = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!');
                case S_TAG_SPACE:
                  s = S_ATTR;
                  start = p;
                  break;
                case S_EQ:
                  s = S_ATTR_NOQUOT_VALUE;
                  start = p;
                  break;
                case S_TAG_CLOSE:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p++;
      }
    }
    function appendElement(el, domBuilder, currentNSMap) {
      var tagName = el.tagName;
      var localNSMap = null;
      var i = el.length;
      while (i--) {
        var a = el[i];
        var qName = a.qName;
        var value = a.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix = a.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === "xmlns" && localName;
        } else {
          localName = qName;
          prefix = null;
          nsPrefix = qName === "xmlns" && "";
        }
        a.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = {};
            _copy(currentNSMap, currentNSMap = {});
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a.uri = NAMESPACE.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value);
        }
      }
      var i = el.length;
      while (i--) {
        a = el[i];
        var prefix = a.prefix;
        if (prefix) {
          if (prefix === "xml") {
            a.uri = NAMESPACE.XML;
          }
          if (prefix !== "xmlns") {
            a.uri = currentNSMap[prefix || ""];
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix = el.prefix = tagName.slice(0, nsp);
        localName = el.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null;
        localName = el.localName = tagName;
      }
      var ns = el.uri = currentNSMap[prefix || ""];
      domBuilder.startElement(ns, localName, tagName, el);
      if (el.closed) {
        domBuilder.endElement(ns, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
              domBuilder.endPrefixMapping(prefix);
            }
          }
        }
      } else {
        el.currentNSMap = currentNSMap;
        el.localNSMap = localNSMap;
        return true;
      }
    }
    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
      if (/^(?:script|textarea)$/i.test(tagName)) {
        var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
        var text = source.substring(elStartEnd + 1, elEndStart);
        if (/[&<]/.test(text)) {
          if (/^script$/i.test(tagName)) {
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
          text = text.replace(/&#?\w+;/g, entityReplacer);
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
      }
      return elStartEnd + 1;
    }
    function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
      var pos = closeMap[tagName];
      if (pos == null) {
        pos = source.lastIndexOf("</" + tagName + ">");
        if (pos < elStartEnd) {
          pos = source.lastIndexOf("</" + tagName);
        }
        closeMap[tagName] = pos;
      }
      return pos < elStartEnd;
    }
    function _copy(source, target) {
      for (var n in source) {
        if (Object.prototype.hasOwnProperty.call(source, n)) {
          target[n] = source[n];
        }
      }
    }
    function parseDCC(source, start, domBuilder, errorHandler) {
      var next = source.charAt(start + 2);
      switch (next) {
        case "-":
          if (source.charAt(start + 3) === "-") {
            var end = source.indexOf("-->", start + 4);
            if (end > start) {
              domBuilder.comment(source, start + 4, end - start - 4);
              return end + 3;
            } else {
              errorHandler.error("Unclosed comment");
              return -1;
            }
          } else {
            return -1;
          }
        default:
          if (source.substr(start + 3, 6) == "CDATA[") {
            var end = source.indexOf("]]>", start + 9);
            domBuilder.startCDATA();
            domBuilder.characters(source, start + 9, end - start - 9);
            domBuilder.endCDATA();
            return end + 3;
          }
          var matchs = split(source, start);
          var len = matchs.length;
          if (len > 1 && /!doctype/i.test(matchs[0][0])) {
            var name = matchs[1][0];
            var pubid = false;
            var sysid = false;
            if (len > 3) {
              if (/^public$/i.test(matchs[2][0])) {
                pubid = matchs[3][0];
                sysid = len > 4 && matchs[4][0];
              } else if (/^system$/i.test(matchs[2][0])) {
                sysid = matchs[3][0];
              }
            }
            var lastMatch = matchs[len - 1];
            domBuilder.startDTD(name, pubid, sysid);
            domBuilder.endDTD();
            return lastMatch.index + lastMatch[0].length;
          }
      }
      return -1;
    }
    function parseInstruction(source, start, domBuilder) {
      var end = source.indexOf("?>", start);
      if (end) {
        var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (match) {
          var len = match[0].length;
          domBuilder.processingInstruction(match[1], match[2]);
          return end + 2;
        } else {
          return -1;
        }
      }
      return -1;
    }
    function ElementAttributes() {
      this.attributeNames = {};
    }
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!tagNamePattern.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function(qName, value, offset) {
        if (!tagNamePattern.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = { qName, value, offset };
      },
      length: 0,
      getLocalName: function(i) {
        return this[i].localName;
      },
      getLocator: function(i) {
        return this[i].locator;
      },
      getQName: function(i) {
        return this[i].qName;
      },
      getURI: function(i) {
        return this[i].uri;
      },
      getValue: function(i) {
        return this[i].value;
      }
      //	,getIndex:function(uri, localName)){
      //		if(localName){
      //
      //		}else{
      //			var qName = uri
      //		}
      //	},
      //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
      //	getType:function(uri,localName){}
      //	getType:function(i){},
    };
    function split(source, start) {
      var match;
      var buf = [];
      var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      reg.lastIndex = start;
      reg.exec(source);
      while (match = reg.exec(source)) {
        buf.push(match);
        if (match[1]) return buf;
      }
    }
    exports2.XMLReader = XMLReader;
    exports2.ParseError = ParseError;
  }
});

// node_modules/@xmldom/xmldom/lib/dom-parser.js
var require_dom_parser = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports2) {
    var conventions = require_conventions();
    var dom = require_dom();
    var entities = require_entities();
    var sax = require_sax();
    var DOMImplementation = dom.DOMImplementation;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = sax.ParseError;
    var XMLReader = sax.XMLReader;
    function normalizeLineEndings(input) {
      return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
    }
    function DOMParser(options2) {
      this.options = options2 || { locator: {} };
    }
    DOMParser.prototype.parseFromString = function(source, mimeType) {
      var options2 = this.options;
      var sax2 = new XMLReader();
      var domBuilder = options2.domBuilder || new DOMHandler();
      var errorHandler = options2.errorHandler;
      var locator = options2.locator;
      var defaultNSMap = options2.xmlns || {};
      var isHTML = /\/x?html?$/.test(mimeType);
      var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
      if (locator) {
        domBuilder.setDocumentLocator(locator);
      }
      sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
      sax2.domBuilder = options2.domBuilder || domBuilder;
      if (isHTML) {
        defaultNSMap[""] = NAMESPACE.HTML;
      }
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      var normalize = options2.normalizeLineEndings || normalizeLineEndings;
      if (source && typeof source === "string") {
        sax2.parse(
          normalize(source),
          defaultNSMap,
          entityMap
        );
      } else {
        sax2.errorHandler.error("invalid doc source");
      }
      return domBuilder.doc;
    };
    function buildErrorHandler(errorImpl, domBuilder, locator) {
      if (!errorImpl) {
        if (domBuilder instanceof DOMHandler) {
          return domBuilder;
        }
        errorImpl = domBuilder;
      }
      var errorHandler = {};
      var isCallback = errorImpl instanceof Function;
      locator = locator || {};
      function build(key) {
        var fn = errorImpl[key];
        if (!fn && isCallback) {
          fn = errorImpl.length == 2 ? function(msg) {
            errorImpl(key, msg);
          } : errorImpl;
        }
        errorHandler[key] = fn && function(msg) {
          fn("[xmldom " + key + "]	" + msg + _locator(locator));
        } || function() {
        };
      }
      build("warning");
      build("error");
      build("fatalError");
      return errorHandler;
    }
    function DOMHandler() {
      this.cdata = false;
    }
    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    DOMHandler.prototype = {
      startDocument: function() {
        this.doc = new DOMImplementation().createDocument(null, null, null);
        if (this.locator) {
          this.doc.documentURI = this.locator.systemId;
        }
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el);
        this.currentElement = el;
        this.locator && position(this.locator, el);
        for (var i = 0; i < len; i++) {
          var namespaceURI = attrs.getURI(i);
          var value = attrs.getValue(i);
          var qName = attrs.getQName(i);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i), attr);
          attr.value = attr.nodeValue = value;
          el.setAttributeNode(attr);
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        var current = this.currentElement;
        var tagName = current.tagName;
        this.currentElement = current.parentNode;
      },
      startPrefixMapping: function(prefix, uri) {
      },
      endPrefixMapping: function(prefix) {
      },
      processingInstruction: function(target, data) {
        var ins = this.doc.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch, start, length) {
      },
      characters: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function(name) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      setDocumentLocator: function(locator) {
        if (this.locator = locator) {
          locator.lineNumber = 0;
        }
      },
      //LexicalHandler
      comment: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name, publicId, systemId) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name, publicId, systemId);
          this.locator && position(this.locator, dt);
          appendElement(this, dt);
          this.doc.doctype = dt;
        }
      },
      /**
       * @see org.xml.sax.ErrorHandler
       * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
       */
      warning: function(error) {
        console.warn("[xmldom warning]	" + error, _locator(this.locator));
      },
      error: function(error) {
        console.error("[xmldom error]	" + error, _locator(this.locator));
      },
      fatalError: function(error) {
        throw new ParseError(error, this.locator);
      }
    };
    function _locator(l) {
      if (l) {
        return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
      }
    }
    function _toString(chars, start, length) {
      if (typeof chars == "string") {
        return chars.substr(start, length);
      } else {
        if (chars.length >= start + length || start) {
          return new java.lang.String(chars, start, length) + "";
        }
        return chars;
      }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
      DOMHandler.prototype[key] = function() {
        return null;
      };
    });
    function appendElement(hander, node) {
      if (!hander.currentElement) {
        hander.doc.appendChild(node);
      } else {
        hander.currentElement.appendChild(node);
      }
    }
    exports2.__DOMHandler = DOMHandler;
    exports2.normalizeLineEndings = normalizeLineEndings;
    exports2.DOMParser = DOMParser;
  }
});

// node_modules/@xmldom/xmldom/lib/index.js
var require_lib = __commonJS({
  "node_modules/@xmldom/xmldom/lib/index.js"(exports2) {
    var dom = require_dom();
    exports2.DOMImplementation = dom.DOMImplementation;
    exports2.XMLSerializer = dom.XMLSerializer;
    exports2.DOMParser = require_dom_parser().DOMParser;
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/strtok3/lib/FsPromise.js
var require_FsPromise = __commonJS({
  "node_modules/strtok3/lib/FsPromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readFile = exports2.writeFileSync = exports2.writeFile = exports2.read = exports2.open = exports2.close = exports2.stat = exports2.createReadStream = exports2.pathExists = void 0;
    var fs = require_fs();
    exports2.pathExists = fs.existsSync;
    exports2.createReadStream = fs.createReadStream;
    async function stat(path) {
      return new Promise((resolve2, reject2) => {
        fs.stat(path, (err, stats) => {
          if (err)
            reject2(err);
          else
            resolve2(stats);
        });
      });
    }
    exports2.stat = stat;
    async function close(fd) {
      return new Promise((resolve2, reject2) => {
        fs.close(fd, (err) => {
          if (err)
            reject2(err);
          else
            resolve2();
        });
      });
    }
    exports2.close = close;
    async function open(path, mode) {
      return new Promise((resolve2, reject2) => {
        fs.open(path, mode, (err, fd) => {
          if (err)
            reject2(err);
          else
            resolve2(fd);
        });
      });
    }
    exports2.open = open;
    async function read(fd, buffer, offset, length, position) {
      return new Promise((resolve2, reject2) => {
        fs.read(fd, buffer, offset, length, position, (err, bytesRead, _buffer) => {
          if (err)
            reject2(err);
          else
            resolve2({ bytesRead, buffer: _buffer });
        });
      });
    }
    exports2.read = read;
    async function writeFile(path, data) {
      return new Promise((resolve2, reject2) => {
        fs.writeFile(path, data, (err) => {
          if (err)
            reject2(err);
          else
            resolve2();
        });
      });
    }
    exports2.writeFile = writeFile;
    function writeFileSync(path, data) {
      fs.writeFileSync(path, data);
    }
    exports2.writeFileSync = writeFileSync;
    async function readFile(path) {
      return new Promise((resolve2, reject2) => {
        fs.readFile(path, (err, buffer) => {
          if (err)
            reject2(err);
          else
            resolve2(buffer);
        });
      });
    }
    exports2.readFile = readFile;
  }
});

// node_modules/peek-readable/lib/EndOfFileStream.js
var require_EndOfFileStream = __commonJS({
  "node_modules/peek-readable/lib/EndOfFileStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EndOfStreamError = exports2.defaultMessages = void 0;
    exports2.defaultMessages = "End-Of-Stream";
    var EndOfStreamError = class extends Error {
      constructor() {
        super(exports2.defaultMessages);
      }
    };
    exports2.EndOfStreamError = EndOfStreamError;
  }
});

// node_modules/peek-readable/lib/Deferred.js
var require_Deferred = __commonJS({
  "node_modules/peek-readable/lib/Deferred.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Deferred = void 0;
    var Deferred = class {
      constructor() {
        this.resolve = () => null;
        this.reject = () => null;
        this.promise = new Promise((resolve2, reject2) => {
          this.reject = reject2;
          this.resolve = resolve2;
        });
      }
    };
    exports2.Deferred = Deferred;
  }
});

// node_modules/peek-readable/lib/StreamReader.js
var require_StreamReader = __commonJS({
  "node_modules/peek-readable/lib/StreamReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamReader = exports2.EndOfStreamError = void 0;
    var EndOfFileStream_1 = require_EndOfFileStream();
    var Deferred_1 = require_Deferred();
    var EndOfFileStream_2 = require_EndOfFileStream();
    Object.defineProperty(exports2, "EndOfStreamError", { enumerable: true, get: function() {
      return EndOfFileStream_2.EndOfStreamError;
    } });
    var maxStreamReadSize = 1 * 1024 * 1024;
    var StreamReader = class {
      constructor(s) {
        this.s = s;
        this.deferred = null;
        this.endOfStream = false;
        this.peekQueue = [];
        if (!s.read || !s.once) {
          throw new Error("Expected an instance of stream.Readable");
        }
        this.s.once("end", () => this.reject(new EndOfFileStream_1.EndOfStreamError()));
        this.s.once("error", (err) => this.reject(err));
        this.s.once("close", () => this.reject(new Error("Stream closed")));
      }
      /**
       * Read ahead (peek) from stream. Subsequent read or peeks will return the same data
       * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in
       * @param offset - Offset target
       * @param length - Number of bytes to read
       * @returns Number of bytes peeked
       */
      async peek(uint8Array, offset, length) {
        const bytesRead = await this.read(uint8Array, offset, length);
        this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead));
        return bytesRead;
      }
      /**
       * Read chunk from stream
       * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
       * @param offset - Offset target
       * @param length - Number of bytes to read
       * @returns Number of bytes read
       */
      async read(buffer, offset, length) {
        if (length === 0) {
          return 0;
        }
        if (this.peekQueue.length === 0 && this.endOfStream) {
          throw new EndOfFileStream_1.EndOfStreamError();
        }
        let remaining = length;
        let bytesRead = 0;
        while (this.peekQueue.length > 0 && remaining > 0) {
          const peekData = this.peekQueue.pop();
          if (!peekData)
            throw new Error("peekData should be defined");
          const lenCopy = Math.min(peekData.length, remaining);
          buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
          bytesRead += lenCopy;
          remaining -= lenCopy;
          if (lenCopy < peekData.length) {
            this.peekQueue.push(peekData.subarray(lenCopy));
          }
        }
        while (remaining > 0 && !this.endOfStream) {
          const reqLen = Math.min(remaining, maxStreamReadSize);
          const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
          bytesRead += chunkLen;
          if (chunkLen < reqLen)
            break;
          remaining -= chunkLen;
        }
        return bytesRead;
      }
      /**
       * Read chunk from stream
       * @param buffer Target Uint8Array (or Buffer) to store data read from stream in
       * @param offset Offset target
       * @param length Number of bytes to read
       * @returns Number of bytes read
       */
      async readFromStream(buffer, offset, length) {
        const readBuffer = this.s.read(length);
        if (readBuffer) {
          buffer.set(readBuffer, offset);
          return readBuffer.length;
        } else {
          const request = {
            buffer,
            offset,
            length,
            deferred: new Deferred_1.Deferred()
          };
          this.deferred = request.deferred;
          this.s.once("readable", () => {
            this.readDeferred(request);
          });
          return request.deferred.promise;
        }
      }
      /**
       * Process deferred read request
       * @param request Deferred read request
       */
      readDeferred(request) {
        const readBuffer = this.s.read(request.length);
        if (readBuffer) {
          request.buffer.set(readBuffer, request.offset);
          request.deferred.resolve(readBuffer.length);
          this.deferred = null;
        } else {
          this.s.once("readable", () => {
            this.readDeferred(request);
          });
        }
      }
      reject(err) {
        this.endOfStream = true;
        if (this.deferred) {
          this.deferred.reject(err);
          this.deferred = null;
        }
      }
    };
    exports2.StreamReader = StreamReader;
  }
});

// node_modules/peek-readable/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/peek-readable/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamReader = exports2.EndOfStreamError = void 0;
    var EndOfFileStream_1 = require_EndOfFileStream();
    Object.defineProperty(exports2, "EndOfStreamError", { enumerable: true, get: function() {
      return EndOfFileStream_1.EndOfStreamError;
    } });
    var StreamReader_1 = require_StreamReader();
    Object.defineProperty(exports2, "StreamReader", { enumerable: true, get: function() {
      return StreamReader_1.StreamReader;
    } });
  }
});

// node_modules/strtok3/lib/AbstractTokenizer.js
var require_AbstractTokenizer = __commonJS({
  "node_modules/strtok3/lib/AbstractTokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractTokenizer = void 0;
    var peek_readable_1 = require_lib2();
    var AbstractTokenizer = class {
      constructor(fileInfo) {
        this.position = 0;
        this.numBuffer = new Uint8Array(8);
        this.fileInfo = fileInfo ? fileInfo : {};
      }
      /**
       * Read a token from the tokenizer-stream
       * @param token - The token to read
       * @param position - If provided, the desired position in the tokenizer-stream
       * @returns Promise with token data
       */
      async readToken(token, position = this.position) {
        const uint8Array = Buffer.alloc(token.len);
        const len = await this.readBuffer(uint8Array, { position });
        if (len < token.len)
          throw new peek_readable_1.EndOfStreamError();
        return token.get(uint8Array, 0);
      }
      /**
       * Peek a token from the tokenizer-stream.
       * @param token - Token to peek from the tokenizer-stream.
       * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
       * @returns Promise with token data
       */
      async peekToken(token, position = this.position) {
        const uint8Array = Buffer.alloc(token.len);
        const len = await this.peekBuffer(uint8Array, { position });
        if (len < token.len)
          throw new peek_readable_1.EndOfStreamError();
        return token.get(uint8Array, 0);
      }
      /**
       * Read a numeric token from the stream
       * @param token - Numeric token
       * @returns Promise with number
       */
      async readNumber(token) {
        const len = await this.readBuffer(this.numBuffer, { length: token.len });
        if (len < token.len)
          throw new peek_readable_1.EndOfStreamError();
        return token.get(this.numBuffer, 0);
      }
      /**
       * Read a numeric token from the stream
       * @param token - Numeric token
       * @returns Promise with number
       */
      async peekNumber(token) {
        const len = await this.peekBuffer(this.numBuffer, { length: token.len });
        if (len < token.len)
          throw new peek_readable_1.EndOfStreamError();
        return token.get(this.numBuffer, 0);
      }
      /**
       * Ignore number of bytes, advances the pointer in under tokenizer-stream.
       * @param length - Number of bytes to ignore
       * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
       */
      async ignore(length) {
        if (this.fileInfo.size !== void 0) {
          const bytesLeft = this.fileInfo.size - this.position;
          if (length > bytesLeft) {
            this.position += bytesLeft;
            return bytesLeft;
          }
        }
        this.position += length;
        return length;
      }
      async close() {
      }
      normalizeOptions(uint8Array, options2) {
        if (options2 && options2.position !== void 0 && options2.position < this.position) {
          throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        }
        if (options2) {
          return {
            mayBeLess: options2.mayBeLess === true,
            offset: options2.offset ? options2.offset : 0,
            length: options2.length ? options2.length : uint8Array.length - (options2.offset ? options2.offset : 0),
            position: options2.position ? options2.position : this.position
          };
        }
        return {
          mayBeLess: false,
          offset: 0,
          length: uint8Array.length,
          position: this.position
        };
      }
    };
    exports2.AbstractTokenizer = AbstractTokenizer;
  }
});

// node_modules/strtok3/lib/ReadStreamTokenizer.js
var require_ReadStreamTokenizer = __commonJS({
  "node_modules/strtok3/lib/ReadStreamTokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadStreamTokenizer = void 0;
    var AbstractTokenizer_1 = require_AbstractTokenizer();
    var peek_readable_1 = require_lib2();
    var maxBufferSize = 256e3;
    var ReadStreamTokenizer = class extends AbstractTokenizer_1.AbstractTokenizer {
      constructor(stream2, fileInfo) {
        super(fileInfo);
        this.streamReader = new peek_readable_1.StreamReader(stream2);
      }
      /**
       * Get file information, an HTTP-client may implement this doing a HEAD request
       * @return Promise with file information
       */
      async getFileInfo() {
        return this.fileInfo;
      }
      /**
       * Read buffer from tokenizer
       * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
       * @param options - Read behaviour options
       * @returns Promise with number of bytes read
       */
      async readBuffer(uint8Array, options2) {
        const normOptions = this.normalizeOptions(uint8Array, options2);
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
          await this.ignore(skipBytes);
          return this.readBuffer(uint8Array, options2);
        } else if (skipBytes < 0) {
          throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        }
        if (normOptions.length === 0) {
          return 0;
        }
        const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
        this.position += bytesRead;
        if ((!options2 || !options2.mayBeLess) && bytesRead < normOptions.length) {
          throw new peek_readable_1.EndOfStreamError();
        }
        return bytesRead;
      }
      /**
       * Peek (read ahead) buffer from tokenizer
       * @param uint8Array - Uint8Array (or Buffer) to write data to
       * @param options - Read behaviour options
       * @returns Promise with number of bytes peeked
       */
      async peekBuffer(uint8Array, options2) {
        const normOptions = this.normalizeOptions(uint8Array, options2);
        let bytesRead = 0;
        if (normOptions.position) {
          const skipBytes = normOptions.position - this.position;
          if (skipBytes > 0) {
            const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
            bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
            uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
            return bytesRead - skipBytes;
          } else if (skipBytes < 0) {
            throw new Error("Cannot peek from a negative offset in a stream");
          }
        }
        if (normOptions.length > 0) {
          try {
            bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
          } catch (err) {
            if (options2 && options2.mayBeLess && err instanceof peek_readable_1.EndOfStreamError) {
              return 0;
            }
            throw err;
          }
          if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
            throw new peek_readable_1.EndOfStreamError();
          }
        }
        return bytesRead;
      }
      async ignore(length) {
        const bufSize = Math.min(maxBufferSize, length);
        const buf = new Uint8Array(bufSize);
        let totBytesRead = 0;
        while (totBytesRead < length) {
          const remaining = length - totBytesRead;
          const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
          if (bytesRead < 0) {
            return bytesRead;
          }
          totBytesRead += bytesRead;
        }
        return totBytesRead;
      }
    };
    exports2.ReadStreamTokenizer = ReadStreamTokenizer;
  }
});

// node_modules/strtok3/lib/BufferTokenizer.js
var require_BufferTokenizer = __commonJS({
  "node_modules/strtok3/lib/BufferTokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BufferTokenizer = void 0;
    var peek_readable_1 = require_lib2();
    var AbstractTokenizer_1 = require_AbstractTokenizer();
    var BufferTokenizer = class extends AbstractTokenizer_1.AbstractTokenizer {
      /**
       * Construct BufferTokenizer
       * @param uint8Array - Uint8Array to tokenize
       * @param fileInfo - Pass additional file information to the tokenizer
       */
      constructor(uint8Array, fileInfo) {
        super(fileInfo);
        this.uint8Array = uint8Array;
        this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : uint8Array.length;
      }
      /**
       * Read buffer from tokenizer
       * @param uint8Array - Uint8Array to tokenize
       * @param options - Read behaviour options
       * @returns {Promise<number>}
       */
      async readBuffer(uint8Array, options2) {
        if (options2 && options2.position) {
          if (options2.position < this.position) {
            throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
          }
          this.position = options2.position;
        }
        const bytesRead = await this.peekBuffer(uint8Array, options2);
        this.position += bytesRead;
        return bytesRead;
      }
      /**
       * Peek (read ahead) buffer from tokenizer
       * @param uint8Array
       * @param options - Read behaviour options
       * @returns {Promise<number>}
       */
      async peekBuffer(uint8Array, options2) {
        const normOptions = this.normalizeOptions(uint8Array, options2);
        const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
        if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
          throw new peek_readable_1.EndOfStreamError();
        } else {
          uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
          return bytes2read;
        }
      }
      async close() {
      }
    };
    exports2.BufferTokenizer = BufferTokenizer;
  }
});

// node_modules/strtok3/lib/core.js
var require_core = __commonJS({
  "node_modules/strtok3/lib/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromBuffer = exports2.fromStream = exports2.EndOfStreamError = void 0;
    var ReadStreamTokenizer_1 = require_ReadStreamTokenizer();
    var BufferTokenizer_1 = require_BufferTokenizer();
    var peek_readable_1 = require_lib2();
    Object.defineProperty(exports2, "EndOfStreamError", { enumerable: true, get: function() {
      return peek_readable_1.EndOfStreamError;
    } });
    function fromStream2(stream2, fileInfo) {
      fileInfo = fileInfo ? fileInfo : {};
      return new ReadStreamTokenizer_1.ReadStreamTokenizer(stream2, fileInfo);
    }
    exports2.fromStream = fromStream2;
    function fromBuffer2(uint8Array, fileInfo) {
      return new BufferTokenizer_1.BufferTokenizer(uint8Array, fileInfo);
    }
    exports2.fromBuffer = fromBuffer2;
  }
});

// node_modules/strtok3/lib/FileTokenizer.js
var require_FileTokenizer = __commonJS({
  "node_modules/strtok3/lib/FileTokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromFile = exports2.FileTokenizer = void 0;
    var AbstractTokenizer_1 = require_AbstractTokenizer();
    var peek_readable_1 = require_lib2();
    var fs = require_FsPromise();
    var FileTokenizer = class extends AbstractTokenizer_1.AbstractTokenizer {
      constructor(fd, fileInfo) {
        super(fileInfo);
        this.fd = fd;
      }
      /**
       * Read buffer from file
       * @param uint8Array - Uint8Array to write result to
       * @param options - Read behaviour options
       * @returns Promise number of bytes read
       */
      async readBuffer(uint8Array, options2) {
        const normOptions = this.normalizeOptions(uint8Array, options2);
        this.position = normOptions.position;
        const res = await fs.read(this.fd, uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        this.position += res.bytesRead;
        if (res.bytesRead < normOptions.length && (!options2 || !options2.mayBeLess)) {
          throw new peek_readable_1.EndOfStreamError();
        }
        return res.bytesRead;
      }
      /**
       * Peek buffer from file
       * @param uint8Array - Uint8Array (or Buffer) to write data to
       * @param options - Read behaviour options
       * @returns Promise number of bytes read
       */
      async peekBuffer(uint8Array, options2) {
        const normOptions = this.normalizeOptions(uint8Array, options2);
        const res = await fs.read(this.fd, uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) {
          throw new peek_readable_1.EndOfStreamError();
        }
        return res.bytesRead;
      }
      async close() {
        return fs.close(this.fd);
      }
    };
    exports2.FileTokenizer = FileTokenizer;
    async function fromFile(sourceFilePath) {
      const stat = await fs.stat(sourceFilePath);
      if (!stat.isFile) {
        throw new Error(`File not a file: ${sourceFilePath}`);
      }
      const fd = await fs.open(sourceFilePath, "r");
      return new FileTokenizer(fd, { path: sourceFilePath, size: stat.size });
    }
    exports2.fromFile = fromFile;
  }
});

// node_modules/strtok3/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/strtok3/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromStream = exports2.fromBuffer = exports2.EndOfStreamError = exports2.fromFile = void 0;
    var fs = require_FsPromise();
    var core = require_core();
    var FileTokenizer_1 = require_FileTokenizer();
    Object.defineProperty(exports2, "fromFile", { enumerable: true, get: function() {
      return FileTokenizer_1.fromFile;
    } });
    var core_1 = require_core();
    Object.defineProperty(exports2, "EndOfStreamError", { enumerable: true, get: function() {
      return core_1.EndOfStreamError;
    } });
    Object.defineProperty(exports2, "fromBuffer", { enumerable: true, get: function() {
      return core_1.fromBuffer;
    } });
    async function fromStream2(stream2, fileInfo) {
      fileInfo = fileInfo ? fileInfo : {};
      if (stream2.path) {
        const stat = await fs.stat(stream2.path);
        fileInfo.path = stream2.path;
        fileInfo.size = stat.size;
      }
      return core.fromStream(stream2, fileInfo);
    }
    exports2.fromStream = fromStream2;
  }
});

// node_modules/token-types/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/token-types/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnsiStringType = exports2.StringType = exports2.BufferType = exports2.Uint8ArrayType = exports2.IgnoreType = exports2.Float80_LE = exports2.Float80_BE = exports2.Float64_LE = exports2.Float64_BE = exports2.Float32_LE = exports2.Float32_BE = exports2.Float16_LE = exports2.Float16_BE = exports2.INT64_BE = exports2.UINT64_BE = exports2.INT64_LE = exports2.UINT64_LE = exports2.INT32_LE = exports2.INT32_BE = exports2.INT24_BE = exports2.INT24_LE = exports2.INT16_LE = exports2.INT16_BE = exports2.INT8 = exports2.UINT32_BE = exports2.UINT32_LE = exports2.UINT24_BE = exports2.UINT24_LE = exports2.UINT16_BE = exports2.UINT16_LE = exports2.UINT8 = void 0;
    var ieee754 = require_ieee754();
    function dv(array) {
      return new DataView(array.buffer, array.byteOffset);
    }
    exports2.UINT8 = {
      len: 1,
      get(array, offset) {
        return dv(array).getUint8(offset);
      },
      put(array, offset, value) {
        dv(array).setUint8(offset, value);
        return offset + 1;
      }
    };
    exports2.UINT16_LE = {
      len: 2,
      get(array, offset) {
        return dv(array).getUint16(offset, true);
      },
      put(array, offset, value) {
        dv(array).setUint16(offset, value, true);
        return offset + 2;
      }
    };
    exports2.UINT16_BE = {
      len: 2,
      get(array, offset) {
        return dv(array).getUint16(offset);
      },
      put(array, offset, value) {
        dv(array).setUint16(offset, value);
        return offset + 2;
      }
    };
    exports2.UINT24_LE = {
      len: 3,
      get(array, offset) {
        const dataView = dv(array);
        return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);
      },
      put(array, offset, value) {
        const dataView = dv(array);
        dataView.setUint8(offset, value & 255);
        dataView.setUint16(offset + 1, value >> 8, true);
        return offset + 3;
      }
    };
    exports2.UINT24_BE = {
      len: 3,
      get(array, offset) {
        const dataView = dv(array);
        return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
      },
      put(array, offset, value) {
        const dataView = dv(array);
        dataView.setUint16(offset, value >> 8);
        dataView.setUint8(offset + 2, value & 255);
        return offset + 3;
      }
    };
    exports2.UINT32_LE = {
      len: 4,
      get(array, offset) {
        return dv(array).getUint32(offset, true);
      },
      put(array, offset, value) {
        dv(array).setUint32(offset, value, true);
        return offset + 4;
      }
    };
    exports2.UINT32_BE = {
      len: 4,
      get(array, offset) {
        return dv(array).getUint32(offset);
      },
      put(array, offset, value) {
        dv(array).setUint32(offset, value);
        return offset + 4;
      }
    };
    exports2.INT8 = {
      len: 1,
      get(array, offset) {
        return dv(array).getInt8(offset);
      },
      put(array, offset, value) {
        dv(array).setInt8(offset, value);
        return offset + 1;
      }
    };
    exports2.INT16_BE = {
      len: 2,
      get(array, offset) {
        return dv(array).getInt16(offset);
      },
      put(array, offset, value) {
        dv(array).setInt16(offset, value);
        return offset + 2;
      }
    };
    exports2.INT16_LE = {
      len: 2,
      get(array, offset) {
        return dv(array).getInt16(offset, true);
      },
      put(array, offset, value) {
        dv(array).setInt16(offset, value, true);
        return offset + 2;
      }
    };
    exports2.INT24_LE = {
      len: 3,
      get(array, offset) {
        const unsigned = exports2.UINT24_LE.get(array, offset);
        return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
      },
      put(array, offset, value) {
        const dataView = dv(array);
        dataView.setUint8(offset, value & 255);
        dataView.setUint16(offset + 1, value >> 8, true);
        return offset + 3;
      }
    };
    exports2.INT24_BE = {
      len: 3,
      get(array, offset) {
        const unsigned = exports2.UINT24_BE.get(array, offset);
        return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
      },
      put(array, offset, value) {
        const dataView = dv(array);
        dataView.setUint16(offset, value >> 8);
        dataView.setUint8(offset + 2, value & 255);
        return offset + 3;
      }
    };
    exports2.INT32_BE = {
      len: 4,
      get(array, offset) {
        return dv(array).getInt32(offset);
      },
      put(array, offset, value) {
        dv(array).setInt32(offset, value);
        return offset + 4;
      }
    };
    exports2.INT32_LE = {
      len: 4,
      get(array, offset) {
        return dv(array).getInt32(offset, true);
      },
      put(array, offset, value) {
        dv(array).setInt32(offset, value, true);
        return offset + 4;
      }
    };
    exports2.UINT64_LE = {
      len: 8,
      get(array, offset) {
        return dv(array).getBigUint64(offset, true);
      },
      put(array, offset, value) {
        dv(array).setBigUint64(offset, value, true);
        return offset + 8;
      }
    };
    exports2.INT64_LE = {
      len: 8,
      get(array, offset) {
        return dv(array).getBigInt64(offset, true);
      },
      put(array, offset, value) {
        dv(array).setBigInt64(offset, value, true);
        return offset + 8;
      }
    };
    exports2.UINT64_BE = {
      len: 8,
      get(array, offset) {
        return dv(array).getBigUint64(offset);
      },
      put(array, offset, value) {
        dv(array).setBigUint64(offset, value);
        return offset + 8;
      }
    };
    exports2.INT64_BE = {
      len: 8,
      get(array, offset) {
        return dv(array).getBigInt64(offset);
      },
      put(array, offset, value) {
        dv(array).setBigInt64(offset, value);
        return offset + 8;
      }
    };
    exports2.Float16_BE = {
      len: 2,
      get(dataView, offset) {
        return ieee754.read(dataView, offset, false, 10, this.len);
      },
      put(dataView, offset, value) {
        ieee754.write(dataView, value, offset, false, 10, this.len);
        return offset + this.len;
      }
    };
    exports2.Float16_LE = {
      len: 2,
      get(array, offset) {
        return ieee754.read(array, offset, true, 10, this.len);
      },
      put(array, offset, value) {
        ieee754.write(array, value, offset, true, 10, this.len);
        return offset + this.len;
      }
    };
    exports2.Float32_BE = {
      len: 4,
      get(array, offset) {
        return dv(array).getFloat32(offset);
      },
      put(array, offset, value) {
        dv(array).setFloat32(offset, value);
        return offset + 4;
      }
    };
    exports2.Float32_LE = {
      len: 4,
      get(array, offset) {
        return dv(array).getFloat32(offset, true);
      },
      put(array, offset, value) {
        dv(array).setFloat32(offset, value, true);
        return offset + 4;
      }
    };
    exports2.Float64_BE = {
      len: 8,
      get(array, offset) {
        return dv(array).getFloat64(offset);
      },
      put(array, offset, value) {
        dv(array).setFloat64(offset, value);
        return offset + 8;
      }
    };
    exports2.Float64_LE = {
      len: 8,
      get(array, offset) {
        return dv(array).getFloat64(offset, true);
      },
      put(array, offset, value) {
        dv(array).setFloat64(offset, value, true);
        return offset + 8;
      }
    };
    exports2.Float80_BE = {
      len: 10,
      get(array, offset) {
        return ieee754.read(array, offset, false, 63, this.len);
      },
      put(array, offset, value) {
        ieee754.write(array, value, offset, false, 63, this.len);
        return offset + this.len;
      }
    };
    exports2.Float80_LE = {
      len: 10,
      get(array, offset) {
        return ieee754.read(array, offset, true, 63, this.len);
      },
      put(array, offset, value) {
        ieee754.write(array, value, offset, true, 63, this.len);
        return offset + this.len;
      }
    };
    var IgnoreType = class {
      /**
       * @param len number of bytes to ignore
       */
      constructor(len) {
        this.len = len;
      }
      // ToDo: don't read, but skip data
      get(array, off) {
      }
    };
    exports2.IgnoreType = IgnoreType;
    var Uint8ArrayType = class {
      constructor(len) {
        this.len = len;
      }
      get(array, offset) {
        return array.subarray(offset, offset + this.len);
      }
    };
    exports2.Uint8ArrayType = Uint8ArrayType;
    var BufferType = class {
      constructor(len) {
        this.len = len;
      }
      get(uint8Array, off) {
        return Buffer.from(uint8Array.subarray(off, off + this.len));
      }
    };
    exports2.BufferType = BufferType;
    var StringType = class {
      constructor(len, encoding) {
        this.len = len;
        this.encoding = encoding;
      }
      get(uint8Array, offset) {
        return Buffer.from(uint8Array).toString(this.encoding, offset, offset + this.len);
      }
    };
    exports2.StringType = StringType;
    var AnsiStringType = class _AnsiStringType {
      constructor(len) {
        this.len = len;
      }
      static decode(buffer, offset, until) {
        let str = "";
        for (let i = offset; i < until; ++i) {
          str += _AnsiStringType.codePointToString(_AnsiStringType.singleByteDecoder(buffer[i]));
        }
        return str;
      }
      static inRange(a, min, max) {
        return min <= a && a <= max;
      }
      static codePointToString(cp) {
        if (cp <= 65535) {
          return String.fromCharCode(cp);
        } else {
          cp -= 65536;
          return String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
        }
      }
      static singleByteDecoder(bite) {
        if (_AnsiStringType.inRange(bite, 0, 127)) {
          return bite;
        }
        const codePoint = _AnsiStringType.windows1252[bite - 128];
        if (codePoint === null) {
          throw Error("invaliding encoding");
        }
        return codePoint;
      }
      get(buffer, offset = 0) {
        return _AnsiStringType.decode(buffer, offset, offset + this.len);
      }
    };
    exports2.AnsiStringType = AnsiStringType;
    AnsiStringType.windows1252 = [
      8364,
      129,
      8218,
      402,
      8222,
      8230,
      8224,
      8225,
      710,
      8240,
      352,
      8249,
      338,
      141,
      381,
      143,
      144,
      8216,
      8217,
      8220,
      8221,
      8226,
      8211,
      8212,
      732,
      8482,
      353,
      8250,
      339,
      157,
      382,
      376,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      193,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      219,
      220,
      221,
      222,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      235,
      236,
      237,
      238,
      239,
      240,
      241,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250,
      251,
      252,
      253,
      254,
      255
    ];
  }
});

// node_modules/file-type/util.js
var require_util2 = __commonJS({
  "node_modules/file-type/util.js"(exports2) {
    "use strict";
    exports2.stringToBytes = (string) => [...string].map((character) => character.charCodeAt(0));
    exports2.tarHeaderChecksumMatches = (buffer, offset = 0) => {
      const readSum = parseInt(buffer.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
      if (isNaN(readSum)) {
        return false;
      }
      let sum = 8 * 32;
      for (let i = offset; i < offset + 148; i++) {
        sum += buffer[i];
      }
      for (let i = offset + 156; i < offset + 512; i++) {
        sum += buffer[i];
      }
      return readSum === sum;
    };
    exports2.uint32SyncSafeToken = {
      get: (buffer, offset) => {
        return buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21;
      },
      len: 4
    };
  }
});

// node_modules/file-type/supported.js
var require_supported = __commonJS({
  "node_modules/file-type/supported.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      extensions: [
        "jpg",
        "png",
        "apng",
        "gif",
        "webp",
        "flif",
        "xcf",
        "cr2",
        "cr3",
        "orf",
        "arw",
        "dng",
        "nef",
        "rw2",
        "raf",
        "tif",
        "bmp",
        "icns",
        "jxr",
        "psd",
        "indd",
        "zip",
        "tar",
        "rar",
        "gz",
        "bz2",
        "7z",
        "dmg",
        "mp4",
        "mid",
        "mkv",
        "webm",
        "mov",
        "avi",
        "mpg",
        "mp2",
        "mp3",
        "m4a",
        "oga",
        "ogg",
        "ogv",
        "opus",
        "flac",
        "wav",
        "spx",
        "amr",
        "pdf",
        "epub",
        "exe",
        "swf",
        "rtf",
        "wasm",
        "woff",
        "woff2",
        "eot",
        "ttf",
        "otf",
        "ico",
        "flv",
        "ps",
        "xz",
        "sqlite",
        "nes",
        "crx",
        "xpi",
        "cab",
        "deb",
        "ar",
        "rpm",
        "Z",
        "lz",
        "cfb",
        "mxf",
        "mts",
        "blend",
        "bpg",
        "docx",
        "pptx",
        "xlsx",
        "3gp",
        "3g2",
        "jp2",
        "jpm",
        "jpx",
        "mj2",
        "aif",
        "qcp",
        "odt",
        "ods",
        "odp",
        "xml",
        "mobi",
        "heic",
        "cur",
        "ktx",
        "ape",
        "wv",
        "dcm",
        "ics",
        "glb",
        "pcap",
        "dsf",
        "lnk",
        "alias",
        "voc",
        "ac3",
        "m4v",
        "m4p",
        "m4b",
        "f4v",
        "f4p",
        "f4b",
        "f4a",
        "mie",
        "asf",
        "ogm",
        "ogx",
        "mpc",
        "arrow",
        "shp",
        "aac",
        "mp1",
        "it",
        "s3m",
        "xm",
        "ai",
        "skp",
        "avif",
        "eps",
        "lzh",
        "pgp",
        "asar",
        "stl",
        "chm",
        "3mf",
        "zst",
        "jxl",
        "vcf"
      ],
      mimeTypes: [
        "image/jpeg",
        "image/png",
        "image/gif",
        "image/webp",
        "image/flif",
        "image/x-xcf",
        "image/x-canon-cr2",
        "image/x-canon-cr3",
        "image/tiff",
        "image/bmp",
        "image/vnd.ms-photo",
        "image/vnd.adobe.photoshop",
        "application/x-indesign",
        "application/epub+zip",
        "application/x-xpinstall",
        "application/vnd.oasis.opendocument.text",
        "application/vnd.oasis.opendocument.spreadsheet",
        "application/vnd.oasis.opendocument.presentation",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "application/zip",
        "application/x-tar",
        "application/x-rar-compressed",
        "application/gzip",
        "application/x-bzip2",
        "application/x-7z-compressed",
        "application/x-apple-diskimage",
        "application/x-apache-arrow",
        "video/mp4",
        "audio/midi",
        "video/x-matroska",
        "video/webm",
        "video/quicktime",
        "video/vnd.avi",
        "audio/vnd.wave",
        "audio/qcelp",
        "audio/x-ms-asf",
        "video/x-ms-asf",
        "application/vnd.ms-asf",
        "video/mpeg",
        "video/3gpp",
        "audio/mpeg",
        "audio/mp4",
        // RFC 4337
        "audio/opus",
        "video/ogg",
        "audio/ogg",
        "application/ogg",
        "audio/x-flac",
        "audio/ape",
        "audio/wavpack",
        "audio/amr",
        "application/pdf",
        "application/x-msdownload",
        "application/x-shockwave-flash",
        "application/rtf",
        "application/wasm",
        "font/woff",
        "font/woff2",
        "application/vnd.ms-fontobject",
        "font/ttf",
        "font/otf",
        "image/x-icon",
        "video/x-flv",
        "application/postscript",
        "application/eps",
        "application/x-xz",
        "application/x-sqlite3",
        "application/x-nintendo-nes-rom",
        "application/x-google-chrome-extension",
        "application/vnd.ms-cab-compressed",
        "application/x-deb",
        "application/x-unix-archive",
        "application/x-rpm",
        "application/x-compress",
        "application/x-lzip",
        "application/x-cfb",
        "application/x-mie",
        "application/mxf",
        "video/mp2t",
        "application/x-blender",
        "image/bpg",
        "image/jp2",
        "image/jpx",
        "image/jpm",
        "image/mj2",
        "audio/aiff",
        "application/xml",
        "application/x-mobipocket-ebook",
        "image/heif",
        "image/heif-sequence",
        "image/heic",
        "image/heic-sequence",
        "image/icns",
        "image/ktx",
        "application/dicom",
        "audio/x-musepack",
        "text/calendar",
        "text/vcard",
        "model/gltf-binary",
        "application/vnd.tcpdump.pcap",
        "audio/x-dsf",
        // Non-standard
        "application/x.ms.shortcut",
        // Invented by us
        "application/x.apple.alias",
        // Invented by us
        "audio/x-voc",
        "audio/vnd.dolby.dd-raw",
        "audio/x-m4a",
        "image/apng",
        "image/x-olympus-orf",
        "image/x-sony-arw",
        "image/x-adobe-dng",
        "image/x-nikon-nef",
        "image/x-panasonic-rw2",
        "image/x-fujifilm-raf",
        "video/x-m4v",
        "video/3gpp2",
        "application/x-esri-shape",
        "audio/aac",
        "audio/x-it",
        "audio/x-s3m",
        "audio/x-xm",
        "video/MP1S",
        "video/MP2P",
        "application/vnd.sketchup.skp",
        "image/avif",
        "application/x-lzh-compressed",
        "application/pgp-encrypted",
        "application/x-asar",
        "model/stl",
        "application/vnd.ms-htmlhelp",
        "model/3mf",
        "image/jxl",
        "application/zstd"
      ]
    };
  }
});

// node_modules/file-type/core.js
var require_core2 = __commonJS({
  "node_modules/file-type/core.js"(exports, module) {
    "use strict";
    var Token = require_lib4();
    var strtok3 = require_core();
    var {
      stringToBytes,
      tarHeaderChecksumMatches,
      uint32SyncSafeToken
    } = require_util2();
    var supported = require_supported();
    var minimumBytes = 4100;
    async function fromStream(stream2) {
      const tokenizer = await strtok3.fromStream(stream2);
      try {
        return await fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    async function fromBuffer(input) {
      if (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {
        throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
      }
      const buffer = input instanceof Buffer ? input : Buffer.from(input);
      if (!(buffer && buffer.length > 1)) {
        return;
      }
      const tokenizer = strtok3.fromBuffer(buffer);
      return fromTokenizer(tokenizer);
    }
    function _check(buffer, headers, options2) {
      options2 = {
        offset: 0,
        ...options2
      };
      for (const [index, header] of headers.entries()) {
        if (options2.mask) {
          if (header !== (options2.mask[index] & buffer[index + options2.offset])) {
            return false;
          }
        } else if (header !== buffer[index + options2.offset]) {
          return false;
        }
      }
      return true;
    }
    async function fromTokenizer(tokenizer) {
      try {
        return _fromTokenizer(tokenizer);
      } catch (error) {
        if (!(error instanceof strtok3.EndOfStreamError)) {
          throw error;
        }
      }
    }
    async function _fromTokenizer(tokenizer) {
      let buffer = Buffer.alloc(minimumBytes);
      const bytesRead = 12;
      const check = (header, options2) => _check(buffer, header, options2);
      const checkString = (header, options2) => check(stringToBytes(header), options2);
      if (!tokenizer.fileInfo.size) {
        tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
      }
      await tokenizer.peekBuffer(buffer, { length: bytesRead, mayBeLess: true });
      if (check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (check([11, 119])) {
        return {
          ext: "ac3",
          mime: "audio/vnd.dolby.dd-raw"
        };
      }
      if (check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if (check([37, 33])) {
        await tokenizer.peekBuffer(buffer, { length: 24, mayBeLess: true });
        if (checkString("PS-Adobe-", { offset: 2 }) && checkString(" EPSF-", { offset: 14 })) {
          return {
            ext: "eps",
            mime: "application/eps"
          };
        }
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (check([31, 160]) || check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (check([255, 216, 255])) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (checkString("ID3")) {
        await tokenizer.ignore(6);
        const id3HeaderLen = await tokenizer.readToken(uint32SyncSafeToken);
        if (tokenizer.position + id3HeaderLen > tokenizer.fileInfo.size) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        await tokenizer.ignore(id3HeaderLen);
        return fromTokenizer(tokenizer);
      }
      if (checkString("MP+")) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if ((buffer[0] === 67 || buffer[0] === 70) && check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (checkString("FLIF")) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if (checkString("8BPS")) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (checkString("WEBP", { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (checkString("MPCK")) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if (checkString("FORM")) {
        return {
          ext: "aif",
          mime: "audio/aiff"
        };
      }
      if (checkString("icns", { offset: 0 })) {
        return {
          ext: "icns",
          mime: "image/icns"
        };
      }
      if (check([80, 75, 3, 4])) {
        try {
          while (tokenizer.position + 30 < tokenizer.fileInfo.size) {
            await tokenizer.readBuffer(buffer, { length: 30 });
            const zipHeader = {
              compressedSize: buffer.readUInt32LE(18),
              uncompressedSize: buffer.readUInt32LE(22),
              filenameLength: buffer.readUInt16LE(26),
              extraFieldLength: buffer.readUInt16LE(28)
            };
            zipHeader.filename = await tokenizer.readToken(new Token.StringType(zipHeader.filenameLength, "utf-8"));
            await tokenizer.ignore(zipHeader.extraFieldLength);
            if (zipHeader.filename === "META-INF/mozilla.rsa") {
              return {
                ext: "xpi",
                mime: "application/x-xpinstall"
              };
            }
            if (zipHeader.filename.endsWith(".rels") || zipHeader.filename.endsWith(".xml")) {
              const type = zipHeader.filename.split("/")[0];
              switch (type) {
                case "_rels":
                  break;
                case "word":
                  return {
                    ext: "docx",
                    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                  };
                case "ppt":
                  return {
                    ext: "pptx",
                    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                  };
                case "xl":
                  return {
                    ext: "xlsx",
                    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                  };
                default:
                  break;
              }
            }
            if (zipHeader.filename.startsWith("xl/")) {
              return {
                ext: "xlsx",
                mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
              };
            }
            if (zipHeader.filename.startsWith("3D/") && zipHeader.filename.endsWith(".model")) {
              return {
                ext: "3mf",
                mime: "model/3mf"
              };
            }
            if (zipHeader.filename === "mimetype" && zipHeader.compressedSize === zipHeader.uncompressedSize) {
              const mimeType = await tokenizer.readToken(new Token.StringType(zipHeader.compressedSize, "utf-8"));
              switch (mimeType) {
                case "application/epub+zip":
                  return {
                    ext: "epub",
                    mime: "application/epub+zip"
                  };
                case "application/vnd.oasis.opendocument.text":
                  return {
                    ext: "odt",
                    mime: "application/vnd.oasis.opendocument.text"
                  };
                case "application/vnd.oasis.opendocument.spreadsheet":
                  return {
                    ext: "ods",
                    mime: "application/vnd.oasis.opendocument.spreadsheet"
                  };
                case "application/vnd.oasis.opendocument.presentation":
                  return {
                    ext: "odp",
                    mime: "application/vnd.oasis.opendocument.presentation"
                  };
                default:
              }
            }
            if (zipHeader.compressedSize === 0) {
              let nextHeaderIndex = -1;
              while (nextHeaderIndex < 0 && tokenizer.position < tokenizer.fileInfo.size) {
                await tokenizer.peekBuffer(buffer, { mayBeLess: true });
                nextHeaderIndex = buffer.indexOf("504B0304", 0, "hex");
                await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : buffer.length);
              }
            } else {
              await tokenizer.ignore(zipHeader.compressedSize);
            }
          }
        } catch (error) {
          if (!(error instanceof strtok3.EndOfStreamError)) {
            throw error;
          }
        }
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (checkString("OggS")) {
        await tokenizer.ignore(28);
        const type = Buffer.alloc(8);
        await tokenizer.readBuffer(type);
        if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
          return {
            ext: "opus",
            mime: "audio/opus"
          };
        }
        if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
          return {
            ext: "ogv",
            mime: "video/ogg"
          };
        }
        if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
          return {
            ext: "ogm",
            mime: "video/ogg"
          };
        }
        if (_check(type, [127, 70, 76, 65, 67])) {
          return {
            ext: "oga",
            mime: "audio/ogg"
          };
        }
        if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
          return {
            ext: "spx",
            mime: "audio/ogg"
          };
        }
        if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
          return {
            ext: "ogg",
            mime: "audio/ogg"
          };
        }
        return {
          ext: "ogx",
          mime: "application/ogg"
        };
      }
      if (check([80, 75]) && (buffer[2] === 3 || buffer[2] === 5 || buffer[2] === 7) && (buffer[3] === 4 || buffer[3] === 6 || buffer[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (checkString("ftyp", { offset: 4 }) && (buffer[8] & 96) !== 0) {
        const brandMajor = buffer.toString("binary", 8, 12).replace("\0", " ").trim();
        switch (brandMajor) {
          case "avif":
            return { ext: "avif", mime: "image/avif" };
          case "mif1":
            return { ext: "heic", mime: "image/heif" };
          case "msf1":
            return { ext: "heic", mime: "image/heif-sequence" };
          case "heic":
          case "heix":
            return { ext: "heic", mime: "image/heic" };
          case "hevc":
          case "hevx":
            return { ext: "heic", mime: "image/heic-sequence" };
          case "qt":
            return { ext: "mov", mime: "video/quicktime" };
          case "M4V":
          case "M4VH":
          case "M4VP":
            return { ext: "m4v", mime: "video/x-m4v" };
          case "M4P":
            return { ext: "m4p", mime: "video/mp4" };
          case "M4B":
            return { ext: "m4b", mime: "audio/mp4" };
          case "M4A":
            return { ext: "m4a", mime: "audio/x-m4a" };
          case "F4V":
            return { ext: "f4v", mime: "video/mp4" };
          case "F4P":
            return { ext: "f4p", mime: "video/mp4" };
          case "F4A":
            return { ext: "f4a", mime: "audio/mp4" };
          case "F4B":
            return { ext: "f4b", mime: "audio/mp4" };
          case "crx":
            return { ext: "cr3", mime: "image/x-canon-cr3" };
          default:
            if (brandMajor.startsWith("3g")) {
              if (brandMajor.startsWith("3g2")) {
                return { ext: "3g2", mime: "video/3gpp2" };
              }
              return { ext: "3gp", mime: "video/3gpp" };
            }
            return { ext: "mp4", mime: "video/mp4" };
        }
      }
      if (checkString("MThd")) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (checkString("wOFF") && (check([0, 1, 0, 0], { offset: 4 }) || checkString("OTTO", { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "font/woff"
        };
      }
      if (checkString("wOF2") && (check([0, 1, 0, 0], { offset: 4 }) || checkString("OTTO", { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      }
      if (check([212, 195, 178, 161]) || check([161, 178, 195, 212])) {
        return {
          ext: "pcap",
          mime: "application/vnd.tcpdump.pcap"
        };
      }
      if (checkString("DSD ")) {
        return {
          ext: "dsf",
          mime: "audio/x-dsf"
          // Non-standard
        };
      }
      if (checkString("LZIP")) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (checkString("fLaC")) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (check([66, 80, 71, 251])) {
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      }
      if (checkString("wvpk")) {
        return {
          ext: "wv",
          mime: "audio/wavpack"
        };
      }
      if (checkString("%PDF")) {
        await tokenizer.ignore(1350);
        const maxBufferSize = 10 * 1024 * 1024;
        const buffer2 = Buffer.alloc(Math.min(maxBufferSize, tokenizer.fileInfo.size));
        await tokenizer.readBuffer(buffer2, { mayBeLess: true });
        if (buffer2.includes(Buffer.from("AIPrivateData"))) {
          return {
            ext: "ai",
            mime: "application/postscript"
          };
        }
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (check([73, 73, 42, 0])) {
        if (checkString("CR", { offset: 8 })) {
          return {
            ext: "cr2",
            mime: "image/x-canon-cr2"
          };
        }
        if (check([28, 0, 254, 0], { offset: 8 }) || check([31, 0, 11, 0], { offset: 8 })) {
          return {
            ext: "nef",
            mime: "image/x-nikon-nef"
          };
        }
        if (check([8, 0, 0, 0], { offset: 4 }) && (check([45, 0, 254, 0], { offset: 8 }) || check([39, 0, 254, 0], { offset: 8 }))) {
          return {
            ext: "dng",
            mime: "image/x-adobe-dng"
          };
        }
        buffer = Buffer.alloc(24);
        await tokenizer.peekBuffer(buffer);
        if ((check([16, 251, 134, 1], { offset: 4 }) || check([8, 0, 0, 0], { offset: 4 })) && // This pattern differentiates ARW from other TIFF-ish file types:
        check([0, 254, 0, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 1], { offset: 9 })) {
          return {
            ext: "arw",
            mime: "image/x-sony-arw"
          };
        }
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (check([77, 77, 0, 42])) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (checkString("MAC ")) {
        return {
          ext: "ape",
          mime: "audio/ape"
        };
      }
      if (check([26, 69, 223, 163])) {
        async function readField() {
          const msb = await tokenizer.peekNumber(Token.UINT8);
          let mask = 128;
          let ic = 0;
          while ((msb & mask) === 0 && mask !== 0) {
            ++ic;
            mask >>= 1;
          }
          const id = Buffer.alloc(ic + 1);
          await tokenizer.readBuffer(id);
          return id;
        }
        async function readElement() {
          const id = await readField();
          const lenField = await readField();
          lenField[0] ^= 128 >> lenField.length - 1;
          const nrLen = Math.min(6, lenField.length);
          return {
            id: id.readUIntBE(0, id.length),
            len: lenField.readUIntBE(lenField.length - nrLen, nrLen)
          };
        }
        async function readChildren(level, children) {
          while (children > 0) {
            const e = await readElement();
            if (e.id === 17026) {
              return tokenizer.readToken(new Token.StringType(e.len, "utf-8"));
            }
            await tokenizer.ignore(e.len);
            --children;
          }
        }
        const re = await readElement();
        const docType = await readChildren(1, re.len);
        switch (docType) {
          case "webm":
            return {
              ext: "webm",
              mime: "video/webm"
            };
          case "matroska":
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          default:
            return;
        }
      }
      if (check([82, 73, 70, 70])) {
        if (check([65, 86, 73], { offset: 8 })) {
          return {
            ext: "avi",
            mime: "video/vnd.avi"
          };
        }
        if (check([87, 65, 86, 69], { offset: 8 })) {
          return {
            ext: "wav",
            mime: "audio/vnd.wave"
          };
        }
        if (check([81, 76, 67, 77], { offset: 8 })) {
          return {
            ext: "qcp",
            mime: "audio/qcelp"
          };
        }
      }
      if (checkString("SQLi")) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (checkString("Cr24")) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (checkString("MSCF") || checkString("ISc(")) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (check([197, 208, 211, 198])) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      if (check([40, 181, 47, 253])) {
        return {
          ext: "zst",
          mime: "application/zstd"
        };
      }
      if (check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "font/otf"
        };
      }
      if (checkString("#!AMR")) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (checkString("{\\rtf")) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (checkString("IMPM")) {
        return {
          ext: "it",
          mime: "audio/x-it"
        };
      }
      if (checkString("-lh0-", { offset: 2 }) || checkString("-lh1-", { offset: 2 }) || checkString("-lh2-", { offset: 2 }) || checkString("-lh3-", { offset: 2 }) || checkString("-lh4-", { offset: 2 }) || checkString("-lh5-", { offset: 2 }) || checkString("-lh6-", { offset: 2 }) || checkString("-lh7-", { offset: 2 }) || checkString("-lzs-", { offset: 2 }) || checkString("-lz4-", { offset: 2 }) || checkString("-lz5-", { offset: 2 }) || checkString("-lhd-", { offset: 2 })) {
        return {
          ext: "lzh",
          mime: "application/x-lzh-compressed"
        };
      }
      if (check([0, 0, 1, 186])) {
        if (check([33], { offset: 4, mask: [241] })) {
          return {
            ext: "mpg",
            // May also be .ps, .mpeg
            mime: "video/MP1S"
          };
        }
        if (check([68], { offset: 4, mask: [196] })) {
          return {
            ext: "mpg",
            // May also be .mpg, .m2p, .vob or .sub
            mime: "video/MP2P"
          };
        }
      }
      if (checkString("ITSF")) {
        return {
          ext: "chm",
          mime: "application/vnd.ms-htmlhelp"
        };
      }
      if (check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (checkString("<?xml ")) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (check([82, 97, 114, 33, 26, 7]) && (buffer[6] === 0 || buffer[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (checkString("solid ")) {
        return {
          ext: "stl",
          mime: "model/stl"
        };
      }
      if (checkString("BLENDER")) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      if (checkString("!<arch>")) {
        await tokenizer.ignore(8);
        const str = await tokenizer.readToken(new Token.StringType(13, "ascii"));
        if (str === "debian-binary") {
          return {
            ext: "deb",
            mime: "application/x-deb"
          };
        }
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
        await tokenizer.ignore(8);
        async function readChunkHeader() {
          return {
            length: await tokenizer.readToken(Token.INT32_BE),
            type: await tokenizer.readToken(new Token.StringType(4, "binary"))
          };
        }
        do {
          const chunk = await readChunkHeader();
          if (chunk.length < 0) {
            return;
          }
          switch (chunk.type) {
            case "IDAT":
              return {
                ext: "png",
                mime: "image/png"
              };
            case "acTL":
              return {
                ext: "apng",
                mime: "image/apng"
              };
            default:
              await tokenizer.ignore(chunk.length + 4);
          }
        } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (check([65, 82, 82, 79, 87, 49, 0, 0])) {
        return {
          ext: "arrow",
          mime: "application/x-apache-arrow"
        };
      }
      if (check([103, 108, 84, 70, 2, 0, 0, 0])) {
        return {
          ext: "glb",
          mime: "model/gltf-binary"
        };
      }
      if (check([102, 114, 101, 101], { offset: 4 }) || // `free`
      check([109, 100, 97, 116], { offset: 4 }) || // `mdat` MJPEG
      check([109, 111, 111, 118], { offset: 4 }) || // `moov`
      check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
        return {
          ext: "orf",
          mime: "image/x-olympus-orf"
        };
      }
      if (checkString("gimp xcf ")) {
        return {
          ext: "xcf",
          mime: "image/x-xcf"
        };
      }
      if (check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
        return {
          ext: "rw2",
          mime: "image/x-panasonic-rw2"
        };
      }
      if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        async function readHeader() {
          const guid = Buffer.alloc(16);
          await tokenizer.readBuffer(guid);
          return {
            id: guid,
            size: Number(await tokenizer.readToken(Token.UINT64_LE))
          };
        }
        await tokenizer.ignore(30);
        while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
          const header = await readHeader();
          let payload = header.size - 24;
          if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
            const typeId = Buffer.alloc(16);
            payload -= await tokenizer.readBuffer(typeId);
            if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
              return {
                ext: "asf",
                mime: "audio/x-ms-asf"
              };
            }
            if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
              return {
                ext: "asf",
                mime: "video/x-ms-asf"
              };
            }
            break;
          }
          await tokenizer.ignore(payload);
        }
        return {
          ext: "asf",
          mime: "application/vnd.ms-asf"
        };
      }
      if (check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
        return {
          ext: "ktx",
          mime: "image/ktx"
        };
      }
      if ((check([126, 16, 4]) || check([126, 24, 4])) && check([48, 77, 73, 69], { offset: 4 })) {
        return {
          ext: "mie",
          mime: "application/x-mie"
        };
      }
      if (check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
        return {
          ext: "shp",
          mime: "application/x-esri-shape"
        };
      }
      if (check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
        await tokenizer.ignore(20);
        const type = await tokenizer.readToken(new Token.StringType(4, "ascii"));
        switch (type) {
          case "jp2 ":
            return {
              ext: "jp2",
              mime: "image/jp2"
            };
          case "jpx ":
            return {
              ext: "jpx",
              mime: "image/jpx"
            };
          case "jpm ":
            return {
              ext: "jpm",
              mime: "image/jpm"
            };
          case "mjp2":
            return {
              ext: "mj2",
              mime: "image/mj2"
            };
          default:
            return;
        }
      }
      if (check([255, 10]) || check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
        return {
          ext: "jxl",
          mime: "image/jxl"
        };
      }
      if (check([0, 0, 1, 186]) || check([0, 0, 1, 179])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      if (check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      }
      if (check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (check([0, 0, 2, 0])) {
        return {
          ext: "cur",
          mime: "image/x-icon"
        };
      }
      if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "cfb",
          mime: "application/x-cfb"
        };
      }
      await tokenizer.peekBuffer(buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
      if (checkString("BEGIN:")) {
        if (checkString("VCARD", { offset: 6 })) {
          return {
            ext: "vcf",
            mime: "text/vcard"
          };
        }
        if (checkString("VCALENDAR", { offset: 6 })) {
          return {
            ext: "ics",
            mime: "text/calendar"
          };
        }
      }
      if (checkString("FUJIFILMCCD-RAW")) {
        return {
          ext: "raf",
          mime: "image/x-fujifilm-raf"
        };
      }
      if (checkString("Extended Module:")) {
        return {
          ext: "xm",
          mime: "audio/x-xm"
        };
      }
      if (checkString("Creative Voice File")) {
        return {
          ext: "voc",
          mime: "audio/x-voc"
        };
      }
      if (check([4, 0, 0, 0]) && buffer.length >= 16) {
        const jsonSize = buffer.readUInt32LE(12);
        if (jsonSize > 12 && buffer.length >= jsonSize + 16) {
          try {
            const header = buffer.slice(16, jsonSize + 16).toString();
            const json = JSON.parse(header);
            if (json.files) {
              return {
                ext: "asar",
                mime: "application/x-asar"
              };
            }
          } catch (_) {
          }
        }
      }
      if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (checkString("SCRM", { offset: 44 })) {
        return {
          ext: "s3m",
          mime: "audio/x-s3m"
        };
      }
      if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 }))) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
        return {
          ext: "mobi",
          mime: "application/x-mobipocket-ebook"
        };
      }
      if (check([68, 73, 67, 77], { offset: 128 })) {
        return {
          ext: "dcm",
          mime: "application/dicom"
        };
      }
      if (check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
        return {
          ext: "lnk",
          mime: "application/x.ms.shortcut"
          // Invented by us
        };
      }
      if (check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
        return {
          ext: "alias",
          mime: "application/x.apple.alias"
          // Invented by us
        };
      }
      if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/vnd.ms-fontobject"
        };
      }
      if (check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
        return {
          ext: "indd",
          mime: "application/x-indesign"
        };
      }
      await tokenizer.peekBuffer(buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
      if (tarHeaderChecksumMatches(buffer)) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (check([255, 254, 255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0])) {
        return {
          ext: "skp",
          mime: "application/vnd.sketchup.skp"
        };
      }
      if (checkString("-----BEGIN PGP MESSAGE-----")) {
        return {
          ext: "pgp",
          mime: "application/pgp-encrypted"
        };
      }
      if (buffer.length >= 2 && check([255, 224], { offset: 0, mask: [255, 224] })) {
        if (check([16], { offset: 1, mask: [22] })) {
          if (check([8], { offset: 1, mask: [8] })) {
            return {
              ext: "aac",
              mime: "audio/aac"
            };
          }
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        if (check([2], { offset: 1, mask: [6] })) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        if (check([4], { offset: 1, mask: [6] })) {
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        }
        if (check([6], { offset: 1, mask: [6] })) {
          return {
            ext: "mp1",
            mime: "audio/mpeg"
          };
        }
      }
    }
    var stream = (readableStream) => new Promise((resolve, reject) => {
      const stream = eval("require")("stream");
      readableStream.on("error", reject);
      readableStream.once("readable", async () => {
        const pass = new stream.PassThrough();
        let outputStream;
        if (stream.pipeline) {
          outputStream = stream.pipeline(readableStream, pass, () => {
          });
        } else {
          outputStream = readableStream.pipe(pass);
        }
        const chunk = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);
        try {
          const fileType2 = await fromBuffer(chunk);
          pass.fileType = fileType2;
        } catch (error) {
          reject(error);
        }
        resolve(outputStream);
      });
    });
    var fileType = {
      fromStream,
      fromTokenizer,
      fromBuffer,
      stream
    };
    Object.defineProperty(fileType, "extensions", {
      get() {
        return new Set(supported.extensions);
      }
    });
    Object.defineProperty(fileType, "mimeTypes", {
      get() {
        return new Set(supported.mimeTypes);
      }
    });
    module.exports = fileType;
  }
});

// node_modules/file-type/index.js
var require_file_type = __commonJS({
  "node_modules/file-type/index.js"(exports2, module2) {
    "use strict";
    var strtok32 = require_lib3();
    var core = require_core2();
    async function fromFile(path) {
      const tokenizer = await strtok32.fromFile(path);
      try {
        return await core.fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    var fileType2 = {
      fromFile
    };
    Object.assign(fileType2, core);
    Object.defineProperty(fileType2, "extensions", {
      get() {
        return core.extensions;
      }
    });
    Object.defineProperty(fileType2, "mimeTypes", {
      get() {
        return core.mimeTypes;
      }
    });
    module2.exports = fileType2;
  }
});

// node_modules/node-ensure/browser.js
var require_browser2 = __commonJS({
  "node_modules/node-ensure/browser.js"(exports2, module2) {
    module2.exports = function() {
      __require.ensure.apply(this, arguments);
    };
  }
});

// node_modules/officeparser/pdfjs-dist-build/pdf.worker.js
var require_pdf_worker = __commonJS({
  "node_modules/officeparser/pdfjs-dist-build/pdf.worker.js"(exports2, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports2 === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("pdfjs-dist/build/pdf.worker", [], factory);
      else if (typeof exports2 === "object")
        exports2["pdfjs-dist/build/pdf.worker"] = factory();
      else
        root["pdfjs-dist/build/pdf.worker"] = root.pdfjsWorker = factory();
    })(exports2, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __w_pdfjs_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module3 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module3.exports, module3, module3.exports, __w_pdfjs_require__);
            module3.l = true;
            return module3.exports;
          }
          __w_pdfjs_require__.m = modules;
          __w_pdfjs_require__.c = installedModules;
          __w_pdfjs_require__.d = function(exports3, name, getter) {
            if (!__w_pdfjs_require__.o(exports3, name)) {
              Object.defineProperty(exports3, name, { enumerable: true, get: getter });
            }
          };
          __w_pdfjs_require__.r = function(exports3) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports3, "__esModule", { value: true });
          };
          __w_pdfjs_require__.t = function(value, mode) {
            if (mode & 1) value = __w_pdfjs_require__(value);
            if (mode & 8) return value;
            if (mode & 4 && typeof value === "object" && value && value.__esModule) return value;
            var ns = /* @__PURE__ */ Object.create(null);
            __w_pdfjs_require__.r(ns);
            Object.defineProperty(ns, "default", { enumerable: true, value });
            if (mode & 2 && typeof value != "string") for (var key in value) __w_pdfjs_require__.d(ns, key, (function(key2) {
              return value[key2];
            }).bind(null, key));
            return ns;
          };
          __w_pdfjs_require__.n = function(module3) {
            var getter = module3 && module3.__esModule ? (
              /******/
              function getDefault() {
                return module3["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module3;
              }
            );
            __w_pdfjs_require__.d(getter, "a", getter);
            return getter;
          };
          __w_pdfjs_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __w_pdfjs_require__.p = "";
          return __w_pdfjs_require__(__w_pdfjs_require__.s = 0);
        }([
          /* 0 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var pdfjsVersion = "2.0.550";
            var pdfjsBuild = "76337fdc";
            var pdfjsCoreWorker = __w_pdfjs_require__(1);
            exports3.WorkerMessageHandler = pdfjsCoreWorker.WorkerMessageHandler;
          },
          /* 1 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.WorkerMessageHandler = exports3.WorkerTask = void 0;
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _util = __w_pdfjs_require__(2);
            var _pdf_manager = __w_pdfjs_require__(115);
            var _is_node = __w_pdfjs_require__(5);
            var _is_node2 = _interopRequireDefault(_is_node);
            var _message_handler = __w_pdfjs_require__(153);
            var _primitives = __w_pdfjs_require__(119);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            var WorkerTask = function WorkerTaskClosure() {
              function WorkerTask2(name) {
                this.name = name;
                this.terminated = false;
                this._capability = (0, _util.createPromiseCapability)();
              }
              WorkerTask2.prototype = {
                get finished() {
                  return this._capability.promise;
                },
                finish: function finish() {
                  this._capability.resolve();
                },
                terminate: function terminate() {
                  this.terminated = true;
                },
                ensureNotTerminated: function ensureNotTerminated() {
                  if (this.terminated) {
                    throw new Error("Worker task was terminated");
                  }
                }
              };
              return WorkerTask2;
            }();
            ;
            var PDFWorkerStream = function PDFWorkerStreamClosure() {
              function PDFWorkerStream2(msgHandler) {
                this._msgHandler = msgHandler;
                this._contentLength = null;
                this._fullRequestReader = null;
                this._rangeRequestReaders = [];
              }
              PDFWorkerStream2.prototype = {
                getFullReader: function getFullReader() {
                  (0, _util.assert)(!this._fullRequestReader);
                  this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler);
                  return this._fullRequestReader;
                },
                getRangeReader: function getRangeReader(begin, end) {
                  var reader = new PDFWorkerStreamRangeReader(begin, end, this._msgHandler);
                  this._rangeRequestReaders.push(reader);
                  return reader;
                },
                cancelAllRequests: function cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  var readers = this._rangeRequestReaders.slice(0);
                  readers.forEach(function(reader) {
                    reader.cancel(reason);
                  });
                }
              };
              function PDFWorkerStreamReader(msgHandler) {
                var _this = this;
                this._msgHandler = msgHandler;
                this._contentLength = null;
                this._isRangeSupported = false;
                this._isStreamingSupported = false;
                var readableStream2 = this._msgHandler.sendWithStream("GetReader");
                this._reader = readableStream2.getReader();
                this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then(function(data) {
                  _this._isStreamingSupported = data.isStreamingSupported;
                  _this._isRangeSupported = data.isRangeSupported;
                  _this._contentLength = data.contentLength;
                });
              }
              PDFWorkerStreamReader.prototype = {
                get headersReady() {
                  return this._headersReady;
                },
                get contentLength() {
                  return this._contentLength;
                },
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                },
                get isRangeSupported() {
                  return this._isRangeSupported;
                },
                read: function read() {
                  return this._reader.read().then(function(_ref) {
                    var value = _ref.value, done = _ref.done;
                    if (done) {
                      return {
                        value: void 0,
                        done: true
                      };
                    }
                    return {
                      value: value.buffer,
                      done: false
                    };
                  });
                },
                cancel: function cancel(reason) {
                  this._reader.cancel(reason);
                }
              };
              function PDFWorkerStreamRangeReader(begin, end, msgHandler) {
                this._msgHandler = msgHandler;
                this.onProgress = null;
                var readableStream2 = this._msgHandler.sendWithStream("GetRangeReader", {
                  begin,
                  end
                });
                this._reader = readableStream2.getReader();
              }
              PDFWorkerStreamRangeReader.prototype = {
                get isStreamingSupported() {
                  return false;
                },
                read: function read() {
                  return this._reader.read().then(function(_ref2) {
                    var value = _ref2.value, done = _ref2.done;
                    if (done) {
                      return {
                        value: void 0,
                        done: true
                      };
                    }
                    return {
                      value: value.buffer,
                      done: false
                    };
                  });
                },
                cancel: function cancel(reason) {
                  this._reader.cancel(reason);
                }
              };
              return PDFWorkerStream2;
            }();
            var WorkerMessageHandler = {
              setup: function setup(handler, port) {
                var testMessageProcessed = false;
                handler.on("test", function wphSetupTest(data) {
                  if (testMessageProcessed) {
                    return;
                  }
                  testMessageProcessed = true;
                  if (!(data instanceof Uint8Array)) {
                    handler.send("test", "main", false);
                    return;
                  }
                  var supportTransfers = data[0] === 255;
                  handler.postMessageTransfers = supportTransfers;
                  var xhr = new XMLHttpRequest();
                  var responseExists = "response" in xhr;
                  try {
                    xhr.responseType;
                  } catch (e) {
                    responseExists = false;
                  }
                  if (!responseExists) {
                    handler.send("test", false);
                    return;
                  }
                  handler.send("test", {
                    supportTypedArray: true,
                    supportTransfers
                  });
                });
                handler.on("configure", function wphConfigure(data) {
                  (0, _util.setVerbosityLevel)(data.verbosity);
                });
                handler.on("GetDocRequest", function wphSetupDoc(data) {
                  return WorkerMessageHandler.createDocumentHandler(data, port);
                });
              },
              createDocumentHandler: function createDocumentHandler(docParams, port) {
                var pdfManager;
                var terminated = false;
                var cancelXHRs = null;
                var WorkerTasks = [];
                var apiVersion = docParams.apiVersion;
                var workerVersion = "2.0.550";
                if (apiVersion !== null && apiVersion !== workerVersion) {
                  throw new Error('The API version "' + apiVersion + '" does not match ' + ('the Worker version "' + workerVersion + '".'));
                }
                var docId = docParams.docId;
                var docBaseUrl = docParams.docBaseUrl;
                var workerHandlerName = docParams.docId + "_worker";
                var handler = new _message_handler.MessageHandler(workerHandlerName, docId, port);
                handler.postMessageTransfers = docParams.postMessageTransfers;
                function ensureNotTerminated() {
                  if (terminated) {
                    throw new Error("Worker was terminated");
                  }
                }
                function startWorkerTask(task) {
                  WorkerTasks.push(task);
                }
                function finishWorkerTask(task) {
                  task.finish();
                  var i = WorkerTasks.indexOf(task);
                  WorkerTasks.splice(i, 1);
                }
                function loadDocument(recoveryMode) {
                  var loadDocumentCapability = (0, _util.createPromiseCapability)();
                  var parseSuccess = function parseSuccess2() {
                    Promise.all([pdfManager.ensureDoc("numPages"), pdfManager.ensureDoc("fingerprint")]).then(function(_ref3) {
                      var _ref4 = _slicedToArray(_ref3, 2), numPages = _ref4[0], fingerprint = _ref4[1];
                      loadDocumentCapability.resolve({
                        numPages,
                        fingerprint
                      });
                    }, parseFailure);
                  };
                  var parseFailure = function parseFailure2(e) {
                    loadDocumentCapability.reject(e);
                  };
                  pdfManager.ensureDoc("checkHeader", []).then(function() {
                    pdfManager.ensureDoc("parseStartXRef", []).then(function() {
                      pdfManager.ensureDoc("parse", [recoveryMode]).then(parseSuccess, parseFailure);
                    }, parseFailure);
                  }, parseFailure);
                  return loadDocumentCapability.promise;
                }
                function getPdfManager(data, evaluatorOptions) {
                  var pdfManagerCapability = (0, _util.createPromiseCapability)();
                  var pdfManager2;
                  var source = data.source;
                  if (source.data) {
                    try {
                      pdfManager2 = new _pdf_manager.LocalPdfManager(docId, source.data, source.password, evaluatorOptions, docBaseUrl);
                      pdfManagerCapability.resolve(pdfManager2);
                    } catch (ex) {
                      pdfManagerCapability.reject(ex);
                    }
                    return pdfManagerCapability.promise;
                  }
                  var pdfStream, cachedChunks = [];
                  try {
                    pdfStream = new PDFWorkerStream(handler);
                  } catch (ex) {
                    pdfManagerCapability.reject(ex);
                    return pdfManagerCapability.promise;
                  }
                  var fullRequest = pdfStream.getFullReader();
                  fullRequest.headersReady.then(function() {
                    if (!fullRequest.isRangeSupported) {
                      return;
                    }
                    var disableAutoFetch = source.disableAutoFetch || fullRequest.isStreamingSupported;
                    pdfManager2 = new _pdf_manager.NetworkPdfManager(docId, pdfStream, {
                      msgHandler: handler,
                      url: source.url,
                      password: source.password,
                      length: fullRequest.contentLength,
                      disableAutoFetch,
                      rangeChunkSize: source.rangeChunkSize
                    }, evaluatorOptions, docBaseUrl);
                    for (var i = 0; i < cachedChunks.length; i++) {
                      pdfManager2.sendProgressiveData(cachedChunks[i]);
                    }
                    cachedChunks = [];
                    pdfManagerCapability.resolve(pdfManager2);
                    cancelXHRs = null;
                  }).catch(function(reason) {
                    pdfManagerCapability.reject(reason);
                    cancelXHRs = null;
                  });
                  var loaded = 0;
                  var flushChunks = function flushChunks2() {
                    var pdfFile = (0, _util.arraysToBytes)(cachedChunks);
                    if (source.length && pdfFile.length !== source.length) {
                      (0, _util.warn)("reported HTTP length is different from actual");
                    }
                    try {
                      pdfManager2 = new _pdf_manager.LocalPdfManager(docId, pdfFile, source.password, evaluatorOptions, docBaseUrl);
                      pdfManagerCapability.resolve(pdfManager2);
                    } catch (ex) {
                      pdfManagerCapability.reject(ex);
                    }
                    cachedChunks = [];
                  };
                  var readPromise = new Promise(function(resolve2, reject2) {
                    var readChunk = function readChunk2(chunk) {
                      try {
                        ensureNotTerminated();
                        if (chunk.done) {
                          if (!pdfManager2) {
                            flushChunks();
                          }
                          cancelXHRs = null;
                          return;
                        }
                        var data2 = chunk.value;
                        loaded += (0, _util.arrayByteLength)(data2);
                        if (!fullRequest.isStreamingSupported) {
                          handler.send("DocProgress", {
                            loaded,
                            total: Math.max(loaded, fullRequest.contentLength || 0)
                          });
                        }
                        if (pdfManager2) {
                          pdfManager2.sendProgressiveData(data2);
                        } else {
                          cachedChunks.push(data2);
                        }
                        fullRequest.read().then(readChunk2, reject2);
                      } catch (e) {
                        reject2(e);
                      }
                    };
                    fullRequest.read().then(readChunk, reject2);
                  });
                  readPromise.catch(function(e) {
                    pdfManagerCapability.reject(e);
                    cancelXHRs = null;
                  });
                  cancelXHRs = function cancelXHRs2() {
                    pdfStream.cancelAllRequests("abort");
                  };
                  return pdfManagerCapability.promise;
                }
                function setupDoc(data) {
                  function onSuccess(doc) {
                    ensureNotTerminated();
                    handler.send("GetDoc", { pdfInfo: doc });
                  }
                  function onFailure(e) {
                    ensureNotTerminated();
                    if (e instanceof _util.PasswordException) {
                      var task = new WorkerTask("PasswordException: response " + e.code);
                      startWorkerTask(task);
                      handler.sendWithPromise("PasswordRequest", e).then(function(data2) {
                        finishWorkerTask(task);
                        pdfManager.updatePassword(data2.password);
                        pdfManagerReady();
                      }).catch((function(boundException) {
                        finishWorkerTask(task);
                        handler.send("PasswordException", boundException);
                      }).bind(null, e));
                    } else if (e instanceof _util.InvalidPDFException) {
                      handler.send("InvalidPDF", e);
                    } else if (e instanceof _util.MissingPDFException) {
                      handler.send("MissingPDF", e);
                    } else if (e instanceof _util.UnexpectedResponseException) {
                      handler.send("UnexpectedResponse", e);
                    } else {
                      handler.send("UnknownError", new _util.UnknownErrorException(e.message, e.toString()));
                    }
                  }
                  function pdfManagerReady() {
                    ensureNotTerminated();
                    loadDocument(false).then(onSuccess, function loadFailure(ex) {
                      ensureNotTerminated();
                      if (!(ex instanceof _util.XRefParseException)) {
                        onFailure(ex);
                        return;
                      }
                      pdfManager.requestLoadedStream();
                      pdfManager.onLoadedStream().then(function() {
                        ensureNotTerminated();
                        loadDocument(true).then(onSuccess, onFailure);
                      });
                    }, onFailure);
                  }
                  ensureNotTerminated();
                  var evaluatorOptions = {
                    forceDataSchema: data.disableCreateObjectURL,
                    maxImageSize: data.maxImageSize,
                    disableFontFace: data.disableFontFace,
                    nativeImageDecoderSupport: data.nativeImageDecoderSupport,
                    ignoreErrors: data.ignoreErrors,
                    isEvalSupported: data.isEvalSupported
                  };
                  getPdfManager(data, evaluatorOptions).then(function(newPdfManager) {
                    if (terminated) {
                      newPdfManager.terminate();
                      throw new Error("Worker was terminated");
                    }
                    pdfManager = newPdfManager;
                    handler.send("PDFManagerReady", null);
                    pdfManager.onLoadedStream().then(function(stream2) {
                      handler.send("DataLoaded", { length: stream2.bytes.byteLength });
                    });
                  }).then(pdfManagerReady, onFailure);
                }
                handler.on("GetPage", function wphSetupGetPage(data) {
                  return pdfManager.getPage(data.pageIndex).then(function(page) {
                    var rotatePromise = pdfManager.ensure(page, "rotate");
                    var refPromise = pdfManager.ensure(page, "ref");
                    var userUnitPromise = pdfManager.ensure(page, "userUnit");
                    var viewPromise = pdfManager.ensure(page, "view");
                    return Promise.all([rotatePromise, refPromise, userUnitPromise, viewPromise]).then(function(results) {
                      return {
                        rotate: results[0],
                        ref: results[1],
                        userUnit: results[2],
                        view: results[3]
                      };
                    });
                  });
                });
                handler.on("GetPageIndex", function wphSetupGetPageIndex(data) {
                  var ref = new _primitives.Ref(data.ref.num, data.ref.gen);
                  var catalog = pdfManager.pdfDocument.catalog;
                  return catalog.getPageIndex(ref);
                });
                handler.on("GetDestinations", function wphSetupGetDestinations(data) {
                  return pdfManager.ensureCatalog("destinations");
                });
                handler.on("GetDestination", function wphSetupGetDestination(data) {
                  return pdfManager.ensureCatalog("getDestination", [data.id]);
                });
                handler.on("GetPageLabels", function wphSetupGetPageLabels(data) {
                  return pdfManager.ensureCatalog("pageLabels");
                });
                handler.on("GetPageMode", function wphSetupGetPageMode(data) {
                  return pdfManager.ensureCatalog("pageMode");
                });
                handler.on("GetAttachments", function wphSetupGetAttachments(data) {
                  return pdfManager.ensureCatalog("attachments");
                });
                handler.on("GetJavaScript", function wphSetupGetJavaScript(data) {
                  return pdfManager.ensureCatalog("javaScript");
                });
                handler.on("GetOutline", function wphSetupGetOutline(data) {
                  return pdfManager.ensureCatalog("documentOutline");
                });
                handler.on("GetMetadata", function wphSetupGetMetadata(data) {
                  return Promise.all([pdfManager.ensureDoc("documentInfo"), pdfManager.ensureCatalog("metadata")]);
                });
                handler.on("GetData", function wphSetupGetData(data) {
                  pdfManager.requestLoadedStream();
                  return pdfManager.onLoadedStream().then(function(stream2) {
                    return stream2.bytes;
                  });
                });
                handler.on("GetStats", function wphSetupGetStats(data) {
                  return pdfManager.pdfDocument.xref.stats;
                });
                handler.on("GetAnnotations", function wphSetupGetAnnotations(data) {
                  return pdfManager.getPage(data.pageIndex).then(function(page) {
                    return pdfManager.ensure(page, "getAnnotationsData", [data.intent]);
                  });
                });
                handler.on("RenderPageRequest", function wphSetupRenderPage(data) {
                  var pageIndex = data.pageIndex;
                  pdfManager.getPage(pageIndex).then(function(page) {
                    var task = new WorkerTask("RenderPageRequest: page " + pageIndex);
                    startWorkerTask(task);
                    var pageNum = pageIndex + 1;
                    var start = Date.now();
                    page.getOperatorList({
                      handler,
                      task,
                      intent: data.intent,
                      renderInteractiveForms: data.renderInteractiveForms
                    }).then(function(operatorList) {
                      finishWorkerTask(task);
                      (0, _util.info)("page=" + pageNum + " - getOperatorList: time=" + (Date.now() - start) + "ms, len=" + operatorList.totalLength);
                    }, function(e) {
                      finishWorkerTask(task);
                      if (task.terminated) {
                        return;
                      }
                      handler.send("UnsupportedFeature", { featureId: _util.UNSUPPORTED_FEATURES.unknown });
                      var minimumStackMessage = "worker.js: while trying to getPage() and getOperatorList()";
                      var wrappedException;
                      if (typeof e === "string") {
                        wrappedException = {
                          message: e,
                          stack: minimumStackMessage
                        };
                      } else if ((typeof e === "undefined" ? "undefined" : _typeof(e)) === "object") {
                        wrappedException = {
                          message: e.message || e.toString(),
                          stack: e.stack || minimumStackMessage
                        };
                      } else {
                        wrappedException = {
                          message: "Unknown exception type: " + (typeof e === "undefined" ? "undefined" : _typeof(e)),
                          stack: minimumStackMessage
                        };
                      }
                      handler.send("PageError", {
                        pageNum,
                        error: wrappedException,
                        intent: data.intent
                      });
                    });
                  });
                }, this);
                handler.on("GetTextContent", function wphExtractText(data, sink) {
                  var pageIndex = data.pageIndex;
                  sink.onPull = function(desiredSize) {
                  };
                  sink.onCancel = function(reason) {
                  };
                  pdfManager.getPage(pageIndex).then(function(page) {
                    var task = new WorkerTask("GetTextContent: page " + pageIndex);
                    startWorkerTask(task);
                    var pageNum = pageIndex + 1;
                    var start = Date.now();
                    page.extractTextContent({
                      handler,
                      task,
                      sink,
                      normalizeWhitespace: data.normalizeWhitespace,
                      combineTextItems: data.combineTextItems
                    }).then(function() {
                      finishWorkerTask(task);
                      (0, _util.info)("text indexing: page=" + pageNum + " - time=" + (Date.now() - start) + "ms");
                      sink.close();
                    }, function(reason) {
                      finishWorkerTask(task);
                      if (task.terminated) {
                        return;
                      }
                      sink.error(reason);
                      throw reason;
                    });
                  });
                });
                handler.on("Cleanup", function wphCleanup(data) {
                  return pdfManager.cleanup();
                });
                handler.on("Terminate", function wphTerminate(data) {
                  terminated = true;
                  if (pdfManager) {
                    pdfManager.terminate();
                    pdfManager = null;
                  }
                  if (cancelXHRs) {
                    cancelXHRs();
                  }
                  var waitOn = [];
                  WorkerTasks.forEach(function(task) {
                    waitOn.push(task.finished);
                    task.terminate();
                  });
                  return Promise.all(waitOn).then(function() {
                    handler.destroy();
                    handler = null;
                  });
                });
                handler.on("Ready", function wphReady(data) {
                  setupDoc(docParams);
                  docParams = null;
                });
                return workerHandlerName;
              },
              initializeFromPort: function initializeFromPort(port) {
                var handler = new _message_handler.MessageHandler("worker", "main", port);
                WorkerMessageHandler.setup(handler, port);
                handler.send("ready", null);
              }
            };
            function isMessagePort(maybePort) {
              return typeof maybePort.postMessage === "function" && "onmessage" in maybePort;
            }
            if (typeof window === "undefined" && !(0, _is_node2.default)() && typeof self !== "undefined" && isMessagePort(self)) {
              WorkerMessageHandler.initializeFromPort(self);
            }
            exports3.WorkerTask = WorkerTask;
            exports3.WorkerMessageHandler = WorkerMessageHandler;
          },
          /* 2 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.unreachable = exports3.warn = exports3.utf8StringToString = exports3.stringToUTF8String = exports3.stringToPDFString = exports3.stringToBytes = exports3.string32 = exports3.shadow = exports3.setVerbosityLevel = exports3.ReadableStream = exports3.removeNullCharacters = exports3.readUint32 = exports3.readUint16 = exports3.readInt8 = exports3.log2 = exports3.isEvalSupported = exports3.isLittleEndian = exports3.createValidAbsoluteUrl = exports3.isSameOrigin = exports3.isSpace = exports3.isString = exports3.isNum = exports3.isEmptyObj = exports3.isBool = exports3.isArrayBuffer = exports3.info = exports3.getVerbosityLevel = exports3.getLookupTableFactory = exports3.getInheritableProperty = exports3.deprecated = exports3.createObjectURL = exports3.createPromiseCapability = exports3.createBlob = exports3.bytesToString = exports3.assert = exports3.arraysToBytes = exports3.arrayByteLength = exports3.FormatError = exports3.XRefParseException = exports3.Util = exports3.UnknownErrorException = exports3.UnexpectedResponseException = exports3.TextRenderingMode = exports3.StreamType = exports3.PasswordResponses = exports3.PasswordException = exports3.NotImplementedException = exports3.NativeImageDecoding = exports3.MissingPDFException = exports3.MissingDataException = exports3.InvalidPDFException = exports3.AbortException = exports3.CMapCompressionType = exports3.ImageKind = exports3.FontType = exports3.AnnotationType = exports3.AnnotationFlag = exports3.AnnotationFieldFlag = exports3.AnnotationBorderStyleType = exports3.UNSUPPORTED_FEATURES = exports3.VerbosityLevel = exports3.OPS = exports3.IDENTITY_MATRIX = exports3.FONT_IDENTITY_MATRIX = void 0;
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            __w_pdfjs_require__(3);
            var _streams_polyfill = __w_pdfjs_require__(113);
            var FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
            var NativeImageDecoding = {
              NONE: "none",
              DECODE: "decode",
              DISPLAY: "display"
            };
            var TextRenderingMode = {
              FILL: 0,
              STROKE: 1,
              FILL_STROKE: 2,
              INVISIBLE: 3,
              FILL_ADD_TO_PATH: 4,
              STROKE_ADD_TO_PATH: 5,
              FILL_STROKE_ADD_TO_PATH: 6,
              ADD_TO_PATH: 7,
              FILL_STROKE_MASK: 3,
              ADD_TO_PATH_FLAG: 4
            };
            var ImageKind = {
              GRAYSCALE_1BPP: 1,
              RGB_24BPP: 2,
              RGBA_32BPP: 3
            };
            var AnnotationType = {
              TEXT: 1,
              LINK: 2,
              FREETEXT: 3,
              LINE: 4,
              SQUARE: 5,
              CIRCLE: 6,
              POLYGON: 7,
              POLYLINE: 8,
              HIGHLIGHT: 9,
              UNDERLINE: 10,
              SQUIGGLY: 11,
              STRIKEOUT: 12,
              STAMP: 13,
              CARET: 14,
              INK: 15,
              POPUP: 16,
              FILEATTACHMENT: 17,
              SOUND: 18,
              MOVIE: 19,
              WIDGET: 20,
              SCREEN: 21,
              PRINTERMARK: 22,
              TRAPNET: 23,
              WATERMARK: 24,
              THREED: 25,
              REDACT: 26
            };
            var AnnotationFlag = {
              INVISIBLE: 1,
              HIDDEN: 2,
              PRINT: 4,
              NOZOOM: 8,
              NOROTATE: 16,
              NOVIEW: 32,
              READONLY: 64,
              LOCKED: 128,
              TOGGLENOVIEW: 256,
              LOCKEDCONTENTS: 512
            };
            var AnnotationFieldFlag = {
              READONLY: 1,
              REQUIRED: 2,
              NOEXPORT: 4,
              MULTILINE: 4096,
              PASSWORD: 8192,
              NOTOGGLETOOFF: 16384,
              RADIO: 32768,
              PUSHBUTTON: 65536,
              COMBO: 131072,
              EDIT: 262144,
              SORT: 524288,
              FILESELECT: 1048576,
              MULTISELECT: 2097152,
              DONOTSPELLCHECK: 4194304,
              DONOTSCROLL: 8388608,
              COMB: 16777216,
              RICHTEXT: 33554432,
              RADIOSINUNISON: 33554432,
              COMMITONSELCHANGE: 67108864
            };
            var AnnotationBorderStyleType = {
              SOLID: 1,
              DASHED: 2,
              BEVELED: 3,
              INSET: 4,
              UNDERLINE: 5
            };
            var StreamType = {
              UNKNOWN: 0,
              FLATE: 1,
              LZW: 2,
              DCT: 3,
              JPX: 4,
              JBIG: 5,
              A85: 6,
              AHX: 7,
              CCF: 8,
              RL: 9
            };
            var FontType = {
              UNKNOWN: 0,
              TYPE1: 1,
              TYPE1C: 2,
              CIDFONTTYPE0: 3,
              CIDFONTTYPE0C: 4,
              TRUETYPE: 5,
              CIDFONTTYPE2: 6,
              TYPE3: 7,
              OPENTYPE: 8,
              TYPE0: 9,
              MMTYPE1: 10
            };
            var VerbosityLevel = {
              ERRORS: 0,
              WARNINGS: 1,
              INFOS: 5
            };
            var CMapCompressionType = {
              NONE: 0,
              BINARY: 1,
              STREAM: 2
            };
            var OPS = {
              dependency: 1,
              setLineWidth: 2,
              setLineCap: 3,
              setLineJoin: 4,
              setMiterLimit: 5,
              setDash: 6,
              setRenderingIntent: 7,
              setFlatness: 8,
              setGState: 9,
              save: 10,
              restore: 11,
              transform: 12,
              moveTo: 13,
              lineTo: 14,
              curveTo: 15,
              curveTo2: 16,
              curveTo3: 17,
              closePath: 18,
              rectangle: 19,
              stroke: 20,
              closeStroke: 21,
              fill: 22,
              eoFill: 23,
              fillStroke: 24,
              eoFillStroke: 25,
              closeFillStroke: 26,
              closeEOFillStroke: 27,
              endPath: 28,
              clip: 29,
              eoClip: 30,
              beginText: 31,
              endText: 32,
              setCharSpacing: 33,
              setWordSpacing: 34,
              setHScale: 35,
              setLeading: 36,
              setFont: 37,
              setTextRenderingMode: 38,
              setTextRise: 39,
              moveText: 40,
              setLeadingMoveText: 41,
              setTextMatrix: 42,
              nextLine: 43,
              showText: 44,
              showSpacedText: 45,
              nextLineShowText: 46,
              nextLineSetSpacingShowText: 47,
              setCharWidth: 48,
              setCharWidthAndBounds: 49,
              setStrokeColorSpace: 50,
              setFillColorSpace: 51,
              setStrokeColor: 52,
              setStrokeColorN: 53,
              setFillColor: 54,
              setFillColorN: 55,
              setStrokeGray: 56,
              setFillGray: 57,
              setStrokeRGBColor: 58,
              setFillRGBColor: 59,
              setStrokeCMYKColor: 60,
              setFillCMYKColor: 61,
              shadingFill: 62,
              beginInlineImage: 63,
              beginImageData: 64,
              endInlineImage: 65,
              paintXObject: 66,
              markPoint: 67,
              markPointProps: 68,
              beginMarkedContent: 69,
              beginMarkedContentProps: 70,
              endMarkedContent: 71,
              beginCompat: 72,
              endCompat: 73,
              paintFormXObjectBegin: 74,
              paintFormXObjectEnd: 75,
              beginGroup: 76,
              endGroup: 77,
              beginAnnotations: 78,
              endAnnotations: 79,
              beginAnnotation: 80,
              endAnnotation: 81,
              paintJpegXObject: 82,
              paintImageMaskXObject: 83,
              paintImageMaskXObjectGroup: 84,
              paintImageXObject: 85,
              paintInlineImageXObject: 86,
              paintInlineImageXObjectGroup: 87,
              paintImageXObjectRepeat: 88,
              paintImageMaskXObjectRepeat: 89,
              paintSolidColorImageMask: 90,
              constructPath: 91
            };
            var verbosity = VerbosityLevel.WARNINGS;
            function setVerbosityLevel(level) {
              if (Number.isInteger(level)) {
                verbosity = level;
              }
            }
            function getVerbosityLevel() {
              return verbosity;
            }
            function info(msg) {
              if (verbosity >= VerbosityLevel.INFOS) {
                console.log("Info: " + msg);
              }
            }
            function warn(msg) {
              if (verbosity >= VerbosityLevel.WARNINGS) {
                console.log("Warning: " + msg);
              }
            }
            function deprecated(details) {
              console.log("Deprecated API usage: " + details);
            }
            function unreachable(msg) {
              throw new Error(msg);
            }
            function assert(cond, msg) {
              if (!cond) {
                unreachable(msg);
              }
            }
            var UNSUPPORTED_FEATURES = {
              unknown: "unknown",
              forms: "forms",
              javaScript: "javaScript",
              smask: "smask",
              shadingPattern: "shadingPattern",
              font: "font"
            };
            function isSameOrigin(baseUrl, otherUrl) {
              try {
                var base = new URL(baseUrl);
                if (!base.origin || base.origin === "null") {
                  return false;
                }
              } catch (e) {
                return false;
              }
              var other = new URL(otherUrl, base);
              return base.origin === other.origin;
            }
            function isValidProtocol(url) {
              if (!url) {
                return false;
              }
              switch (url.protocol) {
                case "http:":
                case "https:":
                case "ftp:":
                case "mailto:":
                case "tel:":
                  return true;
                default:
                  return false;
              }
            }
            function createValidAbsoluteUrl(url, baseUrl) {
              if (!url) {
                return null;
              }
              try {
                var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
                if (isValidProtocol(absoluteUrl)) {
                  return absoluteUrl;
                }
              } catch (ex) {
              }
              return null;
            }
            function shadow(obj, prop, value) {
              Object.defineProperty(obj, prop, {
                value,
                enumerable: true,
                configurable: true,
                writable: false
              });
              return value;
            }
            function getLookupTableFactory(initializer) {
              var lookup;
              return function() {
                if (initializer) {
                  lookup = /* @__PURE__ */ Object.create(null);
                  initializer(lookup);
                  initializer = null;
                }
                return lookup;
              };
            }
            var PasswordResponses = {
              NEED_PASSWORD: 1,
              INCORRECT_PASSWORD: 2
            };
            var PasswordException = function PasswordExceptionClosure() {
              function PasswordException2(msg, code) {
                this.name = "PasswordException";
                this.message = msg;
                this.code = code;
              }
              PasswordException2.prototype = new Error();
              PasswordException2.constructor = PasswordException2;
              return PasswordException2;
            }();
            var UnknownErrorException = function UnknownErrorExceptionClosure() {
              function UnknownErrorException2(msg, details) {
                this.name = "UnknownErrorException";
                this.message = msg;
                this.details = details;
              }
              UnknownErrorException2.prototype = new Error();
              UnknownErrorException2.constructor = UnknownErrorException2;
              return UnknownErrorException2;
            }();
            var InvalidPDFException = function InvalidPDFExceptionClosure() {
              function InvalidPDFException2(msg) {
                this.name = "InvalidPDFException";
                this.message = msg;
              }
              InvalidPDFException2.prototype = new Error();
              InvalidPDFException2.constructor = InvalidPDFException2;
              return InvalidPDFException2;
            }();
            var MissingPDFException = function MissingPDFExceptionClosure() {
              function MissingPDFException2(msg) {
                this.name = "MissingPDFException";
                this.message = msg;
              }
              MissingPDFException2.prototype = new Error();
              MissingPDFException2.constructor = MissingPDFException2;
              return MissingPDFException2;
            }();
            var UnexpectedResponseException = function UnexpectedResponseExceptionClosure() {
              function UnexpectedResponseException2(msg, status) {
                this.name = "UnexpectedResponseException";
                this.message = msg;
                this.status = status;
              }
              UnexpectedResponseException2.prototype = new Error();
              UnexpectedResponseException2.constructor = UnexpectedResponseException2;
              return UnexpectedResponseException2;
            }();
            var NotImplementedException = function NotImplementedExceptionClosure() {
              function NotImplementedException2(msg) {
                this.message = msg;
              }
              NotImplementedException2.prototype = new Error();
              NotImplementedException2.prototype.name = "NotImplementedException";
              NotImplementedException2.constructor = NotImplementedException2;
              return NotImplementedException2;
            }();
            var MissingDataException = function MissingDataExceptionClosure() {
              function MissingDataException2(begin, end) {
                this.begin = begin;
                this.end = end;
                this.message = "Missing data [" + begin + ", " + end + ")";
              }
              MissingDataException2.prototype = new Error();
              MissingDataException2.prototype.name = "MissingDataException";
              MissingDataException2.constructor = MissingDataException2;
              return MissingDataException2;
            }();
            var XRefParseException = function XRefParseExceptionClosure() {
              function XRefParseException2(msg) {
                this.message = msg;
              }
              XRefParseException2.prototype = new Error();
              XRefParseException2.prototype.name = "XRefParseException";
              XRefParseException2.constructor = XRefParseException2;
              return XRefParseException2;
            }();
            var FormatError = function FormatErrorClosure() {
              function FormatError2(msg) {
                this.message = msg;
              }
              FormatError2.prototype = new Error();
              FormatError2.prototype.name = "FormatError";
              FormatError2.constructor = FormatError2;
              return FormatError2;
            }();
            var AbortException = function AbortExceptionClosure() {
              function AbortException2(msg) {
                this.name = "AbortException";
                this.message = msg;
              }
              AbortException2.prototype = new Error();
              AbortException2.constructor = AbortException2;
              return AbortException2;
            }();
            var NullCharactersRegExp = /\x00/g;
            function removeNullCharacters(str) {
              if (typeof str !== "string") {
                warn("The argument for removeNullCharacters must be a string.");
                return str;
              }
              return str.replace(NullCharactersRegExp, "");
            }
            function bytesToString(bytes) {
              assert(bytes !== null && (typeof bytes === "undefined" ? "undefined" : _typeof(bytes)) === "object" && bytes.length !== void 0, "Invalid argument for bytesToString");
              var length = bytes.length;
              var MAX_ARGUMENT_COUNT = 8192;
              if (length < MAX_ARGUMENT_COUNT) {
                return String.fromCharCode.apply(null, bytes);
              }
              var strBuf = [];
              for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
                var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
                var chunk = bytes.subarray(i, chunkEnd);
                strBuf.push(String.fromCharCode.apply(null, chunk));
              }
              return strBuf.join("");
            }
            function stringToBytes2(str) {
              assert(typeof str === "string", "Invalid argument for stringToBytes");
              var length = str.length;
              var bytes = new Uint8Array(length);
              for (var i = 0; i < length; ++i) {
                bytes[i] = str.charCodeAt(i) & 255;
              }
              return bytes;
            }
            function arrayByteLength(arr) {
              if (arr.length !== void 0) {
                return arr.length;
              }
              assert(arr.byteLength !== void 0);
              return arr.byteLength;
            }
            function arraysToBytes(arr) {
              if (arr.length === 1 && arr[0] instanceof Uint8Array) {
                return arr[0];
              }
              var resultLength = 0;
              var i, ii = arr.length;
              var item, itemLength;
              for (i = 0; i < ii; i++) {
                item = arr[i];
                itemLength = arrayByteLength(item);
                resultLength += itemLength;
              }
              var pos = 0;
              var data = new Uint8Array(resultLength);
              for (i = 0; i < ii; i++) {
                item = arr[i];
                if (!(item instanceof Uint8Array)) {
                  if (typeof item === "string") {
                    item = stringToBytes2(item);
                  } else {
                    item = new Uint8Array(item);
                  }
                }
                itemLength = item.byteLength;
                data.set(item, pos);
                pos += itemLength;
              }
              return data;
            }
            function string32(value) {
              return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
            }
            function log2(x) {
              if (x <= 0) {
                return 0;
              }
              return Math.ceil(Math.log2(x));
            }
            function readInt8(data, start) {
              return data[start] << 24 >> 24;
            }
            function readUint16(data, offset) {
              return data[offset] << 8 | data[offset + 1];
            }
            function readUint32(data, offset) {
              return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
            }
            function isLittleEndian() {
              var buffer8 = new Uint8Array(4);
              buffer8[0] = 1;
              var view32 = new Uint32Array(buffer8.buffer, 0, 1);
              return view32[0] === 1;
            }
            function isEvalSupported() {
              try {
                new Function("");
                return true;
              } catch (e) {
                return false;
              }
            }
            function getInheritableProperty(_ref) {
              var dict = _ref.dict, key = _ref.key, _ref$getArray = _ref.getArray, getArray = _ref$getArray === void 0 ? false : _ref$getArray, _ref$stopWhenFound = _ref.stopWhenFound, stopWhenFound = _ref$stopWhenFound === void 0 ? true : _ref$stopWhenFound;
              var LOOP_LIMIT = 100;
              var loopCount = 0;
              var values = void 0;
              while (dict) {
                var value = getArray ? dict.getArray(key) : dict.get(key);
                if (value !== void 0) {
                  if (stopWhenFound) {
                    return value;
                  }
                  if (!values) {
                    values = [];
                  }
                  values.push(value);
                }
                if (++loopCount > LOOP_LIMIT) {
                  warn('getInheritableProperty: maximum loop count exceeded for "' + key + '"');
                  break;
                }
                dict = dict.get("Parent");
              }
              return values;
            }
            var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
            var Util = function UtilClosure() {
              function Util2() {
              }
              var rgbBuf = ["rgb(", 0, ",", 0, ",", 0, ")"];
              Util2.makeCssRgb = function Util_makeCssRgb(r, g, b) {
                rgbBuf[1] = r;
                rgbBuf[3] = g;
                rgbBuf[5] = b;
                return rgbBuf.join("");
              };
              Util2.transform = function Util_transform(m1, m2) {
                return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
              };
              Util2.applyTransform = function Util_applyTransform(p, m) {
                var xt = p[0] * m[0] + p[1] * m[2] + m[4];
                var yt = p[0] * m[1] + p[1] * m[3] + m[5];
                return [xt, yt];
              };
              Util2.applyInverseTransform = function Util_applyInverseTransform(p, m) {
                var d = m[0] * m[3] - m[1] * m[2];
                var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                return [xt, yt];
              };
              Util2.getAxialAlignedBoundingBox = function Util_getAxialAlignedBoundingBox(r, m) {
                var p1 = Util2.applyTransform(r, m);
                var p2 = Util2.applyTransform(r.slice(2, 4), m);
                var p3 = Util2.applyTransform([r[0], r[3]], m);
                var p4 = Util2.applyTransform([r[2], r[1]], m);
                return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
              };
              Util2.inverseTransform = function Util_inverseTransform(m) {
                var d = m[0] * m[3] - m[1] * m[2];
                return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
              };
              Util2.apply3dTransform = function Util_apply3dTransform(m, v) {
                return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
              };
              Util2.singularValueDecompose2dScale = function Util_singularValueDecompose2dScale(m) {
                var transpose = [m[0], m[2], m[1], m[3]];
                var a = m[0] * transpose[0] + m[1] * transpose[2];
                var b = m[0] * transpose[1] + m[1] * transpose[3];
                var c = m[2] * transpose[0] + m[3] * transpose[2];
                var d = m[2] * transpose[1] + m[3] * transpose[3];
                var first = (a + d) / 2;
                var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
                var sx = first + second || 1;
                var sy = first - second || 1;
                return [Math.sqrt(sx), Math.sqrt(sy)];
              };
              Util2.normalizeRect = function Util_normalizeRect(rect) {
                var r = rect.slice(0);
                if (rect[0] > rect[2]) {
                  r[0] = rect[2];
                  r[2] = rect[0];
                }
                if (rect[1] > rect[3]) {
                  r[1] = rect[3];
                  r[3] = rect[1];
                }
                return r;
              };
              Util2.intersect = function Util_intersect(rect1, rect2) {
                function compare(a, b) {
                  return a - b;
                }
                var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare), orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare), result = [];
                rect1 = Util2.normalizeRect(rect1);
                rect2 = Util2.normalizeRect(rect2);
                if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
                  result[0] = orderedX[1];
                  result[2] = orderedX[2];
                } else {
                  return false;
                }
                if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
                  result[1] = orderedY[1];
                  result[3] = orderedY[2];
                } else {
                  return false;
                }
                return result;
              };
              var ROMAN_NUMBER_MAP = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
              Util2.toRoman = function Util_toRoman(number, lowerCase) {
                assert(Number.isInteger(number) && number > 0, "The number should be a positive integer.");
                var pos, romanBuf = [];
                while (number >= 1e3) {
                  number -= 1e3;
                  romanBuf.push("M");
                }
                pos = number / 100 | 0;
                number %= 100;
                romanBuf.push(ROMAN_NUMBER_MAP[pos]);
                pos = number / 10 | 0;
                number %= 10;
                romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
                romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
                var romanStr = romanBuf.join("");
                return lowerCase ? romanStr.toLowerCase() : romanStr;
              };
              Util2.appendToArray = function Util_appendToArray(arr1, arr2) {
                Array.prototype.push.apply(arr1, arr2);
              };
              Util2.prependToArray = function Util_prependToArray(arr1, arr2) {
                Array.prototype.unshift.apply(arr1, arr2);
              };
              Util2.extendObj = function extendObj(obj1, obj2) {
                for (var key in obj2) {
                  obj1[key] = obj2[key];
                }
              };
              Util2.inherit = function Util_inherit(sub, base, prototype) {
                sub.prototype = Object.create(base.prototype);
                sub.prototype.constructor = sub;
                for (var prop in prototype) {
                  sub.prototype[prop] = prototype[prop];
                }
              };
              Util2.loadScript = function Util_loadScript(src, callback) {
                var script = document.createElement("script");
                var loaded = false;
                script.setAttribute("src", src);
                if (callback) {
                  script.onload = function() {
                    if (!loaded) {
                      callback();
                    }
                    loaded = true;
                  };
                }
                document.getElementsByTagName("head")[0].appendChild(script);
              };
              return Util2;
            }();
            var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
            function stringToPDFString(str) {
              var i, n = str.length, strBuf = [];
              if (str[0] === "þ" && str[1] === "ÿ") {
                for (i = 2; i < n; i += 2) {
                  strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
                }
              } else {
                for (i = 0; i < n; ++i) {
                  var code = PDFStringTranslateTable[str.charCodeAt(i)];
                  strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
                }
              }
              return strBuf.join("");
            }
            function stringToUTF8String(str) {
              return decodeURIComponent(escape(str));
            }
            function utf8StringToString(str) {
              return unescape(encodeURIComponent(str));
            }
            function isEmptyObj(obj) {
              for (var key in obj) {
                return false;
              }
              return true;
            }
            function isBool(v) {
              return typeof v === "boolean";
            }
            function isNum(v) {
              return typeof v === "number";
            }
            function isString(v) {
              return typeof v === "string";
            }
            function isArrayBuffer(v) {
              return (typeof v === "undefined" ? "undefined" : _typeof(v)) === "object" && v !== null && v.byteLength !== void 0;
            }
            function isSpace(ch) {
              return ch === 32 || ch === 9 || ch === 13 || ch === 10;
            }
            function createPromiseCapability() {
              var capability = {};
              capability.promise = new Promise(function(resolve2, reject2) {
                capability.resolve = resolve2;
                capability.reject = reject2;
              });
              return capability;
            }
            var createBlob = function createBlob2(data, contentType) {
              if (typeof Blob !== "undefined") {
                return new Blob([data], { type: contentType });
              }
              throw new Error('The "Blob" constructor is not supported.');
            };
            var createObjectURL = /* @__PURE__ */ function createObjectURLClosure() {
              var digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              return function createObjectURL2(data, contentType) {
                var forceDataSchema = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                if (!forceDataSchema && URL.createObjectURL) {
                  var blob = createBlob(data, contentType);
                  return URL.createObjectURL(blob);
                }
                var buffer = "data:" + contentType + ";base64,";
                for (var i = 0, ii = data.length; i < ii; i += 3) {
                  var b1 = data[i] & 255;
                  var b2 = data[i + 1] & 255;
                  var b3 = data[i + 2] & 255;
                  var d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
                  var d3 = i + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
                  var d4 = i + 2 < ii ? b3 & 63 : 64;
                  buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
                }
                return buffer;
              };
            }();
            exports3.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
            exports3.IDENTITY_MATRIX = IDENTITY_MATRIX;
            exports3.OPS = OPS;
            exports3.VerbosityLevel = VerbosityLevel;
            exports3.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
            exports3.AnnotationBorderStyleType = AnnotationBorderStyleType;
            exports3.AnnotationFieldFlag = AnnotationFieldFlag;
            exports3.AnnotationFlag = AnnotationFlag;
            exports3.AnnotationType = AnnotationType;
            exports3.FontType = FontType;
            exports3.ImageKind = ImageKind;
            exports3.CMapCompressionType = CMapCompressionType;
            exports3.AbortException = AbortException;
            exports3.InvalidPDFException = InvalidPDFException;
            exports3.MissingDataException = MissingDataException;
            exports3.MissingPDFException = MissingPDFException;
            exports3.NativeImageDecoding = NativeImageDecoding;
            exports3.NotImplementedException = NotImplementedException;
            exports3.PasswordException = PasswordException;
            exports3.PasswordResponses = PasswordResponses;
            exports3.StreamType = StreamType;
            exports3.TextRenderingMode = TextRenderingMode;
            exports3.UnexpectedResponseException = UnexpectedResponseException;
            exports3.UnknownErrorException = UnknownErrorException;
            exports3.Util = Util;
            exports3.XRefParseException = XRefParseException;
            exports3.FormatError = FormatError;
            exports3.arrayByteLength = arrayByteLength;
            exports3.arraysToBytes = arraysToBytes;
            exports3.assert = assert;
            exports3.bytesToString = bytesToString;
            exports3.createBlob = createBlob;
            exports3.createPromiseCapability = createPromiseCapability;
            exports3.createObjectURL = createObjectURL;
            exports3.deprecated = deprecated;
            exports3.getInheritableProperty = getInheritableProperty;
            exports3.getLookupTableFactory = getLookupTableFactory;
            exports3.getVerbosityLevel = getVerbosityLevel;
            exports3.info = info;
            exports3.isArrayBuffer = isArrayBuffer;
            exports3.isBool = isBool;
            exports3.isEmptyObj = isEmptyObj;
            exports3.isNum = isNum;
            exports3.isString = isString;
            exports3.isSpace = isSpace;
            exports3.isSameOrigin = isSameOrigin;
            exports3.createValidAbsoluteUrl = createValidAbsoluteUrl;
            exports3.isLittleEndian = isLittleEndian;
            exports3.isEvalSupported = isEvalSupported;
            exports3.log2 = log2;
            exports3.readInt8 = readInt8;
            exports3.readUint16 = readUint16;
            exports3.readUint32 = readUint32;
            exports3.removeNullCharacters = removeNullCharacters;
            exports3.ReadableStream = _streams_polyfill.ReadableStream;
            exports3.setVerbosityLevel = setVerbosityLevel;
            exports3.shadow = shadow;
            exports3.string32 = string32;
            exports3.stringToBytes = stringToBytes2;
            exports3.stringToPDFString = stringToPDFString;
            exports3.stringToUTF8String = stringToUTF8String;
            exports3.utf8StringToString = utf8StringToString;
            exports3.warn = warn;
            exports3.unreachable = unreachable;
          },
          /* 3 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var globalScope = __w_pdfjs_require__(4);
            if (!globalScope._pdfjsCompatibilityChecked) {
              globalScope._pdfjsCompatibilityChecked = true;
              var isNodeJS = __w_pdfjs_require__(5);
              var hasDOM = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === "object";
              (function checkNodeBtoa() {
                if (globalScope.btoa || !isNodeJS()) {
                  return;
                }
                globalScope.btoa = function(chars) {
                  return Buffer.from(chars, "binary").toString("base64");
                };
              })();
              (function checkNodeAtob() {
                if (globalScope.atob || !isNodeJS()) {
                  return;
                }
                globalScope.atob = function(input) {
                  return Buffer.from(input, "base64").toString("binary");
                };
              })();
              (function checkCurrentScript() {
                if (!hasDOM) {
                  return;
                }
                if ("currentScript" in document) {
                  return;
                }
                Object.defineProperty(document, "currentScript", {
                  get: function get() {
                    var scripts = document.getElementsByTagName("script");
                    return scripts[scripts.length - 1];
                  },
                  enumerable: true,
                  configurable: true
                });
              })();
              (function checkChildNodeRemove() {
                if (!hasDOM) {
                  return;
                }
                if (typeof Element.prototype.remove !== "undefined") {
                  return;
                }
                Element.prototype.remove = function() {
                  if (this.parentNode) {
                    this.parentNode.removeChild(this);
                  }
                };
              })();
              (function checkStringIncludes() {
                if (String.prototype.includes) {
                  return;
                }
                __w_pdfjs_require__(6);
              })();
              (function checkArrayIncludes() {
                if (Array.prototype.includes) {
                  return;
                }
                __w_pdfjs_require__(34);
              })();
              (function checkMathLog2() {
                if (Math.log2) {
                  return;
                }
                Math.log2 = __w_pdfjs_require__(43);
              })();
              (function checkNumberIsNaN() {
                if (Number.isNaN) {
                  return;
                }
                Number.isNaN = __w_pdfjs_require__(45);
              })();
              (function checkNumberIsInteger() {
                if (Number.isInteger) {
                  return;
                }
                Number.isInteger = __w_pdfjs_require__(47);
              })();
              (function checkPromise() {
                if (globalScope.Promise) {
                  return;
                }
                globalScope.Promise = __w_pdfjs_require__(50);
              })();
              (function checkWeakMap() {
                if (globalScope.WeakMap) {
                  return;
                }
                globalScope.WeakMap = __w_pdfjs_require__(90);
              })();
              (function checkURLConstructor() {
                var hasWorkingUrl = false;
                try {
                  if (typeof URL === "function" && _typeof(URL.prototype) === "object" && "origin" in URL.prototype) {
                    var u = new URL("b", "http://a");
                    u.pathname = "c%20d";
                    hasWorkingUrl = u.href === "http://a/c%20d";
                  }
                } catch (e) {
                }
                if (hasWorkingUrl) {
                  return;
                }
                var relative = /* @__PURE__ */ Object.create(null);
                relative["ftp"] = 21;
                relative["file"] = 0;
                relative["gopher"] = 70;
                relative["http"] = 80;
                relative["https"] = 443;
                relative["ws"] = 80;
                relative["wss"] = 443;
                var relativePathDotMapping = /* @__PURE__ */ Object.create(null);
                relativePathDotMapping["%2e"] = ".";
                relativePathDotMapping[".%2e"] = "..";
                relativePathDotMapping["%2e."] = "..";
                relativePathDotMapping["%2e%2e"] = "..";
                function isRelativeScheme(scheme) {
                  return relative[scheme] !== void 0;
                }
                function invalid() {
                  clear.call(this);
                  this._isInvalid = true;
                }
                function IDNAToASCII(h) {
                  if (h === "") {
                    invalid.call(this);
                  }
                  return h.toLowerCase();
                }
                function percentEscape(c) {
                  var unicode = c.charCodeAt(0);
                  if (unicode > 32 && unicode < 127 && [34, 35, 60, 62, 63, 96].indexOf(unicode) === -1) {
                    return c;
                  }
                  return encodeURIComponent(c);
                }
                function percentEscapeQuery(c) {
                  var unicode = c.charCodeAt(0);
                  if (unicode > 32 && unicode < 127 && [34, 35, 60, 62, 96].indexOf(unicode) === -1) {
                    return c;
                  }
                  return encodeURIComponent(c);
                }
                var EOF, ALPHA = /[a-zA-Z]/, ALPHANUMERIC = /[a-zA-Z0-9\+\-\.]/;
                function parse(input, stateOverride, base) {
                  function err(message) {
                    errors.push(message);
                  }
                  var state = stateOverride || "scheme start", cursor = 0, buffer = "", seenAt = false, seenBracket = false, errors = [];
                  loop: while ((input[cursor - 1] !== EOF || cursor === 0) && !this._isInvalid) {
                    var c = input[cursor];
                    switch (state) {
                      case "scheme start":
                        if (c && ALPHA.test(c)) {
                          buffer += c.toLowerCase();
                          state = "scheme";
                        } else if (!stateOverride) {
                          buffer = "";
                          state = "no scheme";
                          continue;
                        } else {
                          err("Invalid scheme.");
                          break loop;
                        }
                        break;
                      case "scheme":
                        if (c && ALPHANUMERIC.test(c)) {
                          buffer += c.toLowerCase();
                        } else if (c === ":") {
                          this._scheme = buffer;
                          buffer = "";
                          if (stateOverride) {
                            break loop;
                          }
                          if (isRelativeScheme(this._scheme)) {
                            this._isRelative = true;
                          }
                          if (this._scheme === "file") {
                            state = "relative";
                          } else if (this._isRelative && base && base._scheme === this._scheme) {
                            state = "relative or authority";
                          } else if (this._isRelative) {
                            state = "authority first slash";
                          } else {
                            state = "scheme data";
                          }
                        } else if (!stateOverride) {
                          buffer = "";
                          cursor = 0;
                          state = "no scheme";
                          continue;
                        } else if (c === EOF) {
                          break loop;
                        } else {
                          err("Code point not allowed in scheme: " + c);
                          break loop;
                        }
                        break;
                      case "scheme data":
                        if (c === "?") {
                          this._query = "?";
                          state = "query";
                        } else if (c === "#") {
                          this._fragment = "#";
                          state = "fragment";
                        } else {
                          if (c !== EOF && c !== "	" && c !== "\n" && c !== "\r") {
                            this._schemeData += percentEscape(c);
                          }
                        }
                        break;
                      case "no scheme":
                        if (!base || !isRelativeScheme(base._scheme)) {
                          err("Missing scheme.");
                          invalid.call(this);
                        } else {
                          state = "relative";
                          continue;
                        }
                        break;
                      case "relative or authority":
                        if (c === "/" && input[cursor + 1] === "/") {
                          state = "authority ignore slashes";
                        } else {
                          err("Expected /, got: " + c);
                          state = "relative";
                          continue;
                        }
                        break;
                      case "relative":
                        this._isRelative = true;
                        if (this._scheme !== "file") {
                          this._scheme = base._scheme;
                        }
                        if (c === EOF) {
                          this._host = base._host;
                          this._port = base._port;
                          this._path = base._path.slice();
                          this._query = base._query;
                          this._username = base._username;
                          this._password = base._password;
                          break loop;
                        } else if (c === "/" || c === "\\") {
                          if (c === "\\") {
                            err("\\ is an invalid code point.");
                          }
                          state = "relative slash";
                        } else if (c === "?") {
                          this._host = base._host;
                          this._port = base._port;
                          this._path = base._path.slice();
                          this._query = "?";
                          this._username = base._username;
                          this._password = base._password;
                          state = "query";
                        } else if (c === "#") {
                          this._host = base._host;
                          this._port = base._port;
                          this._path = base._path.slice();
                          this._query = base._query;
                          this._fragment = "#";
                          this._username = base._username;
                          this._password = base._password;
                          state = "fragment";
                        } else {
                          var nextC = input[cursor + 1];
                          var nextNextC = input[cursor + 2];
                          if (this._scheme !== "file" || !ALPHA.test(c) || nextC !== ":" && nextC !== "|" || nextNextC !== EOF && nextNextC !== "/" && nextNextC !== "\\" && nextNextC !== "?" && nextNextC !== "#") {
                            this._host = base._host;
                            this._port = base._port;
                            this._username = base._username;
                            this._password = base._password;
                            this._path = base._path.slice();
                            this._path.pop();
                          }
                          state = "relative path";
                          continue;
                        }
                        break;
                      case "relative slash":
                        if (c === "/" || c === "\\") {
                          if (c === "\\") {
                            err("\\ is an invalid code point.");
                          }
                          if (this._scheme === "file") {
                            state = "file host";
                          } else {
                            state = "authority ignore slashes";
                          }
                        } else {
                          if (this._scheme !== "file") {
                            this._host = base._host;
                            this._port = base._port;
                            this._username = base._username;
                            this._password = base._password;
                          }
                          state = "relative path";
                          continue;
                        }
                        break;
                      case "authority first slash":
                        if (c === "/") {
                          state = "authority second slash";
                        } else {
                          err("Expected '/', got: " + c);
                          state = "authority ignore slashes";
                          continue;
                        }
                        break;
                      case "authority second slash":
                        state = "authority ignore slashes";
                        if (c !== "/") {
                          err("Expected '/', got: " + c);
                          continue;
                        }
                        break;
                      case "authority ignore slashes":
                        if (c !== "/" && c !== "\\") {
                          state = "authority";
                          continue;
                        } else {
                          err("Expected authority, got: " + c);
                        }
                        break;
                      case "authority":
                        if (c === "@") {
                          if (seenAt) {
                            err("@ already seen.");
                            buffer += "%40";
                          }
                          seenAt = true;
                          for (var i = 0; i < buffer.length; i++) {
                            var cp = buffer[i];
                            if (cp === "	" || cp === "\n" || cp === "\r") {
                              err("Invalid whitespace in authority.");
                              continue;
                            }
                            if (cp === ":" && this._password === null) {
                              this._password = "";
                              continue;
                            }
                            var tempC = percentEscape(cp);
                            if (this._password !== null) {
                              this._password += tempC;
                            } else {
                              this._username += tempC;
                            }
                          }
                          buffer = "";
                        } else if (c === EOF || c === "/" || c === "\\" || c === "?" || c === "#") {
                          cursor -= buffer.length;
                          buffer = "";
                          state = "host";
                          continue;
                        } else {
                          buffer += c;
                        }
                        break;
                      case "file host":
                        if (c === EOF || c === "/" || c === "\\" || c === "?" || c === "#") {
                          if (buffer.length === 2 && ALPHA.test(buffer[0]) && (buffer[1] === ":" || buffer[1] === "|")) {
                            state = "relative path";
                          } else if (buffer.length === 0) {
                            state = "relative path start";
                          } else {
                            this._host = IDNAToASCII.call(this, buffer);
                            buffer = "";
                            state = "relative path start";
                          }
                          continue;
                        } else if (c === "	" || c === "\n" || c === "\r") {
                          err("Invalid whitespace in file host.");
                        } else {
                          buffer += c;
                        }
                        break;
                      case "host":
                      case "hostname":
                        if (c === ":" && !seenBracket) {
                          this._host = IDNAToASCII.call(this, buffer);
                          buffer = "";
                          state = "port";
                          if (stateOverride === "hostname") {
                            break loop;
                          }
                        } else if (c === EOF || c === "/" || c === "\\" || c === "?" || c === "#") {
                          this._host = IDNAToASCII.call(this, buffer);
                          buffer = "";
                          state = "relative path start";
                          if (stateOverride) {
                            break loop;
                          }
                          continue;
                        } else if (c !== "	" && c !== "\n" && c !== "\r") {
                          if (c === "[") {
                            seenBracket = true;
                          } else if (c === "]") {
                            seenBracket = false;
                          }
                          buffer += c;
                        } else {
                          err("Invalid code point in host/hostname: " + c);
                        }
                        break;
                      case "port":
                        if (/[0-9]/.test(c)) {
                          buffer += c;
                        } else if (c === EOF || c === "/" || c === "\\" || c === "?" || c === "#" || stateOverride) {
                          if (buffer !== "") {
                            var temp = parseInt(buffer, 10);
                            if (temp !== relative[this._scheme]) {
                              this._port = temp + "";
                            }
                            buffer = "";
                          }
                          if (stateOverride) {
                            break loop;
                          }
                          state = "relative path start";
                          continue;
                        } else if (c === "	" || c === "\n" || c === "\r") {
                          err("Invalid code point in port: " + c);
                        } else {
                          invalid.call(this);
                        }
                        break;
                      case "relative path start":
                        if (c === "\\") {
                          err("'\\' not allowed in path.");
                        }
                        state = "relative path";
                        if (c !== "/" && c !== "\\") {
                          continue;
                        }
                        break;
                      case "relative path":
                        if (c === EOF || c === "/" || c === "\\" || !stateOverride && (c === "?" || c === "#")) {
                          if (c === "\\") {
                            err("\\ not allowed in relative path.");
                          }
                          var tmp;
                          if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {
                            buffer = tmp;
                          }
                          if (buffer === "..") {
                            this._path.pop();
                            if (c !== "/" && c !== "\\") {
                              this._path.push("");
                            }
                          } else if (buffer === "." && c !== "/" && c !== "\\") {
                            this._path.push("");
                          } else if (buffer !== ".") {
                            if (this._scheme === "file" && this._path.length === 0 && buffer.length === 2 && ALPHA.test(buffer[0]) && buffer[1] === "|") {
                              buffer = buffer[0] + ":";
                            }
                            this._path.push(buffer);
                          }
                          buffer = "";
                          if (c === "?") {
                            this._query = "?";
                            state = "query";
                          } else if (c === "#") {
                            this._fragment = "#";
                            state = "fragment";
                          }
                        } else if (c !== "	" && c !== "\n" && c !== "\r") {
                          buffer += percentEscape(c);
                        }
                        break;
                      case "query":
                        if (!stateOverride && c === "#") {
                          this._fragment = "#";
                          state = "fragment";
                        } else if (c !== EOF && c !== "	" && c !== "\n" && c !== "\r") {
                          this._query += percentEscapeQuery(c);
                        }
                        break;
                      case "fragment":
                        if (c !== EOF && c !== "	" && c !== "\n" && c !== "\r") {
                          this._fragment += c;
                        }
                        break;
                    }
                    cursor++;
                  }
                }
                function clear() {
                  this._scheme = "";
                  this._schemeData = "";
                  this._username = "";
                  this._password = null;
                  this._host = "";
                  this._port = "";
                  this._path = [];
                  this._query = "";
                  this._fragment = "";
                  this._isInvalid = false;
                  this._isRelative = false;
                }
                function JURL(url, base) {
                  if (base !== void 0 && !(base instanceof JURL)) {
                    base = new JURL(String(base));
                  }
                  this._url = url;
                  clear.call(this);
                  var input = url.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, "");
                  parse.call(this, input, null, base);
                }
                JURL.prototype = {
                  toString: function toString() {
                    return this.href;
                  },
                  get href() {
                    if (this._isInvalid) {
                      return this._url;
                    }
                    var authority = "";
                    if (this._username !== "" || this._password !== null) {
                      authority = this._username + (this._password !== null ? ":" + this._password : "") + "@";
                    }
                    return this.protocol + (this._isRelative ? "//" + authority + this.host : "") + this.pathname + this._query + this._fragment;
                  },
                  set href(value) {
                    clear.call(this);
                    parse.call(this, value);
                  },
                  get protocol() {
                    return this._scheme + ":";
                  },
                  set protocol(value) {
                    if (this._isInvalid) {
                      return;
                    }
                    parse.call(this, value + ":", "scheme start");
                  },
                  get host() {
                    return this._isInvalid ? "" : this._port ? this._host + ":" + this._port : this._host;
                  },
                  set host(value) {
                    if (this._isInvalid || !this._isRelative) {
                      return;
                    }
                    parse.call(this, value, "host");
                  },
                  get hostname() {
                    return this._host;
                  },
                  set hostname(value) {
                    if (this._isInvalid || !this._isRelative) {
                      return;
                    }
                    parse.call(this, value, "hostname");
                  },
                  get port() {
                    return this._port;
                  },
                  set port(value) {
                    if (this._isInvalid || !this._isRelative) {
                      return;
                    }
                    parse.call(this, value, "port");
                  },
                  get pathname() {
                    return this._isInvalid ? "" : this._isRelative ? "/" + this._path.join("/") : this._schemeData;
                  },
                  set pathname(value) {
                    if (this._isInvalid || !this._isRelative) {
                      return;
                    }
                    this._path = [];
                    parse.call(this, value, "relative path start");
                  },
                  get search() {
                    return this._isInvalid || !this._query || this._query === "?" ? "" : this._query;
                  },
                  set search(value) {
                    if (this._isInvalid || !this._isRelative) {
                      return;
                    }
                    this._query = "?";
                    if (value[0] === "?") {
                      value = value.slice(1);
                    }
                    parse.call(this, value, "query");
                  },
                  get hash() {
                    return this._isInvalid || !this._fragment || this._fragment === "#" ? "" : this._fragment;
                  },
                  set hash(value) {
                    if (this._isInvalid) {
                      return;
                    }
                    this._fragment = "#";
                    if (value[0] === "#") {
                      value = value.slice(1);
                    }
                    parse.call(this, value, "fragment");
                  },
                  get origin() {
                    var host;
                    if (this._isInvalid || !this._scheme) {
                      return "";
                    }
                    switch (this._scheme) {
                      case "data":
                      case "file":
                      case "javascript":
                      case "mailto":
                        return "null";
                      case "blob":
                        try {
                          return new JURL(this._schemeData).origin || "null";
                        } catch (_) {
                        }
                        return "null";
                    }
                    host = this.host;
                    if (!host) {
                      return "";
                    }
                    return this._scheme + "://" + host;
                  }
                };
                var OriginalURL = globalScope.URL;
                if (OriginalURL) {
                  JURL.createObjectURL = function(blob) {
                    return OriginalURL.createObjectURL.apply(OriginalURL, arguments);
                  };
                  JURL.revokeObjectURL = function(url) {
                    OriginalURL.revokeObjectURL(url);
                  };
                }
                globalScope.URL = JURL;
              })();
              (function checkObjectValues() {
                if (Object.values) {
                  return;
                }
                Object.values = __w_pdfjs_require__(110);
              })();
            }
          },
          /* 4 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = typeof window !== "undefined" && window.Math === Math ? window : typeof global !== "undefined" && global.Math === Math ? global : typeof self !== "undefined" && self.Math === Math ? self : {};
          },
          /* 5 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            module3.exports = function isNodeJS() {
              return (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process + "" === "[object process]";
            };
          },
          /* 6 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(7);
            module3.exports = __w_pdfjs_require__(10).String.includes;
          },
          /* 7 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(8);
            var context = __w_pdfjs_require__(26);
            var INCLUDES = "includes";
            $export($export.P + $export.F * __w_pdfjs_require__(33)(INCLUDES), "String", {
              includes: function includes(searchString) {
                return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
          },
          /* 8 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var global2 = __w_pdfjs_require__(9);
            var core = __w_pdfjs_require__(10);
            var hide = __w_pdfjs_require__(11);
            var redefine = __w_pdfjs_require__(21);
            var ctx = __w_pdfjs_require__(24);
            var PROTOTYPE = "prototype";
            var $export = function $export2(type, name, source) {
              var IS_FORCED = type & $export2.F;
              var IS_GLOBAL = type & $export2.G;
              var IS_STATIC = type & $export2.S;
              var IS_PROTO = type & $export2.P;
              var IS_BIND = type & $export2.B;
              var target = IS_GLOBAL ? global2 : IS_STATIC ? global2[name] || (global2[name] = {}) : (global2[name] || {})[PROTOTYPE];
              var exports4 = IS_GLOBAL ? core : core[name] || (core[name] = {});
              var expProto = exports4[PROTOTYPE] || (exports4[PROTOTYPE] = {});
              var key, own, out, exp;
              if (IS_GLOBAL) source = name;
              for (key in source) {
                own = !IS_FORCED && target && target[key] !== void 0;
                out = (own ? target : source)[key];
                exp = IS_BIND && own ? ctx(out, global2) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
                if (target) redefine(target, key, out, type & $export2.U);
                if (exports4[key] != out) hide(exports4, key, exp);
                if (IS_PROTO && expProto[key] != out) expProto[key] = out;
              }
            };
            global2.core = core;
            $export.F = 1;
            $export.G = 2;
            $export.S = 4;
            $export.P = 8;
            $export.B = 16;
            $export.W = 32;
            $export.U = 64;
            $export.R = 128;
            module3.exports = $export;
          },
          /* 9 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var global2 = module3.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
            if (typeof __g == "number") __g = global2;
          },
          /* 10 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var core = module3.exports = { version: "2.5.7" };
            if (typeof __e == "number") __e = core;
          },
          /* 11 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var dP = __w_pdfjs_require__(12);
            var createDesc = __w_pdfjs_require__(20);
            module3.exports = __w_pdfjs_require__(16) ? function(object, key, value) {
              return dP.f(object, key, createDesc(1, value));
            } : function(object, key, value) {
              object[key] = value;
              return object;
            };
          },
          /* 12 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var anObject = __w_pdfjs_require__(13);
            var IE8_DOM_DEFINE = __w_pdfjs_require__(15);
            var toPrimitive = __w_pdfjs_require__(19);
            var dP = Object.defineProperty;
            exports3.f = __w_pdfjs_require__(16) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
              anObject(O);
              P = toPrimitive(P, true);
              anObject(Attributes);
              if (IE8_DOM_DEFINE) try {
                return dP(O, P, Attributes);
              } catch (e) {
              }
              if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
              if ("value" in Attributes) O[P] = Attributes.value;
              return O;
            };
          },
          /* 13 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(14);
            module3.exports = function(it) {
              if (!isObject(it)) throw TypeError(it + " is not an object!");
              return it;
            };
          },
          /* 14 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            module3.exports = function(it) {
              return (typeof it === "undefined" ? "undefined" : _typeof(it)) === "object" ? it !== null : typeof it === "function";
            };
          },
          /* 15 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = !__w_pdfjs_require__(16) && !__w_pdfjs_require__(17)(function() {
              return Object.defineProperty(__w_pdfjs_require__(18)("div"), "a", {
                get: function get() {
                  return 7;
                }
              }).a != 7;
            });
          },
          /* 16 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = !__w_pdfjs_require__(17)(function() {
              return Object.defineProperty({}, "a", {
                get: function get() {
                  return 7;
                }
              }).a != 7;
            });
          },
          /* 17 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = function(exec) {
              try {
                return !!exec();
              } catch (e) {
                return true;
              }
            };
          },
          /* 18 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(14);
            var document2 = __w_pdfjs_require__(9).document;
            var is = isObject(document2) && isObject(document2.createElement);
            module3.exports = function(it) {
              return is ? document2.createElement(it) : {};
            };
          },
          /* 19 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(14);
            module3.exports = function(it, S) {
              if (!isObject(it)) return it;
              var fn, val;
              if (S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it))) return val;
              if (typeof (fn = it.valueOf) == "function" && !isObject(val = fn.call(it))) return val;
              if (!S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it))) return val;
              throw TypeError("Can't convert object to primitive value");
            };
          },
          /* 20 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = function(bitmap, value) {
              return {
                enumerable: !(bitmap & 1),
                configurable: !(bitmap & 2),
                writable: !(bitmap & 4),
                value
              };
            };
          },
          /* 21 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var global2 = __w_pdfjs_require__(9);
            var hide = __w_pdfjs_require__(11);
            var has = __w_pdfjs_require__(22);
            var SRC = __w_pdfjs_require__(23)("src");
            var TO_STRING = "toString";
            var $toString = Function[TO_STRING];
            var TPL = ("" + $toString).split(TO_STRING);
            __w_pdfjs_require__(10).inspectSource = function(it) {
              return $toString.call(it);
            };
            (module3.exports = function(O, key, val, safe) {
              var isFunction = typeof val == "function";
              if (isFunction) has(val, "name") || hide(val, "name", key);
              if (O[key] === val) return;
              if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? "" + O[key] : TPL.join(String(key)));
              if (O === global2) {
                O[key] = val;
              } else if (!safe) {
                delete O[key];
                hide(O, key, val);
              } else if (O[key]) {
                O[key] = val;
              } else {
                hide(O, key, val);
              }
            })(Function.prototype, TO_STRING, function toString() {
              return typeof this == "function" && this[SRC] || $toString.call(this);
            });
          },
          /* 22 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var hasOwnProperty = {}.hasOwnProperty;
            module3.exports = function(it, key) {
              return hasOwnProperty.call(it, key);
            };
          },
          /* 23 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var id = 0;
            var px = Math.random();
            module3.exports = function(key) {
              return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
            };
          },
          /* 24 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var aFunction = __w_pdfjs_require__(25);
            module3.exports = function(fn, that, length) {
              aFunction(fn);
              if (that === void 0) return fn;
              switch (length) {
                case 1:
                  return function(a) {
                    return fn.call(that, a);
                  };
                case 2:
                  return function(a, b) {
                    return fn.call(that, a, b);
                  };
                case 3:
                  return function(a, b, c) {
                    return fn.call(that, a, b, c);
                  };
              }
              return function() {
                return fn.apply(that, arguments);
              };
            };
          },
          /* 25 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = function(it) {
              if (typeof it != "function") throw TypeError(it + " is not a function!");
              return it;
            };
          },
          /* 26 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isRegExp = __w_pdfjs_require__(27);
            var defined = __w_pdfjs_require__(32);
            module3.exports = function(that, searchString, NAME) {
              if (isRegExp(searchString)) throw TypeError("String#" + NAME + " doesn't accept regex!");
              return String(defined(that));
            };
          },
          /* 27 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(14);
            var cof = __w_pdfjs_require__(28);
            var MATCH = __w_pdfjs_require__(29)("match");
            module3.exports = function(it) {
              var isRegExp;
              return isObject(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : cof(it) == "RegExp");
            };
          },
          /* 28 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var toString = {}.toString;
            module3.exports = function(it) {
              return toString.call(it).slice(8, -1);
            };
          },
          /* 29 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var store = __w_pdfjs_require__(30)("wks");
            var uid = __w_pdfjs_require__(23);
            var _Symbol = __w_pdfjs_require__(9).Symbol;
            var USE_SYMBOL = typeof _Symbol == "function";
            var $exports = module3.exports = function(name) {
              return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)("Symbol." + name));
            };
            $exports.store = store;
          },
          /* 30 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var core = __w_pdfjs_require__(10);
            var global2 = __w_pdfjs_require__(9);
            var SHARED = "__core-js_shared__";
            var store = global2[SHARED] || (global2[SHARED] = {});
            (module3.exports = function(key, value) {
              return store[key] || (store[key] = value !== void 0 ? value : {});
            })("versions", []).push({
              version: core.version,
              mode: __w_pdfjs_require__(31) ? "pure" : "global",
              copyright: "© 2018 Denis Pushkarev (zloirock.ru)"
            });
          },
          /* 31 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = false;
          },
          /* 32 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = function(it) {
              if (it == void 0) throw TypeError("Can't call method on  " + it);
              return it;
            };
          },
          /* 33 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var MATCH = __w_pdfjs_require__(29)("match");
            module3.exports = function(KEY) {
              var re = /./;
              try {
                "/./"[KEY](re);
              } catch (e) {
                try {
                  re[MATCH] = false;
                  return !"/./"[KEY](re);
                } catch (f) {
                }
              }
              return true;
            };
          },
          /* 34 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(35);
            module3.exports = __w_pdfjs_require__(10).Array.includes;
          },
          /* 35 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(8);
            var $includes = __w_pdfjs_require__(36)(true);
            $export($export.P, "Array", {
              includes: function includes(el) {
                return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
            __w_pdfjs_require__(42)("includes");
          },
          /* 36 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var toIObject = __w_pdfjs_require__(37);
            var toLength = __w_pdfjs_require__(39);
            var toAbsoluteIndex = __w_pdfjs_require__(41);
            module3.exports = function(IS_INCLUDES) {
              return function($this, el, fromIndex) {
                var O = toIObject($this);
                var length = toLength(O.length);
                var index = toAbsoluteIndex(fromIndex, length);
                var value;
                if (IS_INCLUDES && el != el) while (length > index) {
                  value = O[index++];
                  if (value != value) return true;
                }
                else for (; length > index; index++) {
                  if (IS_INCLUDES || index in O) {
                    if (O[index] === el) return IS_INCLUDES || index || 0;
                  }
                }
                return !IS_INCLUDES && -1;
              };
            };
          },
          /* 37 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var IObject = __w_pdfjs_require__(38);
            var defined = __w_pdfjs_require__(32);
            module3.exports = function(it) {
              return IObject(defined(it));
            };
          },
          /* 38 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var cof = __w_pdfjs_require__(28);
            module3.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
              return cof(it) == "String" ? it.split("") : Object(it);
            };
          },
          /* 39 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var toInteger = __w_pdfjs_require__(40);
            var min = Math.min;
            module3.exports = function(it) {
              return it > 0 ? min(toInteger(it), 9007199254740991) : 0;
            };
          },
          /* 40 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var ceil = Math.ceil;
            var floor = Math.floor;
            module3.exports = function(it) {
              return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
            };
          },
          /* 41 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var toInteger = __w_pdfjs_require__(40);
            var max = Math.max;
            var min = Math.min;
            module3.exports = function(index, length) {
              index = toInteger(index);
              return index < 0 ? max(index + length, 0) : min(index, length);
            };
          },
          /* 42 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var UNSCOPABLES = __w_pdfjs_require__(29)("unscopables");
            var ArrayProto = Array.prototype;
            if (ArrayProto[UNSCOPABLES] == void 0) __w_pdfjs_require__(11)(ArrayProto, UNSCOPABLES, {});
            module3.exports = function(key) {
              ArrayProto[UNSCOPABLES][key] = true;
            };
          },
          /* 43 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(44);
            module3.exports = __w_pdfjs_require__(10).Math.log2;
          },
          /* 44 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(8);
            $export($export.S, "Math", {
              log2: function log2(x) {
                return Math.log(x) / Math.LN2;
              }
            });
          },
          /* 45 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(46);
            module3.exports = __w_pdfjs_require__(10).Number.isNaN;
          },
          /* 46 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(8);
            $export($export.S, "Number", {
              isNaN: function isNaN2(number) {
                return number != number;
              }
            });
          },
          /* 47 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(48);
            module3.exports = __w_pdfjs_require__(10).Number.isInteger;
          },
          /* 48 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(8);
            $export($export.S, "Number", { isInteger: __w_pdfjs_require__(49) });
          },
          /* 49 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(14);
            var floor = Math.floor;
            module3.exports = function isInteger(it) {
              return !isObject(it) && isFinite(it) && floor(it) === it;
            };
          },
          /* 50 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(51);
            __w_pdfjs_require__(53);
            __w_pdfjs_require__(68);
            __w_pdfjs_require__(71);
            __w_pdfjs_require__(88);
            __w_pdfjs_require__(89);
            module3.exports = __w_pdfjs_require__(10).Promise;
          },
          /* 51 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var classof = __w_pdfjs_require__(52);
            var test = {};
            test[__w_pdfjs_require__(29)("toStringTag")] = "z";
            if (test + "" != "[object z]") {
              __w_pdfjs_require__(21)(Object.prototype, "toString", function toString() {
                return "[object " + classof(this) + "]";
              }, true);
            }
          },
          /* 52 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var cof = __w_pdfjs_require__(28);
            var TAG = __w_pdfjs_require__(29)("toStringTag");
            var ARG = cof(/* @__PURE__ */ function() {
              return arguments;
            }()) == "Arguments";
            var tryGet = function tryGet2(it, key) {
              try {
                return it[key];
              } catch (e) {
              }
            };
            module3.exports = function(it) {
              var O, T, B;
              return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T = tryGet(O = Object(it), TAG)) == "string" ? T : ARG ? cof(O) : (B = cof(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
            };
          },
          /* 53 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $at = __w_pdfjs_require__(54)(true);
            __w_pdfjs_require__(55)(String, "String", function(iterated) {
              this._t = String(iterated);
              this._i = 0;
            }, function() {
              var O = this._t;
              var index = this._i;
              var point;
              if (index >= O.length) return {
                value: void 0,
                done: true
              };
              point = $at(O, index);
              this._i += point.length;
              return {
                value: point,
                done: false
              };
            });
          },
          /* 54 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var toInteger = __w_pdfjs_require__(40);
            var defined = __w_pdfjs_require__(32);
            module3.exports = function(TO_STRING) {
              return function(that, pos) {
                var s = String(defined(that));
                var i = toInteger(pos);
                var l = s.length;
                var a, b;
                if (i < 0 || i >= l) return TO_STRING ? "" : void 0;
                a = s.charCodeAt(i);
                return a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
              };
            };
          },
          /* 55 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var LIBRARY = __w_pdfjs_require__(31);
            var $export = __w_pdfjs_require__(8);
            var redefine = __w_pdfjs_require__(21);
            var hide = __w_pdfjs_require__(11);
            var Iterators = __w_pdfjs_require__(56);
            var $iterCreate = __w_pdfjs_require__(57);
            var setToStringTag = __w_pdfjs_require__(65);
            var getPrototypeOf = __w_pdfjs_require__(66);
            var ITERATOR = __w_pdfjs_require__(29)("iterator");
            var BUGGY = !([].keys && "next" in [].keys());
            var FF_ITERATOR = "@@iterator";
            var KEYS = "keys";
            var VALUES = "values";
            var returnThis = function returnThis2() {
              return this;
            };
            module3.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
              $iterCreate(Constructor, NAME, next);
              var getMethod = function getMethod2(kind) {
                if (!BUGGY && kind in proto) return proto[kind];
                switch (kind) {
                  case KEYS:
                    return function keys() {
                      return new Constructor(this, kind);
                    };
                  case VALUES:
                    return function values() {
                      return new Constructor(this, kind);
                    };
                }
                return function entries() {
                  return new Constructor(this, kind);
                };
              };
              var TAG = NAME + " Iterator";
              var DEF_VALUES = DEFAULT == VALUES;
              var VALUES_BUG = false;
              var proto = Base.prototype;
              var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
              var $default = $native || getMethod(DEFAULT);
              var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : void 0;
              var $anyNative = NAME == "Array" ? proto.entries || $native : $native;
              var methods, key, IteratorPrototype;
              if ($anyNative) {
                IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
                if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
                  setToStringTag(IteratorPrototype, TAG, true);
                  if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != "function") hide(IteratorPrototype, ITERATOR, returnThis);
                }
              }
              if (DEF_VALUES && $native && $native.name !== VALUES) {
                VALUES_BUG = true;
                $default = function values() {
                  return $native.call(this);
                };
              }
              if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
                hide(proto, ITERATOR, $default);
              }
              Iterators[NAME] = $default;
              Iterators[TAG] = returnThis;
              if (DEFAULT) {
                methods = {
                  values: DEF_VALUES ? $default : getMethod(VALUES),
                  keys: IS_SET ? $default : getMethod(KEYS),
                  entries: $entries
                };
                if (FORCED) for (key in methods) {
                  if (!(key in proto)) redefine(proto, key, methods[key]);
                }
                else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
              }
              return methods;
            };
          },
          /* 56 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = {};
          },
          /* 57 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var create = __w_pdfjs_require__(58);
            var descriptor = __w_pdfjs_require__(20);
            var setToStringTag = __w_pdfjs_require__(65);
            var IteratorPrototype = {};
            __w_pdfjs_require__(11)(IteratorPrototype, __w_pdfjs_require__(29)("iterator"), function() {
              return this;
            });
            module3.exports = function(Constructor, NAME, next) {
              Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
              setToStringTag(Constructor, NAME + " Iterator");
            };
          },
          /* 58 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var anObject = __w_pdfjs_require__(13);
            var dPs = __w_pdfjs_require__(59);
            var enumBugKeys = __w_pdfjs_require__(63);
            var IE_PROTO = __w_pdfjs_require__(62)("IE_PROTO");
            var Empty = function Empty2() {
            };
            var PROTOTYPE = "prototype";
            var _createDict = function createDict() {
              var iframe = __w_pdfjs_require__(18)("iframe");
              var i = enumBugKeys.length;
              var lt = "<";
              var gt = ">";
              var iframeDocument;
              iframe.style.display = "none";
              __w_pdfjs_require__(64).appendChild(iframe);
              iframe.src = "javascript:";
              iframeDocument = iframe.contentWindow.document;
              iframeDocument.open();
              iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
              iframeDocument.close();
              _createDict = iframeDocument.F;
              while (i--) {
                delete _createDict[PROTOTYPE][enumBugKeys[i]];
              }
              return _createDict();
            };
            module3.exports = Object.create || function create(O, Properties) {
              var result;
              if (O !== null) {
                Empty[PROTOTYPE] = anObject(O);
                result = new Empty();
                Empty[PROTOTYPE] = null;
                result[IE_PROTO] = O;
              } else result = _createDict();
              return Properties === void 0 ? result : dPs(result, Properties);
            };
          },
          /* 59 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var dP = __w_pdfjs_require__(12);
            var anObject = __w_pdfjs_require__(13);
            var getKeys = __w_pdfjs_require__(60);
            module3.exports = __w_pdfjs_require__(16) ? Object.defineProperties : function defineProperties(O, Properties) {
              anObject(O);
              var keys = getKeys(Properties);
              var length = keys.length;
              var i = 0;
              var P;
              while (length > i) {
                dP.f(O, P = keys[i++], Properties[P]);
              }
              return O;
            };
          },
          /* 60 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $keys = __w_pdfjs_require__(61);
            var enumBugKeys = __w_pdfjs_require__(63);
            module3.exports = Object.keys || function keys(O) {
              return $keys(O, enumBugKeys);
            };
          },
          /* 61 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var has = __w_pdfjs_require__(22);
            var toIObject = __w_pdfjs_require__(37);
            var arrayIndexOf = __w_pdfjs_require__(36)(false);
            var IE_PROTO = __w_pdfjs_require__(62)("IE_PROTO");
            module3.exports = function(object, names) {
              var O = toIObject(object);
              var i = 0;
              var result = [];
              var key;
              for (key in O) {
                if (key != IE_PROTO) has(O, key) && result.push(key);
              }
              while (names.length > i) {
                if (has(O, key = names[i++])) {
                  ~arrayIndexOf(result, key) || result.push(key);
                }
              }
              return result;
            };
          },
          /* 62 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var shared = __w_pdfjs_require__(30)("keys");
            var uid = __w_pdfjs_require__(23);
            module3.exports = function(key) {
              return shared[key] || (shared[key] = uid(key));
            };
          },
          /* 63 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
          },
          /* 64 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var document2 = __w_pdfjs_require__(9).document;
            module3.exports = document2 && document2.documentElement;
          },
          /* 65 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var def = __w_pdfjs_require__(12).f;
            var has = __w_pdfjs_require__(22);
            var TAG = __w_pdfjs_require__(29)("toStringTag");
            module3.exports = function(it, tag, stat) {
              if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
                configurable: true,
                value: tag
              });
            };
          },
          /* 66 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var has = __w_pdfjs_require__(22);
            var toObject = __w_pdfjs_require__(67);
            var IE_PROTO = __w_pdfjs_require__(62)("IE_PROTO");
            var ObjectProto = Object.prototype;
            module3.exports = Object.getPrototypeOf || function(O) {
              O = toObject(O);
              if (has(O, IE_PROTO)) return O[IE_PROTO];
              if (typeof O.constructor == "function" && O instanceof O.constructor) {
                return O.constructor.prototype;
              }
              return O instanceof Object ? ObjectProto : null;
            };
          },
          /* 67 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var defined = __w_pdfjs_require__(32);
            module3.exports = function(it) {
              return Object(defined(it));
            };
          },
          /* 68 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $iterators = __w_pdfjs_require__(69);
            var getKeys = __w_pdfjs_require__(60);
            var redefine = __w_pdfjs_require__(21);
            var global2 = __w_pdfjs_require__(9);
            var hide = __w_pdfjs_require__(11);
            var Iterators = __w_pdfjs_require__(56);
            var wks = __w_pdfjs_require__(29);
            var ITERATOR = wks("iterator");
            var TO_STRING_TAG = wks("toStringTag");
            var ArrayValues = Iterators.Array;
            var DOMIterables = {
              CSSRuleList: true,
              CSSStyleDeclaration: false,
              CSSValueList: false,
              ClientRectList: false,
              DOMRectList: false,
              DOMStringList: false,
              DOMTokenList: true,
              DataTransferItemList: false,
              FileList: false,
              HTMLAllCollection: false,
              HTMLCollection: false,
              HTMLFormElement: false,
              HTMLSelectElement: false,
              MediaList: true,
              MimeTypeArray: false,
              NamedNodeMap: false,
              NodeList: true,
              PaintRequestList: false,
              Plugin: false,
              PluginArray: false,
              SVGLengthList: false,
              SVGNumberList: false,
              SVGPathSegList: false,
              SVGPointList: false,
              SVGStringList: false,
              SVGTransformList: false,
              SourceBufferList: false,
              StyleSheetList: true,
              TextTrackCueList: false,
              TextTrackList: false,
              TouchList: false
            };
            for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
              var NAME = collections[i];
              var explicit = DOMIterables[NAME];
              var Collection = global2[NAME];
              var proto = Collection && Collection.prototype;
              var key;
              if (proto) {
                if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
                if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
                Iterators[NAME] = ArrayValues;
                if (explicit) for (key in $iterators) {
                  if (!proto[key]) redefine(proto, key, $iterators[key], true);
                }
              }
            }
          },
          /* 69 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var addToUnscopables = __w_pdfjs_require__(42);
            var step = __w_pdfjs_require__(70);
            var Iterators = __w_pdfjs_require__(56);
            var toIObject = __w_pdfjs_require__(37);
            module3.exports = __w_pdfjs_require__(55)(Array, "Array", function(iterated, kind) {
              this._t = toIObject(iterated);
              this._i = 0;
              this._k = kind;
            }, function() {
              var O = this._t;
              var kind = this._k;
              var index = this._i++;
              if (!O || index >= O.length) {
                this._t = void 0;
                return step(1);
              }
              if (kind == "keys") return step(0, index);
              if (kind == "values") return step(0, O[index]);
              return step(0, [index, O[index]]);
            }, "values");
            Iterators.Arguments = Iterators.Array;
            addToUnscopables("keys");
            addToUnscopables("values");
            addToUnscopables("entries");
          },
          /* 70 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = function(done, value) {
              return {
                value,
                done: !!done
              };
            };
          },
          /* 71 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var LIBRARY = __w_pdfjs_require__(31);
            var global2 = __w_pdfjs_require__(9);
            var ctx = __w_pdfjs_require__(24);
            var classof = __w_pdfjs_require__(52);
            var $export = __w_pdfjs_require__(8);
            var isObject = __w_pdfjs_require__(14);
            var aFunction = __w_pdfjs_require__(25);
            var anInstance = __w_pdfjs_require__(72);
            var forOf = __w_pdfjs_require__(73);
            var speciesConstructor = __w_pdfjs_require__(77);
            var task = __w_pdfjs_require__(78).set;
            var microtask = __w_pdfjs_require__(80)();
            var newPromiseCapabilityModule = __w_pdfjs_require__(81);
            var perform = __w_pdfjs_require__(82);
            var userAgent = __w_pdfjs_require__(83);
            var promiseResolve = __w_pdfjs_require__(84);
            var PROMISE = "Promise";
            var TypeError2 = global2.TypeError;
            var process2 = global2.process;
            var versions = process2 && process2.versions;
            var v8 = versions && versions.v8 || "";
            var $Promise = global2[PROMISE];
            var isNode = classof(process2) == "process";
            var empty = function empty2() {
            };
            var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
            var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
            var USE_NATIVE = !!function() {
              try {
                var promise = $Promise.resolve(1);
                var FakePromise = (promise.constructor = {})[__w_pdfjs_require__(29)("species")] = function(exec) {
                  exec(empty, empty);
                };
                return (isNode || typeof PromiseRejectionEvent == "function") && promise.then(empty) instanceof FakePromise && v8.indexOf("6.6") !== 0 && userAgent.indexOf("Chrome/66") === -1;
              } catch (e) {
              }
            }();
            var isThenable = function isThenable2(it) {
              var then;
              return isObject(it) && typeof (then = it.then) == "function" ? then : false;
            };
            var notify = function notify2(promise, isReject) {
              if (promise._n) return;
              promise._n = true;
              var chain = promise._c;
              microtask(function() {
                var value = promise._v;
                var ok = promise._s == 1;
                var i = 0;
                var run = function run2(reaction) {
                  var handler = ok ? reaction.ok : reaction.fail;
                  var resolve2 = reaction.resolve;
                  var reject2 = reaction.reject;
                  var domain = reaction.domain;
                  var result, then, exited;
                  try {
                    if (handler) {
                      if (!ok) {
                        if (promise._h == 2) onHandleUnhandled(promise);
                        promise._h = 1;
                      }
                      if (handler === true) result = value;
                      else {
                        if (domain) domain.enter();
                        result = handler(value);
                        if (domain) {
                          domain.exit();
                          exited = true;
                        }
                      }
                      if (result === reaction.promise) {
                        reject2(TypeError2("Promise-chain cycle"));
                      } else if (then = isThenable(result)) {
                        then.call(result, resolve2, reject2);
                      } else resolve2(result);
                    } else reject2(value);
                  } catch (e) {
                    if (domain && !exited) domain.exit();
                    reject2(e);
                  }
                };
                while (chain.length > i) {
                  run(chain[i++]);
                }
                promise._c = [];
                promise._n = false;
                if (isReject && !promise._h) onUnhandled(promise);
              });
            };
            var onUnhandled = function onUnhandled2(promise) {
              task.call(global2, function() {
                var value = promise._v;
                var unhandled = isUnhandled(promise);
                var result, handler, console2;
                if (unhandled) {
                  result = perform(function() {
                    if (isNode) {
                      process2.emit("unhandledRejection", value, promise);
                    } else if (handler = global2.onunhandledrejection) {
                      handler({
                        promise,
                        reason: value
                      });
                    } else if ((console2 = global2.console) && console2.error) {
                      console2.error("Unhandled promise rejection", value);
                    }
                  });
                  promise._h = isNode || isUnhandled(promise) ? 2 : 1;
                }
                promise._a = void 0;
                if (unhandled && result.e) throw result.v;
              });
            };
            var isUnhandled = function isUnhandled2(promise) {
              return promise._h !== 1 && (promise._a || promise._c).length === 0;
            };
            var onHandleUnhandled = function onHandleUnhandled2(promise) {
              task.call(global2, function() {
                var handler;
                if (isNode) {
                  process2.emit("rejectionHandled", promise);
                } else if (handler = global2.onrejectionhandled) {
                  handler({
                    promise,
                    reason: promise._v
                  });
                }
              });
            };
            var $reject = function $reject2(value) {
              var promise = this;
              if (promise._d) return;
              promise._d = true;
              promise = promise._w || promise;
              promise._v = value;
              promise._s = 2;
              if (!promise._a) promise._a = promise._c.slice();
              notify(promise, true);
            };
            var $resolve = function $resolve2(value) {
              var promise = this;
              var then;
              if (promise._d) return;
              promise._d = true;
              promise = promise._w || promise;
              try {
                if (promise === value) throw TypeError2("Promise can't be resolved itself");
                if (then = isThenable(value)) {
                  microtask(function() {
                    var wrapper = {
                      _w: promise,
                      _d: false
                    };
                    try {
                      then.call(value, ctx($resolve2, wrapper, 1), ctx($reject, wrapper, 1));
                    } catch (e) {
                      $reject.call(wrapper, e);
                    }
                  });
                } else {
                  promise._v = value;
                  promise._s = 1;
                  notify(promise, false);
                }
              } catch (e) {
                $reject.call({
                  _w: promise,
                  _d: false
                }, e);
              }
            };
            if (!USE_NATIVE) {
              $Promise = function Promise2(executor) {
                anInstance(this, $Promise, PROMISE, "_h");
                aFunction(executor);
                Internal.call(this);
                try {
                  executor(ctx($resolve, this, 1), ctx($reject, this, 1));
                } catch (err) {
                  $reject.call(this, err);
                }
              };
              Internal = function Promise2(executor) {
                this._c = [];
                this._a = void 0;
                this._s = 0;
                this._d = false;
                this._v = void 0;
                this._h = 0;
                this._n = false;
              };
              Internal.prototype = __w_pdfjs_require__(85)($Promise.prototype, {
                then: function then(onFulfilled, onRejected) {
                  var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
                  reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
                  reaction.fail = typeof onRejected == "function" && onRejected;
                  reaction.domain = isNode ? process2.domain : void 0;
                  this._c.push(reaction);
                  if (this._a) this._a.push(reaction);
                  if (this._s) notify(this, false);
                  return reaction.promise;
                },
                "catch": function _catch(onRejected) {
                  return this.then(void 0, onRejected);
                }
              });
              OwnPromiseCapability = function OwnPromiseCapability2() {
                var promise = new Internal();
                this.promise = promise;
                this.resolve = ctx($resolve, promise, 1);
                this.reject = ctx($reject, promise, 1);
              };
              newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability2(C) {
                return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
              };
            }
            $export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
            __w_pdfjs_require__(65)($Promise, PROMISE);
            __w_pdfjs_require__(86)(PROMISE);
            Wrapper = __w_pdfjs_require__(10)[PROMISE];
            $export($export.S + $export.F * !USE_NATIVE, PROMISE, {
              reject: function reject2(r) {
                var capability = newPromiseCapability(this);
                var $$reject = capability.reject;
                $$reject(r);
                return capability.promise;
              }
            });
            $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
              resolve: function resolve2(x) {
                return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
              }
            });
            $export($export.S + $export.F * !(USE_NATIVE && __w_pdfjs_require__(87)(function(iter) {
              $Promise.all(iter)["catch"](empty);
            })), PROMISE, {
              all: function all(iterable) {
                var C = this;
                var capability = newPromiseCapability(C);
                var resolve2 = capability.resolve;
                var reject2 = capability.reject;
                var result = perform(function() {
                  var values = [];
                  var index = 0;
                  var remaining = 1;
                  forOf(iterable, false, function(promise) {
                    var $index = index++;
                    var alreadyCalled = false;
                    values.push(void 0);
                    remaining++;
                    C.resolve(promise).then(function(value) {
                      if (alreadyCalled) return;
                      alreadyCalled = true;
                      values[$index] = value;
                      --remaining || resolve2(values);
                    }, reject2);
                  });
                  --remaining || resolve2(values);
                });
                if (result.e) reject2(result.v);
                return capability.promise;
              },
              race: function race(iterable) {
                var C = this;
                var capability = newPromiseCapability(C);
                var reject2 = capability.reject;
                var result = perform(function() {
                  forOf(iterable, false, function(promise) {
                    C.resolve(promise).then(capability.resolve, reject2);
                  });
                });
                if (result.e) reject2(result.v);
                return capability.promise;
              }
            });
          },
          /* 72 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = function(it, Constructor, name, forbiddenField) {
              if (!(it instanceof Constructor) || forbiddenField !== void 0 && forbiddenField in it) {
                throw TypeError(name + ": incorrect invocation!");
              }
              return it;
            };
          },
          /* 73 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var ctx = __w_pdfjs_require__(24);
            var call = __w_pdfjs_require__(74);
            var isArrayIter = __w_pdfjs_require__(75);
            var anObject = __w_pdfjs_require__(13);
            var toLength = __w_pdfjs_require__(39);
            var getIterFn = __w_pdfjs_require__(76);
            var BREAK = {};
            var RETURN = {};
            var _exports = module3.exports = function(iterable, entries, fn, that, ITERATOR) {
              var iterFn = ITERATOR ? function() {
                return iterable;
              } : getIterFn(iterable);
              var f = ctx(fn, that, entries ? 2 : 1);
              var index = 0;
              var length, step, iterator, result;
              if (typeof iterFn != "function") throw TypeError(iterable + " is not iterable!");
              if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
                result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
                if (result === BREAK || result === RETURN) return result;
              }
              else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
                result = call(iterator, f, step.value, entries);
                if (result === BREAK || result === RETURN) return result;
              }
            };
            _exports.BREAK = BREAK;
            _exports.RETURN = RETURN;
          },
          /* 74 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var anObject = __w_pdfjs_require__(13);
            module3.exports = function(iterator, fn, value, entries) {
              try {
                return entries ? fn(anObject(value)[0], value[1]) : fn(value);
              } catch (e) {
                var ret = iterator["return"];
                if (ret !== void 0) anObject(ret.call(iterator));
                throw e;
              }
            };
          },
          /* 75 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var Iterators = __w_pdfjs_require__(56);
            var ITERATOR = __w_pdfjs_require__(29)("iterator");
            var ArrayProto = Array.prototype;
            module3.exports = function(it) {
              return it !== void 0 && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
            };
          },
          /* 76 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var classof = __w_pdfjs_require__(52);
            var ITERATOR = __w_pdfjs_require__(29)("iterator");
            var Iterators = __w_pdfjs_require__(56);
            module3.exports = __w_pdfjs_require__(10).getIteratorMethod = function(it) {
              if (it != void 0) return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
            };
          },
          /* 77 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var anObject = __w_pdfjs_require__(13);
            var aFunction = __w_pdfjs_require__(25);
            var SPECIES = __w_pdfjs_require__(29)("species");
            module3.exports = function(O, D) {
              var C = anObject(O).constructor;
              var S;
              return C === void 0 || (S = anObject(C)[SPECIES]) == void 0 ? D : aFunction(S);
            };
          },
          /* 78 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var ctx = __w_pdfjs_require__(24);
            var invoke = __w_pdfjs_require__(79);
            var html = __w_pdfjs_require__(64);
            var cel = __w_pdfjs_require__(18);
            var global2 = __w_pdfjs_require__(9);
            var process2 = global2.process;
            var setTask = global2.setImmediate;
            var clearTask = global2.clearImmediate;
            var MessageChannel = global2.MessageChannel;
            var Dispatch = global2.Dispatch;
            var counter = 0;
            var queue = {};
            var ONREADYSTATECHANGE = "onreadystatechange";
            var defer, channel, port;
            var run = function run2() {
              var id = +this;
              if (queue.hasOwnProperty(id)) {
                var fn = queue[id];
                delete queue[id];
                fn();
              }
            };
            var listener = function listener2(event) {
              run.call(event.data);
            };
            if (!setTask || !clearTask) {
              setTask = function setImmediate2(fn) {
                var args = [];
                var i = 1;
                while (arguments.length > i) {
                  args.push(arguments[i++]);
                }
                queue[++counter] = function() {
                  invoke(typeof fn == "function" ? fn : Function(fn), args);
                };
                defer(counter);
                return counter;
              };
              clearTask = function clearImmediate(id) {
                delete queue[id];
              };
              if (__w_pdfjs_require__(28)(process2) == "process") {
                defer = function defer2(id) {
                  process2.nextTick(ctx(run, id, 1));
                };
              } else if (Dispatch && Dispatch.now) {
                defer = function defer2(id) {
                  Dispatch.now(ctx(run, id, 1));
                };
              } else if (MessageChannel) {
                channel = new MessageChannel();
                port = channel.port2;
                channel.port1.onmessage = listener;
                defer = ctx(port.postMessage, port, 1);
              } else if (global2.addEventListener && typeof postMessage == "function" && !global2.importScripts) {
                defer = function defer2(id) {
                  global2.postMessage(id + "", "*");
                };
                global2.addEventListener("message", listener, false);
              } else if (ONREADYSTATECHANGE in cel("script")) {
                defer = function defer2(id) {
                  html.appendChild(cel("script"))[ONREADYSTATECHANGE] = function() {
                    html.removeChild(this);
                    run.call(id);
                  };
                };
              } else {
                defer = function defer2(id) {
                  setTimeout(ctx(run, id, 1), 0);
                };
              }
            }
            module3.exports = {
              set: setTask,
              clear: clearTask
            };
          },
          /* 79 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = function(fn, args, that) {
              var un = that === void 0;
              switch (args.length) {
                case 0:
                  return un ? fn() : fn.call(that);
                case 1:
                  return un ? fn(args[0]) : fn.call(that, args[0]);
                case 2:
                  return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
                case 3:
                  return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
                case 4:
                  return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
              }
              return fn.apply(that, args);
            };
          },
          /* 80 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var global2 = __w_pdfjs_require__(9);
            var macrotask = __w_pdfjs_require__(78).set;
            var Observer = global2.MutationObserver || global2.WebKitMutationObserver;
            var process2 = global2.process;
            var Promise2 = global2.Promise;
            var isNode = __w_pdfjs_require__(28)(process2) == "process";
            module3.exports = function() {
              var head, last, notify;
              var flush = function flush2() {
                var parent, fn;
                if (isNode && (parent = process2.domain)) parent.exit();
                while (head) {
                  fn = head.fn;
                  head = head.next;
                  try {
                    fn();
                  } catch (e) {
                    if (head) notify();
                    else last = void 0;
                    throw e;
                  }
                }
                last = void 0;
                if (parent) parent.enter();
              };
              if (isNode) {
                notify = function notify2() {
                  process2.nextTick(flush);
                };
              } else if (Observer && !(global2.navigator && global2.navigator.standalone)) {
                var toggle = true;
                var node = document.createTextNode("");
                new Observer(flush).observe(node, { characterData: true });
                notify = function notify2() {
                  node.data = toggle = !toggle;
                };
              } else if (Promise2 && Promise2.resolve) {
                var promise = Promise2.resolve(void 0);
                notify = function notify2() {
                  promise.then(flush);
                };
              } else {
                notify = function notify2() {
                  macrotask.call(global2, flush);
                };
              }
              return function(fn) {
                var task = {
                  fn,
                  next: void 0
                };
                if (last) last.next = task;
                if (!head) {
                  head = task;
                  notify();
                }
                last = task;
              };
            };
          },
          /* 81 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var aFunction = __w_pdfjs_require__(25);
            function PromiseCapability(C) {
              var resolve2, reject2;
              this.promise = new C(function($$resolve, $$reject) {
                if (resolve2 !== void 0 || reject2 !== void 0) throw TypeError("Bad Promise constructor");
                resolve2 = $$resolve;
                reject2 = $$reject;
              });
              this.resolve = aFunction(resolve2);
              this.reject = aFunction(reject2);
            }
            module3.exports.f = function(C) {
              return new PromiseCapability(C);
            };
          },
          /* 82 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = function(exec) {
              try {
                return {
                  e: false,
                  v: exec()
                };
              } catch (e) {
                return {
                  e: true,
                  v: e
                };
              }
            };
          },
          /* 83 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var global2 = __w_pdfjs_require__(9);
            var navigator2 = global2.navigator;
            module3.exports = navigator2 && navigator2.userAgent || "";
          },
          /* 84 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var anObject = __w_pdfjs_require__(13);
            var isObject = __w_pdfjs_require__(14);
            var newPromiseCapability = __w_pdfjs_require__(81);
            module3.exports = function(C, x) {
              anObject(C);
              if (isObject(x) && x.constructor === C) return x;
              var promiseCapability = newPromiseCapability.f(C);
              var resolve2 = promiseCapability.resolve;
              resolve2(x);
              return promiseCapability.promise;
            };
          },
          /* 85 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var redefine = __w_pdfjs_require__(21);
            module3.exports = function(target, src, safe) {
              for (var key in src) {
                redefine(target, key, src[key], safe);
              }
              return target;
            };
          },
          /* 86 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var global2 = __w_pdfjs_require__(9);
            var dP = __w_pdfjs_require__(12);
            var DESCRIPTORS = __w_pdfjs_require__(16);
            var SPECIES = __w_pdfjs_require__(29)("species");
            module3.exports = function(KEY) {
              var C = global2[KEY];
              if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
                configurable: true,
                get: function get() {
                  return this;
                }
              });
            };
          },
          /* 87 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var ITERATOR = __w_pdfjs_require__(29)("iterator");
            var SAFE_CLOSING = false;
            try {
              var riter = [7][ITERATOR]();
              riter["return"] = function() {
                SAFE_CLOSING = true;
              };
              Array.from(riter, function() {
                throw 2;
              });
            } catch (e) {
            }
            module3.exports = function(exec, skipClosing) {
              if (!skipClosing && !SAFE_CLOSING) return false;
              var safe = false;
              try {
                var arr = [7];
                var iter = arr[ITERATOR]();
                iter.next = function() {
                  return { done: safe = true };
                };
                arr[ITERATOR] = function() {
                  return iter;
                };
                exec(arr);
              } catch (e) {
              }
              return safe;
            };
          },
          /* 88 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(8);
            var core = __w_pdfjs_require__(10);
            var global2 = __w_pdfjs_require__(9);
            var speciesConstructor = __w_pdfjs_require__(77);
            var promiseResolve = __w_pdfjs_require__(84);
            $export($export.P + $export.R, "Promise", {
              "finally": function _finally(onFinally) {
                var C = speciesConstructor(this, core.Promise || global2.Promise);
                var isFunction = typeof onFinally == "function";
                return this.then(isFunction ? function(x) {
                  return promiseResolve(C, onFinally()).then(function() {
                    return x;
                  });
                } : onFinally, isFunction ? function(e) {
                  return promiseResolve(C, onFinally()).then(function() {
                    throw e;
                  });
                } : onFinally);
              }
            });
          },
          /* 89 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(8);
            var newPromiseCapability = __w_pdfjs_require__(81);
            var perform = __w_pdfjs_require__(82);
            $export($export.S, "Promise", {
              "try": function _try(callbackfn) {
                var promiseCapability = newPromiseCapability.f(this);
                var result = perform(callbackfn);
                (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
                return promiseCapability.promise;
              }
            });
          },
          /* 90 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(51);
            __w_pdfjs_require__(68);
            __w_pdfjs_require__(91);
            __w_pdfjs_require__(106);
            __w_pdfjs_require__(108);
            module3.exports = __w_pdfjs_require__(10).WeakMap;
          },
          /* 91 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var each = __w_pdfjs_require__(92)(0);
            var redefine = __w_pdfjs_require__(21);
            var meta = __w_pdfjs_require__(96);
            var assign = __w_pdfjs_require__(97);
            var weak = __w_pdfjs_require__(100);
            var isObject = __w_pdfjs_require__(14);
            var fails = __w_pdfjs_require__(17);
            var validate = __w_pdfjs_require__(101);
            var WEAK_MAP = "WeakMap";
            var getWeak = meta.getWeak;
            var isExtensible = Object.isExtensible;
            var uncaughtFrozenStore = weak.ufstore;
            var tmp = {};
            var InternalMap;
            var wrapper = function wrapper2(get) {
              return function WeakMap2() {
                return get(this, arguments.length > 0 ? arguments[0] : void 0);
              };
            };
            var methods = {
              get: function get(key) {
                if (isObject(key)) {
                  var data = getWeak(key);
                  if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
                  return data ? data[this._i] : void 0;
                }
              },
              set: function set(key, value) {
                return weak.def(validate(this, WEAK_MAP), key, value);
              }
            };
            var $WeakMap = module3.exports = __w_pdfjs_require__(102)(WEAK_MAP, wrapper, methods, weak, true, true);
            if (fails(function() {
              return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7;
            })) {
              InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
              assign(InternalMap.prototype, methods);
              meta.NEED = true;
              each(["delete", "has", "get", "set"], function(key) {
                var proto = $WeakMap.prototype;
                var method = proto[key];
                redefine(proto, key, function(a, b) {
                  if (isObject(a) && !isExtensible(a)) {
                    if (!this._f) this._f = new InternalMap();
                    var result = this._f[key](a, b);
                    return key == "set" ? this : result;
                  }
                  return method.call(this, a, b);
                });
              });
            }
          },
          /* 92 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var ctx = __w_pdfjs_require__(24);
            var IObject = __w_pdfjs_require__(38);
            var toObject = __w_pdfjs_require__(67);
            var toLength = __w_pdfjs_require__(39);
            var asc = __w_pdfjs_require__(93);
            module3.exports = function(TYPE, $create) {
              var IS_MAP = TYPE == 1;
              var IS_FILTER = TYPE == 2;
              var IS_SOME = TYPE == 3;
              var IS_EVERY = TYPE == 4;
              var IS_FIND_INDEX = TYPE == 6;
              var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
              var create = $create || asc;
              return function($this, callbackfn, that) {
                var O = toObject($this);
                var self2 = IObject(O);
                var f = ctx(callbackfn, that, 3);
                var length = toLength(self2.length);
                var index = 0;
                var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0;
                var val, res;
                for (; length > index; index++) {
                  if (NO_HOLES || index in self2) {
                    val = self2[index];
                    res = f(val, index, O);
                    if (TYPE) {
                      if (IS_MAP) result[index] = res;
                      else if (res) switch (TYPE) {
                        case 3:
                          return true;
                        case 5:
                          return val;
                        case 6:
                          return index;
                        case 2:
                          result.push(val);
                      }
                      else if (IS_EVERY) return false;
                    }
                  }
                }
                return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
              };
            };
          },
          /* 93 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var speciesConstructor = __w_pdfjs_require__(94);
            module3.exports = function(original, length) {
              return new (speciesConstructor(original))(length);
            };
          },
          /* 94 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(14);
            var isArray = __w_pdfjs_require__(95);
            var SPECIES = __w_pdfjs_require__(29)("species");
            module3.exports = function(original) {
              var C;
              if (isArray(original)) {
                C = original.constructor;
                if (typeof C == "function" && (C === Array || isArray(C.prototype))) C = void 0;
                if (isObject(C)) {
                  C = C[SPECIES];
                  if (C === null) C = void 0;
                }
              }
              return C === void 0 ? Array : C;
            };
          },
          /* 95 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var cof = __w_pdfjs_require__(28);
            module3.exports = Array.isArray || function isArray(arg) {
              return cof(arg) == "Array";
            };
          },
          /* 96 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var META = __w_pdfjs_require__(23)("meta");
            var isObject = __w_pdfjs_require__(14);
            var has = __w_pdfjs_require__(22);
            var setDesc = __w_pdfjs_require__(12).f;
            var id = 0;
            var isExtensible = Object.isExtensible || function() {
              return true;
            };
            var FREEZE = !__w_pdfjs_require__(17)(function() {
              return isExtensible(Object.preventExtensions({}));
            });
            var setMeta = function setMeta2(it) {
              setDesc(it, META, {
                value: {
                  i: "O" + ++id,
                  w: {}
                }
              });
            };
            var fastKey = function fastKey2(it, create) {
              if (!isObject(it)) return (typeof it === "undefined" ? "undefined" : _typeof(it)) == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
              if (!has(it, META)) {
                if (!isExtensible(it)) return "F";
                if (!create) return "E";
                setMeta(it);
              }
              return it[META].i;
            };
            var getWeak = function getWeak2(it, create) {
              if (!has(it, META)) {
                if (!isExtensible(it)) return true;
                if (!create) return false;
                setMeta(it);
              }
              return it[META].w;
            };
            var onFreeze = function onFreeze2(it) {
              if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
              return it;
            };
            var meta = module3.exports = {
              KEY: META,
              NEED: false,
              fastKey,
              getWeak,
              onFreeze
            };
          },
          /* 97 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var getKeys = __w_pdfjs_require__(60);
            var gOPS = __w_pdfjs_require__(98);
            var pIE = __w_pdfjs_require__(99);
            var toObject = __w_pdfjs_require__(67);
            var IObject = __w_pdfjs_require__(38);
            var $assign = Object.assign;
            module3.exports = !$assign || __w_pdfjs_require__(17)(function() {
              var A = {};
              var B = {};
              var S = Symbol();
              var K = "abcdefghijklmnopqrst";
              A[S] = 7;
              K.split("").forEach(function(k) {
                B[k] = k;
              });
              return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join("") != K;
            }) ? function assign(target, source) {
              var T = toObject(target);
              var aLen = arguments.length;
              var index = 1;
              var getSymbols = gOPS.f;
              var isEnum = pIE.f;
              while (aLen > index) {
                var S = IObject(arguments[index++]);
                var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
                var length = keys.length;
                var j = 0;
                var key;
                while (length > j) {
                  if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
                }
              }
              return T;
            } : $assign;
          },
          /* 98 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            exports3.f = Object.getOwnPropertySymbols;
          },
          /* 99 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            exports3.f = {}.propertyIsEnumerable;
          },
          /* 100 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var redefineAll = __w_pdfjs_require__(85);
            var getWeak = __w_pdfjs_require__(96).getWeak;
            var anObject = __w_pdfjs_require__(13);
            var isObject = __w_pdfjs_require__(14);
            var anInstance = __w_pdfjs_require__(72);
            var forOf = __w_pdfjs_require__(73);
            var createArrayMethod = __w_pdfjs_require__(92);
            var $has = __w_pdfjs_require__(22);
            var validate = __w_pdfjs_require__(101);
            var arrayFind = createArrayMethod(5);
            var arrayFindIndex = createArrayMethod(6);
            var id = 0;
            var uncaughtFrozenStore = function uncaughtFrozenStore2(that) {
              return that._l || (that._l = new UncaughtFrozenStore());
            };
            var UncaughtFrozenStore = function UncaughtFrozenStore2() {
              this.a = [];
            };
            var findUncaughtFrozen = function findUncaughtFrozen2(store, key) {
              return arrayFind(store.a, function(it) {
                return it[0] === key;
              });
            };
            UncaughtFrozenStore.prototype = {
              get: function get(key) {
                var entry = findUncaughtFrozen(this, key);
                if (entry) return entry[1];
              },
              has: function has(key) {
                return !!findUncaughtFrozen(this, key);
              },
              set: function set(key, value) {
                var entry = findUncaughtFrozen(this, key);
                if (entry) entry[1] = value;
                else this.a.push([key, value]);
              },
              "delete": function _delete(key) {
                var index = arrayFindIndex(this.a, function(it) {
                  return it[0] === key;
                });
                if (~index) this.a.splice(index, 1);
                return !!~index;
              }
            };
            module3.exports = {
              getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
                var C = wrapper(function(that, iterable) {
                  anInstance(that, C, NAME, "_i");
                  that._t = NAME;
                  that._i = id++;
                  that._l = void 0;
                  if (iterable != void 0) forOf(iterable, IS_MAP, that[ADDER], that);
                });
                redefineAll(C.prototype, {
                  "delete": function _delete(key) {
                    if (!isObject(key)) return false;
                    var data = getWeak(key);
                    if (data === true) return uncaughtFrozenStore(validate(this, NAME))["delete"](key);
                    return data && $has(data, this._i) && delete data[this._i];
                  },
                  has: function has(key) {
                    if (!isObject(key)) return false;
                    var data = getWeak(key);
                    if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
                    return data && $has(data, this._i);
                  }
                });
                return C;
              },
              def: function def(that, key, value) {
                var data = getWeak(anObject(key), true);
                if (data === true) uncaughtFrozenStore(that).set(key, value);
                else data[that._i] = value;
                return that;
              },
              ufstore: uncaughtFrozenStore
            };
          },
          /* 101 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(14);
            module3.exports = function(it, TYPE) {
              if (!isObject(it) || it._t !== TYPE) throw TypeError("Incompatible receiver, " + TYPE + " required!");
              return it;
            };
          },
          /* 102 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var global2 = __w_pdfjs_require__(9);
            var $export = __w_pdfjs_require__(8);
            var redefine = __w_pdfjs_require__(21);
            var redefineAll = __w_pdfjs_require__(85);
            var meta = __w_pdfjs_require__(96);
            var forOf = __w_pdfjs_require__(73);
            var anInstance = __w_pdfjs_require__(72);
            var isObject = __w_pdfjs_require__(14);
            var fails = __w_pdfjs_require__(17);
            var $iterDetect = __w_pdfjs_require__(87);
            var setToStringTag = __w_pdfjs_require__(65);
            var inheritIfRequired = __w_pdfjs_require__(103);
            module3.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
              var Base = global2[NAME];
              var C = Base;
              var ADDER = IS_MAP ? "set" : "add";
              var proto = C && C.prototype;
              var O = {};
              var fixMethod = function fixMethod2(KEY) {
                var fn = proto[KEY];
                redefine(proto, KEY, KEY == "delete" ? function(a) {
                  return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
                } : KEY == "has" ? function has(a) {
                  return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
                } : KEY == "get" ? function get(a) {
                  return IS_WEAK && !isObject(a) ? void 0 : fn.call(this, a === 0 ? 0 : a);
                } : KEY == "add" ? function add(a) {
                  fn.call(this, a === 0 ? 0 : a);
                  return this;
                } : function set(a, b) {
                  fn.call(this, a === 0 ? 0 : a, b);
                  return this;
                });
              };
              if (typeof C != "function" || !(IS_WEAK || proto.forEach && !fails(function() {
                new C().entries().next();
              }))) {
                C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
                redefineAll(C.prototype, methods);
                meta.NEED = true;
              } else {
                var instance = new C();
                var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
                var THROWS_ON_PRIMITIVES = fails(function() {
                  instance.has(1);
                });
                var ACCEPT_ITERABLES = $iterDetect(function(iter) {
                  new C(iter);
                });
                var BUGGY_ZERO = !IS_WEAK && fails(function() {
                  var $instance = new C();
                  var index = 5;
                  while (index--) {
                    $instance[ADDER](index, index);
                  }
                  return !$instance.has(-0);
                });
                if (!ACCEPT_ITERABLES) {
                  C = wrapper(function(target, iterable) {
                    anInstance(target, C, NAME);
                    var that = inheritIfRequired(new Base(), target, C);
                    if (iterable != void 0) forOf(iterable, IS_MAP, that[ADDER], that);
                    return that;
                  });
                  C.prototype = proto;
                  proto.constructor = C;
                }
                if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
                  fixMethod("delete");
                  fixMethod("has");
                  IS_MAP && fixMethod("get");
                }
                if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
                if (IS_WEAK && proto.clear) delete proto.clear;
              }
              setToStringTag(C, NAME);
              O[NAME] = C;
              $export($export.G + $export.W + $export.F * (C != Base), O);
              if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
              return C;
            };
          },
          /* 103 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(14);
            var setPrototypeOf = __w_pdfjs_require__(104).set;
            module3.exports = function(that, target, C) {
              var S = target.constructor;
              var P;
              if (S !== C && typeof S == "function" && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
                setPrototypeOf(that, P);
              }
              return that;
            };
          },
          /* 104 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(14);
            var anObject = __w_pdfjs_require__(13);
            var check = function check2(O, proto) {
              anObject(O);
              if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
            };
            module3.exports = {
              set: Object.setPrototypeOf || ("__proto__" in {} ? function(test, buggy, set) {
                try {
                  set = __w_pdfjs_require__(24)(Function.call, __w_pdfjs_require__(105).f(Object.prototype, "__proto__").set, 2);
                  set(test, []);
                  buggy = !(test instanceof Array);
                } catch (e) {
                  buggy = true;
                }
                return function setPrototypeOf(O, proto) {
                  check(O, proto);
                  if (buggy) O.__proto__ = proto;
                  else set(O, proto);
                  return O;
                };
              }({}, false) : void 0),
              check
            };
          },
          /* 105 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var pIE = __w_pdfjs_require__(99);
            var createDesc = __w_pdfjs_require__(20);
            var toIObject = __w_pdfjs_require__(37);
            var toPrimitive = __w_pdfjs_require__(19);
            var has = __w_pdfjs_require__(22);
            var IE8_DOM_DEFINE = __w_pdfjs_require__(15);
            var gOPD = Object.getOwnPropertyDescriptor;
            exports3.f = __w_pdfjs_require__(16) ? gOPD : function getOwnPropertyDescriptor(O, P) {
              O = toIObject(O);
              P = toPrimitive(P, true);
              if (IE8_DOM_DEFINE) try {
                return gOPD(O, P);
              } catch (e) {
              }
              if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
            };
          },
          /* 106 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(107)("WeakMap");
          },
          /* 107 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(8);
            module3.exports = function(COLLECTION) {
              $export($export.S, COLLECTION, {
                of: function of() {
                  var length = arguments.length;
                  var A = new Array(length);
                  while (length--) {
                    A[length] = arguments[length];
                  }
                  return new this(A);
                }
              });
            };
          },
          /* 108 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(109)("WeakMap");
          },
          /* 109 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(8);
            var aFunction = __w_pdfjs_require__(25);
            var ctx = __w_pdfjs_require__(24);
            var forOf = __w_pdfjs_require__(73);
            module3.exports = function(COLLECTION) {
              $export($export.S, COLLECTION, {
                from: function from(source) {
                  var mapFn = arguments[1];
                  var mapping, A, n, cb;
                  aFunction(this);
                  mapping = mapFn !== void 0;
                  if (mapping) aFunction(mapFn);
                  if (source == void 0) return new this();
                  A = [];
                  if (mapping) {
                    n = 0;
                    cb = ctx(mapFn, arguments[2], 2);
                    forOf(source, false, function(nextItem) {
                      A.push(cb(nextItem, n++));
                    });
                  } else {
                    forOf(source, false, A.push, A);
                  }
                  return new this(A);
                }
              });
            };
          },
          /* 110 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(111);
            module3.exports = __w_pdfjs_require__(10).Object.values;
          },
          /* 111 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(8);
            var $values = __w_pdfjs_require__(112)(false);
            $export($export.S, "Object", {
              values: function values(it) {
                return $values(it);
              }
            });
          },
          /* 112 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var getKeys = __w_pdfjs_require__(60);
            var toIObject = __w_pdfjs_require__(37);
            var isEnum = __w_pdfjs_require__(99).f;
            module3.exports = function(isEntries) {
              return function(it) {
                var O = toIObject(it);
                var keys = getKeys(O);
                var length = keys.length;
                var i = 0;
                var result = [];
                var key;
                while (length > i) {
                  if (isEnum.call(O, key = keys[i++])) {
                    result.push(isEntries ? [key, O[key]] : O[key]);
                  }
                }
                return result;
              };
            };
          },
          /* 113 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isReadableStreamSupported = false;
            if (typeof ReadableStream !== "undefined") {
              try {
                new ReadableStream({
                  start: function start(controller) {
                    controller.close();
                  }
                });
                isReadableStreamSupported = true;
              } catch (e) {
              }
            }
            if (isReadableStreamSupported) {
              exports3.ReadableStream = ReadableStream;
            } else {
              exports3.ReadableStream = __w_pdfjs_require__(114).ReadableStream;
            }
          },
          /* 114 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            (function(e, a) {
              for (var i in a) {
                e[i] = a[i];
              }
            })(exports3, function(modules) {
              var installedModules = {};
              function __w_pdfjs_require__2(moduleId) {
                if (installedModules[moduleId]) return installedModules[moduleId].exports;
                var module4 = installedModules[moduleId] = {
                  i: moduleId,
                  l: false,
                  exports: {}
                };
                modules[moduleId].call(module4.exports, module4, module4.exports, __w_pdfjs_require__2);
                module4.l = true;
                return module4.exports;
              }
              __w_pdfjs_require__2.m = modules;
              __w_pdfjs_require__2.c = installedModules;
              __w_pdfjs_require__2.i = function(value) {
                return value;
              };
              __w_pdfjs_require__2.d = function(exports4, name, getter) {
                if (!__w_pdfjs_require__2.o(exports4, name)) {
                  Object.defineProperty(exports4, name, {
                    configurable: false,
                    enumerable: true,
                    get: getter
                  });
                }
              };
              __w_pdfjs_require__2.n = function(module4) {
                var getter = module4 && module4.__esModule ? function getDefault() {
                  return module4["default"];
                } : function getModuleExports() {
                  return module4;
                };
                __w_pdfjs_require__2.d(getter, "a", getter);
                return getter;
              };
              __w_pdfjs_require__2.o = function(object, property) {
                return Object.prototype.hasOwnProperty.call(object, property);
              };
              __w_pdfjs_require__2.p = "";
              return __w_pdfjs_require__2(__w_pdfjs_require__2.s = 7);
            }([function(module4, exports4, __w_pdfjs_require__2) {
              "use strict";
              var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function(obj) {
                return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
              } : function(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
              };
              var _require = __w_pdfjs_require__2(1), assert = _require.assert;
              function IsPropertyKey(argument) {
                return typeof argument === "string" || (typeof argument === "undefined" ? "undefined" : _typeof(argument)) === "symbol";
              }
              exports4.typeIsObject = function(x) {
                return (typeof x === "undefined" ? "undefined" : _typeof(x)) === "object" && x !== null || typeof x === "function";
              };
              exports4.createDataProperty = function(o, p, v) {
                assert(exports4.typeIsObject(o));
                Object.defineProperty(o, p, {
                  value: v,
                  writable: true,
                  enumerable: true,
                  configurable: true
                });
              };
              exports4.createArrayFromList = function(elements) {
                return elements.slice();
              };
              exports4.ArrayBufferCopy = function(dest, destOffset, src, srcOffset, n) {
                new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
              };
              exports4.CreateIterResultObject = function(value, done) {
                assert(typeof done === "boolean");
                var obj = {};
                Object.defineProperty(obj, "value", {
                  value,
                  enumerable: true,
                  writable: true,
                  configurable: true
                });
                Object.defineProperty(obj, "done", {
                  value: done,
                  enumerable: true,
                  writable: true,
                  configurable: true
                });
                return obj;
              };
              exports4.IsFiniteNonNegativeNumber = function(v) {
                if (Number.isNaN(v)) {
                  return false;
                }
                if (v === Infinity) {
                  return false;
                }
                if (v < 0) {
                  return false;
                }
                return true;
              };
              function Call(F, V, args) {
                if (typeof F !== "function") {
                  throw new TypeError("Argument is not a function");
                }
                return Function.prototype.apply.call(F, V, args);
              }
              exports4.InvokeOrNoop = function(O, P, args) {
                assert(O !== void 0);
                assert(IsPropertyKey(P));
                assert(Array.isArray(args));
                var method = O[P];
                if (method === void 0) {
                  return void 0;
                }
                return Call(method, O, args);
              };
              exports4.PromiseInvokeOrNoop = function(O, P, args) {
                assert(O !== void 0);
                assert(IsPropertyKey(P));
                assert(Array.isArray(args));
                try {
                  return Promise.resolve(exports4.InvokeOrNoop(O, P, args));
                } catch (returnValueE) {
                  return Promise.reject(returnValueE);
                }
              };
              exports4.PromiseInvokeOrPerformFallback = function(O, P, args, F, argsF) {
                assert(O !== void 0);
                assert(IsPropertyKey(P));
                assert(Array.isArray(args));
                assert(Array.isArray(argsF));
                var method = void 0;
                try {
                  method = O[P];
                } catch (methodE) {
                  return Promise.reject(methodE);
                }
                if (method === void 0) {
                  return F.apply(null, argsF);
                }
                try {
                  return Promise.resolve(Call(method, O, args));
                } catch (e) {
                  return Promise.reject(e);
                }
              };
              exports4.TransferArrayBuffer = function(O) {
                return O.slice();
              };
              exports4.ValidateAndNormalizeHighWaterMark = function(highWaterMark) {
                highWaterMark = Number(highWaterMark);
                if (Number.isNaN(highWaterMark) || highWaterMark < 0) {
                  throw new RangeError("highWaterMark property of a queuing strategy must be non-negative and non-NaN");
                }
                return highWaterMark;
              };
              exports4.ValidateAndNormalizeQueuingStrategy = function(size, highWaterMark) {
                if (size !== void 0 && typeof size !== "function") {
                  throw new TypeError("size property of a queuing strategy must be a function");
                }
                highWaterMark = exports4.ValidateAndNormalizeHighWaterMark(highWaterMark);
                return {
                  size,
                  highWaterMark
                };
              };
            }, function(module4, exports4, __w_pdfjs_require__2) {
              "use strict";
              function rethrowAssertionErrorRejection(e) {
                if (e && e.constructor === AssertionError) {
                  setTimeout(function() {
                    throw e;
                  }, 0);
                }
              }
              function AssertionError(message) {
                this.name = "AssertionError";
                this.message = message || "";
                this.stack = new Error().stack;
              }
              AssertionError.prototype = Object.create(Error.prototype);
              AssertionError.prototype.constructor = AssertionError;
              function assert(value, message) {
                if (!value) {
                  throw new AssertionError(message);
                }
              }
              module4.exports = {
                rethrowAssertionErrorRejection,
                AssertionError,
                assert
              };
            }, function(module4, exports4, __w_pdfjs_require__2) {
              "use strict";
              var _createClass = /* @__PURE__ */ function() {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function(Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var _require = __w_pdfjs_require__2(0), InvokeOrNoop = _require.InvokeOrNoop, PromiseInvokeOrNoop = _require.PromiseInvokeOrNoop, ValidateAndNormalizeQueuingStrategy = _require.ValidateAndNormalizeQueuingStrategy, typeIsObject = _require.typeIsObject;
              var _require2 = __w_pdfjs_require__2(1), assert = _require2.assert, rethrowAssertionErrorRejection = _require2.rethrowAssertionErrorRejection;
              var _require3 = __w_pdfjs_require__2(3), DequeueValue = _require3.DequeueValue, EnqueueValueWithSize = _require3.EnqueueValueWithSize, PeekQueueValue = _require3.PeekQueueValue, ResetQueue = _require3.ResetQueue;
              var WritableStream = function() {
                function WritableStream2() {
                  var underlyingSink = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, size = _ref.size, _ref$highWaterMark = _ref.highWaterMark, highWaterMark = _ref$highWaterMark === void 0 ? 1 : _ref$highWaterMark;
                  _classCallCheck(this, WritableStream2);
                  this._state = "writable";
                  this._storedError = void 0;
                  this._writer = void 0;
                  this._writableStreamController = void 0;
                  this._writeRequests = [];
                  this._inFlightWriteRequest = void 0;
                  this._closeRequest = void 0;
                  this._inFlightCloseRequest = void 0;
                  this._pendingAbortRequest = void 0;
                  this._backpressure = false;
                  var type = underlyingSink.type;
                  if (type !== void 0) {
                    throw new RangeError("Invalid type is specified");
                  }
                  this._writableStreamController = new WritableStreamDefaultController(this, underlyingSink, size, highWaterMark);
                  this._writableStreamController.__startSteps();
                }
                _createClass(WritableStream2, [{
                  key: "abort",
                  value: function abort(reason) {
                    if (IsWritableStream(this) === false) {
                      return Promise.reject(streamBrandCheckException("abort"));
                    }
                    if (IsWritableStreamLocked(this) === true) {
                      return Promise.reject(new TypeError("Cannot abort a stream that already has a writer"));
                    }
                    return WritableStreamAbort(this, reason);
                  }
                }, {
                  key: "getWriter",
                  value: function getWriter() {
                    if (IsWritableStream(this) === false) {
                      throw streamBrandCheckException("getWriter");
                    }
                    return AcquireWritableStreamDefaultWriter(this);
                  }
                }, {
                  key: "locked",
                  get: function get() {
                    if (IsWritableStream(this) === false) {
                      throw streamBrandCheckException("locked");
                    }
                    return IsWritableStreamLocked(this);
                  }
                }]);
                return WritableStream2;
              }();
              module4.exports = {
                AcquireWritableStreamDefaultWriter,
                IsWritableStream,
                IsWritableStreamLocked,
                WritableStream,
                WritableStreamAbort,
                WritableStreamDefaultControllerError,
                WritableStreamDefaultWriterCloseWithErrorPropagation,
                WritableStreamDefaultWriterRelease,
                WritableStreamDefaultWriterWrite,
                WritableStreamCloseQueuedOrInFlight
              };
              function AcquireWritableStreamDefaultWriter(stream2) {
                return new WritableStreamDefaultWriter(stream2);
              }
              function IsWritableStream(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
                  return false;
                }
                return true;
              }
              function IsWritableStreamLocked(stream2) {
                assert(IsWritableStream(stream2) === true, "IsWritableStreamLocked should only be used on known writable streams");
                if (stream2._writer === void 0) {
                  return false;
                }
                return true;
              }
              function WritableStreamAbort(stream2, reason) {
                var state = stream2._state;
                if (state === "closed") {
                  return Promise.resolve(void 0);
                }
                if (state === "errored") {
                  return Promise.reject(stream2._storedError);
                }
                var error = new TypeError("Requested to abort");
                if (stream2._pendingAbortRequest !== void 0) {
                  return Promise.reject(error);
                }
                assert(state === "writable" || state === "erroring", "state must be writable or erroring");
                var wasAlreadyErroring = false;
                if (state === "erroring") {
                  wasAlreadyErroring = true;
                  reason = void 0;
                }
                var promise = new Promise(function(resolve2, reject2) {
                  stream2._pendingAbortRequest = {
                    _resolve: resolve2,
                    _reject: reject2,
                    _reason: reason,
                    _wasAlreadyErroring: wasAlreadyErroring
                  };
                });
                if (wasAlreadyErroring === false) {
                  WritableStreamStartErroring(stream2, error);
                }
                return promise;
              }
              function WritableStreamAddWriteRequest(stream2) {
                assert(IsWritableStreamLocked(stream2) === true);
                assert(stream2._state === "writable");
                var promise = new Promise(function(resolve2, reject2) {
                  var writeRequest = {
                    _resolve: resolve2,
                    _reject: reject2
                  };
                  stream2._writeRequests.push(writeRequest);
                });
                return promise;
              }
              function WritableStreamDealWithRejection(stream2, error) {
                var state = stream2._state;
                if (state === "writable") {
                  WritableStreamStartErroring(stream2, error);
                  return;
                }
                assert(state === "erroring");
                WritableStreamFinishErroring(stream2);
              }
              function WritableStreamStartErroring(stream2, reason) {
                assert(stream2._storedError === void 0, "stream._storedError === undefined");
                assert(stream2._state === "writable", "state must be writable");
                var controller = stream2._writableStreamController;
                assert(controller !== void 0, "controller must not be undefined");
                stream2._state = "erroring";
                stream2._storedError = reason;
                var writer = stream2._writer;
                if (writer !== void 0) {
                  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
                }
                if (WritableStreamHasOperationMarkedInFlight(stream2) === false && controller._started === true) {
                  WritableStreamFinishErroring(stream2);
                }
              }
              function WritableStreamFinishErroring(stream2) {
                assert(stream2._state === "erroring", "stream._state === erroring");
                assert(WritableStreamHasOperationMarkedInFlight(stream2) === false, "WritableStreamHasOperationMarkedInFlight(stream) === false");
                stream2._state = "errored";
                stream2._writableStreamController.__errorSteps();
                var storedError = stream2._storedError;
                for (var i = 0; i < stream2._writeRequests.length; i++) {
                  var writeRequest = stream2._writeRequests[i];
                  writeRequest._reject(storedError);
                }
                stream2._writeRequests = [];
                if (stream2._pendingAbortRequest === void 0) {
                  WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream2);
                  return;
                }
                var abortRequest = stream2._pendingAbortRequest;
                stream2._pendingAbortRequest = void 0;
                if (abortRequest._wasAlreadyErroring === true) {
                  abortRequest._reject(storedError);
                  WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream2);
                  return;
                }
                var promise = stream2._writableStreamController.__abortSteps(abortRequest._reason);
                promise.then(function() {
                  abortRequest._resolve();
                  WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream2);
                }, function(reason) {
                  abortRequest._reject(reason);
                  WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream2);
                });
              }
              function WritableStreamFinishInFlightWrite(stream2) {
                assert(stream2._inFlightWriteRequest !== void 0);
                stream2._inFlightWriteRequest._resolve(void 0);
                stream2._inFlightWriteRequest = void 0;
              }
              function WritableStreamFinishInFlightWriteWithError(stream2, error) {
                assert(stream2._inFlightWriteRequest !== void 0);
                stream2._inFlightWriteRequest._reject(error);
                stream2._inFlightWriteRequest = void 0;
                assert(stream2._state === "writable" || stream2._state === "erroring");
                WritableStreamDealWithRejection(stream2, error);
              }
              function WritableStreamFinishInFlightClose(stream2) {
                assert(stream2._inFlightCloseRequest !== void 0);
                stream2._inFlightCloseRequest._resolve(void 0);
                stream2._inFlightCloseRequest = void 0;
                var state = stream2._state;
                assert(state === "writable" || state === "erroring");
                if (state === "erroring") {
                  stream2._storedError = void 0;
                  if (stream2._pendingAbortRequest !== void 0) {
                    stream2._pendingAbortRequest._resolve();
                    stream2._pendingAbortRequest = void 0;
                  }
                }
                stream2._state = "closed";
                var writer = stream2._writer;
                if (writer !== void 0) {
                  defaultWriterClosedPromiseResolve(writer);
                }
                assert(stream2._pendingAbortRequest === void 0, "stream._pendingAbortRequest === undefined");
                assert(stream2._storedError === void 0, "stream._storedError === undefined");
              }
              function WritableStreamFinishInFlightCloseWithError(stream2, error) {
                assert(stream2._inFlightCloseRequest !== void 0);
                stream2._inFlightCloseRequest._reject(error);
                stream2._inFlightCloseRequest = void 0;
                assert(stream2._state === "writable" || stream2._state === "erroring");
                if (stream2._pendingAbortRequest !== void 0) {
                  stream2._pendingAbortRequest._reject(error);
                  stream2._pendingAbortRequest = void 0;
                }
                WritableStreamDealWithRejection(stream2, error);
              }
              function WritableStreamCloseQueuedOrInFlight(stream2) {
                if (stream2._closeRequest === void 0 && stream2._inFlightCloseRequest === void 0) {
                  return false;
                }
                return true;
              }
              function WritableStreamHasOperationMarkedInFlight(stream2) {
                if (stream2._inFlightWriteRequest === void 0 && stream2._inFlightCloseRequest === void 0) {
                  return false;
                }
                return true;
              }
              function WritableStreamMarkCloseRequestInFlight(stream2) {
                assert(stream2._inFlightCloseRequest === void 0);
                assert(stream2._closeRequest !== void 0);
                stream2._inFlightCloseRequest = stream2._closeRequest;
                stream2._closeRequest = void 0;
              }
              function WritableStreamMarkFirstWriteRequestInFlight(stream2) {
                assert(stream2._inFlightWriteRequest === void 0, "there must be no pending write request");
                assert(stream2._writeRequests.length !== 0, "writeRequests must not be empty");
                stream2._inFlightWriteRequest = stream2._writeRequests.shift();
              }
              function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream2) {
                assert(stream2._state === "errored", '_stream_.[[state]] is `"errored"`');
                if (stream2._closeRequest !== void 0) {
                  assert(stream2._inFlightCloseRequest === void 0);
                  stream2._closeRequest._reject(stream2._storedError);
                  stream2._closeRequest = void 0;
                }
                var writer = stream2._writer;
                if (writer !== void 0) {
                  defaultWriterClosedPromiseReject(writer, stream2._storedError);
                  writer._closedPromise.catch(function() {
                  });
                }
              }
              function WritableStreamUpdateBackpressure(stream2, backpressure) {
                assert(stream2._state === "writable");
                assert(WritableStreamCloseQueuedOrInFlight(stream2) === false);
                var writer = stream2._writer;
                if (writer !== void 0 && backpressure !== stream2._backpressure) {
                  if (backpressure === true) {
                    defaultWriterReadyPromiseReset(writer);
                  } else {
                    assert(backpressure === false);
                    defaultWriterReadyPromiseResolve(writer);
                  }
                }
                stream2._backpressure = backpressure;
              }
              var WritableStreamDefaultWriter = function() {
                function WritableStreamDefaultWriter2(stream2) {
                  _classCallCheck(this, WritableStreamDefaultWriter2);
                  if (IsWritableStream(stream2) === false) {
                    throw new TypeError("WritableStreamDefaultWriter can only be constructed with a WritableStream instance");
                  }
                  if (IsWritableStreamLocked(stream2) === true) {
                    throw new TypeError("This stream has already been locked for exclusive writing by another writer");
                  }
                  this._ownerWritableStream = stream2;
                  stream2._writer = this;
                  var state = stream2._state;
                  if (state === "writable") {
                    if (WritableStreamCloseQueuedOrInFlight(stream2) === false && stream2._backpressure === true) {
                      defaultWriterReadyPromiseInitialize(this);
                    } else {
                      defaultWriterReadyPromiseInitializeAsResolved(this);
                    }
                    defaultWriterClosedPromiseInitialize(this);
                  } else if (state === "erroring") {
                    defaultWriterReadyPromiseInitializeAsRejected(this, stream2._storedError);
                    this._readyPromise.catch(function() {
                    });
                    defaultWriterClosedPromiseInitialize(this);
                  } else if (state === "closed") {
                    defaultWriterReadyPromiseInitializeAsResolved(this);
                    defaultWriterClosedPromiseInitializeAsResolved(this);
                  } else {
                    assert(state === "errored", "state must be errored");
                    var storedError = stream2._storedError;
                    defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
                    this._readyPromise.catch(function() {
                    });
                    defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
                    this._closedPromise.catch(function() {
                    });
                  }
                }
                _createClass(WritableStreamDefaultWriter2, [{
                  key: "abort",
                  value: function abort(reason) {
                    if (IsWritableStreamDefaultWriter(this) === false) {
                      return Promise.reject(defaultWriterBrandCheckException("abort"));
                    }
                    if (this._ownerWritableStream === void 0) {
                      return Promise.reject(defaultWriterLockException("abort"));
                    }
                    return WritableStreamDefaultWriterAbort(this, reason);
                  }
                }, {
                  key: "close",
                  value: function close() {
                    if (IsWritableStreamDefaultWriter(this) === false) {
                      return Promise.reject(defaultWriterBrandCheckException("close"));
                    }
                    var stream2 = this._ownerWritableStream;
                    if (stream2 === void 0) {
                      return Promise.reject(defaultWriterLockException("close"));
                    }
                    if (WritableStreamCloseQueuedOrInFlight(stream2) === true) {
                      return Promise.reject(new TypeError("cannot close an already-closing stream"));
                    }
                    return WritableStreamDefaultWriterClose(this);
                  }
                }, {
                  key: "releaseLock",
                  value: function releaseLock() {
                    if (IsWritableStreamDefaultWriter(this) === false) {
                      throw defaultWriterBrandCheckException("releaseLock");
                    }
                    var stream2 = this._ownerWritableStream;
                    if (stream2 === void 0) {
                      return;
                    }
                    assert(stream2._writer !== void 0);
                    WritableStreamDefaultWriterRelease(this);
                  }
                }, {
                  key: "write",
                  value: function write(chunk) {
                    if (IsWritableStreamDefaultWriter(this) === false) {
                      return Promise.reject(defaultWriterBrandCheckException("write"));
                    }
                    if (this._ownerWritableStream === void 0) {
                      return Promise.reject(defaultWriterLockException("write to"));
                    }
                    return WritableStreamDefaultWriterWrite(this, chunk);
                  }
                }, {
                  key: "closed",
                  get: function get() {
                    if (IsWritableStreamDefaultWriter(this) === false) {
                      return Promise.reject(defaultWriterBrandCheckException("closed"));
                    }
                    return this._closedPromise;
                  }
                }, {
                  key: "desiredSize",
                  get: function get() {
                    if (IsWritableStreamDefaultWriter(this) === false) {
                      throw defaultWriterBrandCheckException("desiredSize");
                    }
                    if (this._ownerWritableStream === void 0) {
                      throw defaultWriterLockException("desiredSize");
                    }
                    return WritableStreamDefaultWriterGetDesiredSize(this);
                  }
                }, {
                  key: "ready",
                  get: function get() {
                    if (IsWritableStreamDefaultWriter(this) === false) {
                      return Promise.reject(defaultWriterBrandCheckException("ready"));
                    }
                    return this._readyPromise;
                  }
                }]);
                return WritableStreamDefaultWriter2;
              }();
              function IsWritableStreamDefaultWriter(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
                  return false;
                }
                return true;
              }
              function WritableStreamDefaultWriterAbort(writer, reason) {
                var stream2 = writer._ownerWritableStream;
                assert(stream2 !== void 0);
                return WritableStreamAbort(stream2, reason);
              }
              function WritableStreamDefaultWriterClose(writer) {
                var stream2 = writer._ownerWritableStream;
                assert(stream2 !== void 0);
                var state = stream2._state;
                if (state === "closed" || state === "errored") {
                  return Promise.reject(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed"));
                }
                assert(state === "writable" || state === "erroring");
                assert(WritableStreamCloseQueuedOrInFlight(stream2) === false);
                var promise = new Promise(function(resolve2, reject2) {
                  var closeRequest = {
                    _resolve: resolve2,
                    _reject: reject2
                  };
                  stream2._closeRequest = closeRequest;
                });
                if (stream2._backpressure === true && state === "writable") {
                  defaultWriterReadyPromiseResolve(writer);
                }
                WritableStreamDefaultControllerClose(stream2._writableStreamController);
                return promise;
              }
              function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
                var stream2 = writer._ownerWritableStream;
                assert(stream2 !== void 0);
                var state = stream2._state;
                if (WritableStreamCloseQueuedOrInFlight(stream2) === true || state === "closed") {
                  return Promise.resolve();
                }
                if (state === "errored") {
                  return Promise.reject(stream2._storedError);
                }
                assert(state === "writable" || state === "erroring");
                return WritableStreamDefaultWriterClose(writer);
              }
              function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
                if (writer._closedPromiseState === "pending") {
                  defaultWriterClosedPromiseReject(writer, error);
                } else {
                  defaultWriterClosedPromiseResetToRejected(writer, error);
                }
                writer._closedPromise.catch(function() {
                });
              }
              function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
                if (writer._readyPromiseState === "pending") {
                  defaultWriterReadyPromiseReject(writer, error);
                } else {
                  defaultWriterReadyPromiseResetToRejected(writer, error);
                }
                writer._readyPromise.catch(function() {
                });
              }
              function WritableStreamDefaultWriterGetDesiredSize(writer) {
                var stream2 = writer._ownerWritableStream;
                var state = stream2._state;
                if (state === "errored" || state === "erroring") {
                  return null;
                }
                if (state === "closed") {
                  return 0;
                }
                return WritableStreamDefaultControllerGetDesiredSize(stream2._writableStreamController);
              }
              function WritableStreamDefaultWriterRelease(writer) {
                var stream2 = writer._ownerWritableStream;
                assert(stream2 !== void 0);
                assert(stream2._writer === writer);
                var releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
                WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
                WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
                stream2._writer = void 0;
                writer._ownerWritableStream = void 0;
              }
              function WritableStreamDefaultWriterWrite(writer, chunk) {
                var stream2 = writer._ownerWritableStream;
                assert(stream2 !== void 0);
                var controller = stream2._writableStreamController;
                var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
                if (stream2 !== writer._ownerWritableStream) {
                  return Promise.reject(defaultWriterLockException("write to"));
                }
                var state = stream2._state;
                if (state === "errored") {
                  return Promise.reject(stream2._storedError);
                }
                if (WritableStreamCloseQueuedOrInFlight(stream2) === true || state === "closed") {
                  return Promise.reject(new TypeError("The stream is closing or closed and cannot be written to"));
                }
                if (state === "erroring") {
                  return Promise.reject(stream2._storedError);
                }
                assert(state === "writable");
                var promise = WritableStreamAddWriteRequest(stream2);
                WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
                return promise;
              }
              var WritableStreamDefaultController = function() {
                function WritableStreamDefaultController2(stream2, underlyingSink, size, highWaterMark) {
                  _classCallCheck(this, WritableStreamDefaultController2);
                  if (IsWritableStream(stream2) === false) {
                    throw new TypeError("WritableStreamDefaultController can only be constructed with a WritableStream instance");
                  }
                  if (stream2._writableStreamController !== void 0) {
                    throw new TypeError("WritableStreamDefaultController instances can only be created by the WritableStream constructor");
                  }
                  this._controlledWritableStream = stream2;
                  this._underlyingSink = underlyingSink;
                  this._queue = void 0;
                  this._queueTotalSize = void 0;
                  ResetQueue(this);
                  this._started = false;
                  var normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
                  this._strategySize = normalizedStrategy.size;
                  this._strategyHWM = normalizedStrategy.highWaterMark;
                  var backpressure = WritableStreamDefaultControllerGetBackpressure(this);
                  WritableStreamUpdateBackpressure(stream2, backpressure);
                }
                _createClass(WritableStreamDefaultController2, [{
                  key: "error",
                  value: function error(e) {
                    if (IsWritableStreamDefaultController(this) === false) {
                      throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");
                    }
                    var state = this._controlledWritableStream._state;
                    if (state !== "writable") {
                      return;
                    }
                    WritableStreamDefaultControllerError(this, e);
                  }
                }, {
                  key: "__abortSteps",
                  value: function __abortSteps(reason) {
                    return PromiseInvokeOrNoop(this._underlyingSink, "abort", [reason]);
                  }
                }, {
                  key: "__errorSteps",
                  value: function __errorSteps() {
                    ResetQueue(this);
                  }
                }, {
                  key: "__startSteps",
                  value: function __startSteps() {
                    var _this = this;
                    var startResult = InvokeOrNoop(this._underlyingSink, "start", [this]);
                    var stream2 = this._controlledWritableStream;
                    Promise.resolve(startResult).then(function() {
                      assert(stream2._state === "writable" || stream2._state === "erroring");
                      _this._started = true;
                      WritableStreamDefaultControllerAdvanceQueueIfNeeded(_this);
                    }, function(r) {
                      assert(stream2._state === "writable" || stream2._state === "erroring");
                      _this._started = true;
                      WritableStreamDealWithRejection(stream2, r);
                    }).catch(rethrowAssertionErrorRejection);
                  }
                }]);
                return WritableStreamDefaultController2;
              }();
              function WritableStreamDefaultControllerClose(controller) {
                EnqueueValueWithSize(controller, "close", 0);
                WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
              }
              function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
                var strategySize = controller._strategySize;
                if (strategySize === void 0) {
                  return 1;
                }
                try {
                  return strategySize(chunk);
                } catch (chunkSizeE) {
                  WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
                  return 1;
                }
              }
              function WritableStreamDefaultControllerGetDesiredSize(controller) {
                return controller._strategyHWM - controller._queueTotalSize;
              }
              function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
                var writeRecord = { chunk };
                try {
                  EnqueueValueWithSize(controller, writeRecord, chunkSize);
                } catch (enqueueE) {
                  WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
                  return;
                }
                var stream2 = controller._controlledWritableStream;
                if (WritableStreamCloseQueuedOrInFlight(stream2) === false && stream2._state === "writable") {
                  var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
                  WritableStreamUpdateBackpressure(stream2, backpressure);
                }
                WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
              }
              function IsWritableStreamDefaultController(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_underlyingSink")) {
                  return false;
                }
                return true;
              }
              function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
                var stream2 = controller._controlledWritableStream;
                if (controller._started === false) {
                  return;
                }
                if (stream2._inFlightWriteRequest !== void 0) {
                  return;
                }
                var state = stream2._state;
                if (state === "closed" || state === "errored") {
                  return;
                }
                if (state === "erroring") {
                  WritableStreamFinishErroring(stream2);
                  return;
                }
                if (controller._queue.length === 0) {
                  return;
                }
                var writeRecord = PeekQueueValue(controller);
                if (writeRecord === "close") {
                  WritableStreamDefaultControllerProcessClose(controller);
                } else {
                  WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);
                }
              }
              function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
                if (controller._controlledWritableStream._state === "writable") {
                  WritableStreamDefaultControllerError(controller, error);
                }
              }
              function WritableStreamDefaultControllerProcessClose(controller) {
                var stream2 = controller._controlledWritableStream;
                WritableStreamMarkCloseRequestInFlight(stream2);
                DequeueValue(controller);
                assert(controller._queue.length === 0, "queue must be empty once the final write record is dequeued");
                var sinkClosePromise = PromiseInvokeOrNoop(controller._underlyingSink, "close", []);
                sinkClosePromise.then(function() {
                  WritableStreamFinishInFlightClose(stream2);
                }, function(reason) {
                  WritableStreamFinishInFlightCloseWithError(stream2, reason);
                }).catch(rethrowAssertionErrorRejection);
              }
              function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
                var stream2 = controller._controlledWritableStream;
                WritableStreamMarkFirstWriteRequestInFlight(stream2);
                var sinkWritePromise = PromiseInvokeOrNoop(controller._underlyingSink, "write", [chunk, controller]);
                sinkWritePromise.then(function() {
                  WritableStreamFinishInFlightWrite(stream2);
                  var state = stream2._state;
                  assert(state === "writable" || state === "erroring");
                  DequeueValue(controller);
                  if (WritableStreamCloseQueuedOrInFlight(stream2) === false && state === "writable") {
                    var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
                    WritableStreamUpdateBackpressure(stream2, backpressure);
                  }
                  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
                }, function(reason) {
                  WritableStreamFinishInFlightWriteWithError(stream2, reason);
                }).catch(rethrowAssertionErrorRejection);
              }
              function WritableStreamDefaultControllerGetBackpressure(controller) {
                var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
                return desiredSize <= 0;
              }
              function WritableStreamDefaultControllerError(controller, error) {
                var stream2 = controller._controlledWritableStream;
                assert(stream2._state === "writable");
                WritableStreamStartErroring(stream2, error);
              }
              function streamBrandCheckException(name) {
                return new TypeError("WritableStream.prototype." + name + " can only be used on a WritableStream");
              }
              function defaultWriterBrandCheckException(name) {
                return new TypeError("WritableStreamDefaultWriter.prototype." + name + " can only be used on a WritableStreamDefaultWriter");
              }
              function defaultWriterLockException(name) {
                return new TypeError("Cannot " + name + " a stream using a released writer");
              }
              function defaultWriterClosedPromiseInitialize(writer) {
                writer._closedPromise = new Promise(function(resolve2, reject2) {
                  writer._closedPromise_resolve = resolve2;
                  writer._closedPromise_reject = reject2;
                  writer._closedPromiseState = "pending";
                });
              }
              function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
                writer._closedPromise = Promise.reject(reason);
                writer._closedPromise_resolve = void 0;
                writer._closedPromise_reject = void 0;
                writer._closedPromiseState = "rejected";
              }
              function defaultWriterClosedPromiseInitializeAsResolved(writer) {
                writer._closedPromise = Promise.resolve(void 0);
                writer._closedPromise_resolve = void 0;
                writer._closedPromise_reject = void 0;
                writer._closedPromiseState = "resolved";
              }
              function defaultWriterClosedPromiseReject(writer, reason) {
                assert(writer._closedPromise_resolve !== void 0, "writer._closedPromise_resolve !== undefined");
                assert(writer._closedPromise_reject !== void 0, "writer._closedPromise_reject !== undefined");
                assert(writer._closedPromiseState === "pending", "writer._closedPromiseState is pending");
                writer._closedPromise_reject(reason);
                writer._closedPromise_resolve = void 0;
                writer._closedPromise_reject = void 0;
                writer._closedPromiseState = "rejected";
              }
              function defaultWriterClosedPromiseResetToRejected(writer, reason) {
                assert(writer._closedPromise_resolve === void 0, "writer._closedPromise_resolve === undefined");
                assert(writer._closedPromise_reject === void 0, "writer._closedPromise_reject === undefined");
                assert(writer._closedPromiseState !== "pending", "writer._closedPromiseState is not pending");
                writer._closedPromise = Promise.reject(reason);
                writer._closedPromiseState = "rejected";
              }
              function defaultWriterClosedPromiseResolve(writer) {
                assert(writer._closedPromise_resolve !== void 0, "writer._closedPromise_resolve !== undefined");
                assert(writer._closedPromise_reject !== void 0, "writer._closedPromise_reject !== undefined");
                assert(writer._closedPromiseState === "pending", "writer._closedPromiseState is pending");
                writer._closedPromise_resolve(void 0);
                writer._closedPromise_resolve = void 0;
                writer._closedPromise_reject = void 0;
                writer._closedPromiseState = "resolved";
              }
              function defaultWriterReadyPromiseInitialize(writer) {
                writer._readyPromise = new Promise(function(resolve2, reject2) {
                  writer._readyPromise_resolve = resolve2;
                  writer._readyPromise_reject = reject2;
                });
                writer._readyPromiseState = "pending";
              }
              function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
                writer._readyPromise = Promise.reject(reason);
                writer._readyPromise_resolve = void 0;
                writer._readyPromise_reject = void 0;
                writer._readyPromiseState = "rejected";
              }
              function defaultWriterReadyPromiseInitializeAsResolved(writer) {
                writer._readyPromise = Promise.resolve(void 0);
                writer._readyPromise_resolve = void 0;
                writer._readyPromise_reject = void 0;
                writer._readyPromiseState = "fulfilled";
              }
              function defaultWriterReadyPromiseReject(writer, reason) {
                assert(writer._readyPromise_resolve !== void 0, "writer._readyPromise_resolve !== undefined");
                assert(writer._readyPromise_reject !== void 0, "writer._readyPromise_reject !== undefined");
                writer._readyPromise_reject(reason);
                writer._readyPromise_resolve = void 0;
                writer._readyPromise_reject = void 0;
                writer._readyPromiseState = "rejected";
              }
              function defaultWriterReadyPromiseReset(writer) {
                assert(writer._readyPromise_resolve === void 0, "writer._readyPromise_resolve === undefined");
                assert(writer._readyPromise_reject === void 0, "writer._readyPromise_reject === undefined");
                writer._readyPromise = new Promise(function(resolve2, reject2) {
                  writer._readyPromise_resolve = resolve2;
                  writer._readyPromise_reject = reject2;
                });
                writer._readyPromiseState = "pending";
              }
              function defaultWriterReadyPromiseResetToRejected(writer, reason) {
                assert(writer._readyPromise_resolve === void 0, "writer._readyPromise_resolve === undefined");
                assert(writer._readyPromise_reject === void 0, "writer._readyPromise_reject === undefined");
                writer._readyPromise = Promise.reject(reason);
                writer._readyPromiseState = "rejected";
              }
              function defaultWriterReadyPromiseResolve(writer) {
                assert(writer._readyPromise_resolve !== void 0, "writer._readyPromise_resolve !== undefined");
                assert(writer._readyPromise_reject !== void 0, "writer._readyPromise_reject !== undefined");
                writer._readyPromise_resolve(void 0);
                writer._readyPromise_resolve = void 0;
                writer._readyPromise_reject = void 0;
                writer._readyPromiseState = "fulfilled";
              }
            }, function(module4, exports4, __w_pdfjs_require__2) {
              "use strict";
              var _require = __w_pdfjs_require__2(0), IsFiniteNonNegativeNumber = _require.IsFiniteNonNegativeNumber;
              var _require2 = __w_pdfjs_require__2(1), assert = _require2.assert;
              exports4.DequeueValue = function(container) {
                assert("_queue" in container && "_queueTotalSize" in container, "Spec-level failure: DequeueValue should only be used on containers with [[queue]] and [[queueTotalSize]].");
                assert(container._queue.length > 0, "Spec-level failure: should never dequeue from an empty queue.");
                var pair = container._queue.shift();
                container._queueTotalSize -= pair.size;
                if (container._queueTotalSize < 0) {
                  container._queueTotalSize = 0;
                }
                return pair.value;
              };
              exports4.EnqueueValueWithSize = function(container, value, size) {
                assert("_queue" in container && "_queueTotalSize" in container, "Spec-level failure: EnqueueValueWithSize should only be used on containers with [[queue]] and [[queueTotalSize]].");
                size = Number(size);
                if (!IsFiniteNonNegativeNumber(size)) {
                  throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
                }
                container._queue.push({
                  value,
                  size
                });
                container._queueTotalSize += size;
              };
              exports4.PeekQueueValue = function(container) {
                assert("_queue" in container && "_queueTotalSize" in container, "Spec-level failure: PeekQueueValue should only be used on containers with [[queue]] and [[queueTotalSize]].");
                assert(container._queue.length > 0, "Spec-level failure: should never peek at an empty queue.");
                var pair = container._queue[0];
                return pair.value;
              };
              exports4.ResetQueue = function(container) {
                assert("_queue" in container && "_queueTotalSize" in container, "Spec-level failure: ResetQueue should only be used on containers with [[queue]] and [[queueTotalSize]].");
                container._queue = [];
                container._queueTotalSize = 0;
              };
            }, function(module4, exports4, __w_pdfjs_require__2) {
              "use strict";
              var _createClass = /* @__PURE__ */ function() {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function(Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var _require = __w_pdfjs_require__2(0), ArrayBufferCopy = _require.ArrayBufferCopy, CreateIterResultObject = _require.CreateIterResultObject, IsFiniteNonNegativeNumber = _require.IsFiniteNonNegativeNumber, InvokeOrNoop = _require.InvokeOrNoop, PromiseInvokeOrNoop = _require.PromiseInvokeOrNoop, TransferArrayBuffer = _require.TransferArrayBuffer, ValidateAndNormalizeQueuingStrategy = _require.ValidateAndNormalizeQueuingStrategy, ValidateAndNormalizeHighWaterMark = _require.ValidateAndNormalizeHighWaterMark;
              var _require2 = __w_pdfjs_require__2(0), createArrayFromList = _require2.createArrayFromList, createDataProperty = _require2.createDataProperty, typeIsObject = _require2.typeIsObject;
              var _require3 = __w_pdfjs_require__2(1), assert = _require3.assert, rethrowAssertionErrorRejection = _require3.rethrowAssertionErrorRejection;
              var _require4 = __w_pdfjs_require__2(3), DequeueValue = _require4.DequeueValue, EnqueueValueWithSize = _require4.EnqueueValueWithSize, ResetQueue = _require4.ResetQueue;
              var _require5 = __w_pdfjs_require__2(2), AcquireWritableStreamDefaultWriter = _require5.AcquireWritableStreamDefaultWriter, IsWritableStream = _require5.IsWritableStream, IsWritableStreamLocked = _require5.IsWritableStreamLocked, WritableStreamAbort = _require5.WritableStreamAbort, WritableStreamDefaultWriterCloseWithErrorPropagation = _require5.WritableStreamDefaultWriterCloseWithErrorPropagation, WritableStreamDefaultWriterRelease = _require5.WritableStreamDefaultWriterRelease, WritableStreamDefaultWriterWrite = _require5.WritableStreamDefaultWriterWrite, WritableStreamCloseQueuedOrInFlight = _require5.WritableStreamCloseQueuedOrInFlight;
              var ReadableStream2 = function() {
                function ReadableStream3() {
                  var underlyingSource = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, size = _ref.size, highWaterMark = _ref.highWaterMark;
                  _classCallCheck(this, ReadableStream3);
                  this._state = "readable";
                  this._reader = void 0;
                  this._storedError = void 0;
                  this._disturbed = false;
                  this._readableStreamController = void 0;
                  var type = underlyingSource.type;
                  var typeString = String(type);
                  if (typeString === "bytes") {
                    if (highWaterMark === void 0) {
                      highWaterMark = 0;
                    }
                    this._readableStreamController = new ReadableByteStreamController(this, underlyingSource, highWaterMark);
                  } else if (type === void 0) {
                    if (highWaterMark === void 0) {
                      highWaterMark = 1;
                    }
                    this._readableStreamController = new ReadableStreamDefaultController(this, underlyingSource, size, highWaterMark);
                  } else {
                    throw new RangeError("Invalid type is specified");
                  }
                }
                _createClass(ReadableStream3, [{
                  key: "cancel",
                  value: function cancel(reason) {
                    if (IsReadableStream(this) === false) {
                      return Promise.reject(streamBrandCheckException("cancel"));
                    }
                    if (IsReadableStreamLocked(this) === true) {
                      return Promise.reject(new TypeError("Cannot cancel a stream that already has a reader"));
                    }
                    return ReadableStreamCancel(this, reason);
                  }
                }, {
                  key: "getReader",
                  value: function getReader() {
                    var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mode = _ref2.mode;
                    if (IsReadableStream(this) === false) {
                      throw streamBrandCheckException("getReader");
                    }
                    if (mode === void 0) {
                      return AcquireReadableStreamDefaultReader(this);
                    }
                    mode = String(mode);
                    if (mode === "byob") {
                      return AcquireReadableStreamBYOBReader(this);
                    }
                    throw new RangeError("Invalid mode is specified");
                  }
                }, {
                  key: "pipeThrough",
                  value: function pipeThrough(_ref3, options2) {
                    var writable = _ref3.writable, readable = _ref3.readable;
                    var promise = this.pipeTo(writable, options2);
                    ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise);
                    return readable;
                  }
                }, {
                  key: "pipeTo",
                  value: function pipeTo(dest) {
                    var _this = this;
                    var _ref4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, preventClose = _ref4.preventClose, preventAbort = _ref4.preventAbort, preventCancel = _ref4.preventCancel;
                    if (IsReadableStream(this) === false) {
                      return Promise.reject(streamBrandCheckException("pipeTo"));
                    }
                    if (IsWritableStream(dest) === false) {
                      return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
                    }
                    preventClose = Boolean(preventClose);
                    preventAbort = Boolean(preventAbort);
                    preventCancel = Boolean(preventCancel);
                    if (IsReadableStreamLocked(this) === true) {
                      return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
                    }
                    if (IsWritableStreamLocked(dest) === true) {
                      return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
                    }
                    var reader = AcquireReadableStreamDefaultReader(this);
                    var writer = AcquireWritableStreamDefaultWriter(dest);
                    var shuttingDown = false;
                    var currentWrite = Promise.resolve();
                    return new Promise(function(resolve2, reject2) {
                      function pipeLoop() {
                        currentWrite = Promise.resolve();
                        if (shuttingDown === true) {
                          return Promise.resolve();
                        }
                        return writer._readyPromise.then(function() {
                          return ReadableStreamDefaultReaderRead(reader).then(function(_ref5) {
                            var value = _ref5.value, done = _ref5.done;
                            if (done === true) {
                              return;
                            }
                            currentWrite = WritableStreamDefaultWriterWrite(writer, value).catch(function() {
                            });
                          });
                        }).then(pipeLoop);
                      }
                      isOrBecomesErrored(_this, reader._closedPromise, function(storedError) {
                        if (preventAbort === false) {
                          shutdownWithAction(function() {
                            return WritableStreamAbort(dest, storedError);
                          }, true, storedError);
                        } else {
                          shutdown(true, storedError);
                        }
                      });
                      isOrBecomesErrored(dest, writer._closedPromise, function(storedError) {
                        if (preventCancel === false) {
                          shutdownWithAction(function() {
                            return ReadableStreamCancel(_this, storedError);
                          }, true, storedError);
                        } else {
                          shutdown(true, storedError);
                        }
                      });
                      isOrBecomesClosed(_this, reader._closedPromise, function() {
                        if (preventClose === false) {
                          shutdownWithAction(function() {
                            return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
                          });
                        } else {
                          shutdown();
                        }
                      });
                      if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === "closed") {
                        var destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
                        if (preventCancel === false) {
                          shutdownWithAction(function() {
                            return ReadableStreamCancel(_this, destClosed);
                          }, true, destClosed);
                        } else {
                          shutdown(true, destClosed);
                        }
                      }
                      pipeLoop().catch(function(err) {
                        currentWrite = Promise.resolve();
                        rethrowAssertionErrorRejection(err);
                      });
                      function waitForWritesToFinish() {
                        var oldCurrentWrite = currentWrite;
                        return currentWrite.then(function() {
                          return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0;
                        });
                      }
                      function isOrBecomesErrored(stream2, promise, action) {
                        if (stream2._state === "errored") {
                          action(stream2._storedError);
                        } else {
                          promise.catch(action).catch(rethrowAssertionErrorRejection);
                        }
                      }
                      function isOrBecomesClosed(stream2, promise, action) {
                        if (stream2._state === "closed") {
                          action();
                        } else {
                          promise.then(action).catch(rethrowAssertionErrorRejection);
                        }
                      }
                      function shutdownWithAction(action, originalIsError, originalError) {
                        if (shuttingDown === true) {
                          return;
                        }
                        shuttingDown = true;
                        if (dest._state === "writable" && WritableStreamCloseQueuedOrInFlight(dest) === false) {
                          waitForWritesToFinish().then(doTheRest);
                        } else {
                          doTheRest();
                        }
                        function doTheRest() {
                          action().then(function() {
                            return finalize(originalIsError, originalError);
                          }, function(newError) {
                            return finalize(true, newError);
                          }).catch(rethrowAssertionErrorRejection);
                        }
                      }
                      function shutdown(isError, error) {
                        if (shuttingDown === true) {
                          return;
                        }
                        shuttingDown = true;
                        if (dest._state === "writable" && WritableStreamCloseQueuedOrInFlight(dest) === false) {
                          waitForWritesToFinish().then(function() {
                            return finalize(isError, error);
                          }).catch(rethrowAssertionErrorRejection);
                        } else {
                          finalize(isError, error);
                        }
                      }
                      function finalize(isError, error) {
                        WritableStreamDefaultWriterRelease(writer);
                        ReadableStreamReaderGenericRelease(reader);
                        if (isError) {
                          reject2(error);
                        } else {
                          resolve2(void 0);
                        }
                      }
                    });
                  }
                }, {
                  key: "tee",
                  value: function tee() {
                    if (IsReadableStream(this) === false) {
                      throw streamBrandCheckException("tee");
                    }
                    var branches = ReadableStreamTee(this, false);
                    return createArrayFromList(branches);
                  }
                }, {
                  key: "locked",
                  get: function get() {
                    if (IsReadableStream(this) === false) {
                      throw streamBrandCheckException("locked");
                    }
                    return IsReadableStreamLocked(this);
                  }
                }]);
                return ReadableStream3;
              }();
              module4.exports = {
                ReadableStream: ReadableStream2,
                IsReadableStreamDisturbed,
                ReadableStreamDefaultControllerClose,
                ReadableStreamDefaultControllerEnqueue,
                ReadableStreamDefaultControllerError,
                ReadableStreamDefaultControllerGetDesiredSize
              };
              function AcquireReadableStreamBYOBReader(stream2) {
                return new ReadableStreamBYOBReader(stream2);
              }
              function AcquireReadableStreamDefaultReader(stream2) {
                return new ReadableStreamDefaultReader(stream2);
              }
              function IsReadableStream(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
                  return false;
                }
                return true;
              }
              function IsReadableStreamDisturbed(stream2) {
                assert(IsReadableStream(stream2) === true, "IsReadableStreamDisturbed should only be used on known readable streams");
                return stream2._disturbed;
              }
              function IsReadableStreamLocked(stream2) {
                assert(IsReadableStream(stream2) === true, "IsReadableStreamLocked should only be used on known readable streams");
                if (stream2._reader === void 0) {
                  return false;
                }
                return true;
              }
              function ReadableStreamTee(stream2, cloneForBranch2) {
                assert(IsReadableStream(stream2) === true);
                assert(typeof cloneForBranch2 === "boolean");
                var reader = AcquireReadableStreamDefaultReader(stream2);
                var teeState = {
                  closedOrErrored: false,
                  canceled1: false,
                  canceled2: false,
                  reason1: void 0,
                  reason2: void 0
                };
                teeState.promise = new Promise(function(resolve2) {
                  teeState._resolve = resolve2;
                });
                var pull = create_ReadableStreamTeePullFunction();
                pull._reader = reader;
                pull._teeState = teeState;
                pull._cloneForBranch2 = cloneForBranch2;
                var cancel1 = create_ReadableStreamTeeBranch1CancelFunction();
                cancel1._stream = stream2;
                cancel1._teeState = teeState;
                var cancel2 = create_ReadableStreamTeeBranch2CancelFunction();
                cancel2._stream = stream2;
                cancel2._teeState = teeState;
                var underlyingSource1 = Object.create(Object.prototype);
                createDataProperty(underlyingSource1, "pull", pull);
                createDataProperty(underlyingSource1, "cancel", cancel1);
                var branch1Stream = new ReadableStream2(underlyingSource1);
                var underlyingSource2 = Object.create(Object.prototype);
                createDataProperty(underlyingSource2, "pull", pull);
                createDataProperty(underlyingSource2, "cancel", cancel2);
                var branch2Stream = new ReadableStream2(underlyingSource2);
                pull._branch1 = branch1Stream._readableStreamController;
                pull._branch2 = branch2Stream._readableStreamController;
                reader._closedPromise.catch(function(r) {
                  if (teeState.closedOrErrored === true) {
                    return;
                  }
                  ReadableStreamDefaultControllerError(pull._branch1, r);
                  ReadableStreamDefaultControllerError(pull._branch2, r);
                  teeState.closedOrErrored = true;
                });
                return [branch1Stream, branch2Stream];
              }
              function create_ReadableStreamTeePullFunction() {
                function f() {
                  var reader = f._reader, branch1 = f._branch1, branch2 = f._branch2, teeState = f._teeState;
                  return ReadableStreamDefaultReaderRead(reader).then(function(result) {
                    assert(typeIsObject(result));
                    var value = result.value;
                    var done = result.done;
                    assert(typeof done === "boolean");
                    if (done === true && teeState.closedOrErrored === false) {
                      if (teeState.canceled1 === false) {
                        ReadableStreamDefaultControllerClose(branch1);
                      }
                      if (teeState.canceled2 === false) {
                        ReadableStreamDefaultControllerClose(branch2);
                      }
                      teeState.closedOrErrored = true;
                    }
                    if (teeState.closedOrErrored === true) {
                      return;
                    }
                    var value1 = value;
                    var value2 = value;
                    if (teeState.canceled1 === false) {
                      ReadableStreamDefaultControllerEnqueue(branch1, value1);
                    }
                    if (teeState.canceled2 === false) {
                      ReadableStreamDefaultControllerEnqueue(branch2, value2);
                    }
                  });
                }
                return f;
              }
              function create_ReadableStreamTeeBranch1CancelFunction() {
                function f(reason) {
                  var stream2 = f._stream, teeState = f._teeState;
                  teeState.canceled1 = true;
                  teeState.reason1 = reason;
                  if (teeState.canceled2 === true) {
                    var compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]);
                    var cancelResult = ReadableStreamCancel(stream2, compositeReason);
                    teeState._resolve(cancelResult);
                  }
                  return teeState.promise;
                }
                return f;
              }
              function create_ReadableStreamTeeBranch2CancelFunction() {
                function f(reason) {
                  var stream2 = f._stream, teeState = f._teeState;
                  teeState.canceled2 = true;
                  teeState.reason2 = reason;
                  if (teeState.canceled1 === true) {
                    var compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]);
                    var cancelResult = ReadableStreamCancel(stream2, compositeReason);
                    teeState._resolve(cancelResult);
                  }
                  return teeState.promise;
                }
                return f;
              }
              function ReadableStreamAddReadIntoRequest(stream2) {
                assert(IsReadableStreamBYOBReader(stream2._reader) === true);
                assert(stream2._state === "readable" || stream2._state === "closed");
                var promise = new Promise(function(resolve2, reject2) {
                  var readIntoRequest = {
                    _resolve: resolve2,
                    _reject: reject2
                  };
                  stream2._reader._readIntoRequests.push(readIntoRequest);
                });
                return promise;
              }
              function ReadableStreamAddReadRequest(stream2) {
                assert(IsReadableStreamDefaultReader(stream2._reader) === true);
                assert(stream2._state === "readable");
                var promise = new Promise(function(resolve2, reject2) {
                  var readRequest = {
                    _resolve: resolve2,
                    _reject: reject2
                  };
                  stream2._reader._readRequests.push(readRequest);
                });
                return promise;
              }
              function ReadableStreamCancel(stream2, reason) {
                stream2._disturbed = true;
                if (stream2._state === "closed") {
                  return Promise.resolve(void 0);
                }
                if (stream2._state === "errored") {
                  return Promise.reject(stream2._storedError);
                }
                ReadableStreamClose(stream2);
                var sourceCancelPromise = stream2._readableStreamController.__cancelSteps(reason);
                return sourceCancelPromise.then(function() {
                  return void 0;
                });
              }
              function ReadableStreamClose(stream2) {
                assert(stream2._state === "readable");
                stream2._state = "closed";
                var reader = stream2._reader;
                if (reader === void 0) {
                  return void 0;
                }
                if (IsReadableStreamDefaultReader(reader) === true) {
                  for (var i = 0; i < reader._readRequests.length; i++) {
                    var _resolve = reader._readRequests[i]._resolve;
                    _resolve(CreateIterResultObject(void 0, true));
                  }
                  reader._readRequests = [];
                }
                defaultReaderClosedPromiseResolve(reader);
                return void 0;
              }
              function ReadableStreamError(stream2, e) {
                assert(IsReadableStream(stream2) === true, "stream must be ReadableStream");
                assert(stream2._state === "readable", "state must be readable");
                stream2._state = "errored";
                stream2._storedError = e;
                var reader = stream2._reader;
                if (reader === void 0) {
                  return void 0;
                }
                if (IsReadableStreamDefaultReader(reader) === true) {
                  for (var i = 0; i < reader._readRequests.length; i++) {
                    var readRequest = reader._readRequests[i];
                    readRequest._reject(e);
                  }
                  reader._readRequests = [];
                } else {
                  assert(IsReadableStreamBYOBReader(reader), "reader must be ReadableStreamBYOBReader");
                  for (var _i = 0; _i < reader._readIntoRequests.length; _i++) {
                    var readIntoRequest = reader._readIntoRequests[_i];
                    readIntoRequest._reject(e);
                  }
                  reader._readIntoRequests = [];
                }
                defaultReaderClosedPromiseReject(reader, e);
                reader._closedPromise.catch(function() {
                });
              }
              function ReadableStreamFulfillReadIntoRequest(stream2, chunk, done) {
                var reader = stream2._reader;
                assert(reader._readIntoRequests.length > 0);
                var readIntoRequest = reader._readIntoRequests.shift();
                readIntoRequest._resolve(CreateIterResultObject(chunk, done));
              }
              function ReadableStreamFulfillReadRequest(stream2, chunk, done) {
                var reader = stream2._reader;
                assert(reader._readRequests.length > 0);
                var readRequest = reader._readRequests.shift();
                readRequest._resolve(CreateIterResultObject(chunk, done));
              }
              function ReadableStreamGetNumReadIntoRequests(stream2) {
                return stream2._reader._readIntoRequests.length;
              }
              function ReadableStreamGetNumReadRequests(stream2) {
                return stream2._reader._readRequests.length;
              }
              function ReadableStreamHasBYOBReader(stream2) {
                var reader = stream2._reader;
                if (reader === void 0) {
                  return false;
                }
                if (IsReadableStreamBYOBReader(reader) === false) {
                  return false;
                }
                return true;
              }
              function ReadableStreamHasDefaultReader(stream2) {
                var reader = stream2._reader;
                if (reader === void 0) {
                  return false;
                }
                if (IsReadableStreamDefaultReader(reader) === false) {
                  return false;
                }
                return true;
              }
              var ReadableStreamDefaultReader = function() {
                function ReadableStreamDefaultReader2(stream2) {
                  _classCallCheck(this, ReadableStreamDefaultReader2);
                  if (IsReadableStream(stream2) === false) {
                    throw new TypeError("ReadableStreamDefaultReader can only be constructed with a ReadableStream instance");
                  }
                  if (IsReadableStreamLocked(stream2) === true) {
                    throw new TypeError("This stream has already been locked for exclusive reading by another reader");
                  }
                  ReadableStreamReaderGenericInitialize(this, stream2);
                  this._readRequests = [];
                }
                _createClass(ReadableStreamDefaultReader2, [{
                  key: "cancel",
                  value: function cancel(reason) {
                    if (IsReadableStreamDefaultReader(this) === false) {
                      return Promise.reject(defaultReaderBrandCheckException("cancel"));
                    }
                    if (this._ownerReadableStream === void 0) {
                      return Promise.reject(readerLockException("cancel"));
                    }
                    return ReadableStreamReaderGenericCancel(this, reason);
                  }
                }, {
                  key: "read",
                  value: function read() {
                    if (IsReadableStreamDefaultReader(this) === false) {
                      return Promise.reject(defaultReaderBrandCheckException("read"));
                    }
                    if (this._ownerReadableStream === void 0) {
                      return Promise.reject(readerLockException("read from"));
                    }
                    return ReadableStreamDefaultReaderRead(this);
                  }
                }, {
                  key: "releaseLock",
                  value: function releaseLock() {
                    if (IsReadableStreamDefaultReader(this) === false) {
                      throw defaultReaderBrandCheckException("releaseLock");
                    }
                    if (this._ownerReadableStream === void 0) {
                      return;
                    }
                    if (this._readRequests.length > 0) {
                      throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
                    }
                    ReadableStreamReaderGenericRelease(this);
                  }
                }, {
                  key: "closed",
                  get: function get() {
                    if (IsReadableStreamDefaultReader(this) === false) {
                      return Promise.reject(defaultReaderBrandCheckException("closed"));
                    }
                    return this._closedPromise;
                  }
                }]);
                return ReadableStreamDefaultReader2;
              }();
              var ReadableStreamBYOBReader = function() {
                function ReadableStreamBYOBReader2(stream2) {
                  _classCallCheck(this, ReadableStreamBYOBReader2);
                  if (!IsReadableStream(stream2)) {
                    throw new TypeError("ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a byte source");
                  }
                  if (IsReadableByteStreamController(stream2._readableStreamController) === false) {
                    throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
                  }
                  if (IsReadableStreamLocked(stream2)) {
                    throw new TypeError("This stream has already been locked for exclusive reading by another reader");
                  }
                  ReadableStreamReaderGenericInitialize(this, stream2);
                  this._readIntoRequests = [];
                }
                _createClass(ReadableStreamBYOBReader2, [{
                  key: "cancel",
                  value: function cancel(reason) {
                    if (!IsReadableStreamBYOBReader(this)) {
                      return Promise.reject(byobReaderBrandCheckException("cancel"));
                    }
                    if (this._ownerReadableStream === void 0) {
                      return Promise.reject(readerLockException("cancel"));
                    }
                    return ReadableStreamReaderGenericCancel(this, reason);
                  }
                }, {
                  key: "read",
                  value: function read(view) {
                    if (!IsReadableStreamBYOBReader(this)) {
                      return Promise.reject(byobReaderBrandCheckException("read"));
                    }
                    if (this._ownerReadableStream === void 0) {
                      return Promise.reject(readerLockException("read from"));
                    }
                    if (!ArrayBuffer.isView(view)) {
                      return Promise.reject(new TypeError("view must be an array buffer view"));
                    }
                    if (view.byteLength === 0) {
                      return Promise.reject(new TypeError("view must have non-zero byteLength"));
                    }
                    return ReadableStreamBYOBReaderRead(this, view);
                  }
                }, {
                  key: "releaseLock",
                  value: function releaseLock() {
                    if (!IsReadableStreamBYOBReader(this)) {
                      throw byobReaderBrandCheckException("releaseLock");
                    }
                    if (this._ownerReadableStream === void 0) {
                      return;
                    }
                    if (this._readIntoRequests.length > 0) {
                      throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
                    }
                    ReadableStreamReaderGenericRelease(this);
                  }
                }, {
                  key: "closed",
                  get: function get() {
                    if (!IsReadableStreamBYOBReader(this)) {
                      return Promise.reject(byobReaderBrandCheckException("closed"));
                    }
                    return this._closedPromise;
                  }
                }]);
                return ReadableStreamBYOBReader2;
              }();
              function IsReadableStreamBYOBReader(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
                  return false;
                }
                return true;
              }
              function IsReadableStreamDefaultReader(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
                  return false;
                }
                return true;
              }
              function ReadableStreamReaderGenericInitialize(reader, stream2) {
                reader._ownerReadableStream = stream2;
                stream2._reader = reader;
                if (stream2._state === "readable") {
                  defaultReaderClosedPromiseInitialize(reader);
                } else if (stream2._state === "closed") {
                  defaultReaderClosedPromiseInitializeAsResolved(reader);
                } else {
                  assert(stream2._state === "errored", "state must be errored");
                  defaultReaderClosedPromiseInitializeAsRejected(reader, stream2._storedError);
                  reader._closedPromise.catch(function() {
                  });
                }
              }
              function ReadableStreamReaderGenericCancel(reader, reason) {
                var stream2 = reader._ownerReadableStream;
                assert(stream2 !== void 0);
                return ReadableStreamCancel(stream2, reason);
              }
              function ReadableStreamReaderGenericRelease(reader) {
                assert(reader._ownerReadableStream !== void 0);
                assert(reader._ownerReadableStream._reader === reader);
                if (reader._ownerReadableStream._state === "readable") {
                  defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
                } else {
                  defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
                }
                reader._closedPromise.catch(function() {
                });
                reader._ownerReadableStream._reader = void 0;
                reader._ownerReadableStream = void 0;
              }
              function ReadableStreamBYOBReaderRead(reader, view) {
                var stream2 = reader._ownerReadableStream;
                assert(stream2 !== void 0);
                stream2._disturbed = true;
                if (stream2._state === "errored") {
                  return Promise.reject(stream2._storedError);
                }
                return ReadableByteStreamControllerPullInto(stream2._readableStreamController, view);
              }
              function ReadableStreamDefaultReaderRead(reader) {
                var stream2 = reader._ownerReadableStream;
                assert(stream2 !== void 0);
                stream2._disturbed = true;
                if (stream2._state === "closed") {
                  return Promise.resolve(CreateIterResultObject(void 0, true));
                }
                if (stream2._state === "errored") {
                  return Promise.reject(stream2._storedError);
                }
                assert(stream2._state === "readable");
                return stream2._readableStreamController.__pullSteps();
              }
              var ReadableStreamDefaultController = function() {
                function ReadableStreamDefaultController2(stream2, underlyingSource, size, highWaterMark) {
                  _classCallCheck(this, ReadableStreamDefaultController2);
                  if (IsReadableStream(stream2) === false) {
                    throw new TypeError("ReadableStreamDefaultController can only be constructed with a ReadableStream instance");
                  }
                  if (stream2._readableStreamController !== void 0) {
                    throw new TypeError("ReadableStreamDefaultController instances can only be created by the ReadableStream constructor");
                  }
                  this._controlledReadableStream = stream2;
                  this._underlyingSource = underlyingSource;
                  this._queue = void 0;
                  this._queueTotalSize = void 0;
                  ResetQueue(this);
                  this._started = false;
                  this._closeRequested = false;
                  this._pullAgain = false;
                  this._pulling = false;
                  var normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
                  this._strategySize = normalizedStrategy.size;
                  this._strategyHWM = normalizedStrategy.highWaterMark;
                  var controller = this;
                  var startResult = InvokeOrNoop(underlyingSource, "start", [this]);
                  Promise.resolve(startResult).then(function() {
                    controller._started = true;
                    assert(controller._pulling === false);
                    assert(controller._pullAgain === false);
                    ReadableStreamDefaultControllerCallPullIfNeeded(controller);
                  }, function(r) {
                    ReadableStreamDefaultControllerErrorIfNeeded(controller, r);
                  }).catch(rethrowAssertionErrorRejection);
                }
                _createClass(ReadableStreamDefaultController2, [{
                  key: "close",
                  value: function close() {
                    if (IsReadableStreamDefaultController(this) === false) {
                      throw defaultControllerBrandCheckException("close");
                    }
                    if (this._closeRequested === true) {
                      throw new TypeError("The stream has already been closed; do not close it again!");
                    }
                    var state = this._controlledReadableStream._state;
                    if (state !== "readable") {
                      throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
                    }
                    ReadableStreamDefaultControllerClose(this);
                  }
                }, {
                  key: "enqueue",
                  value: function enqueue(chunk) {
                    if (IsReadableStreamDefaultController(this) === false) {
                      throw defaultControllerBrandCheckException("enqueue");
                    }
                    if (this._closeRequested === true) {
                      throw new TypeError("stream is closed or draining");
                    }
                    var state = this._controlledReadableStream._state;
                    if (state !== "readable") {
                      throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
                    }
                    return ReadableStreamDefaultControllerEnqueue(this, chunk);
                  }
                }, {
                  key: "error",
                  value: function error(e) {
                    if (IsReadableStreamDefaultController(this) === false) {
                      throw defaultControllerBrandCheckException("error");
                    }
                    var stream2 = this._controlledReadableStream;
                    if (stream2._state !== "readable") {
                      throw new TypeError("The stream is " + stream2._state + " and so cannot be errored");
                    }
                    ReadableStreamDefaultControllerError(this, e);
                  }
                }, {
                  key: "__cancelSteps",
                  value: function __cancelSteps(reason) {
                    ResetQueue(this);
                    return PromiseInvokeOrNoop(this._underlyingSource, "cancel", [reason]);
                  }
                }, {
                  key: "__pullSteps",
                  value: function __pullSteps() {
                    var stream2 = this._controlledReadableStream;
                    if (this._queue.length > 0) {
                      var chunk = DequeueValue(this);
                      if (this._closeRequested === true && this._queue.length === 0) {
                        ReadableStreamClose(stream2);
                      } else {
                        ReadableStreamDefaultControllerCallPullIfNeeded(this);
                      }
                      return Promise.resolve(CreateIterResultObject(chunk, false));
                    }
                    var pendingPromise = ReadableStreamAddReadRequest(stream2);
                    ReadableStreamDefaultControllerCallPullIfNeeded(this);
                    return pendingPromise;
                  }
                }, {
                  key: "desiredSize",
                  get: function get() {
                    if (IsReadableStreamDefaultController(this) === false) {
                      throw defaultControllerBrandCheckException("desiredSize");
                    }
                    return ReadableStreamDefaultControllerGetDesiredSize(this);
                  }
                }]);
                return ReadableStreamDefaultController2;
              }();
              function IsReadableStreamDefaultController(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_underlyingSource")) {
                  return false;
                }
                return true;
              }
              function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
                var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
                if (shouldPull === false) {
                  return void 0;
                }
                if (controller._pulling === true) {
                  controller._pullAgain = true;
                  return void 0;
                }
                assert(controller._pullAgain === false);
                controller._pulling = true;
                var pullPromise = PromiseInvokeOrNoop(controller._underlyingSource, "pull", [controller]);
                pullPromise.then(function() {
                  controller._pulling = false;
                  if (controller._pullAgain === true) {
                    controller._pullAgain = false;
                    return ReadableStreamDefaultControllerCallPullIfNeeded(controller);
                  }
                  return void 0;
                }, function(e) {
                  ReadableStreamDefaultControllerErrorIfNeeded(controller, e);
                }).catch(rethrowAssertionErrorRejection);
                return void 0;
              }
              function ReadableStreamDefaultControllerShouldCallPull(controller) {
                var stream2 = controller._controlledReadableStream;
                if (stream2._state === "closed" || stream2._state === "errored") {
                  return false;
                }
                if (controller._closeRequested === true) {
                  return false;
                }
                if (controller._started === false) {
                  return false;
                }
                if (IsReadableStreamLocked(stream2) === true && ReadableStreamGetNumReadRequests(stream2) > 0) {
                  return true;
                }
                var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
                if (desiredSize > 0) {
                  return true;
                }
                return false;
              }
              function ReadableStreamDefaultControllerClose(controller) {
                var stream2 = controller._controlledReadableStream;
                assert(controller._closeRequested === false);
                assert(stream2._state === "readable");
                controller._closeRequested = true;
                if (controller._queue.length === 0) {
                  ReadableStreamClose(stream2);
                }
              }
              function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
                var stream2 = controller._controlledReadableStream;
                assert(controller._closeRequested === false);
                assert(stream2._state === "readable");
                if (IsReadableStreamLocked(stream2) === true && ReadableStreamGetNumReadRequests(stream2) > 0) {
                  ReadableStreamFulfillReadRequest(stream2, chunk, false);
                } else {
                  var chunkSize = 1;
                  if (controller._strategySize !== void 0) {
                    var strategySize = controller._strategySize;
                    try {
                      chunkSize = strategySize(chunk);
                    } catch (chunkSizeE) {
                      ReadableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
                      throw chunkSizeE;
                    }
                  }
                  try {
                    EnqueueValueWithSize(controller, chunk, chunkSize);
                  } catch (enqueueE) {
                    ReadableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
                    throw enqueueE;
                  }
                }
                ReadableStreamDefaultControllerCallPullIfNeeded(controller);
                return void 0;
              }
              function ReadableStreamDefaultControllerError(controller, e) {
                var stream2 = controller._controlledReadableStream;
                assert(stream2._state === "readable");
                ResetQueue(controller);
                ReadableStreamError(stream2, e);
              }
              function ReadableStreamDefaultControllerErrorIfNeeded(controller, e) {
                if (controller._controlledReadableStream._state === "readable") {
                  ReadableStreamDefaultControllerError(controller, e);
                }
              }
              function ReadableStreamDefaultControllerGetDesiredSize(controller) {
                var stream2 = controller._controlledReadableStream;
                var state = stream2._state;
                if (state === "errored") {
                  return null;
                }
                if (state === "closed") {
                  return 0;
                }
                return controller._strategyHWM - controller._queueTotalSize;
              }
              var ReadableStreamBYOBRequest = function() {
                function ReadableStreamBYOBRequest2(controller, view) {
                  _classCallCheck(this, ReadableStreamBYOBRequest2);
                  this._associatedReadableByteStreamController = controller;
                  this._view = view;
                }
                _createClass(ReadableStreamBYOBRequest2, [{
                  key: "respond",
                  value: function respond(bytesWritten) {
                    if (IsReadableStreamBYOBRequest(this) === false) {
                      throw byobRequestBrandCheckException("respond");
                    }
                    if (this._associatedReadableByteStreamController === void 0) {
                      throw new TypeError("This BYOB request has been invalidated");
                    }
                    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
                  }
                }, {
                  key: "respondWithNewView",
                  value: function respondWithNewView(view) {
                    if (IsReadableStreamBYOBRequest(this) === false) {
                      throw byobRequestBrandCheckException("respond");
                    }
                    if (this._associatedReadableByteStreamController === void 0) {
                      throw new TypeError("This BYOB request has been invalidated");
                    }
                    if (!ArrayBuffer.isView(view)) {
                      throw new TypeError("You can only respond with array buffer views");
                    }
                    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
                  }
                }, {
                  key: "view",
                  get: function get() {
                    return this._view;
                  }
                }]);
                return ReadableStreamBYOBRequest2;
              }();
              var ReadableByteStreamController = function() {
                function ReadableByteStreamController2(stream2, underlyingByteSource, highWaterMark) {
                  _classCallCheck(this, ReadableByteStreamController2);
                  if (IsReadableStream(stream2) === false) {
                    throw new TypeError("ReadableByteStreamController can only be constructed with a ReadableStream instance given a byte source");
                  }
                  if (stream2._readableStreamController !== void 0) {
                    throw new TypeError("ReadableByteStreamController instances can only be created by the ReadableStream constructor given a byte source");
                  }
                  this._controlledReadableStream = stream2;
                  this._underlyingByteSource = underlyingByteSource;
                  this._pullAgain = false;
                  this._pulling = false;
                  ReadableByteStreamControllerClearPendingPullIntos(this);
                  this._queue = this._queueTotalSize = void 0;
                  ResetQueue(this);
                  this._closeRequested = false;
                  this._started = false;
                  this._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);
                  var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
                  if (autoAllocateChunkSize !== void 0) {
                    if (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {
                      throw new RangeError("autoAllocateChunkSize must be a positive integer");
                    }
                  }
                  this._autoAllocateChunkSize = autoAllocateChunkSize;
                  this._pendingPullIntos = [];
                  var controller = this;
                  var startResult = InvokeOrNoop(underlyingByteSource, "start", [this]);
                  Promise.resolve(startResult).then(function() {
                    controller._started = true;
                    assert(controller._pulling === false);
                    assert(controller._pullAgain === false);
                    ReadableByteStreamControllerCallPullIfNeeded(controller);
                  }, function(r) {
                    if (stream2._state === "readable") {
                      ReadableByteStreamControllerError(controller, r);
                    }
                  }).catch(rethrowAssertionErrorRejection);
                }
                _createClass(ReadableByteStreamController2, [{
                  key: "close",
                  value: function close() {
                    if (IsReadableByteStreamController(this) === false) {
                      throw byteStreamControllerBrandCheckException("close");
                    }
                    if (this._closeRequested === true) {
                      throw new TypeError("The stream has already been closed; do not close it again!");
                    }
                    var state = this._controlledReadableStream._state;
                    if (state !== "readable") {
                      throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
                    }
                    ReadableByteStreamControllerClose(this);
                  }
                }, {
                  key: "enqueue",
                  value: function enqueue(chunk) {
                    if (IsReadableByteStreamController(this) === false) {
                      throw byteStreamControllerBrandCheckException("enqueue");
                    }
                    if (this._closeRequested === true) {
                      throw new TypeError("stream is closed or draining");
                    }
                    var state = this._controlledReadableStream._state;
                    if (state !== "readable") {
                      throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
                    }
                    if (!ArrayBuffer.isView(chunk)) {
                      throw new TypeError("You can only enqueue array buffer views when using a ReadableByteStreamController");
                    }
                    ReadableByteStreamControllerEnqueue(this, chunk);
                  }
                }, {
                  key: "error",
                  value: function error(e) {
                    if (IsReadableByteStreamController(this) === false) {
                      throw byteStreamControllerBrandCheckException("error");
                    }
                    var stream2 = this._controlledReadableStream;
                    if (stream2._state !== "readable") {
                      throw new TypeError("The stream is " + stream2._state + " and so cannot be errored");
                    }
                    ReadableByteStreamControllerError(this, e);
                  }
                }, {
                  key: "__cancelSteps",
                  value: function __cancelSteps(reason) {
                    if (this._pendingPullIntos.length > 0) {
                      var firstDescriptor = this._pendingPullIntos[0];
                      firstDescriptor.bytesFilled = 0;
                    }
                    ResetQueue(this);
                    return PromiseInvokeOrNoop(this._underlyingByteSource, "cancel", [reason]);
                  }
                }, {
                  key: "__pullSteps",
                  value: function __pullSteps() {
                    var stream2 = this._controlledReadableStream;
                    assert(ReadableStreamHasDefaultReader(stream2) === true);
                    if (this._queueTotalSize > 0) {
                      assert(ReadableStreamGetNumReadRequests(stream2) === 0);
                      var entry = this._queue.shift();
                      this._queueTotalSize -= entry.byteLength;
                      ReadableByteStreamControllerHandleQueueDrain(this);
                      var view = void 0;
                      try {
                        view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
                      } catch (viewE) {
                        return Promise.reject(viewE);
                      }
                      return Promise.resolve(CreateIterResultObject(view, false));
                    }
                    var autoAllocateChunkSize = this._autoAllocateChunkSize;
                    if (autoAllocateChunkSize !== void 0) {
                      var buffer = void 0;
                      try {
                        buffer = new ArrayBuffer(autoAllocateChunkSize);
                      } catch (bufferE) {
                        return Promise.reject(bufferE);
                      }
                      var pullIntoDescriptor = {
                        buffer,
                        byteOffset: 0,
                        byteLength: autoAllocateChunkSize,
                        bytesFilled: 0,
                        elementSize: 1,
                        ctor: Uint8Array,
                        readerType: "default"
                      };
                      this._pendingPullIntos.push(pullIntoDescriptor);
                    }
                    var promise = ReadableStreamAddReadRequest(stream2);
                    ReadableByteStreamControllerCallPullIfNeeded(this);
                    return promise;
                  }
                }, {
                  key: "byobRequest",
                  get: function get() {
                    if (IsReadableByteStreamController(this) === false) {
                      throw byteStreamControllerBrandCheckException("byobRequest");
                    }
                    if (this._byobRequest === void 0 && this._pendingPullIntos.length > 0) {
                      var firstDescriptor = this._pendingPullIntos[0];
                      var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
                      this._byobRequest = new ReadableStreamBYOBRequest(this, view);
                    }
                    return this._byobRequest;
                  }
                }, {
                  key: "desiredSize",
                  get: function get() {
                    if (IsReadableByteStreamController(this) === false) {
                      throw byteStreamControllerBrandCheckException("desiredSize");
                    }
                    return ReadableByteStreamControllerGetDesiredSize(this);
                  }
                }]);
                return ReadableByteStreamController2;
              }();
              function IsReadableByteStreamController(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_underlyingByteSource")) {
                  return false;
                }
                return true;
              }
              function IsReadableStreamBYOBRequest(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
                  return false;
                }
                return true;
              }
              function ReadableByteStreamControllerCallPullIfNeeded(controller) {
                var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
                if (shouldPull === false) {
                  return void 0;
                }
                if (controller._pulling === true) {
                  controller._pullAgain = true;
                  return void 0;
                }
                assert(controller._pullAgain === false);
                controller._pulling = true;
                var pullPromise = PromiseInvokeOrNoop(controller._underlyingByteSource, "pull", [controller]);
                pullPromise.then(function() {
                  controller._pulling = false;
                  if (controller._pullAgain === true) {
                    controller._pullAgain = false;
                    ReadableByteStreamControllerCallPullIfNeeded(controller);
                  }
                }, function(e) {
                  if (controller._controlledReadableStream._state === "readable") {
                    ReadableByteStreamControllerError(controller, e);
                  }
                }).catch(rethrowAssertionErrorRejection);
                return void 0;
              }
              function ReadableByteStreamControllerClearPendingPullIntos(controller) {
                ReadableByteStreamControllerInvalidateBYOBRequest(controller);
                controller._pendingPullIntos = [];
              }
              function ReadableByteStreamControllerCommitPullIntoDescriptor(stream2, pullIntoDescriptor) {
                assert(stream2._state !== "errored", "state must not be errored");
                var done = false;
                if (stream2._state === "closed") {
                  assert(pullIntoDescriptor.bytesFilled === 0);
                  done = true;
                }
                var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
                if (pullIntoDescriptor.readerType === "default") {
                  ReadableStreamFulfillReadRequest(stream2, filledView, done);
                } else {
                  assert(pullIntoDescriptor.readerType === "byob");
                  ReadableStreamFulfillReadIntoRequest(stream2, filledView, done);
                }
              }
              function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
                var bytesFilled = pullIntoDescriptor.bytesFilled;
                var elementSize = pullIntoDescriptor.elementSize;
                assert(bytesFilled <= pullIntoDescriptor.byteLength);
                assert(bytesFilled % elementSize === 0);
                return new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
              }
              function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
                controller._queue.push({
                  buffer,
                  byteOffset,
                  byteLength
                });
                controller._queueTotalSize += byteLength;
              }
              function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
                var elementSize = pullIntoDescriptor.elementSize;
                var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
                var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
                var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
                var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
                var totalBytesToCopyRemaining = maxBytesToCopy;
                var ready = false;
                if (maxAlignedBytes > currentAlignedBytes) {
                  totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
                  ready = true;
                }
                var queue = controller._queue;
                while (totalBytesToCopyRemaining > 0) {
                  var headOfQueue = queue[0];
                  var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
                  var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
                  ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
                  if (headOfQueue.byteLength === bytesToCopy) {
                    queue.shift();
                  } else {
                    headOfQueue.byteOffset += bytesToCopy;
                    headOfQueue.byteLength -= bytesToCopy;
                  }
                  controller._queueTotalSize -= bytesToCopy;
                  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
                  totalBytesToCopyRemaining -= bytesToCopy;
                }
                if (ready === false) {
                  assert(controller._queueTotalSize === 0, "queue must be empty");
                  assert(pullIntoDescriptor.bytesFilled > 0);
                  assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);
                }
                return ready;
              }
              function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
                assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos[0] === pullIntoDescriptor);
                ReadableByteStreamControllerInvalidateBYOBRequest(controller);
                pullIntoDescriptor.bytesFilled += size;
              }
              function ReadableByteStreamControllerHandleQueueDrain(controller) {
                assert(controller._controlledReadableStream._state === "readable");
                if (controller._queueTotalSize === 0 && controller._closeRequested === true) {
                  ReadableStreamClose(controller._controlledReadableStream);
                } else {
                  ReadableByteStreamControllerCallPullIfNeeded(controller);
                }
              }
              function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
                if (controller._byobRequest === void 0) {
                  return;
                }
                controller._byobRequest._associatedReadableByteStreamController = void 0;
                controller._byobRequest._view = void 0;
                controller._byobRequest = void 0;
              }
              function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
                assert(controller._closeRequested === false);
                while (controller._pendingPullIntos.length > 0) {
                  if (controller._queueTotalSize === 0) {
                    return;
                  }
                  var pullIntoDescriptor = controller._pendingPullIntos[0];
                  if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {
                    ReadableByteStreamControllerShiftPendingPullInto(controller);
                    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor);
                  }
                }
              }
              function ReadableByteStreamControllerPullInto(controller, view) {
                var stream2 = controller._controlledReadableStream;
                var elementSize = 1;
                if (view.constructor !== DataView) {
                  elementSize = view.constructor.BYTES_PER_ELEMENT;
                }
                var ctor = view.constructor;
                var pullIntoDescriptor = {
                  buffer: view.buffer,
                  byteOffset: view.byteOffset,
                  byteLength: view.byteLength,
                  bytesFilled: 0,
                  elementSize,
                  ctor,
                  readerType: "byob"
                };
                if (controller._pendingPullIntos.length > 0) {
                  pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);
                  controller._pendingPullIntos.push(pullIntoDescriptor);
                  return ReadableStreamAddReadIntoRequest(stream2);
                }
                if (stream2._state === "closed") {
                  var emptyView = new view.constructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
                  return Promise.resolve(CreateIterResultObject(emptyView, true));
                }
                if (controller._queueTotalSize > 0) {
                  if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {
                    var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
                    ReadableByteStreamControllerHandleQueueDrain(controller);
                    return Promise.resolve(CreateIterResultObject(filledView, false));
                  }
                  if (controller._closeRequested === true) {
                    var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
                    ReadableByteStreamControllerError(controller, e);
                    return Promise.reject(e);
                  }
                }
                pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);
                controller._pendingPullIntos.push(pullIntoDescriptor);
                var promise = ReadableStreamAddReadIntoRequest(stream2);
                ReadableByteStreamControllerCallPullIfNeeded(controller);
                return promise;
              }
              function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
                firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
                assert(firstDescriptor.bytesFilled === 0, "bytesFilled must be 0");
                var stream2 = controller._controlledReadableStream;
                if (ReadableStreamHasBYOBReader(stream2) === true) {
                  while (ReadableStreamGetNumReadIntoRequests(stream2) > 0) {
                    var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
                    ReadableByteStreamControllerCommitPullIntoDescriptor(stream2, pullIntoDescriptor);
                  }
                }
              }
              function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
                if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {
                  throw new RangeError("bytesWritten out of range");
                }
                ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
                if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
                  return;
                }
                ReadableByteStreamControllerShiftPendingPullInto(controller);
                var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
                if (remainderSize > 0) {
                  var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
                  var remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);
                  ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
                }
                pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);
                pullIntoDescriptor.bytesFilled -= remainderSize;
                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor);
                ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
              }
              function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
                var firstDescriptor = controller._pendingPullIntos[0];
                var stream2 = controller._controlledReadableStream;
                if (stream2._state === "closed") {
                  if (bytesWritten !== 0) {
                    throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
                  }
                  ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
                } else {
                  assert(stream2._state === "readable");
                  ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
                }
              }
              function ReadableByteStreamControllerShiftPendingPullInto(controller) {
                var descriptor = controller._pendingPullIntos.shift();
                ReadableByteStreamControllerInvalidateBYOBRequest(controller);
                return descriptor;
              }
              function ReadableByteStreamControllerShouldCallPull(controller) {
                var stream2 = controller._controlledReadableStream;
                if (stream2._state !== "readable") {
                  return false;
                }
                if (controller._closeRequested === true) {
                  return false;
                }
                if (controller._started === false) {
                  return false;
                }
                if (ReadableStreamHasDefaultReader(stream2) === true && ReadableStreamGetNumReadRequests(stream2) > 0) {
                  return true;
                }
                if (ReadableStreamHasBYOBReader(stream2) === true && ReadableStreamGetNumReadIntoRequests(stream2) > 0) {
                  return true;
                }
                if (ReadableByteStreamControllerGetDesiredSize(controller) > 0) {
                  return true;
                }
                return false;
              }
              function ReadableByteStreamControllerClose(controller) {
                var stream2 = controller._controlledReadableStream;
                assert(controller._closeRequested === false);
                assert(stream2._state === "readable");
                if (controller._queueTotalSize > 0) {
                  controller._closeRequested = true;
                  return;
                }
                if (controller._pendingPullIntos.length > 0) {
                  var firstPendingPullInto = controller._pendingPullIntos[0];
                  if (firstPendingPullInto.bytesFilled > 0) {
                    var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
                    ReadableByteStreamControllerError(controller, e);
                    throw e;
                  }
                }
                ReadableStreamClose(stream2);
              }
              function ReadableByteStreamControllerEnqueue(controller, chunk) {
                var stream2 = controller._controlledReadableStream;
                assert(controller._closeRequested === false);
                assert(stream2._state === "readable");
                var buffer = chunk.buffer;
                var byteOffset = chunk.byteOffset;
                var byteLength = chunk.byteLength;
                var transferredBuffer = TransferArrayBuffer(buffer);
                if (ReadableStreamHasDefaultReader(stream2) === true) {
                  if (ReadableStreamGetNumReadRequests(stream2) === 0) {
                    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
                  } else {
                    assert(controller._queue.length === 0);
                    var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
                    ReadableStreamFulfillReadRequest(stream2, transferredView, false);
                  }
                } else if (ReadableStreamHasBYOBReader(stream2) === true) {
                  ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
                  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
                } else {
                  assert(IsReadableStreamLocked(stream2) === false, "stream must not be locked");
                  ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
                }
              }
              function ReadableByteStreamControllerError(controller, e) {
                var stream2 = controller._controlledReadableStream;
                assert(stream2._state === "readable");
                ReadableByteStreamControllerClearPendingPullIntos(controller);
                ResetQueue(controller);
                ReadableStreamError(stream2, e);
              }
              function ReadableByteStreamControllerGetDesiredSize(controller) {
                var stream2 = controller._controlledReadableStream;
                var state = stream2._state;
                if (state === "errored") {
                  return null;
                }
                if (state === "closed") {
                  return 0;
                }
                return controller._strategyHWM - controller._queueTotalSize;
              }
              function ReadableByteStreamControllerRespond(controller, bytesWritten) {
                bytesWritten = Number(bytesWritten);
                if (IsFiniteNonNegativeNumber(bytesWritten) === false) {
                  throw new RangeError("bytesWritten must be a finite");
                }
                assert(controller._pendingPullIntos.length > 0);
                ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
              }
              function ReadableByteStreamControllerRespondWithNewView(controller, view) {
                assert(controller._pendingPullIntos.length > 0);
                var firstDescriptor = controller._pendingPullIntos[0];
                if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
                  throw new RangeError("The region specified by view does not match byobRequest");
                }
                if (firstDescriptor.byteLength !== view.byteLength) {
                  throw new RangeError("The buffer of view has different capacity than byobRequest");
                }
                firstDescriptor.buffer = view.buffer;
                ReadableByteStreamControllerRespondInternal(controller, view.byteLength);
              }
              function streamBrandCheckException(name) {
                return new TypeError("ReadableStream.prototype." + name + " can only be used on a ReadableStream");
              }
              function readerLockException(name) {
                return new TypeError("Cannot " + name + " a stream using a released reader");
              }
              function defaultReaderBrandCheckException(name) {
                return new TypeError("ReadableStreamDefaultReader.prototype." + name + " can only be used on a ReadableStreamDefaultReader");
              }
              function defaultReaderClosedPromiseInitialize(reader) {
                reader._closedPromise = new Promise(function(resolve2, reject2) {
                  reader._closedPromise_resolve = resolve2;
                  reader._closedPromise_reject = reject2;
                });
              }
              function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
                reader._closedPromise = Promise.reject(reason);
                reader._closedPromise_resolve = void 0;
                reader._closedPromise_reject = void 0;
              }
              function defaultReaderClosedPromiseInitializeAsResolved(reader) {
                reader._closedPromise = Promise.resolve(void 0);
                reader._closedPromise_resolve = void 0;
                reader._closedPromise_reject = void 0;
              }
              function defaultReaderClosedPromiseReject(reader, reason) {
                assert(reader._closedPromise_resolve !== void 0);
                assert(reader._closedPromise_reject !== void 0);
                reader._closedPromise_reject(reason);
                reader._closedPromise_resolve = void 0;
                reader._closedPromise_reject = void 0;
              }
              function defaultReaderClosedPromiseResetToRejected(reader, reason) {
                assert(reader._closedPromise_resolve === void 0);
                assert(reader._closedPromise_reject === void 0);
                reader._closedPromise = Promise.reject(reason);
              }
              function defaultReaderClosedPromiseResolve(reader) {
                assert(reader._closedPromise_resolve !== void 0);
                assert(reader._closedPromise_reject !== void 0);
                reader._closedPromise_resolve(void 0);
                reader._closedPromise_resolve = void 0;
                reader._closedPromise_reject = void 0;
              }
              function byobReaderBrandCheckException(name) {
                return new TypeError("ReadableStreamBYOBReader.prototype." + name + " can only be used on a ReadableStreamBYOBReader");
              }
              function defaultControllerBrandCheckException(name) {
                return new TypeError("ReadableStreamDefaultController.prototype." + name + " can only be used on a ReadableStreamDefaultController");
              }
              function byobRequestBrandCheckException(name) {
                return new TypeError("ReadableStreamBYOBRequest.prototype." + name + " can only be used on a ReadableStreamBYOBRequest");
              }
              function byteStreamControllerBrandCheckException(name) {
                return new TypeError("ReadableByteStreamController.prototype." + name + " can only be used on a ReadableByteStreamController");
              }
              function ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise) {
                try {
                  Promise.prototype.then.call(promise, void 0, function() {
                  });
                } catch (e) {
                }
              }
            }, function(module4, exports4, __w_pdfjs_require__2) {
              "use strict";
              var transformStream = __w_pdfjs_require__2(6);
              var readableStream2 = __w_pdfjs_require__2(4);
              var writableStream = __w_pdfjs_require__2(2);
              exports4.TransformStream = transformStream.TransformStream;
              exports4.ReadableStream = readableStream2.ReadableStream;
              exports4.IsReadableStreamDisturbed = readableStream2.IsReadableStreamDisturbed;
              exports4.ReadableStreamDefaultControllerClose = readableStream2.ReadableStreamDefaultControllerClose;
              exports4.ReadableStreamDefaultControllerEnqueue = readableStream2.ReadableStreamDefaultControllerEnqueue;
              exports4.ReadableStreamDefaultControllerError = readableStream2.ReadableStreamDefaultControllerError;
              exports4.ReadableStreamDefaultControllerGetDesiredSize = readableStream2.ReadableStreamDefaultControllerGetDesiredSize;
              exports4.AcquireWritableStreamDefaultWriter = writableStream.AcquireWritableStreamDefaultWriter;
              exports4.IsWritableStream = writableStream.IsWritableStream;
              exports4.IsWritableStreamLocked = writableStream.IsWritableStreamLocked;
              exports4.WritableStream = writableStream.WritableStream;
              exports4.WritableStreamAbort = writableStream.WritableStreamAbort;
              exports4.WritableStreamDefaultControllerError = writableStream.WritableStreamDefaultControllerError;
              exports4.WritableStreamDefaultWriterCloseWithErrorPropagation = writableStream.WritableStreamDefaultWriterCloseWithErrorPropagation;
              exports4.WritableStreamDefaultWriterRelease = writableStream.WritableStreamDefaultWriterRelease;
              exports4.WritableStreamDefaultWriterWrite = writableStream.WritableStreamDefaultWriterWrite;
            }, function(module4, exports4, __w_pdfjs_require__2) {
              "use strict";
              var _createClass = /* @__PURE__ */ function() {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function(Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var _require = __w_pdfjs_require__2(1), assert = _require.assert;
              var _require2 = __w_pdfjs_require__2(0), InvokeOrNoop = _require2.InvokeOrNoop, PromiseInvokeOrPerformFallback = _require2.PromiseInvokeOrPerformFallback, PromiseInvokeOrNoop = _require2.PromiseInvokeOrNoop, typeIsObject = _require2.typeIsObject;
              var _require3 = __w_pdfjs_require__2(4), ReadableStream2 = _require3.ReadableStream, ReadableStreamDefaultControllerClose = _require3.ReadableStreamDefaultControllerClose, ReadableStreamDefaultControllerEnqueue = _require3.ReadableStreamDefaultControllerEnqueue, ReadableStreamDefaultControllerError = _require3.ReadableStreamDefaultControllerError, ReadableStreamDefaultControllerGetDesiredSize = _require3.ReadableStreamDefaultControllerGetDesiredSize;
              var _require4 = __w_pdfjs_require__2(2), WritableStream = _require4.WritableStream, WritableStreamDefaultControllerError = _require4.WritableStreamDefaultControllerError;
              function TransformStreamCloseReadable(transformStream) {
                if (transformStream._errored === true) {
                  throw new TypeError("TransformStream is already errored");
                }
                if (transformStream._readableClosed === true) {
                  throw new TypeError("Readable side is already closed");
                }
                TransformStreamCloseReadableInternal(transformStream);
              }
              function TransformStreamEnqueueToReadable(transformStream, chunk) {
                if (transformStream._errored === true) {
                  throw new TypeError("TransformStream is already errored");
                }
                if (transformStream._readableClosed === true) {
                  throw new TypeError("Readable side is already closed");
                }
                var controller = transformStream._readableController;
                try {
                  ReadableStreamDefaultControllerEnqueue(controller, chunk);
                } catch (e) {
                  transformStream._readableClosed = true;
                  TransformStreamErrorIfNeeded(transformStream, e);
                  throw transformStream._storedError;
                }
                var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
                var maybeBackpressure = desiredSize <= 0;
                if (maybeBackpressure === true && transformStream._backpressure === false) {
                  TransformStreamSetBackpressure(transformStream, true);
                }
              }
              function TransformStreamError(transformStream, e) {
                if (transformStream._errored === true) {
                  throw new TypeError("TransformStream is already errored");
                }
                TransformStreamErrorInternal(transformStream, e);
              }
              function TransformStreamCloseReadableInternal(transformStream) {
                assert(transformStream._errored === false);
                assert(transformStream._readableClosed === false);
                try {
                  ReadableStreamDefaultControllerClose(transformStream._readableController);
                } catch (e) {
                  assert(false);
                }
                transformStream._readableClosed = true;
              }
              function TransformStreamErrorIfNeeded(transformStream, e) {
                if (transformStream._errored === false) {
                  TransformStreamErrorInternal(transformStream, e);
                }
              }
              function TransformStreamErrorInternal(transformStream, e) {
                assert(transformStream._errored === false);
                transformStream._errored = true;
                transformStream._storedError = e;
                if (transformStream._writableDone === false) {
                  WritableStreamDefaultControllerError(transformStream._writableController, e);
                }
                if (transformStream._readableClosed === false) {
                  ReadableStreamDefaultControllerError(transformStream._readableController, e);
                }
              }
              function TransformStreamReadableReadyPromise(transformStream) {
                assert(transformStream._backpressureChangePromise !== void 0, "_backpressureChangePromise should have been initialized");
                if (transformStream._backpressure === false) {
                  return Promise.resolve();
                }
                assert(transformStream._backpressure === true, "_backpressure should have been initialized");
                return transformStream._backpressureChangePromise;
              }
              function TransformStreamSetBackpressure(transformStream, backpressure) {
                assert(transformStream._backpressure !== backpressure, "TransformStreamSetBackpressure() should be called only when backpressure is changed");
                if (transformStream._backpressureChangePromise !== void 0) {
                  transformStream._backpressureChangePromise_resolve(backpressure);
                }
                transformStream._backpressureChangePromise = new Promise(function(resolve2) {
                  transformStream._backpressureChangePromise_resolve = resolve2;
                });
                transformStream._backpressureChangePromise.then(function(resolution) {
                  assert(resolution !== backpressure, "_backpressureChangePromise should be fulfilled only when backpressure is changed");
                });
                transformStream._backpressure = backpressure;
              }
              function TransformStreamDefaultTransform(chunk, transformStreamController) {
                var transformStream = transformStreamController._controlledTransformStream;
                TransformStreamEnqueueToReadable(transformStream, chunk);
                return Promise.resolve();
              }
              function TransformStreamTransform(transformStream, chunk) {
                assert(transformStream._errored === false);
                assert(transformStream._transforming === false);
                assert(transformStream._backpressure === false);
                transformStream._transforming = true;
                var transformer = transformStream._transformer;
                var controller = transformStream._transformStreamController;
                var transformPromise = PromiseInvokeOrPerformFallback(transformer, "transform", [chunk, controller], TransformStreamDefaultTransform, [chunk, controller]);
                return transformPromise.then(function() {
                  transformStream._transforming = false;
                  return TransformStreamReadableReadyPromise(transformStream);
                }, function(e) {
                  TransformStreamErrorIfNeeded(transformStream, e);
                  return Promise.reject(e);
                });
              }
              function IsTransformStreamDefaultController(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
                  return false;
                }
                return true;
              }
              function IsTransformStream(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
                  return false;
                }
                return true;
              }
              var TransformStreamSink = function() {
                function TransformStreamSink2(transformStream, startPromise) {
                  _classCallCheck(this, TransformStreamSink2);
                  this._transformStream = transformStream;
                  this._startPromise = startPromise;
                }
                _createClass(TransformStreamSink2, [{
                  key: "start",
                  value: function start(c) {
                    var transformStream = this._transformStream;
                    transformStream._writableController = c;
                    return this._startPromise.then(function() {
                      return TransformStreamReadableReadyPromise(transformStream);
                    });
                  }
                }, {
                  key: "write",
                  value: function write(chunk) {
                    var transformStream = this._transformStream;
                    return TransformStreamTransform(transformStream, chunk);
                  }
                }, {
                  key: "abort",
                  value: function abort() {
                    var transformStream = this._transformStream;
                    transformStream._writableDone = true;
                    TransformStreamErrorInternal(transformStream, new TypeError("Writable side aborted"));
                  }
                }, {
                  key: "close",
                  value: function close() {
                    var transformStream = this._transformStream;
                    assert(transformStream._transforming === false);
                    transformStream._writableDone = true;
                    var flushPromise = PromiseInvokeOrNoop(transformStream._transformer, "flush", [transformStream._transformStreamController]);
                    return flushPromise.then(function() {
                      if (transformStream._errored === true) {
                        return Promise.reject(transformStream._storedError);
                      }
                      if (transformStream._readableClosed === false) {
                        TransformStreamCloseReadableInternal(transformStream);
                      }
                      return Promise.resolve();
                    }).catch(function(r) {
                      TransformStreamErrorIfNeeded(transformStream, r);
                      return Promise.reject(transformStream._storedError);
                    });
                  }
                }]);
                return TransformStreamSink2;
              }();
              var TransformStreamSource = function() {
                function TransformStreamSource2(transformStream, startPromise) {
                  _classCallCheck(this, TransformStreamSource2);
                  this._transformStream = transformStream;
                  this._startPromise = startPromise;
                }
                _createClass(TransformStreamSource2, [{
                  key: "start",
                  value: function start(c) {
                    var transformStream = this._transformStream;
                    transformStream._readableController = c;
                    return this._startPromise.then(function() {
                      assert(transformStream._backpressureChangePromise !== void 0, "_backpressureChangePromise should have been initialized");
                      if (transformStream._backpressure === true) {
                        return Promise.resolve();
                      }
                      assert(transformStream._backpressure === false, "_backpressure should have been initialized");
                      return transformStream._backpressureChangePromise;
                    });
                  }
                }, {
                  key: "pull",
                  value: function pull() {
                    var transformStream = this._transformStream;
                    assert(transformStream._backpressure === true, "pull() should be never called while _backpressure is false");
                    assert(transformStream._backpressureChangePromise !== void 0, "_backpressureChangePromise should have been initialized");
                    TransformStreamSetBackpressure(transformStream, false);
                    return transformStream._backpressureChangePromise;
                  }
                }, {
                  key: "cancel",
                  value: function cancel() {
                    var transformStream = this._transformStream;
                    transformStream._readableClosed = true;
                    TransformStreamErrorInternal(transformStream, new TypeError("Readable side canceled"));
                  }
                }]);
                return TransformStreamSource2;
              }();
              var TransformStreamDefaultController = function() {
                function TransformStreamDefaultController2(transformStream) {
                  _classCallCheck(this, TransformStreamDefaultController2);
                  if (IsTransformStream(transformStream) === false) {
                    throw new TypeError("TransformStreamDefaultController can only be constructed with a TransformStream instance");
                  }
                  if (transformStream._transformStreamController !== void 0) {
                    throw new TypeError("TransformStreamDefaultController instances can only be created by the TransformStream constructor");
                  }
                  this._controlledTransformStream = transformStream;
                }
                _createClass(TransformStreamDefaultController2, [{
                  key: "enqueue",
                  value: function enqueue(chunk) {
                    if (IsTransformStreamDefaultController(this) === false) {
                      throw defaultControllerBrandCheckException("enqueue");
                    }
                    TransformStreamEnqueueToReadable(this._controlledTransformStream, chunk);
                  }
                }, {
                  key: "close",
                  value: function close() {
                    if (IsTransformStreamDefaultController(this) === false) {
                      throw defaultControllerBrandCheckException("close");
                    }
                    TransformStreamCloseReadable(this._controlledTransformStream);
                  }
                }, {
                  key: "error",
                  value: function error(reason) {
                    if (IsTransformStreamDefaultController(this) === false) {
                      throw defaultControllerBrandCheckException("error");
                    }
                    TransformStreamError(this._controlledTransformStream, reason);
                  }
                }, {
                  key: "desiredSize",
                  get: function get() {
                    if (IsTransformStreamDefaultController(this) === false) {
                      throw defaultControllerBrandCheckException("desiredSize");
                    }
                    var transformStream = this._controlledTransformStream;
                    var readableController = transformStream._readableController;
                    return ReadableStreamDefaultControllerGetDesiredSize(readableController);
                  }
                }]);
                return TransformStreamDefaultController2;
              }();
              var TransformStream = function() {
                function TransformStream2() {
                  var transformer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  _classCallCheck(this, TransformStream2);
                  this._transformer = transformer;
                  var readableStrategy = transformer.readableStrategy, writableStrategy = transformer.writableStrategy;
                  this._transforming = false;
                  this._errored = false;
                  this._storedError = void 0;
                  this._writableController = void 0;
                  this._readableController = void 0;
                  this._transformStreamController = void 0;
                  this._writableDone = false;
                  this._readableClosed = false;
                  this._backpressure = void 0;
                  this._backpressureChangePromise = void 0;
                  this._backpressureChangePromise_resolve = void 0;
                  this._transformStreamController = new TransformStreamDefaultController(this);
                  var startPromise_resolve = void 0;
                  var startPromise = new Promise(function(resolve2) {
                    startPromise_resolve = resolve2;
                  });
                  var source = new TransformStreamSource(this, startPromise);
                  this._readable = new ReadableStream2(source, readableStrategy);
                  var sink = new TransformStreamSink(this, startPromise);
                  this._writable = new WritableStream(sink, writableStrategy);
                  assert(this._writableController !== void 0);
                  assert(this._readableController !== void 0);
                  var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(this._readableController);
                  TransformStreamSetBackpressure(this, desiredSize <= 0);
                  var transformStream = this;
                  var startResult = InvokeOrNoop(transformer, "start", [transformStream._transformStreamController]);
                  startPromise_resolve(startResult);
                  startPromise.catch(function(e) {
                    if (transformStream._errored === false) {
                      transformStream._errored = true;
                      transformStream._storedError = e;
                    }
                  });
                }
                _createClass(TransformStream2, [{
                  key: "readable",
                  get: function get() {
                    if (IsTransformStream(this) === false) {
                      throw streamBrandCheckException("readable");
                    }
                    return this._readable;
                  }
                }, {
                  key: "writable",
                  get: function get() {
                    if (IsTransformStream(this) === false) {
                      throw streamBrandCheckException("writable");
                    }
                    return this._writable;
                  }
                }]);
                return TransformStream2;
              }();
              module4.exports = { TransformStream };
              function defaultControllerBrandCheckException(name) {
                return new TypeError("TransformStreamDefaultController.prototype." + name + " can only be used on a TransformStreamDefaultController");
              }
              function streamBrandCheckException(name) {
                return new TypeError("TransformStream.prototype." + name + " can only be used on a TransformStream");
              }
            }, function(module4, exports4, __w_pdfjs_require__2) {
              module4.exports = __w_pdfjs_require__2(5);
            }]));
          },
          /* 115 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.NetworkPdfManager = exports3.LocalPdfManager = void 0;
            var _util = __w_pdfjs_require__(2);
            var _chunked_stream = __w_pdfjs_require__(116);
            var _document = __w_pdfjs_require__(117);
            var _stream = __w_pdfjs_require__(121);
            var BasePdfManager = function BasePdfManagerClosure() {
              function BasePdfManager2() {
                (0, _util.unreachable)("Cannot initialize BaseManagerManager");
              }
              BasePdfManager2.prototype = {
                get docId() {
                  return this._docId;
                },
                get password() {
                  return this._password;
                },
                get docBaseUrl() {
                  var docBaseUrl = null;
                  if (this._docBaseUrl) {
                    var absoluteUrl = (0, _util.createValidAbsoluteUrl)(this._docBaseUrl);
                    if (absoluteUrl) {
                      docBaseUrl = absoluteUrl.href;
                    } else {
                      (0, _util.warn)('Invalid absolute docBaseUrl: "' + this._docBaseUrl + '".');
                    }
                  }
                  return (0, _util.shadow)(this, "docBaseUrl", docBaseUrl);
                },
                onLoadedStream: function BasePdfManager_onLoadedStream() {
                  throw new _util.NotImplementedException();
                },
                ensureDoc: function BasePdfManager_ensureDoc(prop, args) {
                  return this.ensure(this.pdfDocument, prop, args);
                },
                ensureXRef: function BasePdfManager_ensureXRef(prop, args) {
                  return this.ensure(this.pdfDocument.xref, prop, args);
                },
                ensureCatalog: function BasePdfManager_ensureCatalog(prop, args) {
                  return this.ensure(this.pdfDocument.catalog, prop, args);
                },
                getPage: function BasePdfManager_getPage(pageIndex) {
                  return this.pdfDocument.getPage(pageIndex);
                },
                cleanup: function BasePdfManager_cleanup() {
                  return this.pdfDocument.cleanup();
                },
                ensure: function BasePdfManager_ensure(obj, prop, args) {
                  return new _util.NotImplementedException();
                },
                requestRange: function BasePdfManager_requestRange(begin, end) {
                  return new _util.NotImplementedException();
                },
                requestLoadedStream: function BasePdfManager_requestLoadedStream() {
                  return new _util.NotImplementedException();
                },
                sendProgressiveData: function BasePdfManager_sendProgressiveData(chunk) {
                  return new _util.NotImplementedException();
                },
                updatePassword: function BasePdfManager_updatePassword(password) {
                  this._password = password;
                },
                terminate: function BasePdfManager_terminate() {
                  return new _util.NotImplementedException();
                }
              };
              return BasePdfManager2;
            }();
            var LocalPdfManager = function LocalPdfManagerClosure() {
              function LocalPdfManager2(docId, data, password, evaluatorOptions, docBaseUrl) {
                this._docId = docId;
                this._password = password;
                this._docBaseUrl = docBaseUrl;
                this.evaluatorOptions = evaluatorOptions;
                var stream2 = new _stream.Stream(data);
                this.pdfDocument = new _document.PDFDocument(this, stream2);
                this._loadedStreamCapability = (0, _util.createPromiseCapability)();
                this._loadedStreamCapability.resolve(stream2);
              }
              _util.Util.inherit(LocalPdfManager2, BasePdfManager, {
                ensure: function LocalPdfManager_ensure(obj, prop, args) {
                  return new Promise(function(resolve2, reject2) {
                    try {
                      var value = obj[prop];
                      var result;
                      if (typeof value === "function") {
                        result = value.apply(obj, args);
                      } else {
                        result = value;
                      }
                      resolve2(result);
                    } catch (e) {
                      reject2(e);
                    }
                  });
                },
                requestRange: function LocalPdfManager_requestRange(begin, end) {
                  return Promise.resolve();
                },
                requestLoadedStream: function LocalPdfManager_requestLoadedStream() {
                },
                onLoadedStream: function LocalPdfManager_onLoadedStream() {
                  return this._loadedStreamCapability.promise;
                },
                terminate: function LocalPdfManager_terminate() {
                }
              });
              return LocalPdfManager2;
            }();
            var NetworkPdfManager = function NetworkPdfManagerClosure() {
              function NetworkPdfManager2(docId, pdfNetworkStream, args, evaluatorOptions, docBaseUrl) {
                this._docId = docId;
                this._password = args.password;
                this._docBaseUrl = docBaseUrl;
                this.msgHandler = args.msgHandler;
                this.evaluatorOptions = evaluatorOptions;
                var params = {
                  msgHandler: args.msgHandler,
                  url: args.url,
                  length: args.length,
                  disableAutoFetch: args.disableAutoFetch,
                  rangeChunkSize: args.rangeChunkSize
                };
                this.streamManager = new _chunked_stream.ChunkedStreamManager(pdfNetworkStream, params);
                this.pdfDocument = new _document.PDFDocument(this, this.streamManager.getStream());
              }
              _util.Util.inherit(NetworkPdfManager2, BasePdfManager, {
                ensure: function NetworkPdfManager_ensure(obj, prop, args) {
                  var pdfManager = this;
                  return new Promise(function(resolve2, reject2) {
                    function ensureHelper() {
                      try {
                        var result;
                        var value = obj[prop];
                        if (typeof value === "function") {
                          result = value.apply(obj, args);
                        } else {
                          result = value;
                        }
                        resolve2(result);
                      } catch (e) {
                        if (!(e instanceof _util.MissingDataException)) {
                          reject2(e);
                          return;
                        }
                        pdfManager.streamManager.requestRange(e.begin, e.end).then(ensureHelper, reject2);
                      }
                    }
                    ensureHelper();
                  });
                },
                requestRange: function NetworkPdfManager_requestRange(begin, end) {
                  return this.streamManager.requestRange(begin, end);
                },
                requestLoadedStream: function NetworkPdfManager_requestLoadedStream() {
                  this.streamManager.requestAllChunks();
                },
                sendProgressiveData: function NetworkPdfManager_sendProgressiveData(chunk) {
                  this.streamManager.onReceiveData({ chunk });
                },
                onLoadedStream: function NetworkPdfManager_onLoadedStream() {
                  return this.streamManager.onLoadedStream();
                },
                terminate: function NetworkPdfManager_terminate() {
                  this.streamManager.abort();
                }
              });
              return NetworkPdfManager2;
            }();
            exports3.LocalPdfManager = LocalPdfManager;
            exports3.NetworkPdfManager = NetworkPdfManager;
          },
          /* 116 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.ChunkedStreamManager = exports3.ChunkedStream = void 0;
            var _util = __w_pdfjs_require__(2);
            var ChunkedStream = function ChunkedStreamClosure() {
              function ChunkedStream2(length, chunkSize, manager) {
                this.bytes = new Uint8Array(length);
                this.start = 0;
                this.pos = 0;
                this.end = length;
                this.chunkSize = chunkSize;
                this.loadedChunks = [];
                this.numChunksLoaded = 0;
                this.numChunks = Math.ceil(length / chunkSize);
                this.manager = manager;
                this.progressiveDataLength = 0;
                this.lastSuccessfulEnsureByteChunk = -1;
              }
              ChunkedStream2.prototype = {
                getMissingChunks: function ChunkedStream_getMissingChunks() {
                  var chunks = [];
                  for (var chunk = 0, n = this.numChunks; chunk < n; ++chunk) {
                    if (!this.loadedChunks[chunk]) {
                      chunks.push(chunk);
                    }
                  }
                  return chunks;
                },
                getBaseStreams: function ChunkedStream_getBaseStreams() {
                  return [this];
                },
                allChunksLoaded: function ChunkedStream_allChunksLoaded() {
                  return this.numChunksLoaded === this.numChunks;
                },
                onReceiveData: function ChunkedStream_onReceiveData(begin, chunk) {
                  var end = begin + chunk.byteLength;
                  if (begin % this.chunkSize !== 0) {
                    throw new Error("Bad begin offset: " + begin);
                  }
                  var length = this.bytes.length;
                  if (end % this.chunkSize !== 0 && end !== length) {
                    throw new Error("Bad end offset: " + end);
                  }
                  this.bytes.set(new Uint8Array(chunk), begin);
                  var chunkSize = this.chunkSize;
                  var beginChunk = Math.floor(begin / chunkSize);
                  var endChunk = Math.floor((end - 1) / chunkSize) + 1;
                  var curChunk;
                  for (curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
                    if (!this.loadedChunks[curChunk]) {
                      this.loadedChunks[curChunk] = true;
                      ++this.numChunksLoaded;
                    }
                  }
                },
                onReceiveProgressiveData: function ChunkedStream_onReceiveProgressiveData(data) {
                  var position = this.progressiveDataLength;
                  var beginChunk = Math.floor(position / this.chunkSize);
                  this.bytes.set(new Uint8Array(data), position);
                  position += data.byteLength;
                  this.progressiveDataLength = position;
                  var endChunk = position >= this.end ? this.numChunks : Math.floor(position / this.chunkSize);
                  var curChunk;
                  for (curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
                    if (!this.loadedChunks[curChunk]) {
                      this.loadedChunks[curChunk] = true;
                      ++this.numChunksLoaded;
                    }
                  }
                },
                ensureByte: function ChunkedStream_ensureByte(pos) {
                  var chunk = Math.floor(pos / this.chunkSize);
                  if (chunk === this.lastSuccessfulEnsureByteChunk) {
                    return;
                  }
                  if (!this.loadedChunks[chunk]) {
                    throw new _util.MissingDataException(pos, pos + 1);
                  }
                  this.lastSuccessfulEnsureByteChunk = chunk;
                },
                ensureRange: function ChunkedStream_ensureRange(begin, end) {
                  if (begin >= end) {
                    return;
                  }
                  if (end <= this.progressiveDataLength) {
                    return;
                  }
                  var chunkSize = this.chunkSize;
                  var beginChunk = Math.floor(begin / chunkSize);
                  var endChunk = Math.floor((end - 1) / chunkSize) + 1;
                  for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
                    if (!this.loadedChunks[chunk]) {
                      throw new _util.MissingDataException(begin, end);
                    }
                  }
                },
                nextEmptyChunk: function ChunkedStream_nextEmptyChunk(beginChunk) {
                  var chunk, numChunks = this.numChunks;
                  for (var i = 0; i < numChunks; ++i) {
                    chunk = (beginChunk + i) % numChunks;
                    if (!this.loadedChunks[chunk]) {
                      return chunk;
                    }
                  }
                  return null;
                },
                hasChunk: function ChunkedStream_hasChunk(chunk) {
                  return !!this.loadedChunks[chunk];
                },
                get length() {
                  return this.end - this.start;
                },
                get isEmpty() {
                  return this.length === 0;
                },
                getByte: function ChunkedStream_getByte() {
                  var pos = this.pos;
                  if (pos >= this.end) {
                    return -1;
                  }
                  this.ensureByte(pos);
                  return this.bytes[this.pos++];
                },
                getUint16: function ChunkedStream_getUint16() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  if (b0 === -1 || b1 === -1) {
                    return -1;
                  }
                  return (b0 << 8) + b1;
                },
                getInt32: function ChunkedStream_getInt32() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  var b2 = this.getByte();
                  var b3 = this.getByte();
                  return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                },
                getBytes: function ChunkedStream_getBytes(length) {
                  var bytes = this.bytes;
                  var pos = this.pos;
                  var strEnd = this.end;
                  if (!length) {
                    this.ensureRange(pos, strEnd);
                    return bytes.subarray(pos, strEnd);
                  }
                  var end = pos + length;
                  if (end > strEnd) {
                    end = strEnd;
                  }
                  this.ensureRange(pos, end);
                  this.pos = end;
                  return bytes.subarray(pos, end);
                },
                peekByte: function ChunkedStream_peekByte() {
                  var peekedByte = this.getByte();
                  this.pos--;
                  return peekedByte;
                },
                peekBytes: function ChunkedStream_peekBytes(length) {
                  var bytes = this.getBytes(length);
                  this.pos -= bytes.length;
                  return bytes;
                },
                getByteRange: function ChunkedStream_getBytes(begin, end) {
                  this.ensureRange(begin, end);
                  return this.bytes.subarray(begin, end);
                },
                skip: function ChunkedStream_skip(n) {
                  if (!n) {
                    n = 1;
                  }
                  this.pos += n;
                },
                reset: function ChunkedStream_reset() {
                  this.pos = this.start;
                },
                moveStart: function ChunkedStream_moveStart() {
                  this.start = this.pos;
                },
                makeSubStream: function ChunkedStream_makeSubStream(start, length, dict) {
                  this.ensureRange(start, start + length);
                  function ChunkedStreamSubstream() {
                  }
                  ChunkedStreamSubstream.prototype = Object.create(this);
                  ChunkedStreamSubstream.prototype.getMissingChunks = function() {
                    var chunkSize = this.chunkSize;
                    var beginChunk = Math.floor(this.start / chunkSize);
                    var endChunk = Math.floor((this.end - 1) / chunkSize) + 1;
                    var missingChunks = [];
                    for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
                      if (!this.loadedChunks[chunk]) {
                        missingChunks.push(chunk);
                      }
                    }
                    return missingChunks;
                  };
                  var subStream = new ChunkedStreamSubstream();
                  subStream.pos = subStream.start = start;
                  subStream.end = start + length || this.end;
                  subStream.dict = dict;
                  return subStream;
                }
              };
              return ChunkedStream2;
            }();
            var ChunkedStreamManager = function ChunkedStreamManagerClosure() {
              function ChunkedStreamManager2(pdfNetworkStream, args) {
                var chunkSize = args.rangeChunkSize;
                var length = args.length;
                this.stream = new ChunkedStream(length, chunkSize, this);
                this.length = length;
                this.chunkSize = chunkSize;
                this.pdfNetworkStream = pdfNetworkStream;
                this.url = args.url;
                this.disableAutoFetch = args.disableAutoFetch;
                this.msgHandler = args.msgHandler;
                this.currRequestId = 0;
                this.chunksNeededByRequest = /* @__PURE__ */ Object.create(null);
                this.requestsByChunk = /* @__PURE__ */ Object.create(null);
                this.promisesByRequest = /* @__PURE__ */ Object.create(null);
                this.progressiveDataLength = 0;
                this.aborted = false;
                this._loadedStreamCapability = (0, _util.createPromiseCapability)();
              }
              ChunkedStreamManager2.prototype = {
                onLoadedStream: function ChunkedStreamManager_getLoadedStream() {
                  return this._loadedStreamCapability.promise;
                },
                sendRequest: function ChunkedStreamManager_sendRequest(begin, end) {
                  var _this = this;
                  var rangeReader = this.pdfNetworkStream.getRangeReader(begin, end);
                  if (!rangeReader.isStreamingSupported) {
                    rangeReader.onProgress = this.onProgress.bind(this);
                  }
                  var chunks = [], loaded = 0;
                  var manager = this;
                  var promise = new Promise(function(resolve2, reject2) {
                    var readChunk = function readChunk2(chunk) {
                      try {
                        if (!chunk.done) {
                          var data = chunk.value;
                          chunks.push(data);
                          loaded += (0, _util.arrayByteLength)(data);
                          if (rangeReader.isStreamingSupported) {
                            manager.onProgress({ loaded });
                          }
                          rangeReader.read().then(readChunk2, reject2);
                          return;
                        }
                        var chunkData = (0, _util.arraysToBytes)(chunks);
                        chunks = null;
                        resolve2(chunkData);
                      } catch (e) {
                        reject2(e);
                      }
                    };
                    rangeReader.read().then(readChunk, reject2);
                  });
                  promise.then(function(data) {
                    if (_this.aborted) {
                      return;
                    }
                    _this.onReceiveData({
                      chunk: data,
                      begin
                    });
                  });
                },
                requestAllChunks: function ChunkedStreamManager_requestAllChunks() {
                  var missingChunks = this.stream.getMissingChunks();
                  this._requestChunks(missingChunks);
                  return this._loadedStreamCapability.promise;
                },
                _requestChunks: function ChunkedStreamManager_requestChunks(chunks) {
                  var requestId = this.currRequestId++;
                  var i, ii;
                  var chunksNeeded = /* @__PURE__ */ Object.create(null);
                  this.chunksNeededByRequest[requestId] = chunksNeeded;
                  for (i = 0, ii = chunks.length; i < ii; i++) {
                    if (!this.stream.hasChunk(chunks[i])) {
                      chunksNeeded[chunks[i]] = true;
                    }
                  }
                  if ((0, _util.isEmptyObj)(chunksNeeded)) {
                    return Promise.resolve();
                  }
                  var capability = (0, _util.createPromiseCapability)();
                  this.promisesByRequest[requestId] = capability;
                  var chunksToRequest = [];
                  for (var chunk in chunksNeeded) {
                    chunk = chunk | 0;
                    if (!(chunk in this.requestsByChunk)) {
                      this.requestsByChunk[chunk] = [];
                      chunksToRequest.push(chunk);
                    }
                    this.requestsByChunk[chunk].push(requestId);
                  }
                  if (!chunksToRequest.length) {
                    return capability.promise;
                  }
                  var groupedChunksToRequest = this.groupChunks(chunksToRequest);
                  for (i = 0; i < groupedChunksToRequest.length; ++i) {
                    var groupedChunk = groupedChunksToRequest[i];
                    var begin = groupedChunk.beginChunk * this.chunkSize;
                    var end = Math.min(groupedChunk.endChunk * this.chunkSize, this.length);
                    this.sendRequest(begin, end);
                  }
                  return capability.promise;
                },
                getStream: function ChunkedStreamManager_getStream() {
                  return this.stream;
                },
                requestRange: function ChunkedStreamManager_requestRange(begin, end) {
                  end = Math.min(end, this.length);
                  var beginChunk = this.getBeginChunk(begin);
                  var endChunk = this.getEndChunk(end);
                  var chunks = [];
                  for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
                    chunks.push(chunk);
                  }
                  return this._requestChunks(chunks);
                },
                requestRanges: function ChunkedStreamManager_requestRanges(ranges) {
                  ranges = ranges || [];
                  var chunksToRequest = [];
                  for (var i = 0; i < ranges.length; i++) {
                    var beginChunk = this.getBeginChunk(ranges[i].begin);
                    var endChunk = this.getEndChunk(ranges[i].end);
                    for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
                      if (!chunksToRequest.includes(chunk)) {
                        chunksToRequest.push(chunk);
                      }
                    }
                  }
                  chunksToRequest.sort(function(a, b) {
                    return a - b;
                  });
                  return this._requestChunks(chunksToRequest);
                },
                groupChunks: function ChunkedStreamManager_groupChunks(chunks) {
                  var groupedChunks = [];
                  var beginChunk = -1;
                  var prevChunk = -1;
                  for (var i = 0; i < chunks.length; ++i) {
                    var chunk = chunks[i];
                    if (beginChunk < 0) {
                      beginChunk = chunk;
                    }
                    if (prevChunk >= 0 && prevChunk + 1 !== chunk) {
                      groupedChunks.push({
                        beginChunk,
                        endChunk: prevChunk + 1
                      });
                      beginChunk = chunk;
                    }
                    if (i + 1 === chunks.length) {
                      groupedChunks.push({
                        beginChunk,
                        endChunk: chunk + 1
                      });
                    }
                    prevChunk = chunk;
                  }
                  return groupedChunks;
                },
                onProgress: function ChunkedStreamManager_onProgress(args) {
                  var bytesLoaded = this.stream.numChunksLoaded * this.chunkSize + args.loaded;
                  this.msgHandler.send("DocProgress", {
                    loaded: bytesLoaded,
                    total: this.length
                  });
                },
                onReceiveData: function ChunkedStreamManager_onReceiveData(args) {
                  var chunk = args.chunk;
                  var isProgressive = args.begin === void 0;
                  var begin = isProgressive ? this.progressiveDataLength : args.begin;
                  var end = begin + chunk.byteLength;
                  var beginChunk = Math.floor(begin / this.chunkSize);
                  var endChunk = end < this.length ? Math.floor(end / this.chunkSize) : Math.ceil(end / this.chunkSize);
                  if (isProgressive) {
                    this.stream.onReceiveProgressiveData(chunk);
                    this.progressiveDataLength = end;
                  } else {
                    this.stream.onReceiveData(begin, chunk);
                  }
                  if (this.stream.allChunksLoaded()) {
                    this._loadedStreamCapability.resolve(this.stream);
                  }
                  var loadedRequests = [];
                  var i, requestId;
                  for (chunk = beginChunk; chunk < endChunk; ++chunk) {
                    var requestIds = this.requestsByChunk[chunk] || [];
                    delete this.requestsByChunk[chunk];
                    for (i = 0; i < requestIds.length; ++i) {
                      requestId = requestIds[i];
                      var chunksNeeded = this.chunksNeededByRequest[requestId];
                      if (chunk in chunksNeeded) {
                        delete chunksNeeded[chunk];
                      }
                      if (!(0, _util.isEmptyObj)(chunksNeeded)) {
                        continue;
                      }
                      loadedRequests.push(requestId);
                    }
                  }
                  if (!this.disableAutoFetch && (0, _util.isEmptyObj)(this.requestsByChunk)) {
                    var nextEmptyChunk;
                    if (this.stream.numChunksLoaded === 1) {
                      var lastChunk = this.stream.numChunks - 1;
                      if (!this.stream.hasChunk(lastChunk)) {
                        nextEmptyChunk = lastChunk;
                      }
                    } else {
                      nextEmptyChunk = this.stream.nextEmptyChunk(endChunk);
                    }
                    if (Number.isInteger(nextEmptyChunk)) {
                      this._requestChunks([nextEmptyChunk]);
                    }
                  }
                  for (i = 0; i < loadedRequests.length; ++i) {
                    requestId = loadedRequests[i];
                    var capability = this.promisesByRequest[requestId];
                    delete this.promisesByRequest[requestId];
                    capability.resolve();
                  }
                  this.msgHandler.send("DocProgress", {
                    loaded: this.stream.numChunksLoaded * this.chunkSize,
                    total: this.length
                  });
                },
                onError: function ChunkedStreamManager_onError(err) {
                  this._loadedStreamCapability.reject(err);
                },
                getBeginChunk: function ChunkedStreamManager_getBeginChunk(begin) {
                  var chunk = Math.floor(begin / this.chunkSize);
                  return chunk;
                },
                getEndChunk: function ChunkedStreamManager_getEndChunk(end) {
                  var chunk = Math.floor((end - 1) / this.chunkSize) + 1;
                  return chunk;
                },
                abort: function ChunkedStreamManager_abort() {
                  this.aborted = true;
                  if (this.pdfNetworkStream) {
                    this.pdfNetworkStream.cancelAllRequests("abort");
                  }
                  for (var requestId in this.promisesByRequest) {
                    var capability = this.promisesByRequest[requestId];
                    capability.reject(new Error("Request was aborted"));
                  }
                }
              };
              return ChunkedStreamManager2;
            }();
            exports3.ChunkedStream = ChunkedStream;
            exports3.ChunkedStreamManager = ChunkedStreamManager;
          },
          /* 117 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.PDFDocument = exports3.Page = void 0;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _obj = __w_pdfjs_require__(118);
            var _primitives = __w_pdfjs_require__(119);
            var _util = __w_pdfjs_require__(2);
            var _stream = __w_pdfjs_require__(121);
            var _annotation = __w_pdfjs_require__(133);
            var _crypto = __w_pdfjs_require__(131);
            var _parser = __w_pdfjs_require__(120);
            var _operator_list = __w_pdfjs_require__(134);
            var _evaluator = __w_pdfjs_require__(135);
            var _function = __w_pdfjs_require__(149);
            var Page = function PageClosure() {
              var DEFAULT_USER_UNIT = 1;
              var LETTER_SIZE_MEDIABOX = [0, 0, 612, 792];
              function isAnnotationRenderable(annotation, intent) {
                return intent === "display" && annotation.viewable || intent === "print" && annotation.printable;
              }
              function Page2(_ref) {
                var pdfManager = _ref.pdfManager, xref = _ref.xref, pageIndex = _ref.pageIndex, pageDict = _ref.pageDict, ref = _ref.ref, fontCache = _ref.fontCache, builtInCMapCache = _ref.builtInCMapCache, pdfFunctionFactory = _ref.pdfFunctionFactory;
                this.pdfManager = pdfManager;
                this.pageIndex = pageIndex;
                this.pageDict = pageDict;
                this.xref = xref;
                this.ref = ref;
                this.fontCache = fontCache;
                this.builtInCMapCache = builtInCMapCache;
                this.pdfFunctionFactory = pdfFunctionFactory;
                this.evaluatorOptions = pdfManager.evaluatorOptions;
                this.resourcesPromise = null;
                var uniquePrefix = "p" + this.pageIndex + "_";
                var idCounters = { obj: 0 };
                this.idFactory = {
                  createObjId: function createObjId() {
                    return uniquePrefix + ++idCounters.obj;
                  }
                };
              }
              Page2.prototype = {
                _getInheritableProperty: function _getInheritableProperty(key) {
                  var getArray = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var value = (0, _util.getInheritableProperty)({
                    dict: this.pageDict,
                    key,
                    getArray,
                    stopWhenFound: false
                  });
                  if (!Array.isArray(value)) {
                    return value;
                  }
                  if (value.length === 1 || !(0, _primitives.isDict)(value[0])) {
                    return value[0];
                  }
                  return _primitives.Dict.merge(this.xref, value);
                },
                get content() {
                  return this.pageDict.get("Contents");
                },
                get resources() {
                  return (0, _util.shadow)(this, "resources", this._getInheritableProperty("Resources") || _primitives.Dict.empty);
                },
                get mediaBox() {
                  var mediaBox = this._getInheritableProperty("MediaBox", true);
                  if (!Array.isArray(mediaBox) || mediaBox.length !== 4) {
                    return (0, _util.shadow)(this, "mediaBox", LETTER_SIZE_MEDIABOX);
                  }
                  return (0, _util.shadow)(this, "mediaBox", mediaBox);
                },
                get cropBox() {
                  var cropBox = this._getInheritableProperty("CropBox", true);
                  if (!Array.isArray(cropBox) || cropBox.length !== 4) {
                    return (0, _util.shadow)(this, "cropBox", this.mediaBox);
                  }
                  return (0, _util.shadow)(this, "cropBox", cropBox);
                },
                get userUnit() {
                  var obj = this.pageDict.get("UserUnit");
                  if (!(0, _util.isNum)(obj) || obj <= 0) {
                    obj = DEFAULT_USER_UNIT;
                  }
                  return (0, _util.shadow)(this, "userUnit", obj);
                },
                get view() {
                  var mediaBox = this.mediaBox, cropBox = this.cropBox;
                  if (mediaBox === cropBox) {
                    return (0, _util.shadow)(this, "view", mediaBox);
                  }
                  var intersection = _util.Util.intersect(cropBox, mediaBox);
                  return (0, _util.shadow)(this, "view", intersection || mediaBox);
                },
                get rotate() {
                  var rotate = this._getInheritableProperty("Rotate") || 0;
                  if (rotate % 90 !== 0) {
                    rotate = 0;
                  } else if (rotate >= 360) {
                    rotate = rotate % 360;
                  } else if (rotate < 0) {
                    rotate = (rotate % 360 + 360) % 360;
                  }
                  return (0, _util.shadow)(this, "rotate", rotate);
                },
                getContentStream: function Page_getContentStream() {
                  var content = this.content;
                  var stream2;
                  if (Array.isArray(content)) {
                    var xref = this.xref;
                    var i, n = content.length;
                    var streams = [];
                    for (i = 0; i < n; ++i) {
                      streams.push(xref.fetchIfRef(content[i]));
                    }
                    stream2 = new _stream.StreamsSequenceStream(streams);
                  } else if ((0, _primitives.isStream)(content)) {
                    stream2 = content;
                  } else {
                    stream2 = new _stream.NullStream();
                  }
                  return stream2;
                },
                loadResources: function Page_loadResources(keys) {
                  var _this = this;
                  if (!this.resourcesPromise) {
                    this.resourcesPromise = this.pdfManager.ensure(this, "resources");
                  }
                  return this.resourcesPromise.then(function() {
                    var objectLoader = new _obj.ObjectLoader(_this.resources, keys, _this.xref);
                    return objectLoader.load();
                  });
                },
                getOperatorList: function getOperatorList(_ref2) {
                  var _this2 = this;
                  var handler = _ref2.handler, task = _ref2.task, intent = _ref2.intent, renderInteractiveForms = _ref2.renderInteractiveForms;
                  var contentStreamPromise = this.pdfManager.ensure(this, "getContentStream");
                  var resourcesPromise = this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"]);
                  var partialEvaluator = new _evaluator.PartialEvaluator({
                    pdfManager: this.pdfManager,
                    xref: this.xref,
                    handler,
                    pageIndex: this.pageIndex,
                    idFactory: this.idFactory,
                    fontCache: this.fontCache,
                    builtInCMapCache: this.builtInCMapCache,
                    options: this.evaluatorOptions,
                    pdfFunctionFactory: this.pdfFunctionFactory
                  });
                  var dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
                  var pageListPromise = dataPromises.then(function(_ref3) {
                    var _ref4 = _slicedToArray(_ref3, 1), contentStream = _ref4[0];
                    var opList = new _operator_list.OperatorList(intent, handler, _this2.pageIndex);
                    handler.send("StartRenderPage", {
                      transparency: partialEvaluator.hasBlendModes(_this2.resources),
                      pageIndex: _this2.pageIndex,
                      intent
                    });
                    return partialEvaluator.getOperatorList({
                      stream: contentStream,
                      task,
                      resources: _this2.resources,
                      operatorList: opList
                    }).then(function() {
                      return opList;
                    });
                  });
                  var annotationsPromise = this.pdfManager.ensure(this, "annotations");
                  return Promise.all([pageListPromise, annotationsPromise]).then(function(_ref5) {
                    var _ref6 = _slicedToArray(_ref5, 2), pageOpList = _ref6[0], annotations = _ref6[1];
                    if (annotations.length === 0) {
                      pageOpList.flush(true);
                      return pageOpList;
                    }
                    var i, ii, opListPromises = [];
                    for (i = 0, ii = annotations.length; i < ii; i++) {
                      if (isAnnotationRenderable(annotations[i], intent)) {
                        opListPromises.push(annotations[i].getOperatorList(partialEvaluator, task, renderInteractiveForms));
                      }
                    }
                    return Promise.all(opListPromises).then(function(opLists) {
                      pageOpList.addOp(_util.OPS.beginAnnotations, []);
                      for (i = 0, ii = opLists.length; i < ii; i++) {
                        pageOpList.addOpList(opLists[i]);
                      }
                      pageOpList.addOp(_util.OPS.endAnnotations, []);
                      pageOpList.flush(true);
                      return pageOpList;
                    });
                  });
                },
                extractTextContent: function extractTextContent(_ref7) {
                  var _this3 = this;
                  var handler = _ref7.handler, task = _ref7.task, normalizeWhitespace = _ref7.normalizeWhitespace, sink = _ref7.sink, combineTextItems = _ref7.combineTextItems;
                  var contentStreamPromise = this.pdfManager.ensure(this, "getContentStream");
                  var resourcesPromise = this.loadResources(["ExtGState", "XObject", "Font"]);
                  var dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
                  return dataPromises.then(function(_ref8) {
                    var _ref9 = _slicedToArray(_ref8, 1), contentStream = _ref9[0];
                    var partialEvaluator = new _evaluator.PartialEvaluator({
                      pdfManager: _this3.pdfManager,
                      xref: _this3.xref,
                      handler,
                      pageIndex: _this3.pageIndex,
                      idFactory: _this3.idFactory,
                      fontCache: _this3.fontCache,
                      builtInCMapCache: _this3.builtInCMapCache,
                      options: _this3.evaluatorOptions,
                      pdfFunctionFactory: _this3.pdfFunctionFactory
                    });
                    return partialEvaluator.getTextContent({
                      stream: contentStream,
                      task,
                      resources: _this3.resources,
                      normalizeWhitespace,
                      combineTextItems,
                      sink
                    });
                  });
                },
                getAnnotationsData: function Page_getAnnotationsData(intent) {
                  var annotations = this.annotations;
                  var annotationsData = [];
                  for (var i = 0, n = annotations.length; i < n; ++i) {
                    if (!intent || isAnnotationRenderable(annotations[i], intent)) {
                      annotationsData.push(annotations[i].data);
                    }
                  }
                  return annotationsData;
                },
                get annotations() {
                  var annotations = [];
                  var annotationRefs = this._getInheritableProperty("Annots") || [];
                  for (var i = 0, n = annotationRefs.length; i < n; ++i) {
                    var annotationRef = annotationRefs[i];
                    var annotation = _annotation.AnnotationFactory.create(this.xref, annotationRef, this.pdfManager, this.idFactory);
                    if (annotation) {
                      annotations.push(annotation);
                    }
                  }
                  return (0, _util.shadow)(this, "annotations", annotations);
                }
              };
              return Page2;
            }();
            var PDFDocument = function PDFDocumentClosure() {
              var FINGERPRINT_FIRST_BYTES = 1024;
              var EMPTY_FINGERPRINT = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
              function PDFDocument2(pdfManager, arg) {
                var stream2;
                if ((0, _primitives.isStream)(arg)) {
                  stream2 = arg;
                } else if ((0, _util.isArrayBuffer)(arg)) {
                  stream2 = new _stream.Stream(arg);
                } else {
                  throw new Error("PDFDocument: Unknown argument type");
                }
                if (stream2.length <= 0) {
                  throw new Error("PDFDocument: stream must have data");
                }
                this.pdfManager = pdfManager;
                this.stream = stream2;
                this.xref = new _obj.XRef(stream2, pdfManager);
                var evaluatorOptions = pdfManager.evaluatorOptions;
                this.pdfFunctionFactory = new _function.PDFFunctionFactory({
                  xref: this.xref,
                  isEvalSupported: evaluatorOptions.isEvalSupported
                });
              }
              function find(stream2, needle, limit, backwards) {
                var pos = stream2.pos;
                var end = stream2.end;
                var strBuf = [];
                if (pos + limit > end) {
                  limit = end - pos;
                }
                for (var n = 0; n < limit; ++n) {
                  strBuf.push(String.fromCharCode(stream2.getByte()));
                }
                var str = strBuf.join("");
                stream2.pos = pos;
                var index = backwards ? str.lastIndexOf(needle) : str.indexOf(needle);
                if (index === -1) {
                  return false;
                }
                stream2.pos += index;
                return true;
              }
              var DocumentInfoValidators = {
                get entries() {
                  return (0, _util.shadow)(this, "entries", {
                    Title: _util.isString,
                    Author: _util.isString,
                    Subject: _util.isString,
                    Keywords: _util.isString,
                    Creator: _util.isString,
                    Producer: _util.isString,
                    CreationDate: _util.isString,
                    ModDate: _util.isString,
                    Trapped: _primitives.isName
                  });
                }
              };
              PDFDocument2.prototype = {
                parse: function PDFDocument_parse(recoveryMode) {
                  this.setup(recoveryMode);
                  var version = this.catalog.catDict.get("Version");
                  if ((0, _primitives.isName)(version)) {
                    this.pdfFormatVersion = version.name;
                  }
                  try {
                    this.acroForm = this.catalog.catDict.get("AcroForm");
                    if (this.acroForm) {
                      this.xfa = this.acroForm.get("XFA");
                      var fields = this.acroForm.get("Fields");
                      if ((!fields || !Array.isArray(fields) || fields.length === 0) && !this.xfa) {
                        this.acroForm = null;
                      }
                    }
                  } catch (ex) {
                    if (ex instanceof _util.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.info)("Something wrong with AcroForm entry");
                    this.acroForm = null;
                  }
                },
                get linearization() {
                  var linearization = null;
                  if (this.stream.length) {
                    try {
                      linearization = _parser.Linearization.create(this.stream);
                    } catch (err) {
                      if (err instanceof _util.MissingDataException) {
                        throw err;
                      }
                      (0, _util.info)(err);
                    }
                  }
                  return (0, _util.shadow)(this, "linearization", linearization);
                },
                get startXRef() {
                  var stream2 = this.stream;
                  var startXRef = 0;
                  var linearization = this.linearization;
                  if (linearization) {
                    stream2.reset();
                    if (find(stream2, "endobj", 1024)) {
                      startXRef = stream2.pos + 6;
                    }
                  } else {
                    var step = 1024;
                    var found = false, pos = stream2.end;
                    while (!found && pos > 0) {
                      pos -= step - "startxref".length;
                      if (pos < 0) {
                        pos = 0;
                      }
                      stream2.pos = pos;
                      found = find(stream2, "startxref", step, true);
                    }
                    if (found) {
                      stream2.skip(9);
                      var ch;
                      do {
                        ch = stream2.getByte();
                      } while ((0, _util.isSpace)(ch));
                      var str = "";
                      while (ch >= 32 && ch <= 57) {
                        str += String.fromCharCode(ch);
                        ch = stream2.getByte();
                      }
                      startXRef = parseInt(str, 10);
                      if (isNaN(startXRef)) {
                        startXRef = 0;
                      }
                    }
                  }
                  return (0, _util.shadow)(this, "startXRef", startXRef);
                },
                get mainXRefEntriesOffset() {
                  var mainXRefEntriesOffset = 0;
                  var linearization = this.linearization;
                  if (linearization) {
                    mainXRefEntriesOffset = linearization.mainXRefEntriesOffset;
                  }
                  return (0, _util.shadow)(this, "mainXRefEntriesOffset", mainXRefEntriesOffset);
                },
                checkHeader: function PDFDocument_checkHeader() {
                  var stream2 = this.stream;
                  stream2.reset();
                  if (find(stream2, "%PDF-", 1024)) {
                    stream2.moveStart();
                    var MAX_VERSION_LENGTH = 12;
                    var version = "", ch;
                    while ((ch = stream2.getByte()) > 32) {
                      if (version.length >= MAX_VERSION_LENGTH) {
                        break;
                      }
                      version += String.fromCharCode(ch);
                    }
                    if (!this.pdfFormatVersion) {
                      this.pdfFormatVersion = version.substring(5);
                    }
                    return;
                  }
                },
                parseStartXRef: function PDFDocument_parseStartXRef() {
                  var startXRef = this.startXRef;
                  this.xref.setStartXRef(startXRef);
                },
                setup: function PDFDocument_setup(recoveryMode) {
                  var _this4 = this;
                  this.xref.parse(recoveryMode);
                  var pageFactory = {
                    createPage: function createPage(pageIndex, dict, ref, fontCache, builtInCMapCache) {
                      return new Page({
                        pdfManager: _this4.pdfManager,
                        xref: _this4.xref,
                        pageIndex,
                        pageDict: dict,
                        ref,
                        fontCache,
                        builtInCMapCache,
                        pdfFunctionFactory: _this4.pdfFunctionFactory
                      });
                    }
                  };
                  this.catalog = new _obj.Catalog(this.pdfManager, this.xref, pageFactory);
                },
                get numPages() {
                  var linearization = this.linearization;
                  var num = linearization ? linearization.numPages : this.catalog.numPages;
                  return (0, _util.shadow)(this, "numPages", num);
                },
                get documentInfo() {
                  var docInfo = {
                    PDFFormatVersion: this.pdfFormatVersion,
                    IsAcroFormPresent: !!this.acroForm,
                    IsXFAPresent: !!this.xfa
                  };
                  var infoDict;
                  try {
                    infoDict = this.xref.trailer.get("Info");
                  } catch (err) {
                    if (err instanceof _util.MissingDataException) {
                      throw err;
                    }
                    (0, _util.info)("The document information dictionary is invalid.");
                  }
                  if (infoDict) {
                    var validEntries = DocumentInfoValidators.entries;
                    for (var key in validEntries) {
                      if (infoDict.has(key)) {
                        var value = infoDict.get(key);
                        if (validEntries[key](value)) {
                          docInfo[key] = typeof value !== "string" ? value : (0, _util.stringToPDFString)(value);
                        } else {
                          (0, _util.info)('Bad value in document info for "' + key + '"');
                        }
                      }
                    }
                  }
                  return (0, _util.shadow)(this, "documentInfo", docInfo);
                },
                get fingerprint() {
                  var xref = this.xref, hash, fileID = "";
                  var idArray = xref.trailer.get("ID");
                  if (Array.isArray(idArray) && idArray[0] && (0, _util.isString)(idArray[0]) && idArray[0] !== EMPTY_FINGERPRINT) {
                    hash = (0, _util.stringToBytes)(idArray[0]);
                  } else {
                    if (this.stream.ensureRange) {
                      this.stream.ensureRange(0, Math.min(FINGERPRINT_FIRST_BYTES, this.stream.end));
                    }
                    hash = (0, _crypto.calculateMD5)(this.stream.bytes.subarray(0, FINGERPRINT_FIRST_BYTES), 0, FINGERPRINT_FIRST_BYTES);
                  }
                  for (var i = 0, n = hash.length; i < n; i++) {
                    var hex = hash[i].toString(16);
                    fileID += hex.length === 1 ? "0" + hex : hex;
                  }
                  return (0, _util.shadow)(this, "fingerprint", fileID);
                },
                getPage: function PDFDocument_getPage(pageIndex) {
                  return this.catalog.getPage(pageIndex);
                },
                cleanup: function PDFDocument_cleanup() {
                  return this.catalog.cleanup();
                }
              };
              return PDFDocument2;
            }();
            exports3.Page = Page;
            exports3.PDFDocument = PDFDocument;
          },
          /* 118 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.FileSpec = exports3.XRef = exports3.ObjectLoader = exports3.Catalog = void 0;
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _util = __w_pdfjs_require__(2);
            var _primitives = __w_pdfjs_require__(119);
            var _parser = __w_pdfjs_require__(120);
            var _chunked_stream = __w_pdfjs_require__(116);
            var _crypto = __w_pdfjs_require__(131);
            var _colorspace = __w_pdfjs_require__(132);
            var Catalog = function CatalogClosure() {
              function Catalog2(pdfManager, xref, pageFactory) {
                this.pdfManager = pdfManager;
                this.xref = xref;
                this.catDict = xref.getCatalogObj();
                if (!(0, _primitives.isDict)(this.catDict)) {
                  throw new _util.FormatError("catalog object is not a dictionary");
                }
                this.fontCache = new _primitives.RefSetCache();
                this.builtInCMapCache = /* @__PURE__ */ Object.create(null);
                this.pageKidsCountCache = new _primitives.RefSetCache();
                this.pageFactory = pageFactory;
                this.pagePromises = [];
              }
              Catalog2.prototype = {
                get metadata() {
                  var streamRef = this.catDict.getRaw("Metadata");
                  if (!(0, _primitives.isRef)(streamRef)) {
                    return (0, _util.shadow)(this, "metadata", null);
                  }
                  var encryptMetadata = !this.xref.encrypt ? false : this.xref.encrypt.encryptMetadata;
                  var stream2 = this.xref.fetch(streamRef, !encryptMetadata);
                  var metadata;
                  if (stream2 && (0, _primitives.isDict)(stream2.dict)) {
                    var type = stream2.dict.get("Type");
                    var subtype = stream2.dict.get("Subtype");
                    if ((0, _primitives.isName)(type, "Metadata") && (0, _primitives.isName)(subtype, "XML")) {
                      try {
                        metadata = (0, _util.stringToUTF8String)((0, _util.bytesToString)(stream2.getBytes()));
                      } catch (e) {
                        if (e instanceof _util.MissingDataException) {
                          throw e;
                        }
                        (0, _util.info)("Skipping invalid metadata.");
                      }
                    }
                  }
                  return (0, _util.shadow)(this, "metadata", metadata);
                },
                get toplevelPagesDict() {
                  var pagesObj = this.catDict.get("Pages");
                  if (!(0, _primitives.isDict)(pagesObj)) {
                    throw new _util.FormatError("invalid top-level pages dictionary");
                  }
                  return (0, _util.shadow)(this, "toplevelPagesDict", pagesObj);
                },
                get documentOutline() {
                  var obj = null;
                  try {
                    obj = this.readDocumentOutline();
                  } catch (ex) {
                    if (ex instanceof _util.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)("Unable to read document outline");
                  }
                  return (0, _util.shadow)(this, "documentOutline", obj);
                },
                readDocumentOutline: function Catalog_readDocumentOutline() {
                  var obj = this.catDict.get("Outlines");
                  if (!(0, _primitives.isDict)(obj)) {
                    return null;
                  }
                  obj = obj.getRaw("First");
                  if (!(0, _primitives.isRef)(obj)) {
                    return null;
                  }
                  var root = { items: [] };
                  var queue = [{
                    obj,
                    parent: root
                  }];
                  var processed = new _primitives.RefSet();
                  processed.put(obj);
                  var xref = this.xref, blackColor = new Uint8Array(3);
                  while (queue.length > 0) {
                    var i = queue.shift();
                    var outlineDict = xref.fetchIfRef(i.obj);
                    if (outlineDict === null) {
                      continue;
                    }
                    if (!outlineDict.has("Title")) {
                      throw new _util.FormatError("Invalid outline item");
                    }
                    var data = {
                      url: null,
                      dest: null
                    };
                    Catalog2.parseDestDictionary({
                      destDict: outlineDict,
                      resultObj: data,
                      docBaseUrl: this.pdfManager.docBaseUrl
                    });
                    var title = outlineDict.get("Title");
                    var flags = outlineDict.get("F") || 0;
                    var color = outlineDict.getArray("C"), rgbColor = blackColor;
                    if (Array.isArray(color) && color.length === 3 && (color[0] !== 0 || color[1] !== 0 || color[2] !== 0)) {
                      rgbColor = _colorspace.ColorSpace.singletons.rgb.getRgb(color, 0);
                    }
                    var outlineItem = {
                      dest: data.dest,
                      url: data.url,
                      unsafeUrl: data.unsafeUrl,
                      newWindow: data.newWindow,
                      title: (0, _util.stringToPDFString)(title),
                      color: rgbColor,
                      count: outlineDict.get("Count"),
                      bold: !!(flags & 2),
                      italic: !!(flags & 1),
                      items: []
                    };
                    i.parent.items.push(outlineItem);
                    obj = outlineDict.getRaw("First");
                    if ((0, _primitives.isRef)(obj) && !processed.has(obj)) {
                      queue.push({
                        obj,
                        parent: outlineItem
                      });
                      processed.put(obj);
                    }
                    obj = outlineDict.getRaw("Next");
                    if ((0, _primitives.isRef)(obj) && !processed.has(obj)) {
                      queue.push({
                        obj,
                        parent: i.parent
                      });
                      processed.put(obj);
                    }
                  }
                  return root.items.length > 0 ? root.items : null;
                },
                get numPages() {
                  var obj = this.toplevelPagesDict.get("Count");
                  if (!Number.isInteger(obj)) {
                    throw new _util.FormatError("page count in top level pages object is not an integer");
                  }
                  return (0, _util.shadow)(this, "numPages", obj);
                },
                get destinations() {
                  function fetchDestination(dest) {
                    return (0, _primitives.isDict)(dest) ? dest.get("D") : dest;
                  }
                  var xref = this.xref;
                  var dests = {}, nameTreeRef, nameDictionaryRef;
                  var obj = this.catDict.get("Names");
                  if (obj && obj.has("Dests")) {
                    nameTreeRef = obj.getRaw("Dests");
                  } else if (this.catDict.has("Dests")) {
                    nameDictionaryRef = this.catDict.get("Dests");
                  }
                  if (nameDictionaryRef) {
                    obj = nameDictionaryRef;
                    obj.forEach(function catalogForEach(key, value) {
                      if (!value) {
                        return;
                      }
                      dests[key] = fetchDestination(value);
                    });
                  }
                  if (nameTreeRef) {
                    var nameTree = new NameTree(nameTreeRef, xref);
                    var names = nameTree.getAll();
                    for (var name in names) {
                      dests[name] = fetchDestination(names[name]);
                    }
                  }
                  return (0, _util.shadow)(this, "destinations", dests);
                },
                getDestination: function Catalog_getDestination(destinationId) {
                  function fetchDestination(dest2) {
                    return (0, _primitives.isDict)(dest2) ? dest2.get("D") : dest2;
                  }
                  var xref = this.xref;
                  var dest = null, nameTreeRef, nameDictionaryRef;
                  var obj = this.catDict.get("Names");
                  if (obj && obj.has("Dests")) {
                    nameTreeRef = obj.getRaw("Dests");
                  } else if (this.catDict.has("Dests")) {
                    nameDictionaryRef = this.catDict.get("Dests");
                  }
                  if (nameDictionaryRef) {
                    var value = nameDictionaryRef.get(destinationId);
                    if (value) {
                      dest = fetchDestination(value);
                    }
                  }
                  if (nameTreeRef) {
                    var nameTree = new NameTree(nameTreeRef, xref);
                    dest = fetchDestination(nameTree.get(destinationId));
                  }
                  return dest;
                },
                get pageLabels() {
                  var obj = null;
                  try {
                    obj = this.readPageLabels();
                  } catch (ex) {
                    if (ex instanceof _util.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)("Unable to read page labels.");
                  }
                  return (0, _util.shadow)(this, "pageLabels", obj);
                },
                readPageLabels: function Catalog_readPageLabels() {
                  var obj = this.catDict.getRaw("PageLabels");
                  if (!obj) {
                    return null;
                  }
                  var pageLabels = new Array(this.numPages);
                  var style = null;
                  var prefix = "";
                  var numberTree = new NumberTree(obj, this.xref);
                  var nums = numberTree.getAll();
                  var currentLabel = "", currentIndex = 1;
                  for (var i = 0, ii = this.numPages; i < ii; i++) {
                    if (i in nums) {
                      var labelDict = nums[i];
                      if (!(0, _primitives.isDict)(labelDict)) {
                        throw new _util.FormatError("The PageLabel is not a dictionary.");
                      }
                      if (labelDict.has("Type") && !(0, _primitives.isName)(labelDict.get("Type"), "PageLabel")) {
                        throw new _util.FormatError("Invalid type in PageLabel dictionary.");
                      }
                      if (labelDict.has("S")) {
                        var s = labelDict.get("S");
                        if (!(0, _primitives.isName)(s)) {
                          throw new _util.FormatError("Invalid style in PageLabel dictionary.");
                        }
                        style = s.name;
                      } else {
                        style = null;
                      }
                      if (labelDict.has("P")) {
                        var p = labelDict.get("P");
                        if (!(0, _util.isString)(p)) {
                          throw new _util.FormatError("Invalid prefix in PageLabel dictionary.");
                        }
                        prefix = (0, _util.stringToPDFString)(p);
                      } else {
                        prefix = "";
                      }
                      if (labelDict.has("St")) {
                        var st = labelDict.get("St");
                        if (!(Number.isInteger(st) && st >= 1)) {
                          throw new _util.FormatError("Invalid start in PageLabel dictionary.");
                        }
                        currentIndex = st;
                      } else {
                        currentIndex = 1;
                      }
                    }
                    switch (style) {
                      case "D":
                        currentLabel = currentIndex;
                        break;
                      case "R":
                      case "r":
                        currentLabel = _util.Util.toRoman(currentIndex, style === "r");
                        break;
                      case "A":
                      case "a":
                        var LIMIT = 26;
                        var A_UPPER_CASE = 65, A_LOWER_CASE = 97;
                        var baseCharCode = style === "a" ? A_LOWER_CASE : A_UPPER_CASE;
                        var letterIndex = currentIndex - 1;
                        var character = String.fromCharCode(baseCharCode + letterIndex % LIMIT);
                        var charBuf = [];
                        for (var j = 0, jj = letterIndex / LIMIT | 0; j <= jj; j++) {
                          charBuf.push(character);
                        }
                        currentLabel = charBuf.join("");
                        break;
                      default:
                        if (style) {
                          throw new _util.FormatError('Invalid style "' + style + '" in PageLabel dictionary.');
                        }
                        currentLabel = "";
                    }
                    pageLabels[i] = prefix + currentLabel;
                    currentIndex++;
                  }
                  return pageLabels;
                },
                get pageMode() {
                  var obj = this.catDict.get("PageMode");
                  var pageMode = "UseNone";
                  if ((0, _primitives.isName)(obj)) {
                    switch (obj.name) {
                      case "UseNone":
                      case "UseOutlines":
                      case "UseThumbs":
                      case "FullScreen":
                      case "UseOC":
                      case "UseAttachments":
                        pageMode = obj.name;
                    }
                  }
                  return (0, _util.shadow)(this, "pageMode", pageMode);
                },
                get attachments() {
                  var xref = this.xref;
                  var attachments = null, nameTreeRef;
                  var obj = this.catDict.get("Names");
                  if (obj) {
                    nameTreeRef = obj.getRaw("EmbeddedFiles");
                  }
                  if (nameTreeRef) {
                    var nameTree = new NameTree(nameTreeRef, xref);
                    var names = nameTree.getAll();
                    for (var name in names) {
                      var fs = new FileSpec(names[name], xref);
                      if (!attachments) {
                        attachments = /* @__PURE__ */ Object.create(null);
                      }
                      attachments[(0, _util.stringToPDFString)(name)] = fs.serializable;
                    }
                  }
                  return (0, _util.shadow)(this, "attachments", attachments);
                },
                get javaScript() {
                  var xref = this.xref;
                  var obj = this.catDict.get("Names");
                  var javaScript = null;
                  function appendIfJavaScriptDict(jsDict2) {
                    var type = jsDict2.get("S");
                    if (!(0, _primitives.isName)(type, "JavaScript")) {
                      return;
                    }
                    var js = jsDict2.get("JS");
                    if ((0, _primitives.isStream)(js)) {
                      js = (0, _util.bytesToString)(js.getBytes());
                    } else if (!(0, _util.isString)(js)) {
                      return;
                    }
                    if (!javaScript) {
                      javaScript = [];
                    }
                    javaScript.push((0, _util.stringToPDFString)(js));
                  }
                  if (obj && obj.has("JavaScript")) {
                    var nameTree = new NameTree(obj.getRaw("JavaScript"), xref);
                    var names = nameTree.getAll();
                    for (var name in names) {
                      var jsDict = names[name];
                      if ((0, _primitives.isDict)(jsDict)) {
                        appendIfJavaScriptDict(jsDict);
                      }
                    }
                  }
                  var openactionDict = this.catDict.get("OpenAction");
                  if ((0, _primitives.isDict)(openactionDict, "Action")) {
                    var actionType = openactionDict.get("S");
                    if ((0, _primitives.isName)(actionType, "Named")) {
                      var action = openactionDict.get("N");
                      if ((0, _primitives.isName)(action, "Print")) {
                        if (!javaScript) {
                          javaScript = [];
                        }
                        javaScript.push("print({});");
                      }
                    } else {
                      appendIfJavaScriptDict(openactionDict);
                    }
                  }
                  return (0, _util.shadow)(this, "javaScript", javaScript);
                },
                cleanup: function Catalog_cleanup() {
                  var _this = this;
                  this.pageKidsCountCache.clear();
                  var promises = [];
                  this.fontCache.forEach(function(promise) {
                    promises.push(promise);
                  });
                  return Promise.all(promises).then(function(translatedFonts) {
                    for (var i = 0, ii = translatedFonts.length; i < ii; i++) {
                      var font = translatedFonts[i].dict;
                      delete font.translated;
                    }
                    _this.fontCache.clear();
                    _this.builtInCMapCache = /* @__PURE__ */ Object.create(null);
                  });
                },
                getPage: function Catalog_getPage(pageIndex) {
                  var _this2 = this;
                  if (!(pageIndex in this.pagePromises)) {
                    this.pagePromises[pageIndex] = this.getPageDict(pageIndex).then(function(_ref) {
                      var _ref2 = _slicedToArray(_ref, 2), dict = _ref2[0], ref = _ref2[1];
                      return _this2.pageFactory.createPage(pageIndex, dict, ref, _this2.fontCache, _this2.builtInCMapCache);
                    });
                  }
                  return this.pagePromises[pageIndex];
                },
                getPageDict: function Catalog_getPageDict(pageIndex) {
                  var capability = (0, _util.createPromiseCapability)();
                  var nodesToVisit = [this.catDict.getRaw("Pages")];
                  var count, currentPageIndex = 0;
                  var xref = this.xref, pageKidsCountCache = this.pageKidsCountCache;
                  function next() {
                    while (nodesToVisit.length) {
                      var currentNode = nodesToVisit.pop();
                      if ((0, _primitives.isRef)(currentNode)) {
                        count = pageKidsCountCache.get(currentNode);
                        if (count > 0 && currentPageIndex + count < pageIndex) {
                          currentPageIndex += count;
                          continue;
                        }
                        xref.fetchAsync(currentNode).then(function(obj) {
                          if ((0, _primitives.isDict)(obj, "Page") || (0, _primitives.isDict)(obj) && !obj.has("Kids")) {
                            if (pageIndex === currentPageIndex) {
                              if (currentNode && !pageKidsCountCache.has(currentNode)) {
                                pageKidsCountCache.put(currentNode, 1);
                              }
                              capability.resolve([obj, currentNode]);
                            } else {
                              currentPageIndex++;
                              next();
                            }
                            return;
                          }
                          nodesToVisit.push(obj);
                          next();
                        }, capability.reject);
                        return;
                      }
                      if (!(0, _primitives.isDict)(currentNode)) {
                        capability.reject(new _util.FormatError("page dictionary kid reference points to wrong type of object"));
                        return;
                      }
                      count = currentNode.get("Count");
                      if (Number.isInteger(count) && count >= 0) {
                        var objId = currentNode.objId;
                        if (objId && !pageKidsCountCache.has(objId)) {
                          pageKidsCountCache.put(objId, count);
                        }
                        if (currentPageIndex + count <= pageIndex) {
                          currentPageIndex += count;
                          continue;
                        }
                      }
                      var kids = currentNode.get("Kids");
                      if (!Array.isArray(kids)) {
                        if ((0, _primitives.isName)(currentNode.get("Type"), "Page") || !currentNode.has("Type") && currentNode.has("Contents")) {
                          if (currentPageIndex === pageIndex) {
                            capability.resolve([currentNode, null]);
                            return;
                          }
                          currentPageIndex++;
                          continue;
                        }
                        capability.reject(new _util.FormatError("page dictionary kids object is not an array"));
                        return;
                      }
                      for (var last = kids.length - 1; last >= 0; last--) {
                        nodesToVisit.push(kids[last]);
                      }
                    }
                    capability.reject(new Error("Page index " + pageIndex + " not found."));
                  }
                  next();
                  return capability.promise;
                },
                getPageIndex: function Catalog_getPageIndex(pageRef) {
                  var xref = this.xref;
                  function pagesBeforeRef(kidRef) {
                    var total2 = 0;
                    var parentRef;
                    return xref.fetchAsync(kidRef).then(function(node) {
                      if ((0, _primitives.isRefsEqual)(kidRef, pageRef) && !(0, _primitives.isDict)(node, "Page") && !((0, _primitives.isDict)(node) && !node.has("Type") && node.has("Contents"))) {
                        throw new _util.FormatError("The reference does not point to a /Page Dict.");
                      }
                      if (!node) {
                        return null;
                      }
                      if (!(0, _primitives.isDict)(node)) {
                        throw new _util.FormatError("node must be a Dict.");
                      }
                      parentRef = node.getRaw("Parent");
                      return node.getAsync("Parent");
                    }).then(function(parent) {
                      if (!parent) {
                        return null;
                      }
                      if (!(0, _primitives.isDict)(parent)) {
                        throw new _util.FormatError("parent must be a Dict.");
                      }
                      return parent.getAsync("Kids");
                    }).then(function(kids) {
                      if (!kids) {
                        return null;
                      }
                      var kidPromises = [];
                      var found = false;
                      for (var i = 0; i < kids.length; i++) {
                        var kid = kids[i];
                        if (!(0, _primitives.isRef)(kid)) {
                          throw new _util.FormatError("kid must be a Ref.");
                        }
                        if ((0, _primitives.isRefsEqual)(kid, kidRef)) {
                          found = true;
                          break;
                        }
                        kidPromises.push(xref.fetchAsync(kid).then(function(kid2) {
                          if (!(0, _primitives.isDict)(kid2)) {
                            throw new _util.FormatError("kid node must be a Dict.");
                          }
                          if (kid2.has("Count")) {
                            var count = kid2.get("Count");
                            total2 += count;
                          } else {
                            total2++;
                          }
                        }));
                      }
                      if (!found) {
                        throw new _util.FormatError("kid ref not found in parents kids");
                      }
                      return Promise.all(kidPromises).then(function() {
                        return [total2, parentRef];
                      });
                    });
                  }
                  var total = 0;
                  function next(ref) {
                    return pagesBeforeRef(ref).then(function(args) {
                      if (!args) {
                        return total;
                      }
                      var count = args[0];
                      var parentRef = args[1];
                      total += count;
                      return next(parentRef);
                    });
                  }
                  return next(pageRef);
                }
              };
              Catalog2.parseDestDictionary = function Catalog_parseDestDictionary(params) {
                function addDefaultProtocolToUrl(url2) {
                  if (url2.indexOf("www.") === 0) {
                    return "http://" + url2;
                  }
                  return url2;
                }
                function tryConvertUrlEncoding(url2) {
                  try {
                    return (0, _util.stringToUTF8String)(url2);
                  } catch (e) {
                    return url2;
                  }
                }
                var destDict = params.destDict;
                if (!(0, _primitives.isDict)(destDict)) {
                  (0, _util.warn)('parseDestDictionary: "destDict" must be a dictionary.');
                  return;
                }
                var resultObj = params.resultObj;
                if ((typeof resultObj === "undefined" ? "undefined" : _typeof(resultObj)) !== "object") {
                  (0, _util.warn)('parseDestDictionary: "resultObj" must be an object.');
                  return;
                }
                var docBaseUrl = params.docBaseUrl || null;
                var action = destDict.get("A"), url, dest;
                if (!(0, _primitives.isDict)(action) && destDict.has("Dest")) {
                  action = destDict.get("Dest");
                }
                if ((0, _primitives.isDict)(action)) {
                  var actionType = action.get("S");
                  if (!(0, _primitives.isName)(actionType)) {
                    (0, _util.warn)("parseDestDictionary: Invalid type in Action dictionary.");
                    return;
                  }
                  var actionName = actionType.name;
                  switch (actionName) {
                    case "URI":
                      url = action.get("URI");
                      if ((0, _primitives.isName)(url)) {
                        url = "/" + url.name;
                      } else if ((0, _util.isString)(url)) {
                        url = addDefaultProtocolToUrl(url);
                      }
                      break;
                    case "GoTo":
                      dest = action.get("D");
                      break;
                    case "Launch":
                    case "GoToR":
                      var urlDict = action.get("F");
                      if ((0, _primitives.isDict)(urlDict)) {
                        url = urlDict.get("F") || null;
                      } else if ((0, _util.isString)(urlDict)) {
                        url = urlDict;
                      }
                      var remoteDest = action.get("D");
                      if (remoteDest) {
                        if ((0, _primitives.isName)(remoteDest)) {
                          remoteDest = remoteDest.name;
                        }
                        if ((0, _util.isString)(url)) {
                          var baseUrl = url.split("#")[0];
                          if ((0, _util.isString)(remoteDest)) {
                            url = baseUrl + "#" + remoteDest;
                          } else if (Array.isArray(remoteDest)) {
                            url = baseUrl + "#" + JSON.stringify(remoteDest);
                          }
                        }
                      }
                      var newWindow = action.get("NewWindow");
                      if ((0, _util.isBool)(newWindow)) {
                        resultObj.newWindow = newWindow;
                      }
                      break;
                    case "Named":
                      var namedAction = action.get("N");
                      if ((0, _primitives.isName)(namedAction)) {
                        resultObj.action = namedAction.name;
                      }
                      break;
                    case "JavaScript":
                      var jsAction = action.get("JS"), js;
                      if ((0, _primitives.isStream)(jsAction)) {
                        js = (0, _util.bytesToString)(jsAction.getBytes());
                      } else if ((0, _util.isString)(jsAction)) {
                        js = jsAction;
                      }
                      if (js) {
                        var URL_OPEN_METHODS = ["app.launchURL", "window.open"];
                        var regex = new RegExp("^\\s*(" + URL_OPEN_METHODS.join("|").split(".").join("\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i");
                        var jsUrl = regex.exec((0, _util.stringToPDFString)(js));
                        if (jsUrl && jsUrl[2]) {
                          url = jsUrl[2];
                          if (jsUrl[3] === "true" && jsUrl[1] === "app.launchURL") {
                            resultObj.newWindow = true;
                          }
                          break;
                        }
                      }
                    default:
                      (0, _util.warn)('parseDestDictionary: Unsupported Action type "' + actionName + '".');
                      break;
                  }
                } else if (destDict.has("Dest")) {
                  dest = destDict.get("Dest");
                }
                if ((0, _util.isString)(url)) {
                  url = tryConvertUrlEncoding(url);
                  var absoluteUrl = (0, _util.createValidAbsoluteUrl)(url, docBaseUrl);
                  if (absoluteUrl) {
                    resultObj.url = absoluteUrl.href;
                  }
                  resultObj.unsafeUrl = url;
                }
                if (dest) {
                  if ((0, _primitives.isName)(dest)) {
                    dest = dest.name;
                  }
                  if ((0, _util.isString)(dest) || Array.isArray(dest)) {
                    resultObj.dest = dest;
                  }
                }
              };
              return Catalog2;
            }();
            var XRef = function XRefClosure() {
              function XRef2(stream2, pdfManager) {
                this.stream = stream2;
                this.pdfManager = pdfManager;
                this.entries = [];
                this.xrefstms = /* @__PURE__ */ Object.create(null);
                this.cache = [];
                this.stats = {
                  streamTypes: [],
                  fontTypes: []
                };
              }
              XRef2.prototype = {
                setStartXRef: function XRef_setStartXRef(startXRef) {
                  this.startXRefQueue = [startXRef];
                },
                parse: function XRef_parse(recoveryMode) {
                  var trailerDict;
                  if (!recoveryMode) {
                    trailerDict = this.readXRef();
                  } else {
                    (0, _util.warn)("Indexing all PDF objects");
                    trailerDict = this.indexObjects();
                  }
                  trailerDict.assignXref(this);
                  this.trailer = trailerDict;
                  var encrypt = trailerDict.get("Encrypt");
                  if ((0, _primitives.isDict)(encrypt)) {
                    var ids = trailerDict.get("ID");
                    var fileId = ids && ids.length ? ids[0] : "";
                    encrypt.suppressEncryption = true;
                    this.encrypt = new _crypto.CipherTransformFactory(encrypt, fileId, this.pdfManager.password);
                  }
                  if (!(this.root = trailerDict.get("Root"))) {
                    throw new _util.FormatError("Invalid root reference");
                  }
                },
                processXRefTable: function XRef_processXRefTable(parser) {
                  if (!("tableState" in this)) {
                    this.tableState = {
                      entryNum: 0,
                      streamPos: parser.lexer.stream.pos,
                      parserBuf1: parser.buf1,
                      parserBuf2: parser.buf2
                    };
                  }
                  var obj = this.readXRefTable(parser);
                  if (!(0, _primitives.isCmd)(obj, "trailer")) {
                    throw new _util.FormatError("Invalid XRef table: could not find trailer dictionary");
                  }
                  var dict = parser.getObj();
                  if (!(0, _primitives.isDict)(dict) && dict.dict) {
                    dict = dict.dict;
                  }
                  if (!(0, _primitives.isDict)(dict)) {
                    throw new _util.FormatError("Invalid XRef table: could not parse trailer dictionary");
                  }
                  delete this.tableState;
                  return dict;
                },
                readXRefTable: function XRef_readXRefTable(parser) {
                  var stream2 = parser.lexer.stream;
                  var tableState = this.tableState;
                  stream2.pos = tableState.streamPos;
                  parser.buf1 = tableState.parserBuf1;
                  parser.buf2 = tableState.parserBuf2;
                  var obj;
                  while (true) {
                    if (!("firstEntryNum" in tableState) || !("entryCount" in tableState)) {
                      if ((0, _primitives.isCmd)(obj = parser.getObj(), "trailer")) {
                        break;
                      }
                      tableState.firstEntryNum = obj;
                      tableState.entryCount = parser.getObj();
                    }
                    var first = tableState.firstEntryNum;
                    var count = tableState.entryCount;
                    if (!Number.isInteger(first) || !Number.isInteger(count)) {
                      throw new _util.FormatError("Invalid XRef table: wrong types in subsection header");
                    }
                    for (var i = tableState.entryNum; i < count; i++) {
                      tableState.streamPos = stream2.pos;
                      tableState.entryNum = i;
                      tableState.parserBuf1 = parser.buf1;
                      tableState.parserBuf2 = parser.buf2;
                      var entry = {};
                      entry.offset = parser.getObj();
                      entry.gen = parser.getObj();
                      var type = parser.getObj();
                      if ((0, _primitives.isCmd)(type, "f")) {
                        entry.free = true;
                      } else if ((0, _primitives.isCmd)(type, "n")) {
                        entry.uncompressed = true;
                      }
                      if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) {
                        throw new _util.FormatError("Invalid entry in XRef subsection: " + first + ", " + count);
                      }
                      if (i === 0 && entry.free && first === 1) {
                        first = 0;
                      }
                      if (!this.entries[i + first]) {
                        this.entries[i + first] = entry;
                      }
                    }
                    tableState.entryNum = 0;
                    tableState.streamPos = stream2.pos;
                    tableState.parserBuf1 = parser.buf1;
                    tableState.parserBuf2 = parser.buf2;
                    delete tableState.firstEntryNum;
                    delete tableState.entryCount;
                  }
                  if (this.entries[0] && !this.entries[0].free) {
                    throw new _util.FormatError("Invalid XRef table: unexpected first object");
                  }
                  return obj;
                },
                processXRefStream: function XRef_processXRefStream(stream2) {
                  if (!("streamState" in this)) {
                    var streamParameters = stream2.dict;
                    var byteWidths = streamParameters.get("W");
                    var range = streamParameters.get("Index");
                    if (!range) {
                      range = [0, streamParameters.get("Size")];
                    }
                    this.streamState = {
                      entryRanges: range,
                      byteWidths,
                      entryNum: 0,
                      streamPos: stream2.pos
                    };
                  }
                  this.readXRefStream(stream2);
                  delete this.streamState;
                  return stream2.dict;
                },
                readXRefStream: function XRef_readXRefStream(stream2) {
                  var i, j;
                  var streamState = this.streamState;
                  stream2.pos = streamState.streamPos;
                  var byteWidths = streamState.byteWidths;
                  var typeFieldWidth = byteWidths[0];
                  var offsetFieldWidth = byteWidths[1];
                  var generationFieldWidth = byteWidths[2];
                  var entryRanges = streamState.entryRanges;
                  while (entryRanges.length > 0) {
                    var first = entryRanges[0];
                    var n = entryRanges[1];
                    if (!Number.isInteger(first) || !Number.isInteger(n)) {
                      throw new _util.FormatError("Invalid XRef range fields: " + first + ", " + n);
                    }
                    if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) {
                      throw new _util.FormatError("Invalid XRef entry fields length: " + first + ", " + n);
                    }
                    for (i = streamState.entryNum; i < n; ++i) {
                      streamState.entryNum = i;
                      streamState.streamPos = stream2.pos;
                      var type = 0, offset = 0, generation = 0;
                      for (j = 0; j < typeFieldWidth; ++j) {
                        type = type << 8 | stream2.getByte();
                      }
                      if (typeFieldWidth === 0) {
                        type = 1;
                      }
                      for (j = 0; j < offsetFieldWidth; ++j) {
                        offset = offset << 8 | stream2.getByte();
                      }
                      for (j = 0; j < generationFieldWidth; ++j) {
                        generation = generation << 8 | stream2.getByte();
                      }
                      var entry = {};
                      entry.offset = offset;
                      entry.gen = generation;
                      switch (type) {
                        case 0:
                          entry.free = true;
                          break;
                        case 1:
                          entry.uncompressed = true;
                          break;
                        case 2:
                          break;
                        default:
                          throw new _util.FormatError("Invalid XRef entry type: " + type);
                      }
                      if (!this.entries[first + i]) {
                        this.entries[first + i] = entry;
                      }
                    }
                    streamState.entryNum = 0;
                    streamState.streamPos = stream2.pos;
                    entryRanges.splice(0, 2);
                  }
                },
                indexObjects: function XRef_indexObjects() {
                  var TAB = 9, LF = 10, CR = 13, SPACE = 32;
                  var PERCENT = 37, LT = 60;
                  function readToken(data, offset) {
                    var token2 = "", ch2 = data[offset];
                    while (ch2 !== LF && ch2 !== CR && ch2 !== LT) {
                      if (++offset >= data.length) {
                        break;
                      }
                      token2 += String.fromCharCode(ch2);
                      ch2 = data[offset];
                    }
                    return token2;
                  }
                  function skipUntil(data, offset, what) {
                    var length2 = what.length, dataLength = data.length;
                    var skipped = 0;
                    while (offset < dataLength) {
                      var i2 = 0;
                      while (i2 < length2 && data[offset + i2] === what[i2]) {
                        ++i2;
                      }
                      if (i2 >= length2) {
                        break;
                      }
                      offset++;
                      skipped++;
                    }
                    return skipped;
                  }
                  var objRegExp = /^(\d+)\s+(\d+)\s+obj\b/;
                  var endobjRegExp = /\bendobj[\b\s]$/;
                  var nestedObjRegExp = /\s+(\d+\s+\d+\s+obj[\b\s])$/;
                  var CHECK_CONTENT_LENGTH = 25;
                  var trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);
                  var startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
                  var objBytes = new Uint8Array([111, 98, 106]);
                  var xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);
                  this.entries.length = 0;
                  var stream2 = this.stream;
                  stream2.pos = 0;
                  var buffer = stream2.getBytes();
                  var position = stream2.start, length = buffer.length;
                  var trailers = [], xrefStms = [];
                  while (position < length) {
                    var ch = buffer[position];
                    if (ch === TAB || ch === LF || ch === CR || ch === SPACE) {
                      ++position;
                      continue;
                    }
                    if (ch === PERCENT) {
                      do {
                        ++position;
                        if (position >= length) {
                          break;
                        }
                        ch = buffer[position];
                      } while (ch !== LF && ch !== CR);
                      continue;
                    }
                    var token = readToken(buffer, position);
                    var m;
                    if (token.indexOf("xref") === 0 && (token.length === 4 || /\s/.test(token[4]))) {
                      position += skipUntil(buffer, position, trailerBytes);
                      trailers.push(position);
                      position += skipUntil(buffer, position, startxrefBytes);
                    } else if (m = objRegExp.exec(token)) {
                      if (typeof this.entries[m[1]] === "undefined") {
                        this.entries[m[1]] = {
                          offset: position - stream2.start,
                          gen: m[2] | 0,
                          uncompressed: true
                        };
                      }
                      var contentLength = void 0, startPos = position + token.length;
                      while (startPos < buffer.length) {
                        var endPos = startPos + skipUntil(buffer, startPos, objBytes) + 4;
                        contentLength = endPos - position;
                        var checkPos = Math.max(endPos - CHECK_CONTENT_LENGTH, startPos);
                        var tokenStr = (0, _util.bytesToString)(buffer.subarray(checkPos, endPos));
                        if (endobjRegExp.test(tokenStr)) {
                          break;
                        } else {
                          var objToken = nestedObjRegExp.exec(tokenStr);
                          if (objToken && objToken[1]) {
                            (0, _util.warn)('indexObjects: Found new "obj" inside of another "obj", caused by missing "endobj" -- trying to recover.');
                            contentLength -= objToken[1].length;
                            break;
                          }
                        }
                        startPos += contentLength;
                      }
                      var content = buffer.subarray(position, position + contentLength);
                      var xrefTagOffset = skipUntil(content, 0, xrefBytes);
                      if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {
                        xrefStms.push(position - stream2.start);
                        this.xrefstms[position - stream2.start] = 1;
                      }
                      position += contentLength;
                    } else if (token.indexOf("trailer") === 0 && (token.length === 7 || /\s/.test(token[7]))) {
                      trailers.push(position);
                      position += skipUntil(buffer, position, startxrefBytes);
                    } else {
                      position += token.length + 1;
                    }
                  }
                  var i, ii;
                  for (i = 0, ii = xrefStms.length; i < ii; ++i) {
                    this.startXRefQueue.push(xrefStms[i]);
                    this.readXRef(true);
                  }
                  var dict;
                  for (i = 0, ii = trailers.length; i < ii; ++i) {
                    stream2.pos = trailers[i];
                    var parser = new _parser.Parser(new _parser.Lexer(stream2), true, this, true);
                    var obj = parser.getObj();
                    if (!(0, _primitives.isCmd)(obj, "trailer")) {
                      continue;
                    }
                    dict = parser.getObj();
                    if (!(0, _primitives.isDict)(dict)) {
                      continue;
                    }
                    if (dict.has("ID")) {
                      return dict;
                    }
                  }
                  if (dict) {
                    return dict;
                  }
                  throw new _util.InvalidPDFException("Invalid PDF structure");
                },
                readXRef: function XRef_readXRef(recoveryMode) {
                  var stream2 = this.stream;
                  var startXRefParsedCache = /* @__PURE__ */ Object.create(null);
                  try {
                    while (this.startXRefQueue.length) {
                      var startXRef = this.startXRefQueue[0];
                      if (startXRefParsedCache[startXRef]) {
                        (0, _util.warn)("readXRef - skipping XRef table since it was already parsed.");
                        this.startXRefQueue.shift();
                        continue;
                      }
                      startXRefParsedCache[startXRef] = true;
                      stream2.pos = startXRef + stream2.start;
                      var parser = new _parser.Parser(new _parser.Lexer(stream2), true, this);
                      var obj = parser.getObj();
                      var dict;
                      if ((0, _primitives.isCmd)(obj, "xref")) {
                        dict = this.processXRefTable(parser);
                        if (!this.topDict) {
                          this.topDict = dict;
                        }
                        obj = dict.get("XRefStm");
                        if (Number.isInteger(obj)) {
                          var pos = obj;
                          if (!(pos in this.xrefstms)) {
                            this.xrefstms[pos] = 1;
                            this.startXRefQueue.push(pos);
                          }
                        }
                      } else if (Number.isInteger(obj)) {
                        if (!Number.isInteger(parser.getObj()) || !(0, _primitives.isCmd)(parser.getObj(), "obj") || !(0, _primitives.isStream)(obj = parser.getObj())) {
                          throw new _util.FormatError("Invalid XRef stream");
                        }
                        dict = this.processXRefStream(obj);
                        if (!this.topDict) {
                          this.topDict = dict;
                        }
                        if (!dict) {
                          throw new _util.FormatError("Failed to read XRef stream");
                        }
                      } else {
                        throw new _util.FormatError("Invalid XRef stream header");
                      }
                      obj = dict.get("Prev");
                      if (Number.isInteger(obj)) {
                        this.startXRefQueue.push(obj);
                      } else if ((0, _primitives.isRef)(obj)) {
                        this.startXRefQueue.push(obj.num);
                      }
                      this.startXRefQueue.shift();
                    }
                    return this.topDict;
                  } catch (e) {
                    if (e instanceof _util.MissingDataException) {
                      throw e;
                    }
                    (0, _util.info)("(while reading XRef): " + e);
                  }
                  if (recoveryMode) {
                    return;
                  }
                  throw new _util.XRefParseException();
                },
                getEntry: function XRef_getEntry(i) {
                  var xrefEntry = this.entries[i];
                  if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {
                    return xrefEntry;
                  }
                  return null;
                },
                fetchIfRef: function XRef_fetchIfRef(obj, suppressEncryption) {
                  if (!(0, _primitives.isRef)(obj)) {
                    return obj;
                  }
                  return this.fetch(obj, suppressEncryption);
                },
                fetch: function XRef_fetch(ref, suppressEncryption) {
                  if (!(0, _primitives.isRef)(ref)) {
                    throw new Error("ref object is not a reference");
                  }
                  var num = ref.num;
                  if (num in this.cache) {
                    var cacheEntry = this.cache[num];
                    if (cacheEntry instanceof _primitives.Dict && !cacheEntry.objId) {
                      cacheEntry.objId = ref.toString();
                    }
                    return cacheEntry;
                  }
                  var xrefEntry = this.getEntry(num);
                  if (xrefEntry === null) {
                    return this.cache[num] = null;
                  }
                  if (xrefEntry.uncompressed) {
                    xrefEntry = this.fetchUncompressed(ref, xrefEntry, suppressEncryption);
                  } else {
                    xrefEntry = this.fetchCompressed(xrefEntry, suppressEncryption);
                  }
                  if ((0, _primitives.isDict)(xrefEntry)) {
                    xrefEntry.objId = ref.toString();
                  } else if ((0, _primitives.isStream)(xrefEntry)) {
                    xrefEntry.dict.objId = ref.toString();
                  }
                  return xrefEntry;
                },
                fetchUncompressed: function XRef_fetchUncompressed(ref, xrefEntry, suppressEncryption) {
                  var gen = ref.gen;
                  var num = ref.num;
                  if (xrefEntry.gen !== gen) {
                    throw new _util.FormatError("inconsistent generation in XRef");
                  }
                  var stream2 = this.stream.makeSubStream(xrefEntry.offset + this.stream.start);
                  var parser = new _parser.Parser(new _parser.Lexer(stream2), true, this);
                  var obj1 = parser.getObj();
                  var obj2 = parser.getObj();
                  var obj3 = parser.getObj();
                  if (!Number.isInteger(obj1)) {
                    obj1 = parseInt(obj1, 10);
                  }
                  if (!Number.isInteger(obj2)) {
                    obj2 = parseInt(obj2, 10);
                  }
                  if (obj1 !== num || obj2 !== gen || !(0, _primitives.isCmd)(obj3)) {
                    throw new _util.FormatError("bad XRef entry");
                  }
                  if (obj3.cmd !== "obj") {
                    if (obj3.cmd.indexOf("obj") === 0) {
                      num = parseInt(obj3.cmd.substring(3), 10);
                      if (!Number.isNaN(num)) {
                        return num;
                      }
                    }
                    throw new _util.FormatError("bad XRef entry");
                  }
                  if (this.encrypt && !suppressEncryption) {
                    xrefEntry = parser.getObj(this.encrypt.createCipherTransform(num, gen));
                  } else {
                    xrefEntry = parser.getObj();
                  }
                  if (!(0, _primitives.isStream)(xrefEntry)) {
                    this.cache[num] = xrefEntry;
                  }
                  return xrefEntry;
                },
                fetchCompressed: function XRef_fetchCompressed(xrefEntry, suppressEncryption) {
                  var tableOffset = xrefEntry.offset;
                  var stream2 = this.fetch(new _primitives.Ref(tableOffset, 0));
                  if (!(0, _primitives.isStream)(stream2)) {
                    throw new _util.FormatError("bad ObjStm stream");
                  }
                  var first = stream2.dict.get("First");
                  var n = stream2.dict.get("N");
                  if (!Number.isInteger(first) || !Number.isInteger(n)) {
                    throw new _util.FormatError("invalid first and n parameters for ObjStm stream");
                  }
                  var parser = new _parser.Parser(new _parser.Lexer(stream2), false, this);
                  parser.allowStreams = true;
                  var i, entries = [], num, nums = [];
                  for (i = 0; i < n; ++i) {
                    num = parser.getObj();
                    if (!Number.isInteger(num)) {
                      throw new _util.FormatError("invalid object number in the ObjStm stream: " + num);
                    }
                    nums.push(num);
                    var offset = parser.getObj();
                    if (!Number.isInteger(offset)) {
                      throw new _util.FormatError("invalid object offset in the ObjStm stream: " + offset);
                    }
                  }
                  for (i = 0; i < n; ++i) {
                    entries.push(parser.getObj());
                    if ((0, _primitives.isCmd)(parser.buf1, "endobj")) {
                      parser.shift();
                    }
                    num = nums[i];
                    var entry = this.entries[num];
                    if (entry && entry.offset === tableOffset && entry.gen === i) {
                      this.cache[num] = entries[i];
                    }
                  }
                  xrefEntry = entries[xrefEntry.gen];
                  if (xrefEntry === void 0) {
                    throw new _util.FormatError("bad XRef entry for compressed object");
                  }
                  return xrefEntry;
                },
                fetchIfRefAsync: function XRef_fetchIfRefAsync(obj, suppressEncryption) {
                  if (!(0, _primitives.isRef)(obj)) {
                    return Promise.resolve(obj);
                  }
                  return this.fetchAsync(obj, suppressEncryption);
                },
                fetchAsync: function XRef_fetchAsync(ref, suppressEncryption) {
                  var streamManager = this.stream.manager;
                  var xref = this;
                  return new Promise(function tryFetch(resolve2, reject2) {
                    try {
                      resolve2(xref.fetch(ref, suppressEncryption));
                    } catch (e) {
                      if (e instanceof _util.MissingDataException) {
                        streamManager.requestRange(e.begin, e.end).then(function() {
                          tryFetch(resolve2, reject2);
                        }, reject2);
                        return;
                      }
                      reject2(e);
                    }
                  });
                },
                getCatalogObj: function XRef_getCatalogObj() {
                  return this.root;
                }
              };
              return XRef2;
            }();
            var NameOrNumberTree = function NameOrNumberTreeClosure() {
              function NameOrNumberTree2(root, xref) {
                (0, _util.unreachable)("Cannot initialize NameOrNumberTree.");
              }
              NameOrNumberTree2.prototype = {
                getAll: function NameOrNumberTree_getAll() {
                  var dict = /* @__PURE__ */ Object.create(null);
                  if (!this.root) {
                    return dict;
                  }
                  var xref = this.xref;
                  var processed = new _primitives.RefSet();
                  processed.put(this.root);
                  var queue = [this.root];
                  while (queue.length > 0) {
                    var i, n;
                    var obj = xref.fetchIfRef(queue.shift());
                    if (!(0, _primitives.isDict)(obj)) {
                      continue;
                    }
                    if (obj.has("Kids")) {
                      var kids = obj.get("Kids");
                      for (i = 0, n = kids.length; i < n; i++) {
                        var kid = kids[i];
                        if (processed.has(kid)) {
                          throw new _util.FormatError('Duplicate entry in "' + this._type + '" tree.');
                        }
                        queue.push(kid);
                        processed.put(kid);
                      }
                      continue;
                    }
                    var entries = obj.get(this._type);
                    if (Array.isArray(entries)) {
                      for (i = 0, n = entries.length; i < n; i += 2) {
                        dict[xref.fetchIfRef(entries[i])] = xref.fetchIfRef(entries[i + 1]);
                      }
                    }
                  }
                  return dict;
                },
                get: function NameOrNumberTree_get(key) {
                  if (!this.root) {
                    return null;
                  }
                  var xref = this.xref;
                  var kidsOrEntries = xref.fetchIfRef(this.root);
                  var loopCount = 0;
                  var MAX_LEVELS = 10;
                  var l, r, m;
                  while (kidsOrEntries.has("Kids")) {
                    if (++loopCount > MAX_LEVELS) {
                      (0, _util.warn)('Search depth limit reached for "' + this._type + '" tree.');
                      return null;
                    }
                    var kids = kidsOrEntries.get("Kids");
                    if (!Array.isArray(kids)) {
                      return null;
                    }
                    l = 0;
                    r = kids.length - 1;
                    while (l <= r) {
                      m = l + r >> 1;
                      var kid = xref.fetchIfRef(kids[m]);
                      var limits = kid.get("Limits");
                      if (key < xref.fetchIfRef(limits[0])) {
                        r = m - 1;
                      } else if (key > xref.fetchIfRef(limits[1])) {
                        l = m + 1;
                      } else {
                        kidsOrEntries = xref.fetchIfRef(kids[m]);
                        break;
                      }
                    }
                    if (l > r) {
                      return null;
                    }
                  }
                  var entries = kidsOrEntries.get(this._type);
                  if (Array.isArray(entries)) {
                    l = 0;
                    r = entries.length - 2;
                    while (l <= r) {
                      m = l + r & ~1;
                      var currentKey = xref.fetchIfRef(entries[m]);
                      if (key < currentKey) {
                        r = m - 2;
                      } else if (key > currentKey) {
                        l = m + 2;
                      } else {
                        return xref.fetchIfRef(entries[m + 1]);
                      }
                    }
                  }
                  return null;
                }
              };
              return NameOrNumberTree2;
            }();
            var NameTree = function NameTreeClosure() {
              function NameTree2(root, xref) {
                this.root = root;
                this.xref = xref;
                this._type = "Names";
              }
              _util.Util.inherit(NameTree2, NameOrNumberTree, {});
              return NameTree2;
            }();
            var NumberTree = function NumberTreeClosure() {
              function NumberTree2(root, xref) {
                this.root = root;
                this.xref = xref;
                this._type = "Nums";
              }
              _util.Util.inherit(NumberTree2, NameOrNumberTree, {});
              return NumberTree2;
            }();
            var FileSpec = function FileSpecClosure() {
              function FileSpec2(root, xref) {
                if (!root || !(0, _primitives.isDict)(root)) {
                  return;
                }
                this.xref = xref;
                this.root = root;
                if (root.has("FS")) {
                  this.fs = root.get("FS");
                }
                this.description = root.has("Desc") ? (0, _util.stringToPDFString)(root.get("Desc")) : "";
                if (root.has("RF")) {
                  (0, _util.warn)("Related file specifications are not supported");
                }
                this.contentAvailable = true;
                if (!root.has("EF")) {
                  this.contentAvailable = false;
                  (0, _util.warn)("Non-embedded file specifications are not supported");
                }
              }
              function pickPlatformItem(dict) {
                if (dict.has("UF")) {
                  return dict.get("UF");
                } else if (dict.has("F")) {
                  return dict.get("F");
                } else if (dict.has("Unix")) {
                  return dict.get("Unix");
                } else if (dict.has("Mac")) {
                  return dict.get("Mac");
                } else if (dict.has("DOS")) {
                  return dict.get("DOS");
                }
                return null;
              }
              FileSpec2.prototype = {
                get filename() {
                  if (!this._filename && this.root) {
                    var filename = pickPlatformItem(this.root) || "unnamed";
                    this._filename = (0, _util.stringToPDFString)(filename).replace(/\\\\/g, "\\").replace(/\\\//g, "/").replace(/\\/g, "/");
                  }
                  return this._filename;
                },
                get content() {
                  if (!this.contentAvailable) {
                    return null;
                  }
                  if (!this.contentRef && this.root) {
                    this.contentRef = pickPlatformItem(this.root.get("EF"));
                  }
                  var content = null;
                  if (this.contentRef) {
                    var xref = this.xref;
                    var fileObj = xref.fetchIfRef(this.contentRef);
                    if (fileObj && (0, _primitives.isStream)(fileObj)) {
                      content = fileObj.getBytes();
                    } else {
                      (0, _util.warn)("Embedded file specification points to non-existing/invalid content");
                    }
                  } else {
                    (0, _util.warn)("Embedded file specification does not have a content");
                  }
                  return content;
                },
                get serializable() {
                  return {
                    filename: this.filename,
                    content: this.content
                  };
                }
              };
              return FileSpec2;
            }();
            var ObjectLoader = function() {
              function mayHaveChildren(value) {
                return (0, _primitives.isRef)(value) || (0, _primitives.isDict)(value) || Array.isArray(value) || (0, _primitives.isStream)(value);
              }
              function addChildren(node, nodesToVisit) {
                if ((0, _primitives.isDict)(node) || (0, _primitives.isStream)(node)) {
                  var dict = (0, _primitives.isDict)(node) ? node : node.dict;
                  var dictKeys = dict.getKeys();
                  for (var i = 0, ii = dictKeys.length; i < ii; i++) {
                    var rawValue = dict.getRaw(dictKeys[i]);
                    if (mayHaveChildren(rawValue)) {
                      nodesToVisit.push(rawValue);
                    }
                  }
                } else if (Array.isArray(node)) {
                  for (var _i = 0, _ii = node.length; _i < _ii; _i++) {
                    var value = node[_i];
                    if (mayHaveChildren(value)) {
                      nodesToVisit.push(value);
                    }
                  }
                }
              }
              function ObjectLoader2(dict, keys, xref) {
                this.dict = dict;
                this.keys = keys;
                this.xref = xref;
                this.refSet = null;
                this.capability = null;
              }
              ObjectLoader2.prototype = {
                load: function load() {
                  this.capability = (0, _util.createPromiseCapability)();
                  if (!(this.xref.stream instanceof _chunked_stream.ChunkedStream) || this.xref.stream.getMissingChunks().length === 0) {
                    this.capability.resolve();
                    return this.capability.promise;
                  }
                  var keys = this.keys, dict = this.dict;
                  this.refSet = new _primitives.RefSet();
                  var nodesToVisit = [];
                  for (var i = 0, ii = keys.length; i < ii; i++) {
                    var rawValue = dict.getRaw(keys[i]);
                    if (rawValue !== void 0) {
                      nodesToVisit.push(rawValue);
                    }
                  }
                  this._walk(nodesToVisit);
                  return this.capability.promise;
                },
                _walk: function _walk(nodesToVisit) {
                  var _this3 = this;
                  var nodesToRevisit = [];
                  var pendingRequests = [];
                  while (nodesToVisit.length) {
                    var currentNode = nodesToVisit.pop();
                    if ((0, _primitives.isRef)(currentNode)) {
                      if (this.refSet.has(currentNode)) {
                        continue;
                      }
                      try {
                        this.refSet.put(currentNode);
                        currentNode = this.xref.fetch(currentNode);
                      } catch (ex) {
                        if (!(ex instanceof _util.MissingDataException)) {
                          throw ex;
                        }
                        nodesToRevisit.push(currentNode);
                        pendingRequests.push({
                          begin: ex.begin,
                          end: ex.end
                        });
                      }
                    }
                    if (currentNode && currentNode.getBaseStreams) {
                      var baseStreams = currentNode.getBaseStreams();
                      var foundMissingData = false;
                      for (var i = 0, ii = baseStreams.length; i < ii; i++) {
                        var stream2 = baseStreams[i];
                        if (stream2.getMissingChunks && stream2.getMissingChunks().length) {
                          foundMissingData = true;
                          pendingRequests.push({
                            begin: stream2.start,
                            end: stream2.end
                          });
                        }
                      }
                      if (foundMissingData) {
                        nodesToRevisit.push(currentNode);
                      }
                    }
                    addChildren(currentNode, nodesToVisit);
                  }
                  if (pendingRequests.length) {
                    this.xref.stream.manager.requestRanges(pendingRequests).then(function() {
                      for (var _i2 = 0, _ii2 = nodesToRevisit.length; _i2 < _ii2; _i2++) {
                        var node = nodesToRevisit[_i2];
                        if ((0, _primitives.isRef)(node)) {
                          _this3.refSet.remove(node);
                        }
                      }
                      _this3._walk(nodesToRevisit);
                    }, this.capability.reject);
                    return;
                  }
                  this.refSet = null;
                  this.capability.resolve();
                }
              };
              return ObjectLoader2;
            }();
            exports3.Catalog = Catalog;
            exports3.ObjectLoader = ObjectLoader;
            exports3.XRef = XRef;
            exports3.FileSpec = FileSpec;
          },
          /* 119 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var EOF = {};
            var Name = function NameClosure() {
              function Name2(name) {
                this.name = name;
              }
              Name2.prototype = {};
              var nameCache = /* @__PURE__ */ Object.create(null);
              Name2.get = function Name_get(name) {
                var nameValue = nameCache[name];
                return nameValue ? nameValue : nameCache[name] = new Name2(name);
              };
              return Name2;
            }();
            var Cmd = function CmdClosure() {
              function Cmd2(cmd) {
                this.cmd = cmd;
              }
              Cmd2.prototype = {};
              var cmdCache = /* @__PURE__ */ Object.create(null);
              Cmd2.get = function Cmd_get(cmd) {
                var cmdValue = cmdCache[cmd];
                return cmdValue ? cmdValue : cmdCache[cmd] = new Cmd2(cmd);
              };
              return Cmd2;
            }();
            var Dict = function DictClosure() {
              var nonSerializable = function nonSerializableClosure() {
                return nonSerializable;
              };
              function Dict2(xref) {
                this._map = /* @__PURE__ */ Object.create(null);
                this.xref = xref;
                this.objId = null;
                this.suppressEncryption = false;
                this.__nonSerializable__ = nonSerializable;
              }
              Dict2.prototype = {
                assignXref: function Dict_assignXref(newXref) {
                  this.xref = newXref;
                },
                get: function Dict_get(key1, key2, key3) {
                  var value;
                  var xref = this.xref, suppressEncryption = this.suppressEncryption;
                  if (typeof (value = this._map[key1]) !== "undefined" || key1 in this._map || typeof key2 === "undefined") {
                    return xref ? xref.fetchIfRef(value, suppressEncryption) : value;
                  }
                  if (typeof (value = this._map[key2]) !== "undefined" || key2 in this._map || typeof key3 === "undefined") {
                    return xref ? xref.fetchIfRef(value, suppressEncryption) : value;
                  }
                  value = this._map[key3] || null;
                  return xref ? xref.fetchIfRef(value, suppressEncryption) : value;
                },
                getAsync: function Dict_getAsync(key1, key2, key3) {
                  var value;
                  var xref = this.xref, suppressEncryption = this.suppressEncryption;
                  if (typeof (value = this._map[key1]) !== "undefined" || key1 in this._map || typeof key2 === "undefined") {
                    if (xref) {
                      return xref.fetchIfRefAsync(value, suppressEncryption);
                    }
                    return Promise.resolve(value);
                  }
                  if (typeof (value = this._map[key2]) !== "undefined" || key2 in this._map || typeof key3 === "undefined") {
                    if (xref) {
                      return xref.fetchIfRefAsync(value, suppressEncryption);
                    }
                    return Promise.resolve(value);
                  }
                  value = this._map[key3] || null;
                  if (xref) {
                    return xref.fetchIfRefAsync(value, suppressEncryption);
                  }
                  return Promise.resolve(value);
                },
                getArray: function Dict_getArray(key1, key2, key3) {
                  var value = this.get(key1, key2, key3);
                  var xref = this.xref, suppressEncryption = this.suppressEncryption;
                  if (!Array.isArray(value) || !xref) {
                    return value;
                  }
                  value = value.slice();
                  for (var i = 0, ii = value.length; i < ii; i++) {
                    if (!isRef(value[i])) {
                      continue;
                    }
                    value[i] = xref.fetch(value[i], suppressEncryption);
                  }
                  return value;
                },
                getRaw: function Dict_getRaw(key) {
                  return this._map[key];
                },
                getKeys: function Dict_getKeys() {
                  return Object.keys(this._map);
                },
                set: function Dict_set(key, value) {
                  this._map[key] = value;
                },
                has: function Dict_has(key) {
                  return key in this._map;
                },
                forEach: function Dict_forEach(callback) {
                  for (var key in this._map) {
                    callback(key, this.get(key));
                  }
                }
              };
              Dict2.empty = new Dict2(null);
              Dict2.merge = function(xref, dictArray) {
                var mergedDict = new Dict2(xref);
                for (var i = 0, ii = dictArray.length; i < ii; i++) {
                  var dict = dictArray[i];
                  if (!isDict(dict)) {
                    continue;
                  }
                  for (var keyName in dict._map) {
                    if (mergedDict._map[keyName] !== void 0) {
                      continue;
                    }
                    mergedDict._map[keyName] = dict._map[keyName];
                  }
                }
                return mergedDict;
              };
              return Dict2;
            }();
            var Ref = function RefClosure() {
              function Ref2(num, gen) {
                this.num = num;
                this.gen = gen;
              }
              Ref2.prototype = {
                toString: function Ref_toString() {
                  var str = this.num + "R";
                  if (this.gen !== 0) {
                    str += this.gen;
                  }
                  return str;
                }
              };
              return Ref2;
            }();
            var RefSet = function RefSetClosure() {
              function RefSet2() {
                this.dict = /* @__PURE__ */ Object.create(null);
              }
              RefSet2.prototype = {
                has: function RefSet_has(ref) {
                  return ref.toString() in this.dict;
                },
                put: function RefSet_put(ref) {
                  this.dict[ref.toString()] = true;
                },
                remove: function RefSet_remove(ref) {
                  delete this.dict[ref.toString()];
                }
              };
              return RefSet2;
            }();
            var RefSetCache = function RefSetCacheClosure() {
              function RefSetCache2() {
                this.dict = /* @__PURE__ */ Object.create(null);
              }
              RefSetCache2.prototype = {
                get: function RefSetCache_get(ref) {
                  return this.dict[ref.toString()];
                },
                has: function RefSetCache_has(ref) {
                  return ref.toString() in this.dict;
                },
                put: function RefSetCache_put(ref, obj) {
                  this.dict[ref.toString()] = obj;
                },
                putAlias: function RefSetCache_putAlias(ref, aliasRef) {
                  this.dict[ref.toString()] = this.get(aliasRef);
                },
                forEach: function RefSetCache_forEach(fn, thisArg) {
                  for (var i in this.dict) {
                    fn.call(thisArg, this.dict[i]);
                  }
                },
                clear: function RefSetCache_clear() {
                  this.dict = /* @__PURE__ */ Object.create(null);
                }
              };
              return RefSetCache2;
            }();
            function isEOF(v) {
              return v === EOF;
            }
            function isName(v, name) {
              return v instanceof Name && (name === void 0 || v.name === name);
            }
            function isCmd(v, cmd) {
              return v instanceof Cmd && (cmd === void 0 || v.cmd === cmd);
            }
            function isDict(v, type) {
              return v instanceof Dict && (type === void 0 || isName(v.get("Type"), type));
            }
            function isRef(v) {
              return v instanceof Ref;
            }
            function isRefsEqual(v1, v2) {
              return v1.num === v2.num && v1.gen === v2.gen;
            }
            function isStream(v) {
              return (typeof v === "undefined" ? "undefined" : _typeof(v)) === "object" && v !== null && v.getBytes !== void 0;
            }
            exports3.EOF = EOF;
            exports3.Cmd = Cmd;
            exports3.Dict = Dict;
            exports3.Name = Name;
            exports3.Ref = Ref;
            exports3.RefSet = RefSet;
            exports3.RefSetCache = RefSetCache;
            exports3.isEOF = isEOF;
            exports3.isCmd = isCmd;
            exports3.isDict = isDict;
            exports3.isName = isName;
            exports3.isRef = isRef;
            exports3.isRefsEqual = isRefsEqual;
            exports3.isStream = isStream;
          },
          /* 120 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.Parser = exports3.Linearization = exports3.Lexer = void 0;
            var _stream = __w_pdfjs_require__(121);
            var _util = __w_pdfjs_require__(2);
            var _primitives = __w_pdfjs_require__(119);
            var _ccitt_stream = __w_pdfjs_require__(122);
            var _jbig2_stream = __w_pdfjs_require__(124);
            var _jpeg_stream = __w_pdfjs_require__(127);
            var _jpx_stream = __w_pdfjs_require__(129);
            var MAX_LENGTH_TO_CACHE = 1e3;
            var MAX_ADLER32_LENGTH = 5552;
            function computeAdler32(bytes) {
              var bytesLength = bytes.length;
              if (bytesLength >= MAX_ADLER32_LENGTH) {
                throw new Error("computeAdler32: The input is too large.");
              }
              var a = 1, b = 0;
              for (var i = 0; i < bytesLength; ++i) {
                a += bytes[i] & 255;
                b += a;
              }
              return b % 65521 << 16 | a % 65521;
            }
            var Parser = function ParserClosure() {
              function Parser2(lexer, allowStreams, xref, recoveryMode) {
                this.lexer = lexer;
                this.allowStreams = allowStreams;
                this.xref = xref;
                this.recoveryMode = recoveryMode || false;
                this.imageCache = /* @__PURE__ */ Object.create(null);
                this.refill();
              }
              Parser2.prototype = {
                refill: function Parser_refill() {
                  this.buf1 = this.lexer.getObj();
                  this.buf2 = this.lexer.getObj();
                },
                shift: function Parser_shift() {
                  if ((0, _primitives.isCmd)(this.buf2, "ID")) {
                    this.buf1 = this.buf2;
                    this.buf2 = null;
                  } else {
                    this.buf1 = this.buf2;
                    this.buf2 = this.lexer.getObj();
                  }
                },
                tryShift: function Parser_tryShift() {
                  try {
                    this.shift();
                    return true;
                  } catch (e) {
                    if (e instanceof _util.MissingDataException) {
                      throw e;
                    }
                    return false;
                  }
                },
                getObj: function Parser_getObj(cipherTransform) {
                  var buf1 = this.buf1;
                  this.shift();
                  if (buf1 instanceof _primitives.Cmd) {
                    switch (buf1.cmd) {
                      case "BI":
                        return this.makeInlineImage(cipherTransform);
                      case "[":
                        var array = [];
                        while (!(0, _primitives.isCmd)(this.buf1, "]") && !(0, _primitives.isEOF)(this.buf1)) {
                          array.push(this.getObj(cipherTransform));
                        }
                        if ((0, _primitives.isEOF)(this.buf1)) {
                          if (!this.recoveryMode) {
                            throw new _util.FormatError("End of file inside array");
                          }
                          return array;
                        }
                        this.shift();
                        return array;
                      case "<<":
                        var dict = new _primitives.Dict(this.xref);
                        while (!(0, _primitives.isCmd)(this.buf1, ">>") && !(0, _primitives.isEOF)(this.buf1)) {
                          if (!(0, _primitives.isName)(this.buf1)) {
                            (0, _util.info)("Malformed dictionary: key must be a name object");
                            this.shift();
                            continue;
                          }
                          var key = this.buf1.name;
                          this.shift();
                          if ((0, _primitives.isEOF)(this.buf1)) {
                            break;
                          }
                          dict.set(key, this.getObj(cipherTransform));
                        }
                        if ((0, _primitives.isEOF)(this.buf1)) {
                          if (!this.recoveryMode) {
                            throw new _util.FormatError("End of file inside dictionary");
                          }
                          return dict;
                        }
                        if ((0, _primitives.isCmd)(this.buf2, "stream")) {
                          return this.allowStreams ? this.makeStream(dict, cipherTransform) : dict;
                        }
                        this.shift();
                        return dict;
                      default:
                        return buf1;
                    }
                  }
                  if (Number.isInteger(buf1)) {
                    var num = buf1;
                    if (Number.isInteger(this.buf1) && (0, _primitives.isCmd)(this.buf2, "R")) {
                      var ref = new _primitives.Ref(num, this.buf1);
                      this.shift();
                      this.shift();
                      return ref;
                    }
                    return num;
                  }
                  if ((0, _util.isString)(buf1)) {
                    var str = buf1;
                    if (cipherTransform) {
                      str = cipherTransform.decryptString(str);
                    }
                    return str;
                  }
                  return buf1;
                },
                findDefaultInlineStreamEnd: function findDefaultInlineStreamEnd(stream2) {
                  var E = 69, I = 73, SPACE = 32, LF = 10, CR = 13;
                  var n = 10, NUL = 0;
                  var startPos = stream2.pos, state = 0, ch = void 0, maybeEIPos = void 0;
                  while ((ch = stream2.getByte()) !== -1) {
                    if (state === 0) {
                      state = ch === E ? 1 : 0;
                    } else if (state === 1) {
                      state = ch === I ? 2 : 0;
                    } else {
                      (0, _util.assert)(state === 2);
                      if (ch === SPACE || ch === LF || ch === CR) {
                        maybeEIPos = stream2.pos;
                        var followingBytes = stream2.peekBytes(n);
                        for (var i = 0, ii = followingBytes.length; i < ii; i++) {
                          ch = followingBytes[i];
                          if (ch === NUL && followingBytes[i + 1] !== NUL) {
                            continue;
                          }
                          if (ch !== LF && ch !== CR && (ch < SPACE || ch > 127)) {
                            state = 0;
                            break;
                          }
                        }
                        if (state === 2) {
                          break;
                        }
                      } else {
                        state = 0;
                      }
                    }
                  }
                  if (ch === -1) {
                    (0, _util.warn)("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker");
                    if (maybeEIPos) {
                      (0, _util.warn)('... trying to recover by using the last "EI" occurrence.');
                      stream2.skip(-(stream2.pos - maybeEIPos));
                    }
                  }
                  return stream2.pos - 4 - startPos;
                },
                findDCTDecodeInlineStreamEnd: function Parser_findDCTDecodeInlineStreamEnd(stream2) {
                  var startPos = stream2.pos, foundEOI = false, b, markerLength, length;
                  while ((b = stream2.getByte()) !== -1) {
                    if (b !== 255) {
                      continue;
                    }
                    switch (stream2.getByte()) {
                      case 0:
                        break;
                      case 255:
                        stream2.skip(-1);
                        break;
                      case 217:
                        foundEOI = true;
                        break;
                      case 192:
                      case 193:
                      case 194:
                      case 195:
                      case 197:
                      case 198:
                      case 199:
                      case 201:
                      case 202:
                      case 203:
                      case 205:
                      case 206:
                      case 207:
                      case 196:
                      case 204:
                      case 218:
                      case 219:
                      case 220:
                      case 221:
                      case 222:
                      case 223:
                      case 224:
                      case 225:
                      case 226:
                      case 227:
                      case 228:
                      case 229:
                      case 230:
                      case 231:
                      case 232:
                      case 233:
                      case 234:
                      case 235:
                      case 236:
                      case 237:
                      case 238:
                      case 239:
                      case 254:
                        markerLength = stream2.getUint16();
                        if (markerLength > 2) {
                          stream2.skip(markerLength - 2);
                        } else {
                          stream2.skip(-2);
                        }
                        break;
                    }
                    if (foundEOI) {
                      break;
                    }
                  }
                  length = stream2.pos - startPos;
                  if (b === -1) {
                    (0, _util.warn)("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead.");
                    stream2.skip(-length);
                    return this.findDefaultInlineStreamEnd(stream2);
                  }
                  this.inlineStreamSkipEI(stream2);
                  return length;
                },
                findASCII85DecodeInlineStreamEnd: function Parser_findASCII85DecodeInlineStreamEnd(stream2) {
                  var TILDE = 126, GT = 62;
                  var startPos = stream2.pos, ch, length;
                  while ((ch = stream2.getByte()) !== -1) {
                    if (ch === TILDE && stream2.peekByte() === GT) {
                      stream2.skip();
                      break;
                    }
                  }
                  length = stream2.pos - startPos;
                  if (ch === -1) {
                    (0, _util.warn)("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead.");
                    stream2.skip(-length);
                    return this.findDefaultInlineStreamEnd(stream2);
                  }
                  this.inlineStreamSkipEI(stream2);
                  return length;
                },
                findASCIIHexDecodeInlineStreamEnd: function Parser_findASCIIHexDecodeInlineStreamEnd(stream2) {
                  var GT = 62;
                  var startPos = stream2.pos, ch, length;
                  while ((ch = stream2.getByte()) !== -1) {
                    if (ch === GT) {
                      break;
                    }
                  }
                  length = stream2.pos - startPos;
                  if (ch === -1) {
                    (0, _util.warn)("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead.");
                    stream2.skip(-length);
                    return this.findDefaultInlineStreamEnd(stream2);
                  }
                  this.inlineStreamSkipEI(stream2);
                  return length;
                },
                inlineStreamSkipEI: function Parser_inlineStreamSkipEI(stream2) {
                  var E = 69, I = 73;
                  var state = 0, ch;
                  while ((ch = stream2.getByte()) !== -1) {
                    if (state === 0) {
                      state = ch === E ? 1 : 0;
                    } else if (state === 1) {
                      state = ch === I ? 2 : 0;
                    } else if (state === 2) {
                      break;
                    }
                  }
                },
                makeInlineImage: function Parser_makeInlineImage(cipherTransform) {
                  var lexer = this.lexer;
                  var stream2 = lexer.stream;
                  var dict = new _primitives.Dict(this.xref), dictLength = void 0;
                  while (!(0, _primitives.isCmd)(this.buf1, "ID") && !(0, _primitives.isEOF)(this.buf1)) {
                    if (!(0, _primitives.isName)(this.buf1)) {
                      throw new _util.FormatError("Dictionary key must be a name object");
                    }
                    var key = this.buf1.name;
                    this.shift();
                    if ((0, _primitives.isEOF)(this.buf1)) {
                      break;
                    }
                    dict.set(key, this.getObj(cipherTransform));
                  }
                  if (lexer.beginInlineImagePos !== -1) {
                    dictLength = stream2.pos - lexer.beginInlineImagePos;
                  }
                  var filter = dict.get("Filter", "F"), filterName;
                  if ((0, _primitives.isName)(filter)) {
                    filterName = filter.name;
                  } else if (Array.isArray(filter)) {
                    var filterZero = this.xref.fetchIfRef(filter[0]);
                    if ((0, _primitives.isName)(filterZero)) {
                      filterName = filterZero.name;
                    }
                  }
                  var startPos = stream2.pos, length = void 0;
                  if (filterName === "DCTDecode" || filterName === "DCT") {
                    length = this.findDCTDecodeInlineStreamEnd(stream2);
                  } else if (filterName === "ASCII85Decode" || filterName === "A85") {
                    length = this.findASCII85DecodeInlineStreamEnd(stream2);
                  } else if (filterName === "ASCIIHexDecode" || filterName === "AHx") {
                    length = this.findASCIIHexDecodeInlineStreamEnd(stream2);
                  } else {
                    length = this.findDefaultInlineStreamEnd(stream2);
                  }
                  var imageStream = stream2.makeSubStream(startPos, length, dict);
                  var cacheKey = void 0;
                  if (length < MAX_LENGTH_TO_CACHE && dictLength < MAX_ADLER32_LENGTH) {
                    var imageBytes = imageStream.getBytes();
                    imageStream.reset();
                    var initialStreamPos = stream2.pos;
                    stream2.pos = lexer.beginInlineImagePos;
                    var dictBytes = stream2.getBytes(dictLength);
                    stream2.pos = initialStreamPos;
                    cacheKey = computeAdler32(imageBytes) + "_" + computeAdler32(dictBytes);
                    var cacheEntry = this.imageCache[cacheKey];
                    if (cacheEntry !== void 0) {
                      this.buf2 = _primitives.Cmd.get("EI");
                      this.shift();
                      cacheEntry.reset();
                      return cacheEntry;
                    }
                  }
                  if (cipherTransform) {
                    imageStream = cipherTransform.createStream(imageStream, length);
                  }
                  imageStream = this.filter(imageStream, dict, length);
                  imageStream.dict = dict;
                  if (cacheKey !== void 0) {
                    imageStream.cacheKey = "inline_" + length + "_" + cacheKey;
                    this.imageCache[cacheKey] = imageStream;
                  }
                  this.buf2 = _primitives.Cmd.get("EI");
                  this.shift();
                  return imageStream;
                },
                makeStream: function Parser_makeStream(dict, cipherTransform) {
                  var lexer = this.lexer;
                  var stream2 = lexer.stream;
                  lexer.skipToNextLine();
                  var pos = stream2.pos - 1;
                  var length = dict.get("Length");
                  if (!Number.isInteger(length)) {
                    (0, _util.info)("Bad " + length + " attribute in stream");
                    length = 0;
                  }
                  stream2.pos = pos + length;
                  lexer.nextChar();
                  if (this.tryShift() && (0, _primitives.isCmd)(this.buf2, "endstream")) {
                    this.shift();
                  } else {
                    stream2.pos = pos;
                    var SCAN_BLOCK_SIZE = 2048;
                    var ENDSTREAM_SIGNATURE_LENGTH = 9;
                    var ENDSTREAM_SIGNATURE = [101, 110, 100, 115, 116, 114, 101, 97, 109];
                    var skipped = 0, found = false, i, j;
                    while (stream2.pos < stream2.end) {
                      var scanBytes = stream2.peekBytes(SCAN_BLOCK_SIZE);
                      var scanLength = scanBytes.length - ENDSTREAM_SIGNATURE_LENGTH;
                      if (scanLength <= 0) {
                        break;
                      }
                      found = false;
                      i = 0;
                      while (i < scanLength) {
                        j = 0;
                        while (j < ENDSTREAM_SIGNATURE_LENGTH && scanBytes[i + j] === ENDSTREAM_SIGNATURE[j]) {
                          j++;
                        }
                        if (j >= ENDSTREAM_SIGNATURE_LENGTH) {
                          found = true;
                          break;
                        }
                        i++;
                      }
                      if (found) {
                        skipped += i;
                        stream2.pos += i;
                        break;
                      }
                      skipped += scanLength;
                      stream2.pos += scanLength;
                    }
                    if (!found) {
                      throw new _util.FormatError("Missing endstream");
                    }
                    length = skipped;
                    lexer.nextChar();
                    this.shift();
                    this.shift();
                  }
                  this.shift();
                  stream2 = stream2.makeSubStream(pos, length, dict);
                  if (cipherTransform) {
                    stream2 = cipherTransform.createStream(stream2, length);
                  }
                  stream2 = this.filter(stream2, dict, length);
                  stream2.dict = dict;
                  return stream2;
                },
                filter: function Parser_filter(stream2, dict, length) {
                  var filter = dict.get("Filter", "F");
                  var params = dict.get("DecodeParms", "DP");
                  if ((0, _primitives.isName)(filter)) {
                    if (Array.isArray(params)) {
                      (0, _util.warn)("/DecodeParms should not contain an Array, when /Filter contains a Name.");
                    }
                    return this.makeFilter(stream2, filter.name, length, params);
                  }
                  var maybeLength = length;
                  if (Array.isArray(filter)) {
                    var filterArray = filter;
                    var paramsArray = params;
                    for (var i = 0, ii = filterArray.length; i < ii; ++i) {
                      filter = this.xref.fetchIfRef(filterArray[i]);
                      if (!(0, _primitives.isName)(filter)) {
                        throw new _util.FormatError("Bad filter name: " + filter);
                      }
                      params = null;
                      if (Array.isArray(paramsArray) && i in paramsArray) {
                        params = this.xref.fetchIfRef(paramsArray[i]);
                      }
                      stream2 = this.makeFilter(stream2, filter.name, maybeLength, params);
                      maybeLength = null;
                    }
                  }
                  return stream2;
                },
                makeFilter: function Parser_makeFilter(stream2, name, maybeLength, params) {
                  if (maybeLength === 0) {
                    (0, _util.warn)('Empty "' + name + '" stream.');
                    return new _stream.NullStream();
                  }
                  try {
                    var xrefStreamStats = this.xref.stats.streamTypes;
                    if (name === "FlateDecode" || name === "Fl") {
                      xrefStreamStats[_util.StreamType.FLATE] = true;
                      if (params) {
                        return new _stream.PredictorStream(new _stream.FlateStream(stream2, maybeLength), maybeLength, params);
                      }
                      return new _stream.FlateStream(stream2, maybeLength);
                    }
                    if (name === "LZWDecode" || name === "LZW") {
                      xrefStreamStats[_util.StreamType.LZW] = true;
                      var earlyChange = 1;
                      if (params) {
                        if (params.has("EarlyChange")) {
                          earlyChange = params.get("EarlyChange");
                        }
                        return new _stream.PredictorStream(new _stream.LZWStream(stream2, maybeLength, earlyChange), maybeLength, params);
                      }
                      return new _stream.LZWStream(stream2, maybeLength, earlyChange);
                    }
                    if (name === "DCTDecode" || name === "DCT") {
                      xrefStreamStats[_util.StreamType.DCT] = true;
                      return new _jpeg_stream.JpegStream(stream2, maybeLength, stream2.dict, params);
                    }
                    if (name === "JPXDecode" || name === "JPX") {
                      xrefStreamStats[_util.StreamType.JPX] = true;
                      return new _jpx_stream.JpxStream(stream2, maybeLength, stream2.dict, params);
                    }
                    if (name === "ASCII85Decode" || name === "A85") {
                      xrefStreamStats[_util.StreamType.A85] = true;
                      return new _stream.Ascii85Stream(stream2, maybeLength);
                    }
                    if (name === "ASCIIHexDecode" || name === "AHx") {
                      xrefStreamStats[_util.StreamType.AHX] = true;
                      return new _stream.AsciiHexStream(stream2, maybeLength);
                    }
                    if (name === "CCITTFaxDecode" || name === "CCF") {
                      xrefStreamStats[_util.StreamType.CCF] = true;
                      return new _ccitt_stream.CCITTFaxStream(stream2, maybeLength, params);
                    }
                    if (name === "RunLengthDecode" || name === "RL") {
                      xrefStreamStats[_util.StreamType.RL] = true;
                      return new _stream.RunLengthStream(stream2, maybeLength);
                    }
                    if (name === "JBIG2Decode") {
                      xrefStreamStats[_util.StreamType.JBIG] = true;
                      return new _jbig2_stream.Jbig2Stream(stream2, maybeLength, stream2.dict, params);
                    }
                    (0, _util.warn)('filter "' + name + '" not supported yet');
                    return stream2;
                  } catch (ex) {
                    if (ex instanceof _util.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)('Invalid stream: "' + ex + '"');
                    return new _stream.NullStream();
                  }
                }
              };
              return Parser2;
            }();
            var Lexer = function LexerClosure() {
              function Lexer2(stream2, knownCommands) {
                this.stream = stream2;
                this.nextChar();
                this.strBuf = [];
                this.knownCommands = knownCommands;
                this.beginInlineImagePos = -1;
              }
              var specialChars = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              function toHexDigit(ch) {
                if (ch >= 48 && ch <= 57) {
                  return ch & 15;
                }
                if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
                  return (ch & 15) + 9;
                }
                return -1;
              }
              Lexer2.prototype = {
                nextChar: function Lexer_nextChar() {
                  return this.currentChar = this.stream.getByte();
                },
                peekChar: function Lexer_peekChar() {
                  return this.stream.peekByte();
                },
                getNumber: function Lexer_getNumber() {
                  var ch = this.currentChar;
                  var eNotation = false;
                  var divideBy = 0;
                  var sign = 1;
                  if (ch === 45) {
                    sign = -1;
                    ch = this.nextChar();
                    if (ch === 45) {
                      ch = this.nextChar();
                    }
                  } else if (ch === 43) {
                    ch = this.nextChar();
                  }
                  if (ch === 46) {
                    divideBy = 10;
                    ch = this.nextChar();
                  }
                  if (ch === 10 || ch === 13) {
                    do {
                      ch = this.nextChar();
                    } while (ch === 10 || ch === 13);
                  }
                  if (ch < 48 || ch > 57) {
                    throw new _util.FormatError("Invalid number: " + String.fromCharCode(ch) + " (charCode " + ch + ")");
                  }
                  var baseValue = ch - 48;
                  var powerValue = 0;
                  var powerValueSign = 1;
                  while ((ch = this.nextChar()) >= 0) {
                    if (48 <= ch && ch <= 57) {
                      var currentDigit = ch - 48;
                      if (eNotation) {
                        powerValue = powerValue * 10 + currentDigit;
                      } else {
                        if (divideBy !== 0) {
                          divideBy *= 10;
                        }
                        baseValue = baseValue * 10 + currentDigit;
                      }
                    } else if (ch === 46) {
                      if (divideBy === 0) {
                        divideBy = 1;
                      } else {
                        break;
                      }
                    } else if (ch === 45) {
                      (0, _util.warn)("Badly formatted number");
                    } else if (ch === 69 || ch === 101) {
                      ch = this.peekChar();
                      if (ch === 43 || ch === 45) {
                        powerValueSign = ch === 45 ? -1 : 1;
                        this.nextChar();
                      } else if (ch < 48 || ch > 57) {
                        break;
                      }
                      eNotation = true;
                    } else {
                      break;
                    }
                  }
                  if (divideBy !== 0) {
                    baseValue /= divideBy;
                  }
                  if (eNotation) {
                    baseValue *= Math.pow(10, powerValueSign * powerValue);
                  }
                  return sign * baseValue;
                },
                getString: function Lexer_getString() {
                  var numParen = 1;
                  var done = false;
                  var strBuf = this.strBuf;
                  strBuf.length = 0;
                  var ch = this.nextChar();
                  while (true) {
                    var charBuffered = false;
                    switch (ch | 0) {
                      case -1:
                        (0, _util.warn)("Unterminated string");
                        done = true;
                        break;
                      case 40:
                        ++numParen;
                        strBuf.push("(");
                        break;
                      case 41:
                        if (--numParen === 0) {
                          this.nextChar();
                          done = true;
                        } else {
                          strBuf.push(")");
                        }
                        break;
                      case 92:
                        ch = this.nextChar();
                        switch (ch) {
                          case -1:
                            (0, _util.warn)("Unterminated string");
                            done = true;
                            break;
                          case 110:
                            strBuf.push("\n");
                            break;
                          case 114:
                            strBuf.push("\r");
                            break;
                          case 116:
                            strBuf.push("	");
                            break;
                          case 98:
                            strBuf.push("\b");
                            break;
                          case 102:
                            strBuf.push("\f");
                            break;
                          case 92:
                          case 40:
                          case 41:
                            strBuf.push(String.fromCharCode(ch));
                            break;
                          case 48:
                          case 49:
                          case 50:
                          case 51:
                          case 52:
                          case 53:
                          case 54:
                          case 55:
                            var x = ch & 15;
                            ch = this.nextChar();
                            charBuffered = true;
                            if (ch >= 48 && ch <= 55) {
                              x = (x << 3) + (ch & 15);
                              ch = this.nextChar();
                              if (ch >= 48 && ch <= 55) {
                                charBuffered = false;
                                x = (x << 3) + (ch & 15);
                              }
                            }
                            strBuf.push(String.fromCharCode(x));
                            break;
                          case 13:
                            if (this.peekChar() === 10) {
                              this.nextChar();
                            }
                            break;
                          case 10:
                            break;
                          default:
                            strBuf.push(String.fromCharCode(ch));
                            break;
                        }
                        break;
                      default:
                        strBuf.push(String.fromCharCode(ch));
                        break;
                    }
                    if (done) {
                      break;
                    }
                    if (!charBuffered) {
                      ch = this.nextChar();
                    }
                  }
                  return strBuf.join("");
                },
                getName: function Lexer_getName() {
                  var ch, previousCh;
                  var strBuf = this.strBuf;
                  strBuf.length = 0;
                  while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
                    if (ch === 35) {
                      ch = this.nextChar();
                      if (specialChars[ch]) {
                        (0, _util.warn)("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number.");
                        strBuf.push("#");
                        break;
                      }
                      var x = toHexDigit(ch);
                      if (x !== -1) {
                        previousCh = ch;
                        ch = this.nextChar();
                        var x2 = toHexDigit(ch);
                        if (x2 === -1) {
                          (0, _util.warn)("Lexer_getName: Illegal digit (" + String.fromCharCode(ch) + ") in hexadecimal number.");
                          strBuf.push("#", String.fromCharCode(previousCh));
                          if (specialChars[ch]) {
                            break;
                          }
                          strBuf.push(String.fromCharCode(ch));
                          continue;
                        }
                        strBuf.push(String.fromCharCode(x << 4 | x2));
                      } else {
                        strBuf.push("#", String.fromCharCode(ch));
                      }
                    } else {
                      strBuf.push(String.fromCharCode(ch));
                    }
                  }
                  if (strBuf.length > 127) {
                    (0, _util.warn)("name token is longer than allowed by the spec: " + strBuf.length);
                  }
                  return _primitives.Name.get(strBuf.join(""));
                },
                getHexString: function Lexer_getHexString() {
                  var strBuf = this.strBuf;
                  strBuf.length = 0;
                  var ch = this.currentChar;
                  var isFirstHex = true;
                  var firstDigit;
                  var secondDigit;
                  while (true) {
                    if (ch < 0) {
                      (0, _util.warn)("Unterminated hex string");
                      break;
                    } else if (ch === 62) {
                      this.nextChar();
                      break;
                    } else if (specialChars[ch] === 1) {
                      ch = this.nextChar();
                      continue;
                    } else {
                      if (isFirstHex) {
                        firstDigit = toHexDigit(ch);
                        if (firstDigit === -1) {
                          (0, _util.warn)('Ignoring invalid character "' + ch + '" in hex string');
                          ch = this.nextChar();
                          continue;
                        }
                      } else {
                        secondDigit = toHexDigit(ch);
                        if (secondDigit === -1) {
                          (0, _util.warn)('Ignoring invalid character "' + ch + '" in hex string');
                          ch = this.nextChar();
                          continue;
                        }
                        strBuf.push(String.fromCharCode(firstDigit << 4 | secondDigit));
                      }
                      isFirstHex = !isFirstHex;
                      ch = this.nextChar();
                    }
                  }
                  return strBuf.join("");
                },
                getObj: function Lexer_getObj() {
                  var comment = false;
                  var ch = this.currentChar;
                  while (true) {
                    if (ch < 0) {
                      return _primitives.EOF;
                    }
                    if (comment) {
                      if (ch === 10 || ch === 13) {
                        comment = false;
                      }
                    } else if (ch === 37) {
                      comment = true;
                    } else if (specialChars[ch] !== 1) {
                      break;
                    }
                    ch = this.nextChar();
                  }
                  switch (ch | 0) {
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                    case 43:
                    case 45:
                    case 46:
                      return this.getNumber();
                    case 40:
                      return this.getString();
                    case 47:
                      return this.getName();
                    case 91:
                      this.nextChar();
                      return _primitives.Cmd.get("[");
                    case 93:
                      this.nextChar();
                      return _primitives.Cmd.get("]");
                    case 60:
                      ch = this.nextChar();
                      if (ch === 60) {
                        this.nextChar();
                        return _primitives.Cmd.get("<<");
                      }
                      return this.getHexString();
                    case 62:
                      ch = this.nextChar();
                      if (ch === 62) {
                        this.nextChar();
                        return _primitives.Cmd.get(">>");
                      }
                      return _primitives.Cmd.get(">");
                    case 123:
                      this.nextChar();
                      return _primitives.Cmd.get("{");
                    case 125:
                      this.nextChar();
                      return _primitives.Cmd.get("}");
                    case 41:
                      this.nextChar();
                      throw new _util.FormatError("Illegal character: " + ch);
                  }
                  var str = String.fromCharCode(ch);
                  var knownCommands = this.knownCommands;
                  var knownCommandFound = knownCommands && knownCommands[str] !== void 0;
                  while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
                    var possibleCommand = str + String.fromCharCode(ch);
                    if (knownCommandFound && knownCommands[possibleCommand] === void 0) {
                      break;
                    }
                    if (str.length === 128) {
                      throw new _util.FormatError("Command token too long: " + str.length);
                    }
                    str = possibleCommand;
                    knownCommandFound = knownCommands && knownCommands[str] !== void 0;
                  }
                  if (str === "true") {
                    return true;
                  }
                  if (str === "false") {
                    return false;
                  }
                  if (str === "null") {
                    return null;
                  }
                  if (str === "BI") {
                    this.beginInlineImagePos = this.stream.pos;
                  }
                  return _primitives.Cmd.get(str);
                },
                skipToNextLine: function Lexer_skipToNextLine() {
                  var ch = this.currentChar;
                  while (ch >= 0) {
                    if (ch === 13) {
                      ch = this.nextChar();
                      if (ch === 10) {
                        this.nextChar();
                      }
                      break;
                    } else if (ch === 10) {
                      this.nextChar();
                      break;
                    }
                    ch = this.nextChar();
                  }
                }
              };
              return Lexer2;
            }();
            var Linearization = {
              create: function LinearizationCreate(stream2) {
                function getInt(name, allowZeroValue) {
                  var obj4 = linDict.get(name);
                  if (Number.isInteger(obj4) && (allowZeroValue ? obj4 >= 0 : obj4 > 0)) {
                    return obj4;
                  }
                  throw new Error('The "' + name + '" parameter in the linearization dictionary is invalid.');
                }
                function getHints() {
                  var hints = linDict.get("H"), hintsLength, item;
                  if (Array.isArray(hints) && ((hintsLength = hints.length) === 2 || hintsLength === 4)) {
                    for (var index = 0; index < hintsLength; index++) {
                      if (!(Number.isInteger(item = hints[index]) && item > 0)) {
                        throw new Error("Hint (" + index + ") in the linearization dictionary is invalid.");
                      }
                    }
                    return hints;
                  }
                  throw new Error("Hint array in the linearization dictionary is invalid.");
                }
                var parser = new Parser(new Lexer(stream2), false, null);
                var obj1 = parser.getObj();
                var obj2 = parser.getObj();
                var obj3 = parser.getObj();
                var linDict = parser.getObj();
                var obj, length;
                if (!(Number.isInteger(obj1) && Number.isInteger(obj2) && (0, _primitives.isCmd)(obj3, "obj") && (0, _primitives.isDict)(linDict) && (0, _util.isNum)(obj = linDict.get("Linearized")) && obj > 0)) {
                  return null;
                } else if ((length = getInt("L")) !== stream2.length) {
                  throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
                }
                return {
                  length,
                  hints: getHints(),
                  objectNumberFirst: getInt("O"),
                  endFirst: getInt("E"),
                  numPages: getInt("N"),
                  mainXRefEntriesOffset: getInt("T"),
                  pageFirst: linDict.has("P") ? getInt("P", true) : 0
                };
              }
            };
            exports3.Lexer = Lexer;
            exports3.Linearization = Linearization;
            exports3.Parser = Parser;
          },
          /* 121 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.LZWStream = exports3.StringStream = exports3.StreamsSequenceStream = exports3.Stream = exports3.RunLengthStream = exports3.PredictorStream = exports3.NullStream = exports3.FlateStream = exports3.DecodeStream = exports3.DecryptStream = exports3.AsciiHexStream = exports3.Ascii85Stream = void 0;
            var _util = __w_pdfjs_require__(2);
            var _primitives = __w_pdfjs_require__(119);
            var Stream = function StreamClosure() {
              function Stream2(arrayBuffer, start, length, dict) {
                this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
                this.start = start || 0;
                this.pos = this.start;
                this.end = start + length || this.bytes.length;
                this.dict = dict;
              }
              Stream2.prototype = {
                get length() {
                  return this.end - this.start;
                },
                get isEmpty() {
                  return this.length === 0;
                },
                getByte: function Stream_getByte() {
                  if (this.pos >= this.end) {
                    return -1;
                  }
                  return this.bytes[this.pos++];
                },
                getUint16: function Stream_getUint16() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  if (b0 === -1 || b1 === -1) {
                    return -1;
                  }
                  return (b0 << 8) + b1;
                },
                getInt32: function Stream_getInt32() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  var b2 = this.getByte();
                  var b3 = this.getByte();
                  return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                },
                getBytes: function Stream_getBytes(length) {
                  var bytes = this.bytes;
                  var pos = this.pos;
                  var strEnd = this.end;
                  if (!length) {
                    return bytes.subarray(pos, strEnd);
                  }
                  var end = pos + length;
                  if (end > strEnd) {
                    end = strEnd;
                  }
                  this.pos = end;
                  return bytes.subarray(pos, end);
                },
                peekByte: function Stream_peekByte() {
                  var peekedByte = this.getByte();
                  this.pos--;
                  return peekedByte;
                },
                peekBytes: function Stream_peekBytes(length) {
                  var bytes = this.getBytes(length);
                  this.pos -= bytes.length;
                  return bytes;
                },
                skip: function Stream_skip(n) {
                  if (!n) {
                    n = 1;
                  }
                  this.pos += n;
                },
                reset: function Stream_reset() {
                  this.pos = this.start;
                },
                moveStart: function Stream_moveStart() {
                  this.start = this.pos;
                },
                makeSubStream: function Stream_makeSubStream(start, length, dict) {
                  return new Stream2(this.bytes.buffer, start, length, dict);
                }
              };
              return Stream2;
            }();
            var StringStream = function StringStreamClosure() {
              function StringStream2(str) {
                var bytes = (0, _util.stringToBytes)(str);
                Stream.call(this, bytes);
              }
              StringStream2.prototype = Stream.prototype;
              return StringStream2;
            }();
            var DecodeStream = function DecodeStreamClosure() {
              var emptyBuffer = new Uint8Array(0);
              function DecodeStream2(maybeMinBufferLength) {
                this.pos = 0;
                this.bufferLength = 0;
                this.eof = false;
                this.buffer = emptyBuffer;
                this.minBufferLength = 512;
                if (maybeMinBufferLength) {
                  while (this.minBufferLength < maybeMinBufferLength) {
                    this.minBufferLength *= 2;
                  }
                }
              }
              DecodeStream2.prototype = {
                get isEmpty() {
                  while (!this.eof && this.bufferLength === 0) {
                    this.readBlock();
                  }
                  return this.bufferLength === 0;
                },
                ensureBuffer: function DecodeStream_ensureBuffer(requested) {
                  var buffer = this.buffer;
                  if (requested <= buffer.byteLength) {
                    return buffer;
                  }
                  var size = this.minBufferLength;
                  while (size < requested) {
                    size *= 2;
                  }
                  var buffer2 = new Uint8Array(size);
                  buffer2.set(buffer);
                  return this.buffer = buffer2;
                },
                getByte: function DecodeStream_getByte() {
                  var pos = this.pos;
                  while (this.bufferLength <= pos) {
                    if (this.eof) {
                      return -1;
                    }
                    this.readBlock();
                  }
                  return this.buffer[this.pos++];
                },
                getUint16: function DecodeStream_getUint16() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  if (b0 === -1 || b1 === -1) {
                    return -1;
                  }
                  return (b0 << 8) + b1;
                },
                getInt32: function DecodeStream_getInt32() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  var b2 = this.getByte();
                  var b3 = this.getByte();
                  return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                },
                getBytes: function DecodeStream_getBytes(length) {
                  var end, pos = this.pos;
                  if (length) {
                    this.ensureBuffer(pos + length);
                    end = pos + length;
                    while (!this.eof && this.bufferLength < end) {
                      this.readBlock();
                    }
                    var bufEnd = this.bufferLength;
                    if (end > bufEnd) {
                      end = bufEnd;
                    }
                  } else {
                    while (!this.eof) {
                      this.readBlock();
                    }
                    end = this.bufferLength;
                  }
                  this.pos = end;
                  return this.buffer.subarray(pos, end);
                },
                peekByte: function DecodeStream_peekByte() {
                  var peekedByte = this.getByte();
                  this.pos--;
                  return peekedByte;
                },
                peekBytes: function DecodeStream_peekBytes(length) {
                  var bytes = this.getBytes(length);
                  this.pos -= bytes.length;
                  return bytes;
                },
                makeSubStream: function DecodeStream_makeSubStream(start, length, dict) {
                  var end = start + length;
                  while (this.bufferLength <= end && !this.eof) {
                    this.readBlock();
                  }
                  return new Stream(this.buffer, start, length, dict);
                },
                skip: function DecodeStream_skip(n) {
                  if (!n) {
                    n = 1;
                  }
                  this.pos += n;
                },
                reset: function DecodeStream_reset() {
                  this.pos = 0;
                },
                getBaseStreams: function DecodeStream_getBaseStreams() {
                  if (this.str && this.str.getBaseStreams) {
                    return this.str.getBaseStreams();
                  }
                  return [];
                }
              };
              return DecodeStream2;
            }();
            var StreamsSequenceStream = function StreamsSequenceStreamClosure() {
              function StreamsSequenceStream2(streams) {
                this.streams = streams;
                DecodeStream.call(this, null);
              }
              StreamsSequenceStream2.prototype = Object.create(DecodeStream.prototype);
              StreamsSequenceStream2.prototype.readBlock = function streamSequenceStreamReadBlock() {
                var streams = this.streams;
                if (streams.length === 0) {
                  this.eof = true;
                  return;
                }
                var stream2 = streams.shift();
                var chunk = stream2.getBytes();
                var bufferLength = this.bufferLength;
                var newLength = bufferLength + chunk.length;
                var buffer = this.ensureBuffer(newLength);
                buffer.set(chunk, bufferLength);
                this.bufferLength = newLength;
              };
              StreamsSequenceStream2.prototype.getBaseStreams = function StreamsSequenceStream_getBaseStreams() {
                var baseStreams = [];
                for (var i = 0, ii = this.streams.length; i < ii; i++) {
                  var stream2 = this.streams[i];
                  if (stream2.getBaseStreams) {
                    _util.Util.appendToArray(baseStreams, stream2.getBaseStreams());
                  }
                }
                return baseStreams;
              };
              return StreamsSequenceStream2;
            }();
            var FlateStream = function FlateStreamClosure() {
              var codeLenCodeMap = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
              var lengthDecode = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]);
              var distDecode = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]);
              var fixedLitCodeTab = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9];
              var fixedDistCodeTab = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
              function FlateStream2(str, maybeLength) {
                this.str = str;
                this.dict = str.dict;
                var cmf = str.getByte();
                var flg = str.getByte();
                if (cmf === -1 || flg === -1) {
                  throw new _util.FormatError("Invalid header in flate stream: " + cmf + ", " + flg);
                }
                if ((cmf & 15) !== 8) {
                  throw new _util.FormatError("Unknown compression method in flate stream: " + cmf + ", " + flg);
                }
                if (((cmf << 8) + flg) % 31 !== 0) {
                  throw new _util.FormatError("Bad FCHECK in flate stream: " + cmf + ", " + flg);
                }
                if (flg & 32) {
                  throw new _util.FormatError("FDICT bit set in flate stream: " + cmf + ", " + flg);
                }
                this.codeSize = 0;
                this.codeBuf = 0;
                DecodeStream.call(this, maybeLength);
              }
              FlateStream2.prototype = Object.create(DecodeStream.prototype);
              FlateStream2.prototype.getBits = function FlateStream_getBits(bits) {
                var str = this.str;
                var codeSize = this.codeSize;
                var codeBuf = this.codeBuf;
                var b;
                while (codeSize < bits) {
                  if ((b = str.getByte()) === -1) {
                    throw new _util.FormatError("Bad encoding in flate stream");
                  }
                  codeBuf |= b << codeSize;
                  codeSize += 8;
                }
                b = codeBuf & (1 << bits) - 1;
                this.codeBuf = codeBuf >> bits;
                this.codeSize = codeSize -= bits;
                return b;
              };
              FlateStream2.prototype.getCode = function FlateStream_getCode(table) {
                var str = this.str;
                var codes = table[0];
                var maxLen = table[1];
                var codeSize = this.codeSize;
                var codeBuf = this.codeBuf;
                var b;
                while (codeSize < maxLen) {
                  if ((b = str.getByte()) === -1) {
                    break;
                  }
                  codeBuf |= b << codeSize;
                  codeSize += 8;
                }
                var code = codes[codeBuf & (1 << maxLen) - 1];
                var codeLen = code >> 16;
                var codeVal = code & 65535;
                if (codeLen < 1 || codeSize < codeLen) {
                  throw new _util.FormatError("Bad encoding in flate stream");
                }
                this.codeBuf = codeBuf >> codeLen;
                this.codeSize = codeSize - codeLen;
                return codeVal;
              };
              FlateStream2.prototype.generateHuffmanTable = function flateStreamGenerateHuffmanTable(lengths) {
                var n = lengths.length;
                var maxLen = 0;
                var i;
                for (i = 0; i < n; ++i) {
                  if (lengths[i] > maxLen) {
                    maxLen = lengths[i];
                  }
                }
                var size = 1 << maxLen;
                var codes = new Int32Array(size);
                for (var len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
                  for (var val = 0; val < n; ++val) {
                    if (lengths[val] === len) {
                      var code2 = 0;
                      var t = code;
                      for (i = 0; i < len; ++i) {
                        code2 = code2 << 1 | t & 1;
                        t >>= 1;
                      }
                      for (i = code2; i < size; i += skip) {
                        codes[i] = len << 16 | val;
                      }
                      ++code;
                    }
                  }
                }
                return [codes, maxLen];
              };
              FlateStream2.prototype.readBlock = function FlateStream_readBlock() {
                var buffer, len;
                var str = this.str;
                var hdr = this.getBits(3);
                if (hdr & 1) {
                  this.eof = true;
                }
                hdr >>= 1;
                if (hdr === 0) {
                  var b;
                  if ((b = str.getByte()) === -1) {
                    throw new _util.FormatError("Bad block header in flate stream");
                  }
                  var blockLen = b;
                  if ((b = str.getByte()) === -1) {
                    throw new _util.FormatError("Bad block header in flate stream");
                  }
                  blockLen |= b << 8;
                  if ((b = str.getByte()) === -1) {
                    throw new _util.FormatError("Bad block header in flate stream");
                  }
                  var check = b;
                  if ((b = str.getByte()) === -1) {
                    throw new _util.FormatError("Bad block header in flate stream");
                  }
                  check |= b << 8;
                  if (check !== (~blockLen & 65535) && (blockLen !== 0 || check !== 0)) {
                    throw new _util.FormatError("Bad uncompressed block length in flate stream");
                  }
                  this.codeBuf = 0;
                  this.codeSize = 0;
                  var bufferLength = this.bufferLength;
                  buffer = this.ensureBuffer(bufferLength + blockLen);
                  var end = bufferLength + blockLen;
                  this.bufferLength = end;
                  if (blockLen === 0) {
                    if (str.peekByte() === -1) {
                      this.eof = true;
                    }
                  } else {
                    for (var n = bufferLength; n < end; ++n) {
                      if ((b = str.getByte()) === -1) {
                        this.eof = true;
                        break;
                      }
                      buffer[n] = b;
                    }
                  }
                  return;
                }
                var litCodeTable;
                var distCodeTable;
                if (hdr === 1) {
                  litCodeTable = fixedLitCodeTab;
                  distCodeTable = fixedDistCodeTab;
                } else if (hdr === 2) {
                  var numLitCodes = this.getBits(5) + 257;
                  var numDistCodes = this.getBits(5) + 1;
                  var numCodeLenCodes = this.getBits(4) + 4;
                  var codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
                  var i;
                  for (i = 0; i < numCodeLenCodes; ++i) {
                    codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
                  }
                  var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
                  len = 0;
                  i = 0;
                  var codes = numLitCodes + numDistCodes;
                  var codeLengths = new Uint8Array(codes);
                  var bitsLength, bitsOffset, what;
                  while (i < codes) {
                    var code = this.getCode(codeLenCodeTab);
                    if (code === 16) {
                      bitsLength = 2;
                      bitsOffset = 3;
                      what = len;
                    } else if (code === 17) {
                      bitsLength = 3;
                      bitsOffset = 3;
                      what = len = 0;
                    } else if (code === 18) {
                      bitsLength = 7;
                      bitsOffset = 11;
                      what = len = 0;
                    } else {
                      codeLengths[i++] = len = code;
                      continue;
                    }
                    var repeatLength = this.getBits(bitsLength) + bitsOffset;
                    while (repeatLength-- > 0) {
                      codeLengths[i++] = what;
                    }
                  }
                  litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
                  distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
                } else {
                  throw new _util.FormatError("Unknown block type in flate stream");
                }
                buffer = this.buffer;
                var limit = buffer ? buffer.length : 0;
                var pos = this.bufferLength;
                while (true) {
                  var code1 = this.getCode(litCodeTable);
                  if (code1 < 256) {
                    if (pos + 1 >= limit) {
                      buffer = this.ensureBuffer(pos + 1);
                      limit = buffer.length;
                    }
                    buffer[pos++] = code1;
                    continue;
                  }
                  if (code1 === 256) {
                    this.bufferLength = pos;
                    return;
                  }
                  code1 -= 257;
                  code1 = lengthDecode[code1];
                  var code2 = code1 >> 16;
                  if (code2 > 0) {
                    code2 = this.getBits(code2);
                  }
                  len = (code1 & 65535) + code2;
                  code1 = this.getCode(distCodeTable);
                  code1 = distDecode[code1];
                  code2 = code1 >> 16;
                  if (code2 > 0) {
                    code2 = this.getBits(code2);
                  }
                  var dist = (code1 & 65535) + code2;
                  if (pos + len >= limit) {
                    buffer = this.ensureBuffer(pos + len);
                    limit = buffer.length;
                  }
                  for (var k = 0; k < len; ++k, ++pos) {
                    buffer[pos] = buffer[pos - dist];
                  }
                }
              };
              return FlateStream2;
            }();
            var PredictorStream = function PredictorStreamClosure() {
              function PredictorStream2(str, maybeLength, params) {
                if (!(0, _primitives.isDict)(params)) {
                  return str;
                }
                var predictor = this.predictor = params.get("Predictor") || 1;
                if (predictor <= 1) {
                  return str;
                }
                if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
                  throw new _util.FormatError("Unsupported predictor: " + predictor);
                }
                if (predictor === 2) {
                  this.readBlock = this.readBlockTiff;
                } else {
                  this.readBlock = this.readBlockPng;
                }
                this.str = str;
                this.dict = str.dict;
                var colors = this.colors = params.get("Colors") || 1;
                var bits = this.bits = params.get("BitsPerComponent") || 8;
                var columns = this.columns = params.get("Columns") || 1;
                this.pixBytes = colors * bits + 7 >> 3;
                this.rowBytes = columns * colors * bits + 7 >> 3;
                DecodeStream.call(this, maybeLength);
                return this;
              }
              PredictorStream2.prototype = Object.create(DecodeStream.prototype);
              PredictorStream2.prototype.readBlockTiff = function predictorStreamReadBlockTiff() {
                var rowBytes = this.rowBytes;
                var bufferLength = this.bufferLength;
                var buffer = this.ensureBuffer(bufferLength + rowBytes);
                var bits = this.bits;
                var colors = this.colors;
                var rawBytes = this.str.getBytes(rowBytes);
                this.eof = !rawBytes.length;
                if (this.eof) {
                  return;
                }
                var inbuf = 0, outbuf = 0;
                var inbits = 0, outbits = 0;
                var pos = bufferLength;
                var i;
                if (bits === 1 && colors === 1) {
                  for (i = 0; i < rowBytes; ++i) {
                    var c = rawBytes[i] ^ inbuf;
                    c ^= c >> 1;
                    c ^= c >> 2;
                    c ^= c >> 4;
                    inbuf = (c & 1) << 7;
                    buffer[pos++] = c;
                  }
                } else if (bits === 8) {
                  for (i = 0; i < colors; ++i) {
                    buffer[pos++] = rawBytes[i];
                  }
                  for (; i < rowBytes; ++i) {
                    buffer[pos] = buffer[pos - colors] + rawBytes[i];
                    pos++;
                  }
                } else if (bits === 16) {
                  var bytesPerPixel = colors * 2;
                  for (i = 0; i < bytesPerPixel; ++i) {
                    buffer[pos++] = rawBytes[i];
                  }
                  for (; i < rowBytes; i += 2) {
                    var sum = ((rawBytes[i] & 255) << 8) + (rawBytes[i + 1] & 255) + ((buffer[pos - bytesPerPixel] & 255) << 8) + (buffer[pos - bytesPerPixel + 1] & 255);
                    buffer[pos++] = sum >> 8 & 255;
                    buffer[pos++] = sum & 255;
                  }
                } else {
                  var compArray = new Uint8Array(colors + 1);
                  var bitMask = (1 << bits) - 1;
                  var j = 0, k = bufferLength;
                  var columns = this.columns;
                  for (i = 0; i < columns; ++i) {
                    for (var kk = 0; kk < colors; ++kk) {
                      if (inbits < bits) {
                        inbuf = inbuf << 8 | rawBytes[j++] & 255;
                        inbits += 8;
                      }
                      compArray[kk] = compArray[kk] + (inbuf >> inbits - bits) & bitMask;
                      inbits -= bits;
                      outbuf = outbuf << bits | compArray[kk];
                      outbits += bits;
                      if (outbits >= 8) {
                        buffer[k++] = outbuf >> outbits - 8 & 255;
                        outbits -= 8;
                      }
                    }
                  }
                  if (outbits > 0) {
                    buffer[k++] = (outbuf << 8 - outbits) + (inbuf & (1 << 8 - outbits) - 1);
                  }
                }
                this.bufferLength += rowBytes;
              };
              PredictorStream2.prototype.readBlockPng = function predictorStreamReadBlockPng() {
                var rowBytes = this.rowBytes;
                var pixBytes = this.pixBytes;
                var predictor = this.str.getByte();
                var rawBytes = this.str.getBytes(rowBytes);
                this.eof = !rawBytes.length;
                if (this.eof) {
                  return;
                }
                var bufferLength = this.bufferLength;
                var buffer = this.ensureBuffer(bufferLength + rowBytes);
                var prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);
                if (prevRow.length === 0) {
                  prevRow = new Uint8Array(rowBytes);
                }
                var i, j = bufferLength, up, c;
                switch (predictor) {
                  case 0:
                    for (i = 0; i < rowBytes; ++i) {
                      buffer[j++] = rawBytes[i];
                    }
                    break;
                  case 1:
                    for (i = 0; i < pixBytes; ++i) {
                      buffer[j++] = rawBytes[i];
                    }
                    for (; i < rowBytes; ++i) {
                      buffer[j] = buffer[j - pixBytes] + rawBytes[i] & 255;
                      j++;
                    }
                    break;
                  case 2:
                    for (i = 0; i < rowBytes; ++i) {
                      buffer[j++] = prevRow[i] + rawBytes[i] & 255;
                    }
                    break;
                  case 3:
                    for (i = 0; i < pixBytes; ++i) {
                      buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];
                    }
                    for (; i < rowBytes; ++i) {
                      buffer[j] = (prevRow[i] + buffer[j - pixBytes] >> 1) + rawBytes[i] & 255;
                      j++;
                    }
                    break;
                  case 4:
                    for (i = 0; i < pixBytes; ++i) {
                      up = prevRow[i];
                      c = rawBytes[i];
                      buffer[j++] = up + c;
                    }
                    for (; i < rowBytes; ++i) {
                      up = prevRow[i];
                      var upLeft = prevRow[i - pixBytes];
                      var left = buffer[j - pixBytes];
                      var p = left + up - upLeft;
                      var pa = p - left;
                      if (pa < 0) {
                        pa = -pa;
                      }
                      var pb = p - up;
                      if (pb < 0) {
                        pb = -pb;
                      }
                      var pc = p - upLeft;
                      if (pc < 0) {
                        pc = -pc;
                      }
                      c = rawBytes[i];
                      if (pa <= pb && pa <= pc) {
                        buffer[j++] = left + c;
                      } else if (pb <= pc) {
                        buffer[j++] = up + c;
                      } else {
                        buffer[j++] = upLeft + c;
                      }
                    }
                    break;
                  default:
                    throw new _util.FormatError("Unsupported predictor: " + predictor);
                }
                this.bufferLength += rowBytes;
              };
              return PredictorStream2;
            }();
            var DecryptStream = function DecryptStreamClosure() {
              function DecryptStream2(str, maybeLength, decrypt) {
                this.str = str;
                this.dict = str.dict;
                this.decrypt = decrypt;
                this.nextChunk = null;
                this.initialized = false;
                DecodeStream.call(this, maybeLength);
              }
              var chunkSize = 512;
              DecryptStream2.prototype = Object.create(DecodeStream.prototype);
              DecryptStream2.prototype.readBlock = function DecryptStream_readBlock() {
                var chunk;
                if (this.initialized) {
                  chunk = this.nextChunk;
                } else {
                  chunk = this.str.getBytes(chunkSize);
                  this.initialized = true;
                }
                if (!chunk || chunk.length === 0) {
                  this.eof = true;
                  return;
                }
                this.nextChunk = this.str.getBytes(chunkSize);
                var hasMoreData = this.nextChunk && this.nextChunk.length > 0;
                var decrypt = this.decrypt;
                chunk = decrypt(chunk, !hasMoreData);
                var bufferLength = this.bufferLength;
                var i, n = chunk.length;
                var buffer = this.ensureBuffer(bufferLength + n);
                for (i = 0; i < n; i++) {
                  buffer[bufferLength++] = chunk[i];
                }
                this.bufferLength = bufferLength;
              };
              return DecryptStream2;
            }();
            var Ascii85Stream = function Ascii85StreamClosure() {
              function Ascii85Stream2(str, maybeLength) {
                this.str = str;
                this.dict = str.dict;
                this.input = new Uint8Array(5);
                if (maybeLength) {
                  maybeLength = 0.8 * maybeLength;
                }
                DecodeStream.call(this, maybeLength);
              }
              Ascii85Stream2.prototype = Object.create(DecodeStream.prototype);
              Ascii85Stream2.prototype.readBlock = function Ascii85Stream_readBlock() {
                var TILDA_CHAR = 126;
                var Z_LOWER_CHAR = 122;
                var EOF = -1;
                var str = this.str;
                var c = str.getByte();
                while ((0, _util.isSpace)(c)) {
                  c = str.getByte();
                }
                if (c === EOF || c === TILDA_CHAR) {
                  this.eof = true;
                  return;
                }
                var bufferLength = this.bufferLength, buffer;
                var i;
                if (c === Z_LOWER_CHAR) {
                  buffer = this.ensureBuffer(bufferLength + 4);
                  for (i = 0; i < 4; ++i) {
                    buffer[bufferLength + i] = 0;
                  }
                  this.bufferLength += 4;
                } else {
                  var input = this.input;
                  input[0] = c;
                  for (i = 1; i < 5; ++i) {
                    c = str.getByte();
                    while ((0, _util.isSpace)(c)) {
                      c = str.getByte();
                    }
                    input[i] = c;
                    if (c === EOF || c === TILDA_CHAR) {
                      break;
                    }
                  }
                  buffer = this.ensureBuffer(bufferLength + i - 1);
                  this.bufferLength += i - 1;
                  if (i < 5) {
                    for (; i < 5; ++i) {
                      input[i] = 33 + 84;
                    }
                    this.eof = true;
                  }
                  var t = 0;
                  for (i = 0; i < 5; ++i) {
                    t = t * 85 + (input[i] - 33);
                  }
                  for (i = 3; i >= 0; --i) {
                    buffer[bufferLength + i] = t & 255;
                    t >>= 8;
                  }
                }
              };
              return Ascii85Stream2;
            }();
            var AsciiHexStream = function AsciiHexStreamClosure() {
              function AsciiHexStream2(str, maybeLength) {
                this.str = str;
                this.dict = str.dict;
                this.firstDigit = -1;
                if (maybeLength) {
                  maybeLength = 0.5 * maybeLength;
                }
                DecodeStream.call(this, maybeLength);
              }
              AsciiHexStream2.prototype = Object.create(DecodeStream.prototype);
              AsciiHexStream2.prototype.readBlock = function AsciiHexStream_readBlock() {
                var UPSTREAM_BLOCK_SIZE = 8e3;
                var bytes = this.str.getBytes(UPSTREAM_BLOCK_SIZE);
                if (!bytes.length) {
                  this.eof = true;
                  return;
                }
                var maxDecodeLength = bytes.length + 1 >> 1;
                var buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
                var bufferLength = this.bufferLength;
                var firstDigit = this.firstDigit;
                for (var i = 0, ii = bytes.length; i < ii; i++) {
                  var ch = bytes[i], digit;
                  if (ch >= 48 && ch <= 57) {
                    digit = ch & 15;
                  } else if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
                    digit = (ch & 15) + 9;
                  } else if (ch === 62) {
                    this.eof = true;
                    break;
                  } else {
                    continue;
                  }
                  if (firstDigit < 0) {
                    firstDigit = digit;
                  } else {
                    buffer[bufferLength++] = firstDigit << 4 | digit;
                    firstDigit = -1;
                  }
                }
                if (firstDigit >= 0 && this.eof) {
                  buffer[bufferLength++] = firstDigit << 4;
                  firstDigit = -1;
                }
                this.firstDigit = firstDigit;
                this.bufferLength = bufferLength;
              };
              return AsciiHexStream2;
            }();
            var RunLengthStream = function RunLengthStreamClosure() {
              function RunLengthStream2(str, maybeLength) {
                this.str = str;
                this.dict = str.dict;
                DecodeStream.call(this, maybeLength);
              }
              RunLengthStream2.prototype = Object.create(DecodeStream.prototype);
              RunLengthStream2.prototype.readBlock = function RunLengthStream_readBlock() {
                var repeatHeader = this.str.getBytes(2);
                if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
                  this.eof = true;
                  return;
                }
                var buffer;
                var bufferLength = this.bufferLength;
                var n = repeatHeader[0];
                if (n < 128) {
                  buffer = this.ensureBuffer(bufferLength + n + 1);
                  buffer[bufferLength++] = repeatHeader[1];
                  if (n > 0) {
                    var source = this.str.getBytes(n);
                    buffer.set(source, bufferLength);
                    bufferLength += n;
                  }
                } else {
                  n = 257 - n;
                  var b = repeatHeader[1];
                  buffer = this.ensureBuffer(bufferLength + n + 1);
                  for (var i = 0; i < n; i++) {
                    buffer[bufferLength++] = b;
                  }
                }
                this.bufferLength = bufferLength;
              };
              return RunLengthStream2;
            }();
            var LZWStream = function LZWStreamClosure() {
              function LZWStream2(str, maybeLength, earlyChange) {
                this.str = str;
                this.dict = str.dict;
                this.cachedData = 0;
                this.bitsCached = 0;
                var maxLzwDictionarySize = 4096;
                var lzwState = {
                  earlyChange,
                  codeLength: 9,
                  nextCode: 258,
                  dictionaryValues: new Uint8Array(maxLzwDictionarySize),
                  dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
                  dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
                  currentSequence: new Uint8Array(maxLzwDictionarySize),
                  currentSequenceLength: 0
                };
                for (var i = 0; i < 256; ++i) {
                  lzwState.dictionaryValues[i] = i;
                  lzwState.dictionaryLengths[i] = 1;
                }
                this.lzwState = lzwState;
                DecodeStream.call(this, maybeLength);
              }
              LZWStream2.prototype = Object.create(DecodeStream.prototype);
              LZWStream2.prototype.readBits = function LZWStream_readBits(n) {
                var bitsCached = this.bitsCached;
                var cachedData = this.cachedData;
                while (bitsCached < n) {
                  var c = this.str.getByte();
                  if (c === -1) {
                    this.eof = true;
                    return null;
                  }
                  cachedData = cachedData << 8 | c;
                  bitsCached += 8;
                }
                this.bitsCached = bitsCached -= n;
                this.cachedData = cachedData;
                this.lastCode = null;
                return cachedData >>> bitsCached & (1 << n) - 1;
              };
              LZWStream2.prototype.readBlock = function LZWStream_readBlock() {
                var blockSize = 512;
                var estimatedDecodedSize = blockSize * 2, decodedSizeDelta = blockSize;
                var i, j, q;
                var lzwState = this.lzwState;
                if (!lzwState) {
                  return;
                }
                var earlyChange = lzwState.earlyChange;
                var nextCode = lzwState.nextCode;
                var dictionaryValues = lzwState.dictionaryValues;
                var dictionaryLengths = lzwState.dictionaryLengths;
                var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
                var codeLength = lzwState.codeLength;
                var prevCode = lzwState.prevCode;
                var currentSequence = lzwState.currentSequence;
                var currentSequenceLength = lzwState.currentSequenceLength;
                var decodedLength = 0;
                var currentBufferLength = this.bufferLength;
                var buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
                for (i = 0; i < blockSize; i++) {
                  var code = this.readBits(codeLength);
                  var hasPrev = currentSequenceLength > 0;
                  if (code < 256) {
                    currentSequence[0] = code;
                    currentSequenceLength = 1;
                  } else if (code >= 258) {
                    if (code < nextCode) {
                      currentSequenceLength = dictionaryLengths[code];
                      for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {
                        currentSequence[j] = dictionaryValues[q];
                        q = dictionaryPrevCodes[q];
                      }
                    } else {
                      currentSequence[currentSequenceLength++] = currentSequence[0];
                    }
                  } else if (code === 256) {
                    codeLength = 9;
                    nextCode = 258;
                    currentSequenceLength = 0;
                    continue;
                  } else {
                    this.eof = true;
                    delete this.lzwState;
                    break;
                  }
                  if (hasPrev) {
                    dictionaryPrevCodes[nextCode] = prevCode;
                    dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
                    dictionaryValues[nextCode] = currentSequence[0];
                    nextCode++;
                    codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
                  }
                  prevCode = code;
                  decodedLength += currentSequenceLength;
                  if (estimatedDecodedSize < decodedLength) {
                    do {
                      estimatedDecodedSize += decodedSizeDelta;
                    } while (estimatedDecodedSize < decodedLength);
                    buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
                  }
                  for (j = 0; j < currentSequenceLength; j++) {
                    buffer[currentBufferLength++] = currentSequence[j];
                  }
                }
                lzwState.nextCode = nextCode;
                lzwState.codeLength = codeLength;
                lzwState.prevCode = prevCode;
                lzwState.currentSequenceLength = currentSequenceLength;
                this.bufferLength = currentBufferLength;
              };
              return LZWStream2;
            }();
            var NullStream = function NullStreamClosure() {
              function NullStream2() {
                Stream.call(this, new Uint8Array(0));
              }
              NullStream2.prototype = Stream.prototype;
              return NullStream2;
            }();
            exports3.Ascii85Stream = Ascii85Stream;
            exports3.AsciiHexStream = AsciiHexStream;
            exports3.DecryptStream = DecryptStream;
            exports3.DecodeStream = DecodeStream;
            exports3.FlateStream = FlateStream;
            exports3.NullStream = NullStream;
            exports3.PredictorStream = PredictorStream;
            exports3.RunLengthStream = RunLengthStream;
            exports3.Stream = Stream;
            exports3.StreamsSequenceStream = StreamsSequenceStream;
            exports3.StringStream = StringStream;
            exports3.LZWStream = LZWStream;
          },
          /* 122 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.CCITTFaxStream = void 0;
            var _primitives = __w_pdfjs_require__(119);
            var _ccitt = __w_pdfjs_require__(123);
            var _stream = __w_pdfjs_require__(121);
            var CCITTFaxStream = function CCITTFaxStreamClosure() {
              function CCITTFaxStream2(str, maybeLength, params) {
                this.str = str;
                this.dict = str.dict;
                if (!(0, _primitives.isDict)(params)) {
                  params = _primitives.Dict.empty;
                }
                var source = {
                  next: function next() {
                    return str.getByte();
                  }
                };
                this.ccittFaxDecoder = new _ccitt.CCITTFaxDecoder(source, {
                  K: params.get("K"),
                  EndOfLine: params.get("EndOfLine"),
                  EncodedByteAlign: params.get("EncodedByteAlign"),
                  Columns: params.get("Columns"),
                  Rows: params.get("Rows"),
                  EndOfBlock: params.get("EndOfBlock"),
                  BlackIs1: params.get("BlackIs1")
                });
                _stream.DecodeStream.call(this, maybeLength);
              }
              CCITTFaxStream2.prototype = Object.create(_stream.DecodeStream.prototype);
              CCITTFaxStream2.prototype.readBlock = function() {
                while (!this.eof) {
                  var c = this.ccittFaxDecoder.readNextChar();
                  if (c === -1) {
                    this.eof = true;
                    return;
                  }
                  this.ensureBuffer(this.bufferLength + 1);
                  this.buffer[this.bufferLength++] = c;
                }
              };
              return CCITTFaxStream2;
            }();
            exports3.CCITTFaxStream = CCITTFaxStream;
          },
          /* 123 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.CCITTFaxDecoder = void 0;
            var _util = __w_pdfjs_require__(2);
            var CCITTFaxDecoder = function CCITTFaxDecoder2() {
              var ccittEOL = -2;
              var ccittEOF = -1;
              var twoDimPass = 0;
              var twoDimHoriz = 1;
              var twoDimVert0 = 2;
              var twoDimVertR1 = 3;
              var twoDimVertL1 = 4;
              var twoDimVertR2 = 5;
              var twoDimVertL2 = 6;
              var twoDimVertR3 = 7;
              var twoDimVertL3 = 8;
              var twoDimTable = [[-1, -1], [-1, -1], [7, twoDimVertL3], [7, twoDimVertR3], [6, twoDimVertL2], [6, twoDimVertL2], [6, twoDimVertR2], [6, twoDimVertR2], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0]];
              var whiteTable1 = [[-1, -1], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]];
              var whiteTable2 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]];
              var blackTable1 = [[-1, -1], [-1, -1], [12, ccittEOL], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]];
              var blackTable2 = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]];
              var blackTable3 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
              function CCITTFaxDecoder3(source) {
                var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                if (!source || typeof source.next !== "function") {
                  throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
                }
                this.source = source;
                this.eof = false;
                this.encoding = options2["K"] || 0;
                this.eoline = options2["EndOfLine"] || false;
                this.byteAlign = options2["EncodedByteAlign"] || false;
                this.columns = options2["Columns"] || 1728;
                this.rows = options2["Rows"] || 0;
                var eoblock = options2["EndOfBlock"];
                if (eoblock === null || eoblock === void 0) {
                  eoblock = true;
                }
                this.eoblock = eoblock;
                this.black = options2["BlackIs1"] || false;
                this.codingLine = new Uint32Array(this.columns + 1);
                this.refLine = new Uint32Array(this.columns + 2);
                this.codingLine[0] = this.columns;
                this.codingPos = 0;
                this.row = 0;
                this.nextLine2D = this.encoding < 0;
                this.inputBits = 0;
                this.inputBuf = 0;
                this.outputBits = 0;
                this.rowsDone = false;
                var code1 = void 0;
                while ((code1 = this._lookBits(12)) === 0) {
                  this._eatBits(1);
                }
                if (code1 === 1) {
                  this._eatBits(12);
                }
                if (this.encoding > 0) {
                  this.nextLine2D = !this._lookBits(1);
                  this._eatBits(1);
                }
              }
              CCITTFaxDecoder3.prototype = {
                readNextChar: function readNextChar() {
                  if (this.eof) {
                    return -1;
                  }
                  var refLine = this.refLine;
                  var codingLine = this.codingLine;
                  var columns = this.columns;
                  var refPos = void 0, blackPixels = void 0, bits = void 0, i = void 0;
                  if (this.outputBits === 0) {
                    if (this.rowsDone) {
                      this.eof = true;
                    }
                    if (this.eof) {
                      return -1;
                    }
                    this.err = false;
                    var code1 = void 0, code2 = void 0, code3 = void 0;
                    if (this.nextLine2D) {
                      for (i = 0; codingLine[i] < columns; ++i) {
                        refLine[i] = codingLine[i];
                      }
                      refLine[i++] = columns;
                      refLine[i] = columns;
                      codingLine[0] = 0;
                      this.codingPos = 0;
                      refPos = 0;
                      blackPixels = 0;
                      while (codingLine[this.codingPos] < columns) {
                        code1 = this._getTwoDimCode();
                        switch (code1) {
                          case twoDimPass:
                            this._addPixels(refLine[refPos + 1], blackPixels);
                            if (refLine[refPos + 1] < columns) {
                              refPos += 2;
                            }
                            break;
                          case twoDimHoriz:
                            code1 = code2 = 0;
                            if (blackPixels) {
                              do {
                                code1 += code3 = this._getBlackCode();
                              } while (code3 >= 64);
                              do {
                                code2 += code3 = this._getWhiteCode();
                              } while (code3 >= 64);
                            } else {
                              do {
                                code1 += code3 = this._getWhiteCode();
                              } while (code3 >= 64);
                              do {
                                code2 += code3 = this._getBlackCode();
                              } while (code3 >= 64);
                            }
                            this._addPixels(codingLine[this.codingPos] + code1, blackPixels);
                            if (codingLine[this.codingPos] < columns) {
                              this._addPixels(codingLine[this.codingPos] + code2, blackPixels ^ 1);
                            }
                            while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                              refPos += 2;
                            }
                            break;
                          case twoDimVertR3:
                            this._addPixels(refLine[refPos] + 3, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              ++refPos;
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertR2:
                            this._addPixels(refLine[refPos] + 2, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              ++refPos;
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertR1:
                            this._addPixels(refLine[refPos] + 1, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              ++refPos;
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVert0:
                            this._addPixels(refLine[refPos], blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              ++refPos;
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertL3:
                            this._addPixelsNeg(refLine[refPos] - 3, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              if (refPos > 0) {
                                --refPos;
                              } else {
                                ++refPos;
                              }
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertL2:
                            this._addPixelsNeg(refLine[refPos] - 2, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              if (refPos > 0) {
                                --refPos;
                              } else {
                                ++refPos;
                              }
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case twoDimVertL1:
                            this._addPixelsNeg(refLine[refPos] - 1, blackPixels);
                            blackPixels ^= 1;
                            if (codingLine[this.codingPos] < columns) {
                              if (refPos > 0) {
                                --refPos;
                              } else {
                                ++refPos;
                              }
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                            }
                            break;
                          case ccittEOF:
                            this._addPixels(columns, 0);
                            this.eof = true;
                            break;
                          default:
                            (0, _util.info)("bad 2d code");
                            this._addPixels(columns, 0);
                            this.err = true;
                        }
                      }
                    } else {
                      codingLine[0] = 0;
                      this.codingPos = 0;
                      blackPixels = 0;
                      while (codingLine[this.codingPos] < columns) {
                        code1 = 0;
                        if (blackPixels) {
                          do {
                            code1 += code3 = this._getBlackCode();
                          } while (code3 >= 64);
                        } else {
                          do {
                            code1 += code3 = this._getWhiteCode();
                          } while (code3 >= 64);
                        }
                        this._addPixels(codingLine[this.codingPos] + code1, blackPixels);
                        blackPixels ^= 1;
                      }
                    }
                    var gotEOL = false;
                    if (this.byteAlign) {
                      this.inputBits &= ~7;
                    }
                    if (!this.eoblock && this.row === this.rows - 1) {
                      this.rowsDone = true;
                    } else {
                      code1 = this._lookBits(12);
                      if (this.eoline) {
                        while (code1 !== ccittEOF && code1 !== 1) {
                          this._eatBits(1);
                          code1 = this._lookBits(12);
                        }
                      } else {
                        while (code1 === 0) {
                          this._eatBits(1);
                          code1 = this._lookBits(12);
                        }
                      }
                      if (code1 === 1) {
                        this._eatBits(12);
                        gotEOL = true;
                      } else if (code1 === ccittEOF) {
                        this.eof = true;
                      }
                    }
                    if (!this.eof && this.encoding > 0 && !this.rowsDone) {
                      this.nextLine2D = !this._lookBits(1);
                      this._eatBits(1);
                    }
                    if (this.eoblock && gotEOL && this.byteAlign) {
                      code1 = this._lookBits(12);
                      if (code1 === 1) {
                        this._eatBits(12);
                        if (this.encoding > 0) {
                          this._lookBits(1);
                          this._eatBits(1);
                        }
                        if (this.encoding >= 0) {
                          for (i = 0; i < 4; ++i) {
                            code1 = this._lookBits(12);
                            if (code1 !== 1) {
                              (0, _util.info)("bad rtc code: " + code1);
                            }
                            this._eatBits(12);
                            if (this.encoding > 0) {
                              this._lookBits(1);
                              this._eatBits(1);
                            }
                          }
                        }
                        this.eof = true;
                      }
                    } else if (this.err && this.eoline) {
                      while (true) {
                        code1 = this._lookBits(13);
                        if (code1 === ccittEOF) {
                          this.eof = true;
                          return -1;
                        }
                        if (code1 >> 1 === 1) {
                          break;
                        }
                        this._eatBits(1);
                      }
                      this._eatBits(12);
                      if (this.encoding > 0) {
                        this._eatBits(1);
                        this.nextLine2D = !(code1 & 1);
                      }
                    }
                    if (codingLine[0] > 0) {
                      this.outputBits = codingLine[this.codingPos = 0];
                    } else {
                      this.outputBits = codingLine[this.codingPos = 1];
                    }
                    this.row++;
                  }
                  var c = void 0;
                  if (this.outputBits >= 8) {
                    c = this.codingPos & 1 ? 0 : 255;
                    this.outputBits -= 8;
                    if (this.outputBits === 0 && codingLine[this.codingPos] < columns) {
                      this.codingPos++;
                      this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
                    }
                  } else {
                    bits = 8;
                    c = 0;
                    do {
                      if (this.outputBits > bits) {
                        c <<= bits;
                        if (!(this.codingPos & 1)) {
                          c |= 255 >> 8 - bits;
                        }
                        this.outputBits -= bits;
                        bits = 0;
                      } else {
                        c <<= this.outputBits;
                        if (!(this.codingPos & 1)) {
                          c |= 255 >> 8 - this.outputBits;
                        }
                        bits -= this.outputBits;
                        this.outputBits = 0;
                        if (codingLine[this.codingPos] < columns) {
                          this.codingPos++;
                          this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
                        } else if (bits > 0) {
                          c <<= bits;
                          bits = 0;
                        }
                      }
                    } while (bits);
                  }
                  if (this.black) {
                    c ^= 255;
                  }
                  return c;
                },
                _addPixels: function _addPixels(a1, blackPixels) {
                  var codingLine = this.codingLine;
                  var codingPos = this.codingPos;
                  if (a1 > codingLine[codingPos]) {
                    if (a1 > this.columns) {
                      (0, _util.info)("row is wrong length");
                      this.err = true;
                      a1 = this.columns;
                    }
                    if (codingPos & 1 ^ blackPixels) {
                      ++codingPos;
                    }
                    codingLine[codingPos] = a1;
                  }
                  this.codingPos = codingPos;
                },
                _addPixelsNeg: function _addPixelsNeg(a1, blackPixels) {
                  var codingLine = this.codingLine;
                  var codingPos = this.codingPos;
                  if (a1 > codingLine[codingPos]) {
                    if (a1 > this.columns) {
                      (0, _util.info)("row is wrong length");
                      this.err = true;
                      a1 = this.columns;
                    }
                    if (codingPos & 1 ^ blackPixels) {
                      ++codingPos;
                    }
                    codingLine[codingPos] = a1;
                  } else if (a1 < codingLine[codingPos]) {
                    if (a1 < 0) {
                      (0, _util.info)("invalid code");
                      this.err = true;
                      a1 = 0;
                    }
                    while (codingPos > 0 && a1 < codingLine[codingPos - 1]) {
                      --codingPos;
                    }
                    codingLine[codingPos] = a1;
                  }
                  this.codingPos = codingPos;
                },
                _findTableCode: function _findTableCode(start, end, table, limit) {
                  var limitValue = limit || 0;
                  for (var i = start; i <= end; ++i) {
                    var code = this._lookBits(i);
                    if (code === ccittEOF) {
                      return [true, 1, false];
                    }
                    if (i < end) {
                      code <<= end - i;
                    }
                    if (!limitValue || code >= limitValue) {
                      var p = table[code - limitValue];
                      if (p[0] === i) {
                        this._eatBits(i);
                        return [true, p[1], true];
                      }
                    }
                  }
                  return [false, 0, false];
                },
                _getTwoDimCode: function _getTwoDimCode() {
                  var code = 0;
                  var p = void 0;
                  if (this.eoblock) {
                    code = this._lookBits(7);
                    p = twoDimTable[code];
                    if (p && p[0] > 0) {
                      this._eatBits(p[0]);
                      return p[1];
                    }
                  } else {
                    var result = this._findTableCode(1, 7, twoDimTable);
                    if (result[0] && result[2]) {
                      return result[1];
                    }
                  }
                  (0, _util.info)("Bad two dim code");
                  return ccittEOF;
                },
                _getWhiteCode: function _getWhiteCode() {
                  var code = 0;
                  var p = void 0;
                  if (this.eoblock) {
                    code = this._lookBits(12);
                    if (code === ccittEOF) {
                      return 1;
                    }
                    if (code >> 5 === 0) {
                      p = whiteTable1[code];
                    } else {
                      p = whiteTable2[code >> 3];
                    }
                    if (p[0] > 0) {
                      this._eatBits(p[0]);
                      return p[1];
                    }
                  } else {
                    var result = this._findTableCode(1, 9, whiteTable2);
                    if (result[0]) {
                      return result[1];
                    }
                    result = this._findTableCode(11, 12, whiteTable1);
                    if (result[0]) {
                      return result[1];
                    }
                  }
                  (0, _util.info)("bad white code");
                  this._eatBits(1);
                  return 1;
                },
                _getBlackCode: function _getBlackCode() {
                  var code = void 0, p = void 0;
                  if (this.eoblock) {
                    code = this._lookBits(13);
                    if (code === ccittEOF) {
                      return 1;
                    }
                    if (code >> 7 === 0) {
                      p = blackTable1[code];
                    } else if (code >> 9 === 0 && code >> 7 !== 0) {
                      p = blackTable2[(code >> 1) - 64];
                    } else {
                      p = blackTable3[code >> 7];
                    }
                    if (p[0] > 0) {
                      this._eatBits(p[0]);
                      return p[1];
                    }
                  } else {
                    var result = this._findTableCode(2, 6, blackTable3);
                    if (result[0]) {
                      return result[1];
                    }
                    result = this._findTableCode(7, 12, blackTable2, 64);
                    if (result[0]) {
                      return result[1];
                    }
                    result = this._findTableCode(10, 13, blackTable1);
                    if (result[0]) {
                      return result[1];
                    }
                  }
                  (0, _util.info)("bad black code");
                  this._eatBits(1);
                  return 1;
                },
                _lookBits: function _lookBits(n) {
                  var c = void 0;
                  while (this.inputBits < n) {
                    if ((c = this.source.next()) === -1) {
                      if (this.inputBits === 0) {
                        return ccittEOF;
                      }
                      return this.inputBuf << n - this.inputBits & 65535 >> 16 - n;
                    }
                    this.inputBuf = this.inputBuf << 8 | c;
                    this.inputBits += 8;
                  }
                  return this.inputBuf >> this.inputBits - n & 65535 >> 16 - n;
                },
                _eatBits: function _eatBits(n) {
                  if ((this.inputBits -= n) < 0) {
                    this.inputBits = 0;
                  }
                }
              };
              return CCITTFaxDecoder3;
            }();
            exports3.CCITTFaxDecoder = CCITTFaxDecoder;
          },
          /* 124 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.Jbig2Stream = void 0;
            var _primitives = __w_pdfjs_require__(119);
            var _stream = __w_pdfjs_require__(121);
            var _jbig = __w_pdfjs_require__(125);
            var _util = __w_pdfjs_require__(2);
            var Jbig2Stream = function Jbig2StreamClosure() {
              function Jbig2Stream2(stream2, maybeLength, dict, params) {
                this.stream = stream2;
                this.maybeLength = maybeLength;
                this.dict = dict;
                this.params = params;
                _stream.DecodeStream.call(this, maybeLength);
              }
              Jbig2Stream2.prototype = Object.create(_stream.DecodeStream.prototype);
              Object.defineProperty(Jbig2Stream2.prototype, "bytes", {
                get: function get() {
                  return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
                },
                configurable: true
              });
              Jbig2Stream2.prototype.ensureBuffer = function(requested) {
              };
              Jbig2Stream2.prototype.readBlock = function() {
                if (this.eof) {
                  return;
                }
                var jbig2Image = new _jbig.Jbig2Image();
                var chunks = [];
                if ((0, _primitives.isDict)(this.params)) {
                  var globalsStream = this.params.get("JBIG2Globals");
                  if ((0, _primitives.isStream)(globalsStream)) {
                    var globals = globalsStream.getBytes();
                    chunks.push({
                      data: globals,
                      start: 0,
                      end: globals.length
                    });
                  }
                }
                chunks.push({
                  data: this.bytes,
                  start: 0,
                  end: this.bytes.length
                });
                var data = jbig2Image.parseChunks(chunks);
                var dataLength = data.length;
                for (var i = 0; i < dataLength; i++) {
                  data[i] ^= 255;
                }
                this.buffer = data;
                this.bufferLength = dataLength;
                this.eof = true;
              };
              return Jbig2Stream2;
            }();
            exports3.Jbig2Stream = Jbig2Stream;
          },
          /* 125 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.Jbig2Image = void 0;
            var _util = __w_pdfjs_require__(2);
            var _arithmetic_decoder = __w_pdfjs_require__(126);
            var _ccitt = __w_pdfjs_require__(123);
            var Jbig2Error = function Jbig2ErrorClosure() {
              function Jbig2Error2(msg) {
                this.message = "JBIG2 error: " + msg;
              }
              Jbig2Error2.prototype = new Error();
              Jbig2Error2.prototype.name = "Jbig2Error";
              Jbig2Error2.constructor = Jbig2Error2;
              return Jbig2Error2;
            }();
            var Jbig2Image = function Jbig2ImageClosure() {
              function ContextCache() {
              }
              ContextCache.prototype = {
                getContexts: function getContexts(id) {
                  if (id in this) {
                    return this[id];
                  }
                  return this[id] = new Int8Array(1 << 16);
                }
              };
              function DecodingContext(data, start, end) {
                this.data = data;
                this.start = start;
                this.end = end;
              }
              DecodingContext.prototype = {
                get decoder() {
                  var decoder = new _arithmetic_decoder.ArithmeticDecoder(this.data, this.start, this.end);
                  return (0, _util.shadow)(this, "decoder", decoder);
                },
                get contextCache() {
                  var cache = new ContextCache();
                  return (0, _util.shadow)(this, "contextCache", cache);
                }
              };
              function decodeInteger(contextCache, procedure, decoder) {
                var contexts = contextCache.getContexts(procedure);
                var prev = 1;
                function readBits(length) {
                  var v = 0;
                  for (var i = 0; i < length; i++) {
                    var bit = decoder.readBit(contexts, prev);
                    prev = prev < 256 ? prev << 1 | bit : (prev << 1 | bit) & 511 | 256;
                    v = v << 1 | bit;
                  }
                  return v >>> 0;
                }
                var sign = readBits(1);
                var value = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
                return sign === 0 ? value : value > 0 ? -value : null;
              }
              function decodeIAID(contextCache, decoder, codeLength) {
                var contexts = contextCache.getContexts("IAID");
                var prev = 1;
                for (var i = 0; i < codeLength; i++) {
                  var bit = decoder.readBit(contexts, prev);
                  prev = prev << 1 | bit;
                }
                if (codeLength < 31) {
                  return prev & (1 << codeLength) - 1;
                }
                return prev & 2147483647;
              }
              var SegmentTypes = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"];
              var CodingTemplates = [[{
                x: -1,
                y: -2
              }, {
                x: 0,
                y: -2
              }, {
                x: 1,
                y: -2
              }, {
                x: -2,
                y: -1
              }, {
                x: -1,
                y: -1
              }, {
                x: 0,
                y: -1
              }, {
                x: 1,
                y: -1
              }, {
                x: 2,
                y: -1
              }, {
                x: -4,
                y: 0
              }, {
                x: -3,
                y: 0
              }, {
                x: -2,
                y: 0
              }, {
                x: -1,
                y: 0
              }], [{
                x: -1,
                y: -2
              }, {
                x: 0,
                y: -2
              }, {
                x: 1,
                y: -2
              }, {
                x: 2,
                y: -2
              }, {
                x: -2,
                y: -1
              }, {
                x: -1,
                y: -1
              }, {
                x: 0,
                y: -1
              }, {
                x: 1,
                y: -1
              }, {
                x: 2,
                y: -1
              }, {
                x: -3,
                y: 0
              }, {
                x: -2,
                y: 0
              }, {
                x: -1,
                y: 0
              }], [{
                x: -1,
                y: -2
              }, {
                x: 0,
                y: -2
              }, {
                x: 1,
                y: -2
              }, {
                x: -2,
                y: -1
              }, {
                x: -1,
                y: -1
              }, {
                x: 0,
                y: -1
              }, {
                x: 1,
                y: -1
              }, {
                x: -2,
                y: 0
              }, {
                x: -1,
                y: 0
              }], [{
                x: -3,
                y: -1
              }, {
                x: -2,
                y: -1
              }, {
                x: -1,
                y: -1
              }, {
                x: 0,
                y: -1
              }, {
                x: 1,
                y: -1
              }, {
                x: -4,
                y: 0
              }, {
                x: -3,
                y: 0
              }, {
                x: -2,
                y: 0
              }, {
                x: -1,
                y: 0
              }]];
              var RefinementTemplates = [{
                coding: [{
                  x: 0,
                  y: -1
                }, {
                  x: 1,
                  y: -1
                }, {
                  x: -1,
                  y: 0
                }],
                reference: [{
                  x: 0,
                  y: -1
                }, {
                  x: 1,
                  y: -1
                }, {
                  x: -1,
                  y: 0
                }, {
                  x: 0,
                  y: 0
                }, {
                  x: 1,
                  y: 0
                }, {
                  x: -1,
                  y: 1
                }, {
                  x: 0,
                  y: 1
                }, {
                  x: 1,
                  y: 1
                }]
              }, {
                coding: [{
                  x: -1,
                  y: -1
                }, {
                  x: 0,
                  y: -1
                }, {
                  x: 1,
                  y: -1
                }, {
                  x: -1,
                  y: 0
                }],
                reference: [{
                  x: 0,
                  y: -1
                }, {
                  x: -1,
                  y: 0
                }, {
                  x: 0,
                  y: 0
                }, {
                  x: 1,
                  y: 0
                }, {
                  x: 0,
                  y: 1
                }, {
                  x: 1,
                  y: 1
                }]
              }];
              var ReusedContexts = [39717, 1941, 229, 405];
              var RefinementReusedContexts = [32, 8];
              function decodeBitmapTemplate0(width, height, decodingContext) {
                var decoder = decodingContext.decoder;
                var contexts = decodingContext.contextCache.getContexts("GB");
                var contextLabel, i, j, pixel, row, row1, row2, bitmap = [];
                var OLD_PIXEL_MASK = 31735;
                for (i = 0; i < height; i++) {
                  row = bitmap[i] = new Uint8Array(width);
                  row1 = i < 1 ? row : bitmap[i - 1];
                  row2 = i < 2 ? row : bitmap[i - 2];
                  contextLabel = row2[0] << 13 | row2[1] << 12 | row2[2] << 11 | row1[0] << 7 | row1[1] << 6 | row1[2] << 5 | row1[3] << 4;
                  for (j = 0; j < width; j++) {
                    row[j] = pixel = decoder.readBit(contexts, contextLabel);
                    contextLabel = (contextLabel & OLD_PIXEL_MASK) << 1 | (j + 3 < width ? row2[j + 3] << 11 : 0) | (j + 4 < width ? row1[j + 4] << 4 : 0) | pixel;
                  }
                }
                return bitmap;
              }
              function decodeBitmap(mmr, width, height, templateIndex, prediction, skip, at, decodingContext) {
                if (mmr) {
                  var input = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
                  return decodeMMRBitmap(input, width, height, false);
                }
                if (templateIndex === 0 && !skip && !prediction && at.length === 4 && at[0].x === 3 && at[0].y === -1 && at[1].x === -3 && at[1].y === -1 && at[2].x === 2 && at[2].y === -2 && at[3].x === -2 && at[3].y === -2) {
                  return decodeBitmapTemplate0(width, height, decodingContext);
                }
                var useskip = !!skip;
                var template = CodingTemplates[templateIndex].concat(at);
                template.sort(function(a, b) {
                  return a.y - b.y || a.x - b.x;
                });
                var templateLength = template.length;
                var templateX = new Int8Array(templateLength);
                var templateY = new Int8Array(templateLength);
                var changingTemplateEntries = [];
                var reuseMask = 0, minX = 0, maxX = 0, minY = 0;
                var c, k;
                for (k = 0; k < templateLength; k++) {
                  templateX[k] = template[k].x;
                  templateY[k] = template[k].y;
                  minX = Math.min(minX, template[k].x);
                  maxX = Math.max(maxX, template[k].x);
                  minY = Math.min(minY, template[k].y);
                  if (k < templateLength - 1 && template[k].y === template[k + 1].y && template[k].x === template[k + 1].x - 1) {
                    reuseMask |= 1 << templateLength - 1 - k;
                  } else {
                    changingTemplateEntries.push(k);
                  }
                }
                var changingEntriesLength = changingTemplateEntries.length;
                var changingTemplateX = new Int8Array(changingEntriesLength);
                var changingTemplateY = new Int8Array(changingEntriesLength);
                var changingTemplateBit = new Uint16Array(changingEntriesLength);
                for (c = 0; c < changingEntriesLength; c++) {
                  k = changingTemplateEntries[c];
                  changingTemplateX[c] = template[k].x;
                  changingTemplateY[c] = template[k].y;
                  changingTemplateBit[c] = 1 << templateLength - 1 - k;
                }
                var sbb_left = -minX;
                var sbb_top = -minY;
                var sbb_right = width - maxX;
                var pseudoPixelContext = ReusedContexts[templateIndex];
                var row = new Uint8Array(width);
                var bitmap = [];
                var decoder = decodingContext.decoder;
                var contexts = decodingContext.contextCache.getContexts("GB");
                var ltp = 0, j, i0, j0, contextLabel = 0, bit, shift;
                for (var i = 0; i < height; i++) {
                  if (prediction) {
                    var sltp = decoder.readBit(contexts, pseudoPixelContext);
                    ltp ^= sltp;
                    if (ltp) {
                      bitmap.push(row);
                      continue;
                    }
                  }
                  row = new Uint8Array(row);
                  bitmap.push(row);
                  for (j = 0; j < width; j++) {
                    if (useskip && skip[i][j]) {
                      row[j] = 0;
                      continue;
                    }
                    if (j >= sbb_left && j < sbb_right && i >= sbb_top) {
                      contextLabel = contextLabel << 1 & reuseMask;
                      for (k = 0; k < changingEntriesLength; k++) {
                        i0 = i + changingTemplateY[k];
                        j0 = j + changingTemplateX[k];
                        bit = bitmap[i0][j0];
                        if (bit) {
                          bit = changingTemplateBit[k];
                          contextLabel |= bit;
                        }
                      }
                    } else {
                      contextLabel = 0;
                      shift = templateLength - 1;
                      for (k = 0; k < templateLength; k++, shift--) {
                        j0 = j + templateX[k];
                        if (j0 >= 0 && j0 < width) {
                          i0 = i + templateY[k];
                          if (i0 >= 0) {
                            bit = bitmap[i0][j0];
                            if (bit) {
                              contextLabel |= bit << shift;
                            }
                          }
                        }
                      }
                    }
                    var pixel = decoder.readBit(contexts, contextLabel);
                    row[j] = pixel;
                  }
                }
                return bitmap;
              }
              function decodeRefinement(width, height, templateIndex, referenceBitmap, offsetX, offsetY, prediction, at, decodingContext) {
                var codingTemplate = RefinementTemplates[templateIndex].coding;
                if (templateIndex === 0) {
                  codingTemplate = codingTemplate.concat([at[0]]);
                }
                var codingTemplateLength = codingTemplate.length;
                var codingTemplateX = new Int32Array(codingTemplateLength);
                var codingTemplateY = new Int32Array(codingTemplateLength);
                var k;
                for (k = 0; k < codingTemplateLength; k++) {
                  codingTemplateX[k] = codingTemplate[k].x;
                  codingTemplateY[k] = codingTemplate[k].y;
                }
                var referenceTemplate = RefinementTemplates[templateIndex].reference;
                if (templateIndex === 0) {
                  referenceTemplate = referenceTemplate.concat([at[1]]);
                }
                var referenceTemplateLength = referenceTemplate.length;
                var referenceTemplateX = new Int32Array(referenceTemplateLength);
                var referenceTemplateY = new Int32Array(referenceTemplateLength);
                for (k = 0; k < referenceTemplateLength; k++) {
                  referenceTemplateX[k] = referenceTemplate[k].x;
                  referenceTemplateY[k] = referenceTemplate[k].y;
                }
                var referenceWidth = referenceBitmap[0].length;
                var referenceHeight = referenceBitmap.length;
                var pseudoPixelContext = RefinementReusedContexts[templateIndex];
                var bitmap = [];
                var decoder = decodingContext.decoder;
                var contexts = decodingContext.contextCache.getContexts("GR");
                var ltp = 0;
                for (var i = 0; i < height; i++) {
                  if (prediction) {
                    var sltp = decoder.readBit(contexts, pseudoPixelContext);
                    ltp ^= sltp;
                    if (ltp) {
                      throw new Jbig2Error("prediction is not supported");
                    }
                  }
                  var row = new Uint8Array(width);
                  bitmap.push(row);
                  for (var j = 0; j < width; j++) {
                    var i0, j0;
                    var contextLabel = 0;
                    for (k = 0; k < codingTemplateLength; k++) {
                      i0 = i + codingTemplateY[k];
                      j0 = j + codingTemplateX[k];
                      if (i0 < 0 || j0 < 0 || j0 >= width) {
                        contextLabel <<= 1;
                      } else {
                        contextLabel = contextLabel << 1 | bitmap[i0][j0];
                      }
                    }
                    for (k = 0; k < referenceTemplateLength; k++) {
                      i0 = i + referenceTemplateY[k] - offsetY;
                      j0 = j + referenceTemplateX[k] - offsetX;
                      if (i0 < 0 || i0 >= referenceHeight || j0 < 0 || j0 >= referenceWidth) {
                        contextLabel <<= 1;
                      } else {
                        contextLabel = contextLabel << 1 | referenceBitmap[i0][j0];
                      }
                    }
                    var pixel = decoder.readBit(contexts, contextLabel);
                    row[j] = pixel;
                  }
                }
                return bitmap;
              }
              function decodeSymbolDictionary(huffman, refinement, symbols, numberOfNewSymbols, numberOfExportedSymbols, huffmanTables, templateIndex, at, refinementTemplateIndex, refinementAt, decodingContext, huffmanInput) {
                if (huffman && refinement) {
                  throw new Jbig2Error("symbol refinement with Huffman is not supported");
                }
                var newSymbols = [];
                var currentHeight = 0;
                var symbolCodeLength = (0, _util.log2)(symbols.length + numberOfNewSymbols);
                var decoder = decodingContext.decoder;
                var contextCache = decodingContext.contextCache;
                var tableB1 = void 0, symbolWidths = void 0;
                if (huffman) {
                  tableB1 = getStandardTable(1);
                  symbolWidths = [];
                  symbolCodeLength = Math.max(symbolCodeLength, 1);
                }
                while (newSymbols.length < numberOfNewSymbols) {
                  var deltaHeight = huffman ? huffmanTables.tableDeltaHeight.decode(huffmanInput) : decodeInteger(contextCache, "IADH", decoder);
                  currentHeight += deltaHeight;
                  var currentWidth = 0, totalWidth = 0;
                  var firstSymbol = huffman ? symbolWidths.length : 0;
                  while (true) {
                    var deltaWidth = huffman ? huffmanTables.tableDeltaWidth.decode(huffmanInput) : decodeInteger(contextCache, "IADW", decoder);
                    if (deltaWidth === null) {
                      break;
                    }
                    currentWidth += deltaWidth;
                    totalWidth += currentWidth;
                    var bitmap;
                    if (refinement) {
                      var numberOfInstances = decodeInteger(contextCache, "IAAI", decoder);
                      if (numberOfInstances > 1) {
                        bitmap = decodeTextRegion(huffman, refinement, currentWidth, currentHeight, 0, numberOfInstances, 1, symbols.concat(newSymbols), symbolCodeLength, 0, 0, 1, 0, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, 0, huffmanInput);
                      } else {
                        var symbolId = decodeIAID(contextCache, decoder, symbolCodeLength);
                        var rdx = decodeInteger(contextCache, "IARDX", decoder);
                        var rdy = decodeInteger(contextCache, "IARDY", decoder);
                        var symbol = symbolId < symbols.length ? symbols[symbolId] : newSymbols[symbolId - symbols.length];
                        bitmap = decodeRefinement(currentWidth, currentHeight, refinementTemplateIndex, symbol, rdx, rdy, false, refinementAt, decodingContext);
                      }
                      newSymbols.push(bitmap);
                    } else if (huffman) {
                      symbolWidths.push(currentWidth);
                    } else {
                      bitmap = decodeBitmap(false, currentWidth, currentHeight, templateIndex, false, null, at, decodingContext);
                      newSymbols.push(bitmap);
                    }
                  }
                  if (huffman && !refinement) {
                    var bitmapSize = huffmanTables.tableBitmapSize.decode(huffmanInput);
                    huffmanInput.byteAlign();
                    var collectiveBitmap = void 0;
                    if (bitmapSize === 0) {
                      collectiveBitmap = readUncompressedBitmap(huffmanInput, totalWidth, currentHeight);
                    } else {
                      var originalEnd = huffmanInput.end;
                      var bitmapEnd = huffmanInput.position + bitmapSize;
                      huffmanInput.end = bitmapEnd;
                      collectiveBitmap = decodeMMRBitmap(huffmanInput, totalWidth, currentHeight, false);
                      huffmanInput.end = originalEnd;
                      huffmanInput.position = bitmapEnd;
                    }
                    var numberOfSymbolsDecoded = symbolWidths.length;
                    if (firstSymbol === numberOfSymbolsDecoded - 1) {
                      newSymbols.push(collectiveBitmap);
                    } else {
                      var _i = void 0, y = void 0, xMin = 0, xMax = void 0, bitmapWidth = void 0, symbolBitmap = void 0;
                      for (_i = firstSymbol; _i < numberOfSymbolsDecoded; _i++) {
                        bitmapWidth = symbolWidths[_i];
                        xMax = xMin + bitmapWidth;
                        symbolBitmap = [];
                        for (y = 0; y < currentHeight; y++) {
                          symbolBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));
                        }
                        newSymbols.push(symbolBitmap);
                        xMin = xMax;
                      }
                    }
                  }
                }
                var exportedSymbols = [];
                var flags = [], currentFlag = false;
                var totalSymbolsLength = symbols.length + numberOfNewSymbols;
                while (flags.length < totalSymbolsLength) {
                  var runLength = huffman ? tableB1.decode(huffmanInput) : decodeInteger(contextCache, "IAEX", decoder);
                  while (runLength--) {
                    flags.push(currentFlag);
                  }
                  currentFlag = !currentFlag;
                }
                for (var i = 0, ii = symbols.length; i < ii; i++) {
                  if (flags[i]) {
                    exportedSymbols.push(symbols[i]);
                  }
                }
                for (var j = 0; j < numberOfNewSymbols; i++, j++) {
                  if (flags[i]) {
                    exportedSymbols.push(newSymbols[j]);
                  }
                }
                return exportedSymbols;
              }
              function decodeTextRegion(huffman, refinement, width, height, defaultPixelValue, numberOfSymbolInstances, stripSize, inputSymbols, symbolCodeLength, transposed, dsOffset, referenceCorner, combinationOperator, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, logStripSize, huffmanInput) {
                if (huffman && refinement) {
                  throw new Jbig2Error("refinement with Huffman is not supported");
                }
                var bitmap = [];
                var i, row;
                for (i = 0; i < height; i++) {
                  row = new Uint8Array(width);
                  if (defaultPixelValue) {
                    for (var j = 0; j < width; j++) {
                      row[j] = defaultPixelValue;
                    }
                  }
                  bitmap.push(row);
                }
                var decoder = decodingContext.decoder;
                var contextCache = decodingContext.contextCache;
                var stripT = huffman ? -huffmanTables.tableDeltaT.decode(huffmanInput) : -decodeInteger(contextCache, "IADT", decoder);
                var firstS = 0;
                i = 0;
                while (i < numberOfSymbolInstances) {
                  var deltaT = huffman ? huffmanTables.tableDeltaT.decode(huffmanInput) : decodeInteger(contextCache, "IADT", decoder);
                  stripT += deltaT;
                  var deltaFirstS = huffman ? huffmanTables.tableFirstS.decode(huffmanInput) : decodeInteger(contextCache, "IAFS", decoder);
                  firstS += deltaFirstS;
                  var currentS = firstS;
                  do {
                    var currentT = 0;
                    if (stripSize > 1) {
                      currentT = huffman ? huffmanInput.readBits(logStripSize) : decodeInteger(contextCache, "IAIT", decoder);
                    }
                    var t = stripSize * stripT + currentT;
                    var symbolId = huffman ? huffmanTables.symbolIDTable.decode(huffmanInput) : decodeIAID(contextCache, decoder, symbolCodeLength);
                    var applyRefinement = refinement && (huffman ? huffmanInput.readBit() : decodeInteger(contextCache, "IARI", decoder));
                    var symbolBitmap = inputSymbols[symbolId];
                    var symbolWidth = symbolBitmap[0].length;
                    var symbolHeight = symbolBitmap.length;
                    if (applyRefinement) {
                      var rdw = decodeInteger(contextCache, "IARDW", decoder);
                      var rdh = decodeInteger(contextCache, "IARDH", decoder);
                      var rdx = decodeInteger(contextCache, "IARDX", decoder);
                      var rdy = decodeInteger(contextCache, "IARDY", decoder);
                      symbolWidth += rdw;
                      symbolHeight += rdh;
                      symbolBitmap = decodeRefinement(symbolWidth, symbolHeight, refinementTemplateIndex, symbolBitmap, (rdw >> 1) + rdx, (rdh >> 1) + rdy, false, refinementAt, decodingContext);
                    }
                    var offsetT = t - (referenceCorner & 1 ? 0 : symbolHeight - 1);
                    var offsetS = currentS - (referenceCorner & 2 ? symbolWidth - 1 : 0);
                    var s2, t2, symbolRow;
                    if (transposed) {
                      for (s2 = 0; s2 < symbolHeight; s2++) {
                        row = bitmap[offsetS + s2];
                        if (!row) {
                          continue;
                        }
                        symbolRow = symbolBitmap[s2];
                        var maxWidth = Math.min(width - offsetT, symbolWidth);
                        switch (combinationOperator) {
                          case 0:
                            for (t2 = 0; t2 < maxWidth; t2++) {
                              row[offsetT + t2] |= symbolRow[t2];
                            }
                            break;
                          case 2:
                            for (t2 = 0; t2 < maxWidth; t2++) {
                              row[offsetT + t2] ^= symbolRow[t2];
                            }
                            break;
                          default:
                            throw new Jbig2Error("operator " + combinationOperator + " is not supported");
                        }
                      }
                      currentS += symbolHeight - 1;
                    } else {
                      for (t2 = 0; t2 < symbolHeight; t2++) {
                        row = bitmap[offsetT + t2];
                        if (!row) {
                          continue;
                        }
                        symbolRow = symbolBitmap[t2];
                        switch (combinationOperator) {
                          case 0:
                            for (s2 = 0; s2 < symbolWidth; s2++) {
                              row[offsetS + s2] |= symbolRow[s2];
                            }
                            break;
                          case 2:
                            for (s2 = 0; s2 < symbolWidth; s2++) {
                              row[offsetS + s2] ^= symbolRow[s2];
                            }
                            break;
                          default:
                            throw new Jbig2Error("operator " + combinationOperator + " is not supported");
                        }
                      }
                      currentS += symbolWidth - 1;
                    }
                    i++;
                    var deltaS = huffman ? huffmanTables.tableDeltaS.decode(huffmanInput) : decodeInteger(contextCache, "IADS", decoder);
                    if (deltaS === null) {
                      break;
                    }
                    currentS += deltaS + dsOffset;
                  } while (true);
                }
                return bitmap;
              }
              function decodePatternDictionary(mmr, patternWidth, patternHeight, maxPatternIndex, template, decodingContext) {
                var at = [];
                if (!mmr) {
                  at.push({
                    x: -patternWidth,
                    y: 0
                  });
                  if (template === 0) {
                    at.push({
                      x: -3,
                      y: -1
                    });
                    at.push({
                      x: 2,
                      y: -2
                    });
                    at.push({
                      x: -2,
                      y: -2
                    });
                  }
                }
                var collectiveWidth = (maxPatternIndex + 1) * patternWidth;
                var collectiveBitmap = decodeBitmap(mmr, collectiveWidth, patternHeight, template, false, null, at, decodingContext);
                var patterns = [], i = 0, patternBitmap = void 0, xMin = void 0, xMax = void 0, y = void 0;
                while (i <= maxPatternIndex) {
                  patternBitmap = [];
                  xMin = patternWidth * i;
                  xMax = xMin + patternWidth;
                  for (y = 0; y < patternHeight; y++) {
                    patternBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));
                  }
                  patterns.push(patternBitmap);
                  i++;
                }
                return patterns;
              }
              function decodeHalftoneRegion(mmr, patterns, template, regionWidth, regionHeight, defaultPixelValue, enableSkip, combinationOperator, gridWidth, gridHeight, gridOffsetX, gridOffsetY, gridVectorX, gridVectorY, decodingContext) {
                var skip = null;
                if (enableSkip) {
                  throw new Jbig2Error("skip is not supported");
                }
                if (combinationOperator !== 0) {
                  throw new Jbig2Error("operator " + combinationOperator + " is not supported in halftone region");
                }
                var regionBitmap = [];
                var i = void 0, j = void 0, row = void 0;
                for (i = 0; i < regionHeight; i++) {
                  row = new Uint8Array(regionWidth);
                  if (defaultPixelValue) {
                    for (j = 0; j < regionWidth; j++) {
                      row[j] = defaultPixelValue;
                    }
                  }
                  regionBitmap.push(row);
                }
                var numberOfPatterns = patterns.length;
                var pattern0 = patterns[0];
                var patternWidth = pattern0[0].length, patternHeight = pattern0.length;
                var bitsPerValue = (0, _util.log2)(numberOfPatterns);
                var at = [];
                if (!mmr) {
                  at.push({
                    x: template <= 1 ? 3 : 2,
                    y: -1
                  });
                  if (template === 0) {
                    at.push({
                      x: -3,
                      y: -1
                    });
                    at.push({
                      x: 2,
                      y: -2
                    });
                    at.push({
                      x: -2,
                      y: -2
                    });
                  }
                }
                var grayScaleBitPlanes = [], mmrInput = void 0, bitmap = void 0;
                if (mmr) {
                  mmrInput = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
                }
                for (i = bitsPerValue - 1; i >= 0; i--) {
                  if (mmr) {
                    bitmap = decodeMMRBitmap(mmrInput, gridWidth, gridHeight, true);
                  } else {
                    bitmap = decodeBitmap(false, gridWidth, gridHeight, template, false, skip, at, decodingContext);
                  }
                  grayScaleBitPlanes[i] = bitmap;
                }
                var mg = void 0, ng = void 0, bit = void 0, patternIndex = void 0, patternBitmap = void 0, x = void 0, y = void 0, patternRow = void 0, regionRow = void 0;
                for (mg = 0; mg < gridHeight; mg++) {
                  for (ng = 0; ng < gridWidth; ng++) {
                    bit = 0;
                    patternIndex = 0;
                    for (j = bitsPerValue - 1; j >= 0; j--) {
                      bit = grayScaleBitPlanes[j][mg][ng] ^ bit;
                      patternIndex |= bit << j;
                    }
                    patternBitmap = patterns[patternIndex];
                    x = gridOffsetX + mg * gridVectorY + ng * gridVectorX >> 8;
                    y = gridOffsetY + mg * gridVectorX - ng * gridVectorY >> 8;
                    if (x >= 0 && x + patternWidth <= regionWidth && y >= 0 && y + patternHeight <= regionHeight) {
                      for (i = 0; i < patternHeight; i++) {
                        regionRow = regionBitmap[y + i];
                        patternRow = patternBitmap[i];
                        for (j = 0; j < patternWidth; j++) {
                          regionRow[x + j] |= patternRow[j];
                        }
                      }
                    } else {
                      var regionX = void 0, regionY = void 0;
                      for (i = 0; i < patternHeight; i++) {
                        regionY = y + i;
                        if (regionY < 0 || regionY >= regionHeight) {
                          continue;
                        }
                        regionRow = regionBitmap[regionY];
                        patternRow = patternBitmap[i];
                        for (j = 0; j < patternWidth; j++) {
                          regionX = x + j;
                          if (regionX >= 0 && regionX < regionWidth) {
                            regionRow[regionX] |= patternRow[j];
                          }
                        }
                      }
                    }
                  }
                }
                return regionBitmap;
              }
              function readSegmentHeader(data, start) {
                var segmentHeader = {};
                segmentHeader.number = (0, _util.readUint32)(data, start);
                var flags = data[start + 4];
                var segmentType = flags & 63;
                if (!SegmentTypes[segmentType]) {
                  throw new Jbig2Error("invalid segment type: " + segmentType);
                }
                segmentHeader.type = segmentType;
                segmentHeader.typeName = SegmentTypes[segmentType];
                segmentHeader.deferredNonRetain = !!(flags & 128);
                var pageAssociationFieldSize = !!(flags & 64);
                var referredFlags = data[start + 5];
                var referredToCount = referredFlags >> 5 & 7;
                var retainBits = [referredFlags & 31];
                var position = start + 6;
                if (referredFlags === 7) {
                  referredToCount = (0, _util.readUint32)(data, position - 1) & 536870911;
                  position += 3;
                  var bytes = referredToCount + 7 >> 3;
                  retainBits[0] = data[position++];
                  while (--bytes > 0) {
                    retainBits.push(data[position++]);
                  }
                } else if (referredFlags === 5 || referredFlags === 6) {
                  throw new Jbig2Error("invalid referred-to flags");
                }
                segmentHeader.retainBits = retainBits;
                var referredToSegmentNumberSize = segmentHeader.number <= 256 ? 1 : segmentHeader.number <= 65536 ? 2 : 4;
                var referredTo = [];
                var i, ii;
                for (i = 0; i < referredToCount; i++) {
                  var number = referredToSegmentNumberSize === 1 ? data[position] : referredToSegmentNumberSize === 2 ? (0, _util.readUint16)(data, position) : (0, _util.readUint32)(data, position);
                  referredTo.push(number);
                  position += referredToSegmentNumberSize;
                }
                segmentHeader.referredTo = referredTo;
                if (!pageAssociationFieldSize) {
                  segmentHeader.pageAssociation = data[position++];
                } else {
                  segmentHeader.pageAssociation = (0, _util.readUint32)(data, position);
                  position += 4;
                }
                segmentHeader.length = (0, _util.readUint32)(data, position);
                position += 4;
                if (segmentHeader.length === 4294967295) {
                  if (segmentType === 38) {
                    var genericRegionInfo = readRegionSegmentInformation(data, position);
                    var genericRegionSegmentFlags = data[position + RegionSegmentInformationFieldLength];
                    var genericRegionMmr = !!(genericRegionSegmentFlags & 1);
                    var searchPatternLength = 6;
                    var searchPattern = new Uint8Array(searchPatternLength);
                    if (!genericRegionMmr) {
                      searchPattern[0] = 255;
                      searchPattern[1] = 172;
                    }
                    searchPattern[2] = genericRegionInfo.height >>> 24 & 255;
                    searchPattern[3] = genericRegionInfo.height >> 16 & 255;
                    searchPattern[4] = genericRegionInfo.height >> 8 & 255;
                    searchPattern[5] = genericRegionInfo.height & 255;
                    for (i = position, ii = data.length; i < ii; i++) {
                      var j = 0;
                      while (j < searchPatternLength && searchPattern[j] === data[i + j]) {
                        j++;
                      }
                      if (j === searchPatternLength) {
                        segmentHeader.length = i + searchPatternLength;
                        break;
                      }
                    }
                    if (segmentHeader.length === 4294967295) {
                      throw new Jbig2Error("segment end was not found");
                    }
                  } else {
                    throw new Jbig2Error("invalid unknown segment length");
                  }
                }
                segmentHeader.headerEnd = position;
                return segmentHeader;
              }
              function readSegments(header, data, start, end) {
                var segments = [];
                var position = start;
                while (position < end) {
                  var segmentHeader = readSegmentHeader(data, position);
                  position = segmentHeader.headerEnd;
                  var segment = {
                    header: segmentHeader,
                    data
                  };
                  if (!header.randomAccess) {
                    segment.start = position;
                    position += segmentHeader.length;
                    segment.end = position;
                  }
                  segments.push(segment);
                  if (segmentHeader.type === 51) {
                    break;
                  }
                }
                if (header.randomAccess) {
                  for (var i = 0, ii = segments.length; i < ii; i++) {
                    segments[i].start = position;
                    position += segments[i].header.length;
                    segments[i].end = position;
                  }
                }
                return segments;
              }
              function readRegionSegmentInformation(data, start) {
                return {
                  width: (0, _util.readUint32)(data, start),
                  height: (0, _util.readUint32)(data, start + 4),
                  x: (0, _util.readUint32)(data, start + 8),
                  y: (0, _util.readUint32)(data, start + 12),
                  combinationOperator: data[start + 16] & 7
                };
              }
              var RegionSegmentInformationFieldLength = 17;
              function processSegment(segment, visitor) {
                var header = segment.header;
                var data = segment.data, position = segment.start, end = segment.end;
                var args, at, i, atLength;
                switch (header.type) {
                  case 0:
                    var dictionary = {};
                    var dictionaryFlags = (0, _util.readUint16)(data, position);
                    dictionary.huffman = !!(dictionaryFlags & 1);
                    dictionary.refinement = !!(dictionaryFlags & 2);
                    dictionary.huffmanDHSelector = dictionaryFlags >> 2 & 3;
                    dictionary.huffmanDWSelector = dictionaryFlags >> 4 & 3;
                    dictionary.bitmapSizeSelector = dictionaryFlags >> 6 & 1;
                    dictionary.aggregationInstancesSelector = dictionaryFlags >> 7 & 1;
                    dictionary.bitmapCodingContextUsed = !!(dictionaryFlags & 256);
                    dictionary.bitmapCodingContextRetained = !!(dictionaryFlags & 512);
                    dictionary.template = dictionaryFlags >> 10 & 3;
                    dictionary.refinementTemplate = dictionaryFlags >> 12 & 1;
                    position += 2;
                    if (!dictionary.huffman) {
                      atLength = dictionary.template === 0 ? 4 : 1;
                      at = [];
                      for (i = 0; i < atLength; i++) {
                        at.push({
                          x: (0, _util.readInt8)(data, position),
                          y: (0, _util.readInt8)(data, position + 1)
                        });
                        position += 2;
                      }
                      dictionary.at = at;
                    }
                    if (dictionary.refinement && !dictionary.refinementTemplate) {
                      at = [];
                      for (i = 0; i < 2; i++) {
                        at.push({
                          x: (0, _util.readInt8)(data, position),
                          y: (0, _util.readInt8)(data, position + 1)
                        });
                        position += 2;
                      }
                      dictionary.refinementAt = at;
                    }
                    dictionary.numberOfExportedSymbols = (0, _util.readUint32)(data, position);
                    position += 4;
                    dictionary.numberOfNewSymbols = (0, _util.readUint32)(data, position);
                    position += 4;
                    args = [dictionary, header.number, header.referredTo, data, position, end];
                    break;
                  case 6:
                  case 7:
                    var textRegion = {};
                    textRegion.info = readRegionSegmentInformation(data, position);
                    position += RegionSegmentInformationFieldLength;
                    var textRegionSegmentFlags = (0, _util.readUint16)(data, position);
                    position += 2;
                    textRegion.huffman = !!(textRegionSegmentFlags & 1);
                    textRegion.refinement = !!(textRegionSegmentFlags & 2);
                    textRegion.logStripSize = textRegionSegmentFlags >> 2 & 3;
                    textRegion.stripSize = 1 << textRegion.logStripSize;
                    textRegion.referenceCorner = textRegionSegmentFlags >> 4 & 3;
                    textRegion.transposed = !!(textRegionSegmentFlags & 64);
                    textRegion.combinationOperator = textRegionSegmentFlags >> 7 & 3;
                    textRegion.defaultPixelValue = textRegionSegmentFlags >> 9 & 1;
                    textRegion.dsOffset = textRegionSegmentFlags << 17 >> 27;
                    textRegion.refinementTemplate = textRegionSegmentFlags >> 15 & 1;
                    if (textRegion.huffman) {
                      var textRegionHuffmanFlags = (0, _util.readUint16)(data, position);
                      position += 2;
                      textRegion.huffmanFS = textRegionHuffmanFlags & 3;
                      textRegion.huffmanDS = textRegionHuffmanFlags >> 2 & 3;
                      textRegion.huffmanDT = textRegionHuffmanFlags >> 4 & 3;
                      textRegion.huffmanRefinementDW = textRegionHuffmanFlags >> 6 & 3;
                      textRegion.huffmanRefinementDH = textRegionHuffmanFlags >> 8 & 3;
                      textRegion.huffmanRefinementDX = textRegionHuffmanFlags >> 10 & 3;
                      textRegion.huffmanRefinementDY = textRegionHuffmanFlags >> 12 & 3;
                      textRegion.huffmanRefinementSizeSelector = !!(textRegionHuffmanFlags & 16384);
                    }
                    if (textRegion.refinement && !textRegion.refinementTemplate) {
                      at = [];
                      for (i = 0; i < 2; i++) {
                        at.push({
                          x: (0, _util.readInt8)(data, position),
                          y: (0, _util.readInt8)(data, position + 1)
                        });
                        position += 2;
                      }
                      textRegion.refinementAt = at;
                    }
                    textRegion.numberOfSymbolInstances = (0, _util.readUint32)(data, position);
                    position += 4;
                    args = [textRegion, header.referredTo, data, position, end];
                    break;
                  case 16:
                    var patternDictionary = {};
                    var patternDictionaryFlags = data[position++];
                    patternDictionary.mmr = !!(patternDictionaryFlags & 1);
                    patternDictionary.template = patternDictionaryFlags >> 1 & 3;
                    patternDictionary.patternWidth = data[position++];
                    patternDictionary.patternHeight = data[position++];
                    patternDictionary.maxPatternIndex = (0, _util.readUint32)(data, position);
                    position += 4;
                    args = [patternDictionary, header.number, data, position, end];
                    break;
                  case 22:
                  case 23:
                    var halftoneRegion = {};
                    halftoneRegion.info = readRegionSegmentInformation(data, position);
                    position += RegionSegmentInformationFieldLength;
                    var halftoneRegionFlags = data[position++];
                    halftoneRegion.mmr = !!(halftoneRegionFlags & 1);
                    halftoneRegion.template = halftoneRegionFlags >> 1 & 3;
                    halftoneRegion.enableSkip = !!(halftoneRegionFlags & 8);
                    halftoneRegion.combinationOperator = halftoneRegionFlags >> 4 & 7;
                    halftoneRegion.defaultPixelValue = halftoneRegionFlags >> 7 & 1;
                    halftoneRegion.gridWidth = (0, _util.readUint32)(data, position);
                    position += 4;
                    halftoneRegion.gridHeight = (0, _util.readUint32)(data, position);
                    position += 4;
                    halftoneRegion.gridOffsetX = (0, _util.readUint32)(data, position) & 4294967295;
                    position += 4;
                    halftoneRegion.gridOffsetY = (0, _util.readUint32)(data, position) & 4294967295;
                    position += 4;
                    halftoneRegion.gridVectorX = (0, _util.readUint16)(data, position);
                    position += 2;
                    halftoneRegion.gridVectorY = (0, _util.readUint16)(data, position);
                    position += 2;
                    args = [halftoneRegion, header.referredTo, data, position, end];
                    break;
                  case 38:
                  case 39:
                    var genericRegion = {};
                    genericRegion.info = readRegionSegmentInformation(data, position);
                    position += RegionSegmentInformationFieldLength;
                    var genericRegionSegmentFlags = data[position++];
                    genericRegion.mmr = !!(genericRegionSegmentFlags & 1);
                    genericRegion.template = genericRegionSegmentFlags >> 1 & 3;
                    genericRegion.prediction = !!(genericRegionSegmentFlags & 8);
                    if (!genericRegion.mmr) {
                      atLength = genericRegion.template === 0 ? 4 : 1;
                      at = [];
                      for (i = 0; i < atLength; i++) {
                        at.push({
                          x: (0, _util.readInt8)(data, position),
                          y: (0, _util.readInt8)(data, position + 1)
                        });
                        position += 2;
                      }
                      genericRegion.at = at;
                    }
                    args = [genericRegion, data, position, end];
                    break;
                  case 48:
                    var pageInfo = {
                      width: (0, _util.readUint32)(data, position),
                      height: (0, _util.readUint32)(data, position + 4),
                      resolutionX: (0, _util.readUint32)(data, position + 8),
                      resolutionY: (0, _util.readUint32)(data, position + 12)
                    };
                    if (pageInfo.height === 4294967295) {
                      delete pageInfo.height;
                    }
                    var pageSegmentFlags = data[position + 16];
                    (0, _util.readUint16)(data, position + 17);
                    pageInfo.lossless = !!(pageSegmentFlags & 1);
                    pageInfo.refinement = !!(pageSegmentFlags & 2);
                    pageInfo.defaultPixelValue = pageSegmentFlags >> 2 & 1;
                    pageInfo.combinationOperator = pageSegmentFlags >> 3 & 3;
                    pageInfo.requiresBuffer = !!(pageSegmentFlags & 32);
                    pageInfo.combinationOperatorOverride = !!(pageSegmentFlags & 64);
                    args = [pageInfo];
                    break;
                  case 49:
                    break;
                  case 50:
                    break;
                  case 51:
                    break;
                  case 53:
                    args = [header.number, data, position, end];
                    break;
                  case 62:
                    break;
                  default:
                    throw new Jbig2Error("segment type " + header.typeName + "(" + header.type + ") is not implemented");
                }
                var callbackName = "on" + header.typeName;
                if (callbackName in visitor) {
                  visitor[callbackName].apply(visitor, args);
                }
              }
              function processSegments(segments, visitor) {
                for (var i = 0, ii = segments.length; i < ii; i++) {
                  processSegment(segments[i], visitor);
                }
              }
              function parseJbig2Chunks(chunks) {
                var visitor = new SimpleSegmentVisitor();
                for (var i = 0, ii = chunks.length; i < ii; i++) {
                  var chunk = chunks[i];
                  var segments = readSegments({}, chunk.data, chunk.start, chunk.end);
                  processSegments(segments, visitor);
                }
                return visitor.buffer;
              }
              function SimpleSegmentVisitor() {
              }
              SimpleSegmentVisitor.prototype = {
                onPageInformation: function SimpleSegmentVisitor_onPageInformation(info) {
                  this.currentPageInfo = info;
                  var rowSize = info.width + 7 >> 3;
                  var buffer = new Uint8ClampedArray(rowSize * info.height);
                  if (info.defaultPixelValue) {
                    for (var i = 0, ii = buffer.length; i < ii; i++) {
                      buffer[i] = 255;
                    }
                  }
                  this.buffer = buffer;
                },
                drawBitmap: function SimpleSegmentVisitor_drawBitmap(regionInfo, bitmap) {
                  var pageInfo = this.currentPageInfo;
                  var width = regionInfo.width, height = regionInfo.height;
                  var rowSize = pageInfo.width + 7 >> 3;
                  var combinationOperator = pageInfo.combinationOperatorOverride ? regionInfo.combinationOperator : pageInfo.combinationOperator;
                  var buffer = this.buffer;
                  var mask0 = 128 >> (regionInfo.x & 7);
                  var offset0 = regionInfo.y * rowSize + (regionInfo.x >> 3);
                  var i, j, mask, offset;
                  switch (combinationOperator) {
                    case 0:
                      for (i = 0; i < height; i++) {
                        mask = mask0;
                        offset = offset0;
                        for (j = 0; j < width; j++) {
                          if (bitmap[i][j]) {
                            buffer[offset] |= mask;
                          }
                          mask >>= 1;
                          if (!mask) {
                            mask = 128;
                            offset++;
                          }
                        }
                        offset0 += rowSize;
                      }
                      break;
                    case 2:
                      for (i = 0; i < height; i++) {
                        mask = mask0;
                        offset = offset0;
                        for (j = 0; j < width; j++) {
                          if (bitmap[i][j]) {
                            buffer[offset] ^= mask;
                          }
                          mask >>= 1;
                          if (!mask) {
                            mask = 128;
                            offset++;
                          }
                        }
                        offset0 += rowSize;
                      }
                      break;
                    default:
                      throw new Jbig2Error("operator " + combinationOperator + " is not supported");
                  }
                },
                onImmediateGenericRegion: function SimpleSegmentVisitor_onImmediateGenericRegion(region, data, start, end) {
                  var regionInfo = region.info;
                  var decodingContext = new DecodingContext(data, start, end);
                  var bitmap = decodeBitmap(region.mmr, regionInfo.width, regionInfo.height, region.template, region.prediction, null, region.at, decodingContext);
                  this.drawBitmap(regionInfo, bitmap);
                },
                onImmediateLosslessGenericRegion: function SimpleSegmentVisitor_onImmediateLosslessGenericRegion() {
                  this.onImmediateGenericRegion.apply(this, arguments);
                },
                onSymbolDictionary: function SimpleSegmentVisitor_onSymbolDictionary(dictionary, currentSegment, referredSegments, data, start, end) {
                  var huffmanTables = void 0, huffmanInput = void 0;
                  if (dictionary.huffman) {
                    huffmanTables = getSymbolDictionaryHuffmanTables(dictionary, referredSegments, this.customTables);
                    huffmanInput = new Reader(data, start, end);
                  }
                  var symbols = this.symbols;
                  if (!symbols) {
                    this.symbols = symbols = {};
                  }
                  var inputSymbols = [];
                  for (var i = 0, ii = referredSegments.length; i < ii; i++) {
                    var referredSymbols = symbols[referredSegments[i]];
                    if (referredSymbols) {
                      inputSymbols = inputSymbols.concat(referredSymbols);
                    }
                  }
                  var decodingContext = new DecodingContext(data, start, end);
                  symbols[currentSegment] = decodeSymbolDictionary(dictionary.huffman, dictionary.refinement, inputSymbols, dictionary.numberOfNewSymbols, dictionary.numberOfExportedSymbols, huffmanTables, dictionary.template, dictionary.at, dictionary.refinementTemplate, dictionary.refinementAt, decodingContext, huffmanInput);
                },
                onImmediateTextRegion: function SimpleSegmentVisitor_onImmediateTextRegion(region, referredSegments, data, start, end) {
                  var regionInfo = region.info;
                  var huffmanTables = void 0, huffmanInput = void 0;
                  var symbols = this.symbols;
                  var inputSymbols = [];
                  for (var i = 0, ii = referredSegments.length; i < ii; i++) {
                    var referredSymbols = symbols[referredSegments[i]];
                    if (referredSymbols) {
                      inputSymbols = inputSymbols.concat(referredSymbols);
                    }
                  }
                  var symbolCodeLength = (0, _util.log2)(inputSymbols.length);
                  if (region.huffman) {
                    huffmanInput = new Reader(data, start, end);
                    huffmanTables = getTextRegionHuffmanTables(region, referredSegments, this.customTables, inputSymbols.length, huffmanInput);
                  }
                  var decodingContext = new DecodingContext(data, start, end);
                  var bitmap = decodeTextRegion(region.huffman, region.refinement, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.numberOfSymbolInstances, region.stripSize, inputSymbols, symbolCodeLength, region.transposed, region.dsOffset, region.referenceCorner, region.combinationOperator, huffmanTables, region.refinementTemplate, region.refinementAt, decodingContext, region.logStripSize, huffmanInput);
                  this.drawBitmap(regionInfo, bitmap);
                },
                onImmediateLosslessTextRegion: function SimpleSegmentVisitor_onImmediateLosslessTextRegion() {
                  this.onImmediateTextRegion.apply(this, arguments);
                },
                onPatternDictionary: function onPatternDictionary(dictionary, currentSegment, data, start, end) {
                  var patterns = this.patterns;
                  if (!patterns) {
                    this.patterns = patterns = {};
                  }
                  var decodingContext = new DecodingContext(data, start, end);
                  patterns[currentSegment] = decodePatternDictionary(dictionary.mmr, dictionary.patternWidth, dictionary.patternHeight, dictionary.maxPatternIndex, dictionary.template, decodingContext);
                },
                onImmediateHalftoneRegion: function onImmediateHalftoneRegion(region, referredSegments, data, start, end) {
                  var patterns = this.patterns[referredSegments[0]];
                  var regionInfo = region.info;
                  var decodingContext = new DecodingContext(data, start, end);
                  var bitmap = decodeHalftoneRegion(region.mmr, patterns, region.template, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.enableSkip, region.combinationOperator, region.gridWidth, region.gridHeight, region.gridOffsetX, region.gridOffsetY, region.gridVectorX, region.gridVectorY, decodingContext);
                  this.drawBitmap(regionInfo, bitmap);
                },
                onImmediateLosslessHalftoneRegion: function onImmediateLosslessHalftoneRegion() {
                  this.onImmediateHalftoneRegion.apply(this, arguments);
                },
                onTables: function onTables(currentSegment, data, start, end) {
                  var customTables = this.customTables;
                  if (!customTables) {
                    this.customTables = customTables = {};
                  }
                  customTables[currentSegment] = decodeTablesSegment(data, start, end);
                }
              };
              function HuffmanLine(lineData) {
                if (lineData.length === 2) {
                  this.isOOB = true;
                  this.rangeLow = 0;
                  this.prefixLength = lineData[0];
                  this.rangeLength = 0;
                  this.prefixCode = lineData[1];
                  this.isLowerRange = false;
                } else {
                  this.isOOB = false;
                  this.rangeLow = lineData[0];
                  this.prefixLength = lineData[1];
                  this.rangeLength = lineData[2];
                  this.prefixCode = lineData[3];
                  this.isLowerRange = lineData[4] === "lower";
                }
              }
              function HuffmanTreeNode(line) {
                this.children = [];
                if (line) {
                  this.isLeaf = true;
                  this.rangeLength = line.rangeLength;
                  this.rangeLow = line.rangeLow;
                  this.isLowerRange = line.isLowerRange;
                  this.isOOB = line.isOOB;
                } else {
                  this.isLeaf = false;
                }
              }
              HuffmanTreeNode.prototype = {
                buildTree: function buildTree(line, shift) {
                  var bit = line.prefixCode >> shift & 1;
                  if (shift <= 0) {
                    this.children[bit] = new HuffmanTreeNode(line);
                  } else {
                    var node = this.children[bit];
                    if (!node) {
                      this.children[bit] = node = new HuffmanTreeNode(null);
                    }
                    node.buildTree(line, shift - 1);
                  }
                },
                decodeNode: function decodeNode(reader) {
                  if (this.isLeaf) {
                    if (this.isOOB) {
                      return null;
                    }
                    var htOffset = reader.readBits(this.rangeLength);
                    return this.rangeLow + (this.isLowerRange ? -htOffset : htOffset);
                  }
                  var node = this.children[reader.readBit()];
                  if (!node) {
                    throw new Jbig2Error("invalid Huffman data");
                  }
                  return node.decodeNode(reader);
                }
              };
              function HuffmanTable(lines, prefixCodesDone) {
                if (!prefixCodesDone) {
                  this.assignPrefixCodes(lines);
                }
                this.rootNode = new HuffmanTreeNode(null);
                var i = void 0, ii = lines.length, line = void 0;
                for (i = 0; i < ii; i++) {
                  line = lines[i];
                  if (line.prefixLength > 0) {
                    this.rootNode.buildTree(line, line.prefixLength - 1);
                  }
                }
              }
              HuffmanTable.prototype = {
                decode: function decode(reader) {
                  return this.rootNode.decodeNode(reader);
                },
                assignPrefixCodes: function assignPrefixCodes(lines) {
                  var linesLength = lines.length, prefixLengthMax = 0, i = void 0;
                  for (i = 0; i < linesLength; i++) {
                    prefixLengthMax = Math.max(prefixLengthMax, lines[i].prefixLength);
                  }
                  var histogram = new Uint32Array(prefixLengthMax + 1);
                  for (i = 0; i < linesLength; i++) {
                    histogram[lines[i].prefixLength]++;
                  }
                  var currentLength = 1, firstCode = 0, currentCode = void 0, currentTemp = void 0, line = void 0;
                  histogram[0] = 0;
                  while (currentLength <= prefixLengthMax) {
                    firstCode = firstCode + histogram[currentLength - 1] << 1;
                    currentCode = firstCode;
                    currentTemp = 0;
                    while (currentTemp < linesLength) {
                      line = lines[currentTemp];
                      if (line.prefixLength === currentLength) {
                        line.prefixCode = currentCode;
                        currentCode++;
                      }
                      currentTemp++;
                    }
                    currentLength++;
                  }
                }
              };
              function decodeTablesSegment(data, start, end) {
                var flags = data[start];
                var lowestValue = (0, _util.readUint32)(data, start + 1) & 4294967295;
                var highestValue = (0, _util.readUint32)(data, start + 5) & 4294967295;
                var reader = new Reader(data, start + 9, end);
                var prefixSizeBits = (flags >> 1 & 7) + 1;
                var rangeSizeBits = (flags >> 4 & 7) + 1;
                var lines = [];
                var prefixLength = void 0, rangeLength = void 0, currentRangeLow = lowestValue;
                do {
                  prefixLength = reader.readBits(prefixSizeBits);
                  rangeLength = reader.readBits(rangeSizeBits);
                  lines.push(new HuffmanLine([currentRangeLow, prefixLength, rangeLength, 0]));
                  currentRangeLow += 1 << rangeLength;
                } while (currentRangeLow < highestValue);
                prefixLength = reader.readBits(prefixSizeBits);
                lines.push(new HuffmanLine([lowestValue - 1, prefixLength, 32, 0, "lower"]));
                prefixLength = reader.readBits(prefixSizeBits);
                lines.push(new HuffmanLine([highestValue, prefixLength, 32, 0]));
                if (flags & 1) {
                  prefixLength = reader.readBits(prefixSizeBits);
                  lines.push(new HuffmanLine([prefixLength, 0]));
                }
                return new HuffmanTable(lines, false);
              }
              var standardTablesCache = {};
              function getStandardTable(number) {
                var table = standardTablesCache[number];
                if (table) {
                  return table;
                }
                var lines = void 0;
                switch (number) {
                  case 1:
                    lines = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
                    break;
                  case 2:
                    lines = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
                    break;
                  case 3:
                    lines = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
                    break;
                  case 4:
                    lines = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
                    break;
                  case 5:
                    lines = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
                    break;
                  case 6:
                    lines = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
                    break;
                  case 7:
                    lines = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
                    break;
                  case 8:
                    lines = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
                    break;
                  case 9:
                    lines = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
                    break;
                  case 10:
                    lines = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
                    break;
                  case 11:
                    lines = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
                    break;
                  case 12:
                    lines = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
                    break;
                  case 13:
                    lines = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
                    break;
                  case 14:
                    lines = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
                    break;
                  case 15:
                    lines = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
                    break;
                  default:
                    throw new Jbig2Error("standard table B." + number + " does not exist");
                }
                var length = lines.length, i = void 0;
                for (i = 0; i < length; i++) {
                  lines[i] = new HuffmanLine(lines[i]);
                }
                table = new HuffmanTable(lines, true);
                standardTablesCache[number] = table;
                return table;
              }
              function Reader(data, start, end) {
                this.data = data;
                this.start = start;
                this.end = end;
                this.position = start;
                this.shift = -1;
                this.currentByte = 0;
              }
              Reader.prototype = {
                readBit: function readBit() {
                  if (this.shift < 0) {
                    if (this.position >= this.end) {
                      throw new Jbig2Error("end of data while reading bit");
                    }
                    this.currentByte = this.data[this.position++];
                    this.shift = 7;
                  }
                  var bit = this.currentByte >> this.shift & 1;
                  this.shift--;
                  return bit;
                },
                readBits: function readBits(numBits) {
                  var result = 0, i = void 0;
                  for (i = numBits - 1; i >= 0; i--) {
                    result |= this.readBit() << i;
                  }
                  return result;
                },
                byteAlign: function byteAlign() {
                  this.shift = -1;
                },
                next: function next() {
                  if (this.position >= this.end) {
                    return -1;
                  }
                  return this.data[this.position++];
                }
              };
              function getCustomHuffmanTable(index, referredTo, customTables) {
                var currentIndex = 0, i = void 0, ii = referredTo.length, table = void 0;
                for (i = 0; i < ii; i++) {
                  table = customTables[referredTo[i]];
                  if (table) {
                    if (index === currentIndex) {
                      return table;
                    }
                    currentIndex++;
                  }
                }
                throw new Jbig2Error("can't find custom Huffman table");
              }
              function getTextRegionHuffmanTables(textRegion, referredTo, customTables, numberOfSymbols, reader) {
                var codes = [], i = void 0, codeLength = void 0;
                for (i = 0; i <= 34; i++) {
                  codeLength = reader.readBits(4);
                  codes.push(new HuffmanLine([i, codeLength, 0, 0]));
                }
                var runCodesTable = new HuffmanTable(codes, false);
                codes.length = 0;
                for (i = 0; i < numberOfSymbols; ) {
                  codeLength = runCodesTable.decode(reader);
                  if (codeLength >= 32) {
                    var repeatedLength = void 0, numberOfRepeats = void 0, j = void 0;
                    switch (codeLength) {
                      case 32:
                        if (i === 0) {
                          throw new Jbig2Error("no previous value in symbol ID table");
                        }
                        numberOfRepeats = reader.readBits(2) + 3;
                        repeatedLength = codes[i - 1].prefixLength;
                        break;
                      case 33:
                        numberOfRepeats = reader.readBits(3) + 3;
                        repeatedLength = 0;
                        break;
                      case 34:
                        numberOfRepeats = reader.readBits(7) + 11;
                        repeatedLength = 0;
                        break;
                      default:
                        throw new Jbig2Error("invalid code length in symbol ID table");
                    }
                    for (j = 0; j < numberOfRepeats; j++) {
                      codes.push(new HuffmanLine([i, repeatedLength, 0, 0]));
                      i++;
                    }
                  } else {
                    codes.push(new HuffmanLine([i, codeLength, 0, 0]));
                    i++;
                  }
                }
                reader.byteAlign();
                var symbolIDTable = new HuffmanTable(codes, false);
                var customIndex = 0, tableFirstS = void 0, tableDeltaS = void 0, tableDeltaT = void 0;
                switch (textRegion.huffmanFS) {
                  case 0:
                  case 1:
                    tableFirstS = getStandardTable(textRegion.huffmanFS + 6);
                    break;
                  case 3:
                    tableFirstS = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman FS selector");
                }
                switch (textRegion.huffmanDS) {
                  case 0:
                  case 1:
                  case 2:
                    tableDeltaS = getStandardTable(textRegion.huffmanDS + 8);
                    break;
                  case 3:
                    tableDeltaS = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DS selector");
                }
                switch (textRegion.huffmanDT) {
                  case 0:
                  case 1:
                  case 2:
                    tableDeltaT = getStandardTable(textRegion.huffmanDT + 11);
                    break;
                  case 3:
                    tableDeltaT = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DT selector");
                }
                if (textRegion.refinement) {
                  throw new Jbig2Error("refinement with Huffman is not supported");
                }
                return {
                  symbolIDTable,
                  tableFirstS,
                  tableDeltaS,
                  tableDeltaT
                };
              }
              function getSymbolDictionaryHuffmanTables(dictionary, referredTo, customTables) {
                var customIndex = 0, tableDeltaHeight = void 0, tableDeltaWidth = void 0;
                switch (dictionary.huffmanDHSelector) {
                  case 0:
                  case 1:
                    tableDeltaHeight = getStandardTable(dictionary.huffmanDHSelector + 4);
                    break;
                  case 3:
                    tableDeltaHeight = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DH selector");
                }
                switch (dictionary.huffmanDWSelector) {
                  case 0:
                  case 1:
                    tableDeltaWidth = getStandardTable(dictionary.huffmanDWSelector + 2);
                    break;
                  case 3:
                    tableDeltaWidth = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    customIndex++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DW selector");
                }
                var tableBitmapSize = void 0, tableAggregateInstances = void 0;
                if (dictionary.bitmapSizeSelector) {
                  tableBitmapSize = getCustomHuffmanTable(customIndex, referredTo, customTables);
                  customIndex++;
                } else {
                  tableBitmapSize = getStandardTable(1);
                }
                if (dictionary.aggregationInstancesSelector) {
                  tableAggregateInstances = getCustomHuffmanTable(customIndex, referredTo, customTables);
                } else {
                  tableAggregateInstances = getStandardTable(1);
                }
                return {
                  tableDeltaHeight,
                  tableDeltaWidth,
                  tableBitmapSize,
                  tableAggregateInstances
                };
              }
              function readUncompressedBitmap(reader, width, height) {
                var bitmap = [], x = void 0, y = void 0, row = void 0;
                for (y = 0; y < height; y++) {
                  row = new Uint8Array(width);
                  bitmap.push(row);
                  for (x = 0; x < width; x++) {
                    row[x] = reader.readBit();
                  }
                  reader.byteAlign();
                }
                return bitmap;
              }
              function decodeMMRBitmap(input, width, height, endOfBlock) {
                var params = {
                  K: -1,
                  Columns: width,
                  Rows: height,
                  BlackIs1: true,
                  EndOfBlock: endOfBlock
                };
                var decoder = new _ccitt.CCITTFaxDecoder(input, params);
                var bitmap = [], x = void 0, y = void 0, row = void 0, currentByte = void 0, shift = void 0, eof = false;
                for (y = 0; y < height; y++) {
                  row = new Uint8Array(width);
                  bitmap.push(row);
                  shift = -1;
                  for (x = 0; x < width; x++) {
                    if (shift < 0) {
                      currentByte = decoder.readNextChar();
                      if (currentByte === -1) {
                        currentByte = 0;
                        eof = true;
                      }
                      shift = 7;
                    }
                    row[x] = currentByte >> shift & 1;
                    shift--;
                  }
                }
                if (endOfBlock && !eof) {
                  var lookForEOFLimit = 5;
                  for (var i = 0; i < lookForEOFLimit; i++) {
                    if (decoder.readNextChar() === -1) {
                      break;
                    }
                  }
                }
                return bitmap;
              }
              function Jbig2Image2() {
              }
              Jbig2Image2.prototype = {
                parseChunks: function Jbig2Image_parseChunks(chunks) {
                  return parseJbig2Chunks(chunks);
                }
              };
              return Jbig2Image2;
            }();
            exports3.Jbig2Image = Jbig2Image;
          },
          /* 126 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            var ArithmeticDecoder = function ArithmeticDecoderClosure() {
              var QeTable = [{
                qe: 22017,
                nmps: 1,
                nlps: 1,
                switchFlag: 1
              }, {
                qe: 13313,
                nmps: 2,
                nlps: 6,
                switchFlag: 0
              }, {
                qe: 6145,
                nmps: 3,
                nlps: 9,
                switchFlag: 0
              }, {
                qe: 2753,
                nmps: 4,
                nlps: 12,
                switchFlag: 0
              }, {
                qe: 1313,
                nmps: 5,
                nlps: 29,
                switchFlag: 0
              }, {
                qe: 545,
                nmps: 38,
                nlps: 33,
                switchFlag: 0
              }, {
                qe: 22017,
                nmps: 7,
                nlps: 6,
                switchFlag: 1
              }, {
                qe: 21505,
                nmps: 8,
                nlps: 14,
                switchFlag: 0
              }, {
                qe: 18433,
                nmps: 9,
                nlps: 14,
                switchFlag: 0
              }, {
                qe: 14337,
                nmps: 10,
                nlps: 14,
                switchFlag: 0
              }, {
                qe: 12289,
                nmps: 11,
                nlps: 17,
                switchFlag: 0
              }, {
                qe: 9217,
                nmps: 12,
                nlps: 18,
                switchFlag: 0
              }, {
                qe: 7169,
                nmps: 13,
                nlps: 20,
                switchFlag: 0
              }, {
                qe: 5633,
                nmps: 29,
                nlps: 21,
                switchFlag: 0
              }, {
                qe: 22017,
                nmps: 15,
                nlps: 14,
                switchFlag: 1
              }, {
                qe: 21505,
                nmps: 16,
                nlps: 14,
                switchFlag: 0
              }, {
                qe: 20737,
                nmps: 17,
                nlps: 15,
                switchFlag: 0
              }, {
                qe: 18433,
                nmps: 18,
                nlps: 16,
                switchFlag: 0
              }, {
                qe: 14337,
                nmps: 19,
                nlps: 17,
                switchFlag: 0
              }, {
                qe: 13313,
                nmps: 20,
                nlps: 18,
                switchFlag: 0
              }, {
                qe: 12289,
                nmps: 21,
                nlps: 19,
                switchFlag: 0
              }, {
                qe: 10241,
                nmps: 22,
                nlps: 19,
                switchFlag: 0
              }, {
                qe: 9217,
                nmps: 23,
                nlps: 20,
                switchFlag: 0
              }, {
                qe: 8705,
                nmps: 24,
                nlps: 21,
                switchFlag: 0
              }, {
                qe: 7169,
                nmps: 25,
                nlps: 22,
                switchFlag: 0
              }, {
                qe: 6145,
                nmps: 26,
                nlps: 23,
                switchFlag: 0
              }, {
                qe: 5633,
                nmps: 27,
                nlps: 24,
                switchFlag: 0
              }, {
                qe: 5121,
                nmps: 28,
                nlps: 25,
                switchFlag: 0
              }, {
                qe: 4609,
                nmps: 29,
                nlps: 26,
                switchFlag: 0
              }, {
                qe: 4353,
                nmps: 30,
                nlps: 27,
                switchFlag: 0
              }, {
                qe: 2753,
                nmps: 31,
                nlps: 28,
                switchFlag: 0
              }, {
                qe: 2497,
                nmps: 32,
                nlps: 29,
                switchFlag: 0
              }, {
                qe: 2209,
                nmps: 33,
                nlps: 30,
                switchFlag: 0
              }, {
                qe: 1313,
                nmps: 34,
                nlps: 31,
                switchFlag: 0
              }, {
                qe: 1089,
                nmps: 35,
                nlps: 32,
                switchFlag: 0
              }, {
                qe: 673,
                nmps: 36,
                nlps: 33,
                switchFlag: 0
              }, {
                qe: 545,
                nmps: 37,
                nlps: 34,
                switchFlag: 0
              }, {
                qe: 321,
                nmps: 38,
                nlps: 35,
                switchFlag: 0
              }, {
                qe: 273,
                nmps: 39,
                nlps: 36,
                switchFlag: 0
              }, {
                qe: 133,
                nmps: 40,
                nlps: 37,
                switchFlag: 0
              }, {
                qe: 73,
                nmps: 41,
                nlps: 38,
                switchFlag: 0
              }, {
                qe: 37,
                nmps: 42,
                nlps: 39,
                switchFlag: 0
              }, {
                qe: 21,
                nmps: 43,
                nlps: 40,
                switchFlag: 0
              }, {
                qe: 9,
                nmps: 44,
                nlps: 41,
                switchFlag: 0
              }, {
                qe: 5,
                nmps: 45,
                nlps: 42,
                switchFlag: 0
              }, {
                qe: 1,
                nmps: 45,
                nlps: 43,
                switchFlag: 0
              }, {
                qe: 22017,
                nmps: 46,
                nlps: 46,
                switchFlag: 0
              }];
              function ArithmeticDecoder2(data, start, end) {
                this.data = data;
                this.bp = start;
                this.dataEnd = end;
                this.chigh = data[start];
                this.clow = 0;
                this.byteIn();
                this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127;
                this.clow = this.clow << 7 & 65535;
                this.ct -= 7;
                this.a = 32768;
              }
              ArithmeticDecoder2.prototype = {
                byteIn: function ArithmeticDecoder_byteIn() {
                  var data = this.data;
                  var bp = this.bp;
                  if (data[bp] === 255) {
                    var b1 = data[bp + 1];
                    if (b1 > 143) {
                      this.clow += 65280;
                      this.ct = 8;
                    } else {
                      bp++;
                      this.clow += data[bp] << 9;
                      this.ct = 7;
                      this.bp = bp;
                    }
                  } else {
                    bp++;
                    this.clow += bp < this.dataEnd ? data[bp] << 8 : 65280;
                    this.ct = 8;
                    this.bp = bp;
                  }
                  if (this.clow > 65535) {
                    this.chigh += this.clow >> 16;
                    this.clow &= 65535;
                  }
                },
                readBit: function ArithmeticDecoder_readBit(contexts, pos) {
                  var cx_index = contexts[pos] >> 1, cx_mps = contexts[pos] & 1;
                  var qeTableIcx = QeTable[cx_index];
                  var qeIcx = qeTableIcx.qe;
                  var d;
                  var a = this.a - qeIcx;
                  if (this.chigh < qeIcx) {
                    if (a < qeIcx) {
                      a = qeIcx;
                      d = cx_mps;
                      cx_index = qeTableIcx.nmps;
                    } else {
                      a = qeIcx;
                      d = 1 ^ cx_mps;
                      if (qeTableIcx.switchFlag === 1) {
                        cx_mps = d;
                      }
                      cx_index = qeTableIcx.nlps;
                    }
                  } else {
                    this.chigh -= qeIcx;
                    if ((a & 32768) !== 0) {
                      this.a = a;
                      return cx_mps;
                    }
                    if (a < qeIcx) {
                      d = 1 ^ cx_mps;
                      if (qeTableIcx.switchFlag === 1) {
                        cx_mps = d;
                      }
                      cx_index = qeTableIcx.nlps;
                    } else {
                      d = cx_mps;
                      cx_index = qeTableIcx.nmps;
                    }
                  }
                  do {
                    if (this.ct === 0) {
                      this.byteIn();
                    }
                    a <<= 1;
                    this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1;
                    this.clow = this.clow << 1 & 65535;
                    this.ct--;
                  } while ((a & 32768) === 0);
                  this.a = a;
                  contexts[pos] = cx_index << 1 | cx_mps;
                  return d;
                }
              };
              return ArithmeticDecoder2;
            }();
            exports3.ArithmeticDecoder = ArithmeticDecoder;
          },
          /* 127 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.JpegStream = void 0;
            var _util = __w_pdfjs_require__(2);
            var _stream = __w_pdfjs_require__(121);
            var _primitives = __w_pdfjs_require__(119);
            var _jpg = __w_pdfjs_require__(128);
            var JpegStream = function JpegStreamClosure() {
              function JpegStream2(stream2, maybeLength, dict, params) {
                var ch = void 0;
                while ((ch = stream2.getByte()) !== -1) {
                  if (ch === 255) {
                    stream2.skip(-1);
                    break;
                  }
                }
                this.stream = stream2;
                this.maybeLength = maybeLength;
                this.dict = dict;
                this.params = params;
                _stream.DecodeStream.call(this, maybeLength);
              }
              JpegStream2.prototype = Object.create(_stream.DecodeStream.prototype);
              Object.defineProperty(JpegStream2.prototype, "bytes", {
                get: function JpegStream_bytes() {
                  return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
                },
                configurable: true
              });
              JpegStream2.prototype.ensureBuffer = function(requested) {
              };
              JpegStream2.prototype.readBlock = function() {
                if (this.eof) {
                  return;
                }
                var jpegImage = new _jpg.JpegImage();
                var decodeArr = this.dict.getArray("Decode", "D");
                if (this.forceRGB && Array.isArray(decodeArr)) {
                  var bitsPerComponent = this.dict.get("BitsPerComponent") || 8;
                  var decodeArrLength = decodeArr.length;
                  var transform = new Int32Array(decodeArrLength);
                  var transformNeeded = false;
                  var maxValue = (1 << bitsPerComponent) - 1;
                  for (var i = 0; i < decodeArrLength; i += 2) {
                    transform[i] = (decodeArr[i + 1] - decodeArr[i]) * 256 | 0;
                    transform[i + 1] = decodeArr[i] * maxValue | 0;
                    if (transform[i] !== 256 || transform[i + 1] !== 0) {
                      transformNeeded = true;
                    }
                  }
                  if (transformNeeded) {
                    jpegImage.decodeTransform = transform;
                  }
                }
                if ((0, _primitives.isDict)(this.params)) {
                  var colorTransform = this.params.get("ColorTransform");
                  if (Number.isInteger(colorTransform)) {
                    jpegImage.colorTransform = colorTransform;
                  }
                }
                jpegImage.parse(this.bytes);
                var data = jpegImage.getData(this.drawWidth, this.drawHeight, this.forceRGB);
                this.buffer = data;
                this.bufferLength = data.length;
                this.eof = true;
              };
              JpegStream2.prototype.getIR = function() {
                var forceDataSchema = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                return (0, _util.createObjectURL)(this.bytes, "image/jpeg", forceDataSchema);
              };
              return JpegStream2;
            }();
            exports3.JpegStream = JpegStream;
          },
          /* 128 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.JpegImage = void 0;
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var _util = __w_pdfjs_require__(2);
            var JpegError = function JpegErrorClosure() {
              function JpegError2(msg) {
                this.message = "JPEG error: " + msg;
              }
              JpegError2.prototype = new Error();
              JpegError2.prototype.name = "JpegError";
              JpegError2.constructor = JpegError2;
              return JpegError2;
            }();
            var DNLMarkerError = function DNLMarkerErrorClosure() {
              function DNLMarkerError2(message, scanLines) {
                this.message = message;
                this.scanLines = scanLines;
              }
              DNLMarkerError2.prototype = new Error();
              DNLMarkerError2.prototype.name = "DNLMarkerError";
              DNLMarkerError2.constructor = DNLMarkerError2;
              return DNLMarkerError2;
            }();
            var EOIMarkerError = function EOIMarkerErrorClosure() {
              function EOIMarkerError2(message) {
                this.message = message;
              }
              EOIMarkerError2.prototype = new Error();
              EOIMarkerError2.prototype.name = "EOIMarkerError";
              EOIMarkerError2.constructor = EOIMarkerError2;
              return EOIMarkerError2;
            }();
            var JpegImage = function JpegImageClosure() {
              var dctZigZag = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
              var dctCos1 = 4017;
              var dctSin1 = 799;
              var dctCos3 = 3406;
              var dctSin3 = 2276;
              var dctCos6 = 1567;
              var dctSin6 = 3784;
              var dctSqrt2 = 5793;
              var dctSqrt1d2 = 2896;
              function JpegImage2() {
                this.decodeTransform = null;
                this.colorTransform = -1;
              }
              function buildHuffmanTable(codeLengths, values) {
                var k = 0, code = [], i, j, length = 16;
                while (length > 0 && !codeLengths[length - 1]) {
                  length--;
                }
                code.push({
                  children: [],
                  index: 0
                });
                var p = code[0], q;
                for (i = 0; i < length; i++) {
                  for (j = 0; j < codeLengths[i]; j++) {
                    p = code.pop();
                    p.children[p.index] = values[k];
                    while (p.index > 0) {
                      p = code.pop();
                    }
                    p.index++;
                    code.push(p);
                    while (code.length <= i) {
                      code.push(q = {
                        children: [],
                        index: 0
                      });
                      p.children[p.index] = q.children;
                      p = q;
                    }
                    k++;
                  }
                  if (i + 1 < length) {
                    code.push(q = {
                      children: [],
                      index: 0
                    });
                    p.children[p.index] = q.children;
                    p = q;
                  }
                }
                return code[0].children;
              }
              function getBlockBufferOffset(component, row, col) {
                return 64 * ((component.blocksPerLine + 1) * row + col);
              }
              function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {
                var parseDNLMarker = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : false;
                var mcusPerLine = frame.mcusPerLine;
                var progressive = frame.progressive;
                var startOffset = offset, bitsData = 0, bitsCount = 0;
                function readBit() {
                  if (bitsCount > 0) {
                    bitsCount--;
                    return bitsData >> bitsCount & 1;
                  }
                  bitsData = data[offset++];
                  if (bitsData === 255) {
                    var nextByte = data[offset++];
                    if (nextByte) {
                      if (nextByte === 220 && parseDNLMarker) {
                        offset += 2;
                        var scanLines = data[offset++] << 8 | data[offset++];
                        if (scanLines > 0 && scanLines !== frame.scanLines) {
                          throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", scanLines);
                        }
                      } else if (nextByte === 217) {
                        throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
                      }
                      throw new JpegError("unexpected marker " + (bitsData << 8 | nextByte).toString(16));
                    }
                  }
                  bitsCount = 7;
                  return bitsData >>> 7;
                }
                function decodeHuffman(tree) {
                  var node = tree;
                  while (true) {
                    node = node[readBit()];
                    if (typeof node === "number") {
                      return node;
                    }
                    if ((typeof node === "undefined" ? "undefined" : _typeof(node)) !== "object") {
                      throw new JpegError("invalid huffman sequence");
                    }
                  }
                }
                function receive(length) {
                  var n2 = 0;
                  while (length > 0) {
                    n2 = n2 << 1 | readBit();
                    length--;
                  }
                  return n2;
                }
                function receiveAndExtend(length) {
                  if (length === 1) {
                    return readBit() === 1 ? 1 : -1;
                  }
                  var n2 = receive(length);
                  if (n2 >= 1 << length - 1) {
                    return n2;
                  }
                  return n2 + (-1 << length) + 1;
                }
                function decodeBaseline(component2, offset2) {
                  var t = decodeHuffman(component2.huffmanTableDC);
                  var diff = t === 0 ? 0 : receiveAndExtend(t);
                  component2.blockData[offset2] = component2.pred += diff;
                  var k2 = 1;
                  while (k2 < 64) {
                    var rs = decodeHuffman(component2.huffmanTableAC);
                    var s = rs & 15, r = rs >> 4;
                    if (s === 0) {
                      if (r < 15) {
                        break;
                      }
                      k2 += 16;
                      continue;
                    }
                    k2 += r;
                    var z = dctZigZag[k2];
                    component2.blockData[offset2 + z] = receiveAndExtend(s);
                    k2++;
                  }
                }
                function decodeDCFirst(component2, offset2) {
                  var t = decodeHuffman(component2.huffmanTableDC);
                  var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
                  component2.blockData[offset2] = component2.pred += diff;
                }
                function decodeDCSuccessive(component2, offset2) {
                  component2.blockData[offset2] |= readBit() << successive;
                }
                var eobrun = 0;
                function decodeACFirst(component2, offset2) {
                  if (eobrun > 0) {
                    eobrun--;
                    return;
                  }
                  var k2 = spectralStart, e = spectralEnd;
                  while (k2 <= e) {
                    var rs = decodeHuffman(component2.huffmanTableAC);
                    var s = rs & 15, r = rs >> 4;
                    if (s === 0) {
                      if (r < 15) {
                        eobrun = receive(r) + (1 << r) - 1;
                        break;
                      }
                      k2 += 16;
                      continue;
                    }
                    k2 += r;
                    var z = dctZigZag[k2];
                    component2.blockData[offset2 + z] = receiveAndExtend(s) * (1 << successive);
                    k2++;
                  }
                }
                var successiveACState = 0, successiveACNextValue;
                function decodeACSuccessive(component2, offset2) {
                  var k2 = spectralStart;
                  var e = spectralEnd;
                  var r = 0;
                  var s;
                  var rs;
                  while (k2 <= e) {
                    var offsetZ = offset2 + dctZigZag[k2];
                    var sign = component2.blockData[offsetZ] < 0 ? -1 : 1;
                    switch (successiveACState) {
                      case 0:
                        rs = decodeHuffman(component2.huffmanTableAC);
                        s = rs & 15;
                        r = rs >> 4;
                        if (s === 0) {
                          if (r < 15) {
                            eobrun = receive(r) + (1 << r);
                            successiveACState = 4;
                          } else {
                            r = 16;
                            successiveACState = 1;
                          }
                        } else {
                          if (s !== 1) {
                            throw new JpegError("invalid ACn encoding");
                          }
                          successiveACNextValue = receiveAndExtend(s);
                          successiveACState = r ? 2 : 3;
                        }
                        continue;
                      case 1:
                      case 2:
                        if (component2.blockData[offsetZ]) {
                          component2.blockData[offsetZ] += sign * (readBit() << successive);
                        } else {
                          r--;
                          if (r === 0) {
                            successiveACState = successiveACState === 2 ? 3 : 0;
                          }
                        }
                        break;
                      case 3:
                        if (component2.blockData[offsetZ]) {
                          component2.blockData[offsetZ] += sign * (readBit() << successive);
                        } else {
                          component2.blockData[offsetZ] = successiveACNextValue << successive;
                          successiveACState = 0;
                        }
                        break;
                      case 4:
                        if (component2.blockData[offsetZ]) {
                          component2.blockData[offsetZ] += sign * (readBit() << successive);
                        }
                        break;
                    }
                    k2++;
                  }
                  if (successiveACState === 4) {
                    eobrun--;
                    if (eobrun === 0) {
                      successiveACState = 0;
                    }
                  }
                }
                function decodeMcu(component2, decode, mcu2, row, col) {
                  var mcuRow = mcu2 / mcusPerLine | 0;
                  var mcuCol = mcu2 % mcusPerLine;
                  var blockRow = mcuRow * component2.v + row;
                  var blockCol = mcuCol * component2.h + col;
                  var offset2 = getBlockBufferOffset(component2, blockRow, blockCol);
                  decode(component2, offset2);
                }
                function decodeBlock(component2, decode, mcu2) {
                  var blockRow = mcu2 / component2.blocksPerLine | 0;
                  var blockCol = mcu2 % component2.blocksPerLine;
                  var offset2 = getBlockBufferOffset(component2, blockRow, blockCol);
                  decode(component2, offset2);
                }
                var componentsLength = components.length;
                var component, i, j, k, n;
                var decodeFn;
                if (progressive) {
                  if (spectralStart === 0) {
                    decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
                  } else {
                    decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
                  }
                } else {
                  decodeFn = decodeBaseline;
                }
                var mcu = 0, fileMarker;
                var mcuExpected;
                if (componentsLength === 1) {
                  mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
                } else {
                  mcuExpected = mcusPerLine * frame.mcusPerColumn;
                }
                var h, v;
                while (mcu < mcuExpected) {
                  var mcuToRead = resetInterval ? Math.min(mcuExpected - mcu, resetInterval) : mcuExpected;
                  for (i = 0; i < componentsLength; i++) {
                    components[i].pred = 0;
                  }
                  eobrun = 0;
                  if (componentsLength === 1) {
                    component = components[0];
                    for (n = 0; n < mcuToRead; n++) {
                      decodeBlock(component, decodeFn, mcu);
                      mcu++;
                    }
                  } else {
                    for (n = 0; n < mcuToRead; n++) {
                      for (i = 0; i < componentsLength; i++) {
                        component = components[i];
                        h = component.h;
                        v = component.v;
                        for (j = 0; j < v; j++) {
                          for (k = 0; k < h; k++) {
                            decodeMcu(component, decodeFn, mcu, j, k);
                          }
                        }
                      }
                      mcu++;
                    }
                  }
                  bitsCount = 0;
                  fileMarker = findNextFileMarker(data, offset);
                  if (fileMarker && fileMarker.invalid) {
                    (0, _util.warn)("decodeScan - unexpected MCU data, current marker is: " + fileMarker.invalid);
                    offset = fileMarker.offset;
                  }
                  var marker = fileMarker && fileMarker.marker;
                  if (!marker || marker <= 65280) {
                    throw new JpegError("marker was not found");
                  }
                  if (marker >= 65488 && marker <= 65495) {
                    offset += 2;
                  } else {
                    break;
                  }
                }
                fileMarker = findNextFileMarker(data, offset);
                if (fileMarker && fileMarker.invalid) {
                  (0, _util.warn)("decodeScan - unexpected Scan data, current marker is: " + fileMarker.invalid);
                  offset = fileMarker.offset;
                }
                return offset - startOffset;
              }
              function quantizeAndInverse(component, blockBufferOffset, p) {
                var qt = component.quantizationTable, blockData = component.blockData;
                var v0, v1, v2, v3, v4, v5, v6, v7;
                var p0, p1, p2, p3, p4, p5, p6, p7;
                var t;
                if (!qt) {
                  throw new JpegError("missing required Quantization Table.");
                }
                for (var row = 0; row < 64; row += 8) {
                  p0 = blockData[blockBufferOffset + row];
                  p1 = blockData[blockBufferOffset + row + 1];
                  p2 = blockData[blockBufferOffset + row + 2];
                  p3 = blockData[blockBufferOffset + row + 3];
                  p4 = blockData[blockBufferOffset + row + 4];
                  p5 = blockData[blockBufferOffset + row + 5];
                  p6 = blockData[blockBufferOffset + row + 6];
                  p7 = blockData[blockBufferOffset + row + 7];
                  p0 *= qt[row];
                  if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
                    t = dctSqrt2 * p0 + 512 >> 10;
                    p[row] = t;
                    p[row + 1] = t;
                    p[row + 2] = t;
                    p[row + 3] = t;
                    p[row + 4] = t;
                    p[row + 5] = t;
                    p[row + 6] = t;
                    p[row + 7] = t;
                    continue;
                  }
                  p1 *= qt[row + 1];
                  p2 *= qt[row + 2];
                  p3 *= qt[row + 3];
                  p4 *= qt[row + 4];
                  p5 *= qt[row + 5];
                  p6 *= qt[row + 6];
                  p7 *= qt[row + 7];
                  v0 = dctSqrt2 * p0 + 128 >> 8;
                  v1 = dctSqrt2 * p4 + 128 >> 8;
                  v2 = p2;
                  v3 = p6;
                  v4 = dctSqrt1d2 * (p1 - p7) + 128 >> 8;
                  v7 = dctSqrt1d2 * (p1 + p7) + 128 >> 8;
                  v5 = p3 << 4;
                  v6 = p5 << 4;
                  v0 = v0 + v1 + 1 >> 1;
                  v1 = v0 - v1;
                  t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
                  v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
                  v3 = t;
                  v4 = v4 + v6 + 1 >> 1;
                  v6 = v4 - v6;
                  v7 = v7 + v5 + 1 >> 1;
                  v5 = v7 - v5;
                  v0 = v0 + v3 + 1 >> 1;
                  v3 = v0 - v3;
                  v1 = v1 + v2 + 1 >> 1;
                  v2 = v1 - v2;
                  t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
                  v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
                  v7 = t;
                  t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
                  v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
                  v6 = t;
                  p[row] = v0 + v7;
                  p[row + 7] = v0 - v7;
                  p[row + 1] = v1 + v6;
                  p[row + 6] = v1 - v6;
                  p[row + 2] = v2 + v5;
                  p[row + 5] = v2 - v5;
                  p[row + 3] = v3 + v4;
                  p[row + 4] = v3 - v4;
                }
                for (var col = 0; col < 8; ++col) {
                  p0 = p[col];
                  p1 = p[col + 8];
                  p2 = p[col + 16];
                  p3 = p[col + 24];
                  p4 = p[col + 32];
                  p5 = p[col + 40];
                  p6 = p[col + 48];
                  p7 = p[col + 56];
                  if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
                    t = dctSqrt2 * p0 + 8192 >> 14;
                    t = t < -2040 ? 0 : t >= 2024 ? 255 : t + 2056 >> 4;
                    blockData[blockBufferOffset + col] = t;
                    blockData[blockBufferOffset + col + 8] = t;
                    blockData[blockBufferOffset + col + 16] = t;
                    blockData[blockBufferOffset + col + 24] = t;
                    blockData[blockBufferOffset + col + 32] = t;
                    blockData[blockBufferOffset + col + 40] = t;
                    blockData[blockBufferOffset + col + 48] = t;
                    blockData[blockBufferOffset + col + 56] = t;
                    continue;
                  }
                  v0 = dctSqrt2 * p0 + 2048 >> 12;
                  v1 = dctSqrt2 * p4 + 2048 >> 12;
                  v2 = p2;
                  v3 = p6;
                  v4 = dctSqrt1d2 * (p1 - p7) + 2048 >> 12;
                  v7 = dctSqrt1d2 * (p1 + p7) + 2048 >> 12;
                  v5 = p3;
                  v6 = p5;
                  v0 = (v0 + v1 + 1 >> 1) + 4112;
                  v1 = v0 - v1;
                  t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
                  v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
                  v3 = t;
                  v4 = v4 + v6 + 1 >> 1;
                  v6 = v4 - v6;
                  v7 = v7 + v5 + 1 >> 1;
                  v5 = v7 - v5;
                  v0 = v0 + v3 + 1 >> 1;
                  v3 = v0 - v3;
                  v1 = v1 + v2 + 1 >> 1;
                  v2 = v1 - v2;
                  t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
                  v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
                  v7 = t;
                  t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
                  v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
                  v6 = t;
                  p0 = v0 + v7;
                  p7 = v0 - v7;
                  p1 = v1 + v6;
                  p6 = v1 - v6;
                  p2 = v2 + v5;
                  p5 = v2 - v5;
                  p3 = v3 + v4;
                  p4 = v3 - v4;
                  p0 = p0 < 16 ? 0 : p0 >= 4080 ? 255 : p0 >> 4;
                  p1 = p1 < 16 ? 0 : p1 >= 4080 ? 255 : p1 >> 4;
                  p2 = p2 < 16 ? 0 : p2 >= 4080 ? 255 : p2 >> 4;
                  p3 = p3 < 16 ? 0 : p3 >= 4080 ? 255 : p3 >> 4;
                  p4 = p4 < 16 ? 0 : p4 >= 4080 ? 255 : p4 >> 4;
                  p5 = p5 < 16 ? 0 : p5 >= 4080 ? 255 : p5 >> 4;
                  p6 = p6 < 16 ? 0 : p6 >= 4080 ? 255 : p6 >> 4;
                  p7 = p7 < 16 ? 0 : p7 >= 4080 ? 255 : p7 >> 4;
                  blockData[blockBufferOffset + col] = p0;
                  blockData[blockBufferOffset + col + 8] = p1;
                  blockData[blockBufferOffset + col + 16] = p2;
                  blockData[blockBufferOffset + col + 24] = p3;
                  blockData[blockBufferOffset + col + 32] = p4;
                  blockData[blockBufferOffset + col + 40] = p5;
                  blockData[blockBufferOffset + col + 48] = p6;
                  blockData[blockBufferOffset + col + 56] = p7;
                }
              }
              function buildComponentData(frame, component) {
                var blocksPerLine = component.blocksPerLine;
                var blocksPerColumn = component.blocksPerColumn;
                var computationBuffer = new Int16Array(64);
                for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
                  for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
                    var offset = getBlockBufferOffset(component, blockRow, blockCol);
                    quantizeAndInverse(component, offset, computationBuffer);
                  }
                }
                return component.blockData;
              }
              function findNextFileMarker(data, currentPos) {
                var startPos = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : currentPos;
                function peekUint16(pos) {
                  return data[pos] << 8 | data[pos + 1];
                }
                var maxPos = data.length - 1;
                var newPos = startPos < currentPos ? startPos : currentPos;
                if (currentPos >= maxPos) {
                  return null;
                }
                var currentMarker = peekUint16(currentPos);
                if (currentMarker >= 65472 && currentMarker <= 65534) {
                  return {
                    invalid: null,
                    marker: currentMarker,
                    offset: currentPos
                  };
                }
                var newMarker = peekUint16(newPos);
                while (!(newMarker >= 65472 && newMarker <= 65534)) {
                  if (++newPos >= maxPos) {
                    return null;
                  }
                  newMarker = peekUint16(newPos);
                }
                return {
                  invalid: currentMarker.toString(16),
                  marker: newMarker,
                  offset: newPos
                };
              }
              JpegImage2.prototype = {
                parse: function parse(data) {
                  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$dnlScanLines = _ref.dnlScanLines, dnlScanLines = _ref$dnlScanLines === void 0 ? null : _ref$dnlScanLines;
                  function readUint16() {
                    var value = data[offset] << 8 | data[offset + 1];
                    offset += 2;
                    return value;
                  }
                  function readDataBlock() {
                    var length = readUint16();
                    var endOffset = offset + length - 2;
                    var fileMarker2 = findNextFileMarker(data, endOffset, offset);
                    if (fileMarker2 && fileMarker2.invalid) {
                      (0, _util.warn)("readDataBlock - incorrect length, current marker is: " + fileMarker2.invalid);
                      endOffset = fileMarker2.offset;
                    }
                    var array = data.subarray(offset, endOffset);
                    offset += array.length;
                    return array;
                  }
                  function prepareComponents(frame2) {
                    var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / frame2.maxH);
                    var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / frame2.maxV);
                    for (var i2 = 0; i2 < frame2.components.length; i2++) {
                      component = frame2.components[i2];
                      var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component.h / frame2.maxH);
                      var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component.v / frame2.maxV);
                      var blocksPerLineForMcu = mcusPerLine * component.h;
                      var blocksPerColumnForMcu = mcusPerColumn * component.v;
                      var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
                      component.blockData = new Int16Array(blocksBufferSize);
                      component.blocksPerLine = blocksPerLine;
                      component.blocksPerColumn = blocksPerColumn;
                    }
                    frame2.mcusPerLine = mcusPerLine;
                    frame2.mcusPerColumn = mcusPerColumn;
                  }
                  var offset = 0;
                  var jfif = null;
                  var adobe = null;
                  var frame, resetInterval;
                  var numSOSMarkers = 0;
                  var quantizationTables = [];
                  var huffmanTablesAC = [], huffmanTablesDC = [];
                  var fileMarker = readUint16();
                  if (fileMarker !== 65496) {
                    throw new JpegError("SOI not found");
                  }
                  fileMarker = readUint16();
                  markerLoop: while (fileMarker !== 65497) {
                    var i, j, l;
                    switch (fileMarker) {
                      case 65504:
                      case 65505:
                      case 65506:
                      case 65507:
                      case 65508:
                      case 65509:
                      case 65510:
                      case 65511:
                      case 65512:
                      case 65513:
                      case 65514:
                      case 65515:
                      case 65516:
                      case 65517:
                      case 65518:
                      case 65519:
                      case 65534:
                        var appData = readDataBlock();
                        if (fileMarker === 65504) {
                          if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                            jfif = {
                              version: {
                                major: appData[5],
                                minor: appData[6]
                              },
                              densityUnits: appData[7],
                              xDensity: appData[8] << 8 | appData[9],
                              yDensity: appData[10] << 8 | appData[11],
                              thumbWidth: appData[12],
                              thumbHeight: appData[13],
                              thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                            };
                          }
                        }
                        if (fileMarker === 65518) {
                          if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101) {
                            adobe = {
                              version: appData[5] << 8 | appData[6],
                              flags0: appData[7] << 8 | appData[8],
                              flags1: appData[9] << 8 | appData[10],
                              transformCode: appData[11]
                            };
                          }
                        }
                        break;
                      case 65499:
                        var quantizationTablesLength = readUint16();
                        var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                        var z;
                        while (offset < quantizationTablesEnd) {
                          var quantizationTableSpec = data[offset++];
                          var tableData = new Uint16Array(64);
                          if (quantizationTableSpec >> 4 === 0) {
                            for (j = 0; j < 64; j++) {
                              z = dctZigZag[j];
                              tableData[z] = data[offset++];
                            }
                          } else if (quantizationTableSpec >> 4 === 1) {
                            for (j = 0; j < 64; j++) {
                              z = dctZigZag[j];
                              tableData[z] = readUint16();
                            }
                          } else {
                            throw new JpegError("DQT - invalid table spec");
                          }
                          quantizationTables[quantizationTableSpec & 15] = tableData;
                        }
                        break;
                      case 65472:
                      case 65473:
                      case 65474:
                        if (frame) {
                          throw new JpegError("Only single frame JPEGs supported");
                        }
                        readUint16();
                        frame = {};
                        frame.extended = fileMarker === 65473;
                        frame.progressive = fileMarker === 65474;
                        frame.precision = data[offset++];
                        var sofScanLines = readUint16();
                        frame.scanLines = dnlScanLines || sofScanLines;
                        frame.samplesPerLine = readUint16();
                        frame.components = [];
                        frame.componentIds = {};
                        var componentsCount = data[offset++], componentId;
                        var maxH = 0, maxV = 0;
                        for (i = 0; i < componentsCount; i++) {
                          componentId = data[offset];
                          var h = data[offset + 1] >> 4;
                          var v = data[offset + 1] & 15;
                          if (maxH < h) {
                            maxH = h;
                          }
                          if (maxV < v) {
                            maxV = v;
                          }
                          var qId = data[offset + 2];
                          l = frame.components.push({
                            h,
                            v,
                            quantizationId: qId,
                            quantizationTable: null
                          });
                          frame.componentIds[componentId] = l - 1;
                          offset += 3;
                        }
                        frame.maxH = maxH;
                        frame.maxV = maxV;
                        prepareComponents(frame);
                        break;
                      case 65476:
                        var huffmanLength = readUint16();
                        for (i = 2; i < huffmanLength; ) {
                          var huffmanTableSpec = data[offset++];
                          var codeLengths = new Uint8Array(16);
                          var codeLengthSum = 0;
                          for (j = 0; j < 16; j++, offset++) {
                            codeLengthSum += codeLengths[j] = data[offset];
                          }
                          var huffmanValues = new Uint8Array(codeLengthSum);
                          for (j = 0; j < codeLengthSum; j++, offset++) {
                            huffmanValues[j] = data[offset];
                          }
                          i += 17 + codeLengthSum;
                          (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                        }
                        break;
                      case 65501:
                        readUint16();
                        resetInterval = readUint16();
                        break;
                      case 65498:
                        var parseDNLMarker = ++numSOSMarkers === 1 && !dnlScanLines;
                        readUint16();
                        var selectorsCount = data[offset++];
                        var components = [], component;
                        for (i = 0; i < selectorsCount; i++) {
                          var componentIndex = frame.componentIds[data[offset++]];
                          component = frame.components[componentIndex];
                          var tableSpec = data[offset++];
                          component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                          component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                          components.push(component);
                        }
                        var spectralStart = data[offset++];
                        var spectralEnd = data[offset++];
                        var successiveApproximation = data[offset++];
                        try {
                          var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, parseDNLMarker);
                          offset += processed;
                        } catch (ex) {
                          if (ex instanceof DNLMarkerError) {
                            (0, _util.warn)(ex.message + " -- attempting to re-parse the JPEG image.");
                            return this.parse(data, { dnlScanLines: ex.scanLines });
                          } else if (ex instanceof EOIMarkerError) {
                            (0, _util.warn)(ex.message + " -- ignoring the rest of the image data.");
                            break markerLoop;
                          }
                          throw ex;
                        }
                        break;
                      case 65500:
                        offset += 4;
                        break;
                      case 65535:
                        if (data[offset] !== 255) {
                          offset--;
                        }
                        break;
                      default:
                        if (data[offset - 3] === 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                          offset -= 3;
                          break;
                        }
                        var nextFileMarker = findNextFileMarker(data, offset - 2);
                        if (nextFileMarker && nextFileMarker.invalid) {
                          (0, _util.warn)("JpegImage.parse - unexpected data, current marker is: " + nextFileMarker.invalid);
                          offset = nextFileMarker.offset;
                          break;
                        }
                        throw new JpegError("unknown marker " + fileMarker.toString(16));
                    }
                    fileMarker = readUint16();
                  }
                  this.width = frame.samplesPerLine;
                  this.height = frame.scanLines;
                  this.jfif = jfif;
                  this.adobe = adobe;
                  this.components = [];
                  for (i = 0; i < frame.components.length; i++) {
                    component = frame.components[i];
                    var quantizationTable = quantizationTables[component.quantizationId];
                    if (quantizationTable) {
                      component.quantizationTable = quantizationTable;
                    }
                    this.components.push({
                      output: buildComponentData(frame, component),
                      scaleX: component.h / frame.maxH,
                      scaleY: component.v / frame.maxV,
                      blocksPerLine: component.blocksPerLine,
                      blocksPerColumn: component.blocksPerColumn
                    });
                  }
                  this.numComponents = this.components.length;
                },
                _getLinearizedBlockData: function getLinearizedBlockData(width, height) {
                  var scaleX = this.width / width, scaleY = this.height / height;
                  var component, componentScaleX, componentScaleY, blocksPerScanline;
                  var x, y, i, j, k;
                  var index;
                  var offset = 0;
                  var output;
                  var numComponents = this.components.length;
                  var dataLength = width * height * numComponents;
                  var data = new Uint8ClampedArray(dataLength);
                  var xScaleBlockOffset = new Uint32Array(width);
                  var mask3LSB = 4294967288;
                  for (i = 0; i < numComponents; i++) {
                    component = this.components[i];
                    componentScaleX = component.scaleX * scaleX;
                    componentScaleY = component.scaleY * scaleY;
                    offset = i;
                    output = component.output;
                    blocksPerScanline = component.blocksPerLine + 1 << 3;
                    for (x = 0; x < width; x++) {
                      j = 0 | x * componentScaleX;
                      xScaleBlockOffset[x] = (j & mask3LSB) << 3 | j & 7;
                    }
                    for (y = 0; y < height; y++) {
                      j = 0 | y * componentScaleY;
                      index = blocksPerScanline * (j & mask3LSB) | (j & 7) << 3;
                      for (x = 0; x < width; x++) {
                        data[offset] = output[index + xScaleBlockOffset[x]];
                        offset += numComponents;
                      }
                    }
                  }
                  var transform = this.decodeTransform;
                  if (transform) {
                    for (i = 0; i < dataLength; ) {
                      for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {
                        data[i] = (data[i] * transform[k] >> 8) + transform[k + 1];
                      }
                    }
                  }
                  return data;
                },
                _isColorConversionNeeded: function _isColorConversionNeeded() {
                  if (this.adobe) {
                    return !!this.adobe.transformCode;
                  }
                  if (this.numComponents === 3) {
                    if (this.colorTransform === 0) {
                      return false;
                    }
                    return true;
                  }
                  if (this.colorTransform === 1) {
                    return true;
                  }
                  return false;
                },
                _convertYccToRgb: function convertYccToRgb(data) {
                  var Y, Cb, Cr;
                  for (var i = 0, length = data.length; i < length; i += 3) {
                    Y = data[i];
                    Cb = data[i + 1];
                    Cr = data[i + 2];
                    data[i] = Y - 179.456 + 1.402 * Cr;
                    data[i + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;
                    data[i + 2] = Y - 226.816 + 1.772 * Cb;
                  }
                  return data;
                },
                _convertYcckToRgb: function convertYcckToRgb(data) {
                  var Y, Cb, Cr, k;
                  var offset = 0;
                  for (var i = 0, length = data.length; i < length; i += 4) {
                    Y = data[i];
                    Cb = data[i + 1];
                    Cr = data[i + 2];
                    k = data[i + 3];
                    data[offset++] = -122.67195406894 + Cb * (-660635669420364e-19 * Cb + 437130475926232e-18 * Cr - 54080610064599e-18 * Y + 48449797120281e-17 * k - 0.154362151871126) + Cr * (-957964378445773e-18 * Cr + 817076911346625e-18 * Y - 0.00477271405408747 * k + 1.53380253221734) + Y * (961250184130688e-18 * Y - 0.00266257332283933 * k + 0.48357088451265) + k * (-336197177618394e-18 * k + 0.484791561490776);
                    data[offset++] = 107.268039397724 + Cb * (219927104525741e-19 * Cb - 640992018297945e-18 * Cr + 659397001245577e-18 * Y + 426105652938837e-18 * k - 0.176491792462875) + Cr * (-778269941513683e-18 * Cr + 0.00130872261408275 * Y + 770482631801132e-18 * k - 0.151051492775562) + Y * (0.00126935368114843 * Y - 0.00265090189010898 * k + 0.25802910206845) + k * (-318913117588328e-18 * k - 0.213742400323665);
                    data[offset++] = -20.810012546947 + Cb * (-570115196973677e-18 * Cb - 263409051004589e-19 * Cr + 0.0020741088115012 * Y - 0.00288260236853442 * k + 0.814272968359295) + Cr * (-153496057440975e-19 * Cr - 132689043961446e-18 * Y + 560833691242812e-18 * k - 0.195152027534049) + Y * (0.00174418132927582 * Y - 0.00255243321439347 * k + 0.116935020465145) + k * (-343531996510555e-18 * k + 0.24165260232407);
                  }
                  return data.subarray(0, offset);
                },
                _convertYcckToCmyk: function convertYcckToCmyk(data) {
                  var Y, Cb, Cr;
                  for (var i = 0, length = data.length; i < length; i += 4) {
                    Y = data[i];
                    Cb = data[i + 1];
                    Cr = data[i + 2];
                    data[i] = 434.456 - Y - 1.402 * Cr;
                    data[i + 1] = 119.541 - Y + 0.344 * Cb + 0.714 * Cr;
                    data[i + 2] = 481.816 - Y - 1.772 * Cb;
                  }
                  return data;
                },
                _convertCmykToRgb: function convertCmykToRgb(data) {
                  var c, m, y, k;
                  var offset = 0;
                  var scale = 1 / 255;
                  for (var i = 0, length = data.length; i < length; i += 4) {
                    c = data[i] * scale;
                    m = data[i + 1] * scale;
                    y = data[i + 2] * scale;
                    k = data[i + 3] * scale;
                    data[offset++] = 255 + c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k - 285.2331026137004) + m * (1.7149763477362134 * m - 5.6096736904047315 * y - 17.873870861415444 * k - 5.497006427196366) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 17.5119270841813) - k * (21.86122147463605 * k + 189.48180835922747);
                    data[offset++] = 255 + c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k - 79.2970844816548) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 190.9453302588951) + y * (4.444339102852739 * y + 9.8632861493405 * k - 24.86741582555878) - k * (20.737325471181034 * k + 187.80453709719578);
                    data[offset++] = 255 + c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k - 14.183576799673286) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 112.23884253719248) + y * (0.03296041114873217 * y + 115.60384449646641 * k - 193.58209356861505) - k * (22.33816807309886 * k + 180.12613974708367);
                  }
                  return data.subarray(0, offset);
                },
                getData: function getData(width, height, forceRGBoutput) {
                  if (this.numComponents > 4) {
                    throw new JpegError("Unsupported color mode");
                  }
                  var data = this._getLinearizedBlockData(width, height);
                  if (this.numComponents === 1 && forceRGBoutput) {
                    var dataLength = data.length;
                    var rgbData = new Uint8ClampedArray(dataLength * 3);
                    var offset = 0;
                    for (var i = 0; i < dataLength; i++) {
                      var grayColor = data[i];
                      rgbData[offset++] = grayColor;
                      rgbData[offset++] = grayColor;
                      rgbData[offset++] = grayColor;
                    }
                    return rgbData;
                  } else if (this.numComponents === 3 && this._isColorConversionNeeded()) {
                    return this._convertYccToRgb(data);
                  } else if (this.numComponents === 4) {
                    if (this._isColorConversionNeeded()) {
                      if (forceRGBoutput) {
                        return this._convertYcckToRgb(data);
                      }
                      return this._convertYcckToCmyk(data);
                    } else if (forceRGBoutput) {
                      return this._convertCmykToRgb(data);
                    }
                  }
                  return data;
                }
              };
              return JpegImage2;
            }();
            exports3.JpegImage = JpegImage;
          },
          /* 129 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.JpxStream = void 0;
            var _stream = __w_pdfjs_require__(121);
            var _jpx = __w_pdfjs_require__(130);
            var _util = __w_pdfjs_require__(2);
            var JpxStream = function JpxStreamClosure() {
              function JpxStream2(stream2, maybeLength, dict, params) {
                this.stream = stream2;
                this.maybeLength = maybeLength;
                this.dict = dict;
                this.params = params;
                _stream.DecodeStream.call(this, maybeLength);
              }
              JpxStream2.prototype = Object.create(_stream.DecodeStream.prototype);
              Object.defineProperty(JpxStream2.prototype, "bytes", {
                get: function JpxStream_bytes() {
                  return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
                },
                configurable: true
              });
              JpxStream2.prototype.ensureBuffer = function(requested) {
              };
              JpxStream2.prototype.readBlock = function() {
                if (this.eof) {
                  return;
                }
                var jpxImage = new _jpx.JpxImage();
                jpxImage.parse(this.bytes);
                var width = jpxImage.width;
                var height = jpxImage.height;
                var componentsCount = jpxImage.componentsCount;
                var tileCount = jpxImage.tiles.length;
                if (tileCount === 1) {
                  this.buffer = jpxImage.tiles[0].items;
                } else {
                  var data = new Uint8ClampedArray(width * height * componentsCount);
                  for (var k = 0; k < tileCount; k++) {
                    var tileComponents = jpxImage.tiles[k];
                    var tileWidth = tileComponents.width;
                    var tileHeight = tileComponents.height;
                    var tileLeft = tileComponents.left;
                    var tileTop = tileComponents.top;
                    var src = tileComponents.items;
                    var srcPosition = 0;
                    var dataPosition = (width * tileTop + tileLeft) * componentsCount;
                    var imgRowSize = width * componentsCount;
                    var tileRowSize = tileWidth * componentsCount;
                    for (var j = 0; j < tileHeight; j++) {
                      var rowBytes = src.subarray(srcPosition, srcPosition + tileRowSize);
                      data.set(rowBytes, dataPosition);
                      srcPosition += tileRowSize;
                      dataPosition += imgRowSize;
                    }
                  }
                  this.buffer = data;
                }
                this.bufferLength = this.buffer.length;
                this.eof = true;
              };
              return JpxStream2;
            }();
            exports3.JpxStream = JpxStream;
          },
          /* 130 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.JpxImage = void 0;
            var _util = __w_pdfjs_require__(2);
            var _arithmetic_decoder = __w_pdfjs_require__(126);
            var JpxError = function JpxErrorClosure() {
              function JpxError2(msg) {
                this.message = "JPX error: " + msg;
              }
              JpxError2.prototype = new Error();
              JpxError2.prototype.name = "JpxError";
              JpxError2.constructor = JpxError2;
              return JpxError2;
            }();
            var JpxImage = function JpxImageClosure() {
              var SubbandsGainLog2 = {
                "LL": 0,
                "LH": 1,
                "HL": 1,
                "HH": 2
              };
              function JpxImage2() {
                this.failOnCorruptedImage = false;
              }
              JpxImage2.prototype = {
                parse: function JpxImage_parse(data) {
                  var head = (0, _util.readUint16)(data, 0);
                  if (head === 65359) {
                    this.parseCodestream(data, 0, data.length);
                    return;
                  }
                  var position = 0, length = data.length;
                  while (position < length) {
                    var headerSize = 8;
                    var lbox = (0, _util.readUint32)(data, position);
                    var tbox = (0, _util.readUint32)(data, position + 4);
                    position += headerSize;
                    if (lbox === 1) {
                      lbox = (0, _util.readUint32)(data, position) * 4294967296 + (0, _util.readUint32)(data, position + 4);
                      position += 8;
                      headerSize += 8;
                    }
                    if (lbox === 0) {
                      lbox = length - position + headerSize;
                    }
                    if (lbox < headerSize) {
                      throw new JpxError("Invalid box field size");
                    }
                    var dataLength = lbox - headerSize;
                    var jumpDataLength = true;
                    switch (tbox) {
                      case 1785737832:
                        jumpDataLength = false;
                        break;
                      case 1668246642:
                        var method = data[position];
                        if (method === 1) {
                          var colorspace = (0, _util.readUint32)(data, position + 3);
                          switch (colorspace) {
                            case 16:
                            case 17:
                            case 18:
                              break;
                            default:
                              (0, _util.warn)("Unknown colorspace " + colorspace);
                              break;
                          }
                        } else if (method === 2) {
                          (0, _util.info)("ICC profile not supported");
                        }
                        break;
                      case 1785737827:
                        this.parseCodestream(data, position, position + dataLength);
                        break;
                      case 1783636e3:
                        if ((0, _util.readUint32)(data, position) !== 218793738) {
                          (0, _util.warn)("Invalid JP2 signature");
                        }
                        break;
                      case 1783634458:
                      case 1718909296:
                      case 1920099697:
                      case 1919251232:
                      case 1768449138:
                        break;
                      default:
                        var headerType = String.fromCharCode(tbox >> 24 & 255, tbox >> 16 & 255, tbox >> 8 & 255, tbox & 255);
                        (0, _util.warn)("Unsupported header type " + tbox + " (" + headerType + ")");
                        break;
                    }
                    if (jumpDataLength) {
                      position += dataLength;
                    }
                  }
                },
                parseImageProperties: function JpxImage_parseImageProperties(stream2) {
                  var newByte = stream2.getByte();
                  while (newByte >= 0) {
                    var oldByte = newByte;
                    newByte = stream2.getByte();
                    var code = oldByte << 8 | newByte;
                    if (code === 65361) {
                      stream2.skip(4);
                      var Xsiz = stream2.getInt32() >>> 0;
                      var Ysiz = stream2.getInt32() >>> 0;
                      var XOsiz = stream2.getInt32() >>> 0;
                      var YOsiz = stream2.getInt32() >>> 0;
                      stream2.skip(16);
                      var Csiz = stream2.getUint16();
                      this.width = Xsiz - XOsiz;
                      this.height = Ysiz - YOsiz;
                      this.componentsCount = Csiz;
                      this.bitsPerComponent = 8;
                      return;
                    }
                  }
                  throw new JpxError("No size marker found in JPX stream");
                },
                parseCodestream: function JpxImage_parseCodestream(data, start, end) {
                  var context = {};
                  var doNotRecover = false;
                  try {
                    var position = start;
                    while (position + 1 < end) {
                      var code = (0, _util.readUint16)(data, position);
                      position += 2;
                      var length = 0, j, sqcd, spqcds, spqcdSize, scalarExpounded, tile;
                      switch (code) {
                        case 65359:
                          context.mainHeader = true;
                          break;
                        case 65497:
                          break;
                        case 65361:
                          length = (0, _util.readUint16)(data, position);
                          var siz = {};
                          siz.Xsiz = (0, _util.readUint32)(data, position + 4);
                          siz.Ysiz = (0, _util.readUint32)(data, position + 8);
                          siz.XOsiz = (0, _util.readUint32)(data, position + 12);
                          siz.YOsiz = (0, _util.readUint32)(data, position + 16);
                          siz.XTsiz = (0, _util.readUint32)(data, position + 20);
                          siz.YTsiz = (0, _util.readUint32)(data, position + 24);
                          siz.XTOsiz = (0, _util.readUint32)(data, position + 28);
                          siz.YTOsiz = (0, _util.readUint32)(data, position + 32);
                          var componentsCount = (0, _util.readUint16)(data, position + 36);
                          siz.Csiz = componentsCount;
                          var components = [];
                          j = position + 38;
                          for (var i = 0; i < componentsCount; i++) {
                            var component = {
                              precision: (data[j] & 127) + 1,
                              isSigned: !!(data[j] & 128),
                              XRsiz: data[j + 1],
                              YRsiz: data[j + 2]
                            };
                            j += 3;
                            calculateComponentDimensions(component, siz);
                            components.push(component);
                          }
                          context.SIZ = siz;
                          context.components = components;
                          calculateTileGrids(context, components);
                          context.QCC = [];
                          context.COC = [];
                          break;
                        case 65372:
                          length = (0, _util.readUint16)(data, position);
                          var qcd = {};
                          j = position + 2;
                          sqcd = data[j++];
                          switch (sqcd & 31) {
                            case 0:
                              spqcdSize = 8;
                              scalarExpounded = true;
                              break;
                            case 1:
                              spqcdSize = 16;
                              scalarExpounded = false;
                              break;
                            case 2:
                              spqcdSize = 16;
                              scalarExpounded = true;
                              break;
                            default:
                              throw new Error("Invalid SQcd value " + sqcd);
                          }
                          qcd.noQuantization = spqcdSize === 8;
                          qcd.scalarExpounded = scalarExpounded;
                          qcd.guardBits = sqcd >> 5;
                          spqcds = [];
                          while (j < length + position) {
                            var spqcd = {};
                            if (spqcdSize === 8) {
                              spqcd.epsilon = data[j++] >> 3;
                              spqcd.mu = 0;
                            } else {
                              spqcd.epsilon = data[j] >> 3;
                              spqcd.mu = (data[j] & 7) << 8 | data[j + 1];
                              j += 2;
                            }
                            spqcds.push(spqcd);
                          }
                          qcd.SPqcds = spqcds;
                          if (context.mainHeader) {
                            context.QCD = qcd;
                          } else {
                            context.currentTile.QCD = qcd;
                            context.currentTile.QCC = [];
                          }
                          break;
                        case 65373:
                          length = (0, _util.readUint16)(data, position);
                          var qcc = {};
                          j = position + 2;
                          var cqcc;
                          if (context.SIZ.Csiz < 257) {
                            cqcc = data[j++];
                          } else {
                            cqcc = (0, _util.readUint16)(data, j);
                            j += 2;
                          }
                          sqcd = data[j++];
                          switch (sqcd & 31) {
                            case 0:
                              spqcdSize = 8;
                              scalarExpounded = true;
                              break;
                            case 1:
                              spqcdSize = 16;
                              scalarExpounded = false;
                              break;
                            case 2:
                              spqcdSize = 16;
                              scalarExpounded = true;
                              break;
                            default:
                              throw new Error("Invalid SQcd value " + sqcd);
                          }
                          qcc.noQuantization = spqcdSize === 8;
                          qcc.scalarExpounded = scalarExpounded;
                          qcc.guardBits = sqcd >> 5;
                          spqcds = [];
                          while (j < length + position) {
                            spqcd = {};
                            if (spqcdSize === 8) {
                              spqcd.epsilon = data[j++] >> 3;
                              spqcd.mu = 0;
                            } else {
                              spqcd.epsilon = data[j] >> 3;
                              spqcd.mu = (data[j] & 7) << 8 | data[j + 1];
                              j += 2;
                            }
                            spqcds.push(spqcd);
                          }
                          qcc.SPqcds = spqcds;
                          if (context.mainHeader) {
                            context.QCC[cqcc] = qcc;
                          } else {
                            context.currentTile.QCC[cqcc] = qcc;
                          }
                          break;
                        case 65362:
                          length = (0, _util.readUint16)(data, position);
                          var cod = {};
                          j = position + 2;
                          var scod = data[j++];
                          cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
                          cod.sopMarkerUsed = !!(scod & 2);
                          cod.ephMarkerUsed = !!(scod & 4);
                          cod.progressionOrder = data[j++];
                          cod.layersCount = (0, _util.readUint16)(data, j);
                          j += 2;
                          cod.multipleComponentTransform = data[j++];
                          cod.decompositionLevelsCount = data[j++];
                          cod.xcb = (data[j++] & 15) + 2;
                          cod.ycb = (data[j++] & 15) + 2;
                          var blockStyle = data[j++];
                          cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
                          cod.resetContextProbabilities = !!(blockStyle & 2);
                          cod.terminationOnEachCodingPass = !!(blockStyle & 4);
                          cod.verticallyStripe = !!(blockStyle & 8);
                          cod.predictableTermination = !!(blockStyle & 16);
                          cod.segmentationSymbolUsed = !!(blockStyle & 32);
                          cod.reversibleTransformation = data[j++];
                          if (cod.entropyCoderWithCustomPrecincts) {
                            var precinctsSizes = [];
                            while (j < length + position) {
                              var precinctsSize = data[j++];
                              precinctsSizes.push({
                                PPx: precinctsSize & 15,
                                PPy: precinctsSize >> 4
                              });
                            }
                            cod.precinctsSizes = precinctsSizes;
                          }
                          var unsupported = [];
                          if (cod.selectiveArithmeticCodingBypass) {
                            unsupported.push("selectiveArithmeticCodingBypass");
                          }
                          if (cod.resetContextProbabilities) {
                            unsupported.push("resetContextProbabilities");
                          }
                          if (cod.terminationOnEachCodingPass) {
                            unsupported.push("terminationOnEachCodingPass");
                          }
                          if (cod.verticallyStripe) {
                            unsupported.push("verticallyStripe");
                          }
                          if (cod.predictableTermination) {
                            unsupported.push("predictableTermination");
                          }
                          if (unsupported.length > 0) {
                            doNotRecover = true;
                            throw new Error("Unsupported COD options (" + unsupported.join(", ") + ")");
                          }
                          if (context.mainHeader) {
                            context.COD = cod;
                          } else {
                            context.currentTile.COD = cod;
                            context.currentTile.COC = [];
                          }
                          break;
                        case 65424:
                          length = (0, _util.readUint16)(data, position);
                          tile = {};
                          tile.index = (0, _util.readUint16)(data, position + 2);
                          tile.length = (0, _util.readUint32)(data, position + 4);
                          tile.dataEnd = tile.length + position - 2;
                          tile.partIndex = data[position + 8];
                          tile.partsCount = data[position + 9];
                          context.mainHeader = false;
                          if (tile.partIndex === 0) {
                            tile.COD = context.COD;
                            tile.COC = context.COC.slice(0);
                            tile.QCD = context.QCD;
                            tile.QCC = context.QCC.slice(0);
                          }
                          context.currentTile = tile;
                          break;
                        case 65427:
                          tile = context.currentTile;
                          if (tile.partIndex === 0) {
                            initializeTile(context, tile.index);
                            buildPackets(context);
                          }
                          length = tile.dataEnd - position;
                          parseTilePackets(context, data, position, length);
                          break;
                        case 65365:
                        case 65367:
                        case 65368:
                        case 65380:
                          length = (0, _util.readUint16)(data, position);
                          break;
                        case 65363:
                          throw new Error("Codestream code 0xFF53 (COC) is not implemented");
                        default:
                          throw new Error("Unknown codestream code: " + code.toString(16));
                      }
                      position += length;
                    }
                  } catch (e) {
                    if (doNotRecover || this.failOnCorruptedImage) {
                      throw new JpxError(e.message);
                    } else {
                      (0, _util.warn)("JPX: Trying to recover from: " + e.message);
                    }
                  }
                  this.tiles = transformComponents(context);
                  this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
                  this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
                  this.componentsCount = context.SIZ.Csiz;
                }
              };
              function calculateComponentDimensions(component, siz) {
                component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
                component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
                component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
                component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
                component.width = component.x1 - component.x0;
                component.height = component.y1 - component.y0;
              }
              function calculateTileGrids(context, components) {
                var siz = context.SIZ;
                var tile, tiles = [];
                var numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
                var numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);
                for (var q = 0; q < numYtiles; q++) {
                  for (var p = 0; p < numXtiles; p++) {
                    tile = {};
                    tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
                    tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
                    tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
                    tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
                    tile.width = tile.tx1 - tile.tx0;
                    tile.height = tile.ty1 - tile.ty0;
                    tile.components = [];
                    tiles.push(tile);
                  }
                }
                context.tiles = tiles;
                var componentsCount = siz.Csiz;
                for (var i = 0, ii = componentsCount; i < ii; i++) {
                  var component = components[i];
                  for (var j = 0, jj = tiles.length; j < jj; j++) {
                    var tileComponent = {};
                    tile = tiles[j];
                    tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
                    tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
                    tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
                    tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
                    tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
                    tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
                    tile.components[i] = tileComponent;
                  }
                }
              }
              function getBlocksDimensions(context, component, r) {
                var codOrCoc = component.codingStyleParameters;
                var result = {};
                if (!codOrCoc.entropyCoderWithCustomPrecincts) {
                  result.PPx = 15;
                  result.PPy = 15;
                } else {
                  result.PPx = codOrCoc.precinctsSizes[r].PPx;
                  result.PPy = codOrCoc.precinctsSizes[r].PPy;
                }
                result.xcb_ = r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) : Math.min(codOrCoc.xcb, result.PPx);
                result.ycb_ = r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) : Math.min(codOrCoc.ycb, result.PPy);
                return result;
              }
              function buildPrecincts(context, resolution, dimensions) {
                var precinctWidth = 1 << dimensions.PPx;
                var precinctHeight = 1 << dimensions.PPy;
                var isZeroRes = resolution.resLevel === 0;
                var precinctWidthInSubband = 1 << dimensions.PPx + (isZeroRes ? 0 : -1);
                var precinctHeightInSubband = 1 << dimensions.PPy + (isZeroRes ? 0 : -1);
                var numprecinctswide = resolution.trx1 > resolution.trx0 ? Math.ceil(resolution.trx1 / precinctWidth) - Math.floor(resolution.trx0 / precinctWidth) : 0;
                var numprecinctshigh = resolution.try1 > resolution.try0 ? Math.ceil(resolution.try1 / precinctHeight) - Math.floor(resolution.try0 / precinctHeight) : 0;
                var numprecincts = numprecinctswide * numprecinctshigh;
                resolution.precinctParameters = {
                  precinctWidth,
                  precinctHeight,
                  numprecinctswide,
                  numprecinctshigh,
                  numprecincts,
                  precinctWidthInSubband,
                  precinctHeightInSubband
                };
              }
              function buildCodeblocks(context, subband, dimensions) {
                var xcb_ = dimensions.xcb_;
                var ycb_ = dimensions.ycb_;
                var codeblockWidth = 1 << xcb_;
                var codeblockHeight = 1 << ycb_;
                var cbx0 = subband.tbx0 >> xcb_;
                var cby0 = subband.tby0 >> ycb_;
                var cbx1 = subband.tbx1 + codeblockWidth - 1 >> xcb_;
                var cby1 = subband.tby1 + codeblockHeight - 1 >> ycb_;
                var precinctParameters = subband.resolution.precinctParameters;
                var codeblocks = [];
                var precincts = [];
                var i, j, codeblock, precinctNumber;
                for (j = cby0; j < cby1; j++) {
                  for (i = cbx0; i < cbx1; i++) {
                    codeblock = {
                      cbx: i,
                      cby: j,
                      tbx0: codeblockWidth * i,
                      tby0: codeblockHeight * j,
                      tbx1: codeblockWidth * (i + 1),
                      tby1: codeblockHeight * (j + 1)
                    };
                    codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
                    codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
                    codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
                    codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);
                    var pi = Math.floor((codeblock.tbx0_ - subband.tbx0) / precinctParameters.precinctWidthInSubband);
                    var pj = Math.floor((codeblock.tby0_ - subband.tby0) / precinctParameters.precinctHeightInSubband);
                    precinctNumber = pi + pj * precinctParameters.numprecinctswide;
                    codeblock.precinctNumber = precinctNumber;
                    codeblock.subbandType = subband.type;
                    codeblock.Lblock = 3;
                    if (codeblock.tbx1_ <= codeblock.tbx0_ || codeblock.tby1_ <= codeblock.tby0_) {
                      continue;
                    }
                    codeblocks.push(codeblock);
                    var precinct = precincts[precinctNumber];
                    if (precinct !== void 0) {
                      if (i < precinct.cbxMin) {
                        precinct.cbxMin = i;
                      } else if (i > precinct.cbxMax) {
                        precinct.cbxMax = i;
                      }
                      if (j < precinct.cbyMin) {
                        precinct.cbxMin = j;
                      } else if (j > precinct.cbyMax) {
                        precinct.cbyMax = j;
                      }
                    } else {
                      precincts[precinctNumber] = precinct = {
                        cbxMin: i,
                        cbyMin: j,
                        cbxMax: i,
                        cbyMax: j
                      };
                    }
                    codeblock.precinct = precinct;
                  }
                }
                subband.codeblockParameters = {
                  codeblockWidth: xcb_,
                  codeblockHeight: ycb_,
                  numcodeblockwide: cbx1 - cbx0 + 1,
                  numcodeblockhigh: cby1 - cby0 + 1
                };
                subband.codeblocks = codeblocks;
                subband.precincts = precincts;
              }
              function createPacket(resolution, precinctNumber, layerNumber) {
                var precinctCodeblocks = [];
                var subbands = resolution.subbands;
                for (var i = 0, ii = subbands.length; i < ii; i++) {
                  var subband = subbands[i];
                  var codeblocks = subband.codeblocks;
                  for (var j = 0, jj = codeblocks.length; j < jj; j++) {
                    var codeblock = codeblocks[j];
                    if (codeblock.precinctNumber !== precinctNumber) {
                      continue;
                    }
                    precinctCodeblocks.push(codeblock);
                  }
                }
                return {
                  layerNumber,
                  codeblocks: precinctCodeblocks
                };
              }
              function LayerResolutionComponentPositionIterator(context) {
                var siz = context.SIZ;
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var layersCount = tile.codingStyleDefaultParameters.layersCount;
                var componentsCount = siz.Csiz;
                var maxDecompositionLevelsCount = 0;
                for (var q = 0; q < componentsCount; q++) {
                  maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
                }
                var l = 0, r = 0, i = 0, k = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; l < layersCount; l++) {
                    for (; r <= maxDecompositionLevelsCount; r++) {
                      for (; i < componentsCount; i++) {
                        var component = tile.components[i];
                        if (r > component.codingStyleParameters.decompositionLevelsCount) {
                          continue;
                        }
                        var resolution = component.resolutions[r];
                        var numprecincts = resolution.precinctParameters.numprecincts;
                        for (; k < numprecincts; ) {
                          var packet = createPacket(resolution, k, l);
                          k++;
                          return packet;
                        }
                        k = 0;
                      }
                      i = 0;
                    }
                    r = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function ResolutionLayerComponentPositionIterator(context) {
                var siz = context.SIZ;
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var layersCount = tile.codingStyleDefaultParameters.layersCount;
                var componentsCount = siz.Csiz;
                var maxDecompositionLevelsCount = 0;
                for (var q = 0; q < componentsCount; q++) {
                  maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
                }
                var r = 0, l = 0, i = 0, k = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; r <= maxDecompositionLevelsCount; r++) {
                    for (; l < layersCount; l++) {
                      for (; i < componentsCount; i++) {
                        var component = tile.components[i];
                        if (r > component.codingStyleParameters.decompositionLevelsCount) {
                          continue;
                        }
                        var resolution = component.resolutions[r];
                        var numprecincts = resolution.precinctParameters.numprecincts;
                        for (; k < numprecincts; ) {
                          var packet = createPacket(resolution, k, l);
                          k++;
                          return packet;
                        }
                        k = 0;
                      }
                      i = 0;
                    }
                    l = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function ResolutionPositionComponentLayerIterator(context) {
                var siz = context.SIZ;
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var layersCount = tile.codingStyleDefaultParameters.layersCount;
                var componentsCount = siz.Csiz;
                var l, r, c, p;
                var maxDecompositionLevelsCount = 0;
                for (c = 0; c < componentsCount; c++) {
                  var component = tile.components[c];
                  maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, component.codingStyleParameters.decompositionLevelsCount);
                }
                var maxNumPrecinctsInLevel = new Int32Array(maxDecompositionLevelsCount + 1);
                for (r = 0; r <= maxDecompositionLevelsCount; ++r) {
                  var maxNumPrecincts = 0;
                  for (c = 0; c < componentsCount; ++c) {
                    var resolutions = tile.components[c].resolutions;
                    if (r < resolutions.length) {
                      maxNumPrecincts = Math.max(maxNumPrecincts, resolutions[r].precinctParameters.numprecincts);
                    }
                  }
                  maxNumPrecinctsInLevel[r] = maxNumPrecincts;
                }
                l = 0;
                r = 0;
                c = 0;
                p = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; r <= maxDecompositionLevelsCount; r++) {
                    for (; p < maxNumPrecinctsInLevel[r]; p++) {
                      for (; c < componentsCount; c++) {
                        var component2 = tile.components[c];
                        if (r > component2.codingStyleParameters.decompositionLevelsCount) {
                          continue;
                        }
                        var resolution = component2.resolutions[r];
                        var numprecincts = resolution.precinctParameters.numprecincts;
                        if (p >= numprecincts) {
                          continue;
                        }
                        for (; l < layersCount; ) {
                          var packet = createPacket(resolution, p, l);
                          l++;
                          return packet;
                        }
                        l = 0;
                      }
                      c = 0;
                    }
                    p = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function PositionComponentResolutionLayerIterator(context) {
                var siz = context.SIZ;
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var layersCount = tile.codingStyleDefaultParameters.layersCount;
                var componentsCount = siz.Csiz;
                var precinctsSizes = getPrecinctSizesInImageScale(tile);
                var precinctsIterationSizes = precinctsSizes;
                var l = 0, r = 0, c = 0, px = 0, py = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; py < precinctsIterationSizes.maxNumHigh; py++) {
                    for (; px < precinctsIterationSizes.maxNumWide; px++) {
                      for (; c < componentsCount; c++) {
                        var component = tile.components[c];
                        var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                        for (; r <= decompositionLevelsCount; r++) {
                          var resolution = component.resolutions[r];
                          var sizeInImageScale = precinctsSizes.components[c].resolutions[r];
                          var k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
                          if (k === null) {
                            continue;
                          }
                          for (; l < layersCount; ) {
                            var packet = createPacket(resolution, k, l);
                            l++;
                            return packet;
                          }
                          l = 0;
                        }
                        r = 0;
                      }
                      c = 0;
                    }
                    px = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function ComponentPositionResolutionLayerIterator(context) {
                var siz = context.SIZ;
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var layersCount = tile.codingStyleDefaultParameters.layersCount;
                var componentsCount = siz.Csiz;
                var precinctsSizes = getPrecinctSizesInImageScale(tile);
                var l = 0, r = 0, c = 0, px = 0, py = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; c < componentsCount; ++c) {
                    var component = tile.components[c];
                    var precinctsIterationSizes = precinctsSizes.components[c];
                    var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                    for (; py < precinctsIterationSizes.maxNumHigh; py++) {
                      for (; px < precinctsIterationSizes.maxNumWide; px++) {
                        for (; r <= decompositionLevelsCount; r++) {
                          var resolution = component.resolutions[r];
                          var sizeInImageScale = precinctsIterationSizes.resolutions[r];
                          var k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
                          if (k === null) {
                            continue;
                          }
                          for (; l < layersCount; ) {
                            var packet = createPacket(resolution, k, l);
                            l++;
                            return packet;
                          }
                          l = 0;
                        }
                        r = 0;
                      }
                      px = 0;
                    }
                    py = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function getPrecinctIndexIfExist(pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {
                var posX = pxIndex * precinctIterationSizes.minWidth;
                var posY = pyIndex * precinctIterationSizes.minHeight;
                if (posX % sizeInImageScale.width !== 0 || posY % sizeInImageScale.height !== 0) {
                  return null;
                }
                var startPrecinctRowIndex = posY / sizeInImageScale.width * resolution.precinctParameters.numprecinctswide;
                return posX / sizeInImageScale.height + startPrecinctRowIndex;
              }
              function getPrecinctSizesInImageScale(tile) {
                var componentsCount = tile.components.length;
                var minWidth = Number.MAX_VALUE;
                var minHeight = Number.MAX_VALUE;
                var maxNumWide = 0;
                var maxNumHigh = 0;
                var sizePerComponent = new Array(componentsCount);
                for (var c = 0; c < componentsCount; c++) {
                  var component = tile.components[c];
                  var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                  var sizePerResolution = new Array(decompositionLevelsCount + 1);
                  var minWidthCurrentComponent = Number.MAX_VALUE;
                  var minHeightCurrentComponent = Number.MAX_VALUE;
                  var maxNumWideCurrentComponent = 0;
                  var maxNumHighCurrentComponent = 0;
                  var scale = 1;
                  for (var r = decompositionLevelsCount; r >= 0; --r) {
                    var resolution = component.resolutions[r];
                    var widthCurrentResolution = scale * resolution.precinctParameters.precinctWidth;
                    var heightCurrentResolution = scale * resolution.precinctParameters.precinctHeight;
                    minWidthCurrentComponent = Math.min(minWidthCurrentComponent, widthCurrentResolution);
                    minHeightCurrentComponent = Math.min(minHeightCurrentComponent, heightCurrentResolution);
                    maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent, resolution.precinctParameters.numprecinctswide);
                    maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent, resolution.precinctParameters.numprecinctshigh);
                    sizePerResolution[r] = {
                      width: widthCurrentResolution,
                      height: heightCurrentResolution
                    };
                    scale <<= 1;
                  }
                  minWidth = Math.min(minWidth, minWidthCurrentComponent);
                  minHeight = Math.min(minHeight, minHeightCurrentComponent);
                  maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
                  maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
                  sizePerComponent[c] = {
                    resolutions: sizePerResolution,
                    minWidth: minWidthCurrentComponent,
                    minHeight: minHeightCurrentComponent,
                    maxNumWide: maxNumWideCurrentComponent,
                    maxNumHigh: maxNumHighCurrentComponent
                  };
                }
                return {
                  components: sizePerComponent,
                  minWidth,
                  minHeight,
                  maxNumWide,
                  maxNumHigh
                };
              }
              function buildPackets(context) {
                var siz = context.SIZ;
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var componentsCount = siz.Csiz;
                for (var c = 0; c < componentsCount; c++) {
                  var component = tile.components[c];
                  var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                  var resolutions = [];
                  var subbands = [];
                  for (var r = 0; r <= decompositionLevelsCount; r++) {
                    var blocksDimensions = getBlocksDimensions(context, component, r);
                    var resolution = {};
                    var scale = 1 << decompositionLevelsCount - r;
                    resolution.trx0 = Math.ceil(component.tcx0 / scale);
                    resolution.try0 = Math.ceil(component.tcy0 / scale);
                    resolution.trx1 = Math.ceil(component.tcx1 / scale);
                    resolution.try1 = Math.ceil(component.tcy1 / scale);
                    resolution.resLevel = r;
                    buildPrecincts(context, resolution, blocksDimensions);
                    resolutions.push(resolution);
                    var subband;
                    if (r === 0) {
                      subband = {};
                      subband.type = "LL";
                      subband.tbx0 = Math.ceil(component.tcx0 / scale);
                      subband.tby0 = Math.ceil(component.tcy0 / scale);
                      subband.tbx1 = Math.ceil(component.tcx1 / scale);
                      subband.tby1 = Math.ceil(component.tcy1 / scale);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolution.subbands = [subband];
                    } else {
                      var bscale = 1 << decompositionLevelsCount - r + 1;
                      var resolutionSubbands = [];
                      subband = {};
                      subband.type = "HL";
                      subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
                      subband.tby0 = Math.ceil(component.tcy0 / bscale);
                      subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
                      subband.tby1 = Math.ceil(component.tcy1 / bscale);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolutionSubbands.push(subband);
                      subband = {};
                      subband.type = "LH";
                      subband.tbx0 = Math.ceil(component.tcx0 / bscale);
                      subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
                      subband.tbx1 = Math.ceil(component.tcx1 / bscale);
                      subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolutionSubbands.push(subband);
                      subband = {};
                      subband.type = "HH";
                      subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
                      subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
                      subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
                      subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolutionSubbands.push(subband);
                      resolution.subbands = resolutionSubbands;
                    }
                  }
                  component.resolutions = resolutions;
                  component.subbands = subbands;
                }
                var progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;
                switch (progressionOrder) {
                  case 0:
                    tile.packetsIterator = new LayerResolutionComponentPositionIterator(context);
                    break;
                  case 1:
                    tile.packetsIterator = new ResolutionLayerComponentPositionIterator(context);
                    break;
                  case 2:
                    tile.packetsIterator = new ResolutionPositionComponentLayerIterator(context);
                    break;
                  case 3:
                    tile.packetsIterator = new PositionComponentResolutionLayerIterator(context);
                    break;
                  case 4:
                    tile.packetsIterator = new ComponentPositionResolutionLayerIterator(context);
                    break;
                  default:
                    throw new JpxError("Unsupported progression order " + progressionOrder);
                }
              }
              function parseTilePackets(context, data, offset, dataLength) {
                var position = 0;
                var buffer, bufferSize = 0, skipNextBit = false;
                function readBits(count) {
                  while (bufferSize < count) {
                    var b = data[offset + position];
                    position++;
                    if (skipNextBit) {
                      buffer = buffer << 7 | b;
                      bufferSize += 7;
                      skipNextBit = false;
                    } else {
                      buffer = buffer << 8 | b;
                      bufferSize += 8;
                    }
                    if (b === 255) {
                      skipNextBit = true;
                    }
                  }
                  bufferSize -= count;
                  return buffer >>> bufferSize & (1 << count) - 1;
                }
                function skipMarkerIfEqual(value) {
                  if (data[offset + position - 1] === 255 && data[offset + position] === value) {
                    skipBytes(1);
                    return true;
                  } else if (data[offset + position] === 255 && data[offset + position + 1] === value) {
                    skipBytes(2);
                    return true;
                  }
                  return false;
                }
                function skipBytes(count) {
                  position += count;
                }
                function alignToByte() {
                  bufferSize = 0;
                  if (skipNextBit) {
                    position++;
                    skipNextBit = false;
                  }
                }
                function readCodingpasses() {
                  if (readBits(1) === 0) {
                    return 1;
                  }
                  if (readBits(1) === 0) {
                    return 2;
                  }
                  var value = readBits(2);
                  if (value < 3) {
                    return value + 3;
                  }
                  value = readBits(5);
                  if (value < 31) {
                    return value + 6;
                  }
                  value = readBits(7);
                  return value + 37;
                }
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var sopMarkerUsed = context.COD.sopMarkerUsed;
                var ephMarkerUsed = context.COD.ephMarkerUsed;
                var packetsIterator = tile.packetsIterator;
                while (position < dataLength) {
                  alignToByte();
                  if (sopMarkerUsed && skipMarkerIfEqual(145)) {
                    skipBytes(4);
                  }
                  var packet = packetsIterator.nextPacket();
                  if (!readBits(1)) {
                    continue;
                  }
                  var layerNumber = packet.layerNumber;
                  var queue = [], codeblock;
                  for (var i = 0, ii = packet.codeblocks.length; i < ii; i++) {
                    codeblock = packet.codeblocks[i];
                    var precinct = codeblock.precinct;
                    var codeblockColumn = codeblock.cbx - precinct.cbxMin;
                    var codeblockRow = codeblock.cby - precinct.cbyMin;
                    var codeblockIncluded = false;
                    var firstTimeInclusion = false;
                    var valueReady;
                    if (codeblock["included"] !== void 0) {
                      codeblockIncluded = !!readBits(1);
                    } else {
                      precinct = codeblock.precinct;
                      var inclusionTree, zeroBitPlanesTree;
                      if (precinct["inclusionTree"] !== void 0) {
                        inclusionTree = precinct.inclusionTree;
                      } else {
                        var width = precinct.cbxMax - precinct.cbxMin + 1;
                        var height = precinct.cbyMax - precinct.cbyMin + 1;
                        inclusionTree = new InclusionTree(width, height, layerNumber);
                        zeroBitPlanesTree = new TagTree(width, height);
                        precinct.inclusionTree = inclusionTree;
                        precinct.zeroBitPlanesTree = zeroBitPlanesTree;
                      }
                      if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {
                        while (true) {
                          if (readBits(1)) {
                            valueReady = !inclusionTree.nextLevel();
                            if (valueReady) {
                              codeblock.included = true;
                              codeblockIncluded = firstTimeInclusion = true;
                              break;
                            }
                          } else {
                            inclusionTree.incrementValue(layerNumber);
                            break;
                          }
                        }
                      }
                    }
                    if (!codeblockIncluded) {
                      continue;
                    }
                    if (firstTimeInclusion) {
                      zeroBitPlanesTree = precinct.zeroBitPlanesTree;
                      zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);
                      while (true) {
                        if (readBits(1)) {
                          valueReady = !zeroBitPlanesTree.nextLevel();
                          if (valueReady) {
                            break;
                          }
                        } else {
                          zeroBitPlanesTree.incrementValue();
                        }
                      }
                      codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
                    }
                    var codingpasses = readCodingpasses();
                    while (readBits(1)) {
                      codeblock.Lblock++;
                    }
                    var codingpassesLog2 = (0, _util.log2)(codingpasses);
                    var bits = (codingpasses < 1 << codingpassesLog2 ? codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;
                    var codedDataLength = readBits(bits);
                    queue.push({
                      codeblock,
                      codingpasses,
                      dataLength: codedDataLength
                    });
                  }
                  alignToByte();
                  if (ephMarkerUsed) {
                    skipMarkerIfEqual(146);
                  }
                  while (queue.length > 0) {
                    var packetItem = queue.shift();
                    codeblock = packetItem.codeblock;
                    if (codeblock["data"] === void 0) {
                      codeblock.data = [];
                    }
                    codeblock.data.push({
                      data,
                      start: offset + position,
                      end: offset + position + packetItem.dataLength,
                      codingpasses: packetItem.codingpasses
                    });
                    position += packetItem.dataLength;
                  }
                }
                return position;
              }
              function copyCoefficients(coefficients, levelWidth, levelHeight, subband, delta, mb, reversible, segmentationSymbolUsed) {
                var x0 = subband.tbx0;
                var y0 = subband.tby0;
                var width = subband.tbx1 - subband.tbx0;
                var codeblocks = subband.codeblocks;
                var right = subband.type.charAt(0) === "H" ? 1 : 0;
                var bottom = subband.type.charAt(1) === "H" ? levelWidth : 0;
                for (var i = 0, ii = codeblocks.length; i < ii; ++i) {
                  var codeblock = codeblocks[i];
                  var blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
                  var blockHeight = codeblock.tby1_ - codeblock.tby0_;
                  if (blockWidth === 0 || blockHeight === 0) {
                    continue;
                  }
                  if (codeblock["data"] === void 0) {
                    continue;
                  }
                  var bitModel, currentCodingpassType;
                  bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType, codeblock.zeroBitPlanes, mb);
                  currentCodingpassType = 2;
                  var data = codeblock.data, totalLength = 0, codingpasses = 0;
                  var j, jj, dataItem;
                  for (j = 0, jj = data.length; j < jj; j++) {
                    dataItem = data[j];
                    totalLength += dataItem.end - dataItem.start;
                    codingpasses += dataItem.codingpasses;
                  }
                  var encodedData = new Uint8Array(totalLength);
                  var position = 0;
                  for (j = 0, jj = data.length; j < jj; j++) {
                    dataItem = data[j];
                    var chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
                    encodedData.set(chunk, position);
                    position += chunk.length;
                  }
                  var decoder = new _arithmetic_decoder.ArithmeticDecoder(encodedData, 0, totalLength);
                  bitModel.setDecoder(decoder);
                  for (j = 0; j < codingpasses; j++) {
                    switch (currentCodingpassType) {
                      case 0:
                        bitModel.runSignificancePropagationPass();
                        break;
                      case 1:
                        bitModel.runMagnitudeRefinementPass();
                        break;
                      case 2:
                        bitModel.runCleanupPass();
                        if (segmentationSymbolUsed) {
                          bitModel.checkSegmentationSymbol();
                        }
                        break;
                    }
                    currentCodingpassType = (currentCodingpassType + 1) % 3;
                  }
                  var offset = codeblock.tbx0_ - x0 + (codeblock.tby0_ - y0) * width;
                  var sign = bitModel.coefficentsSign;
                  var magnitude = bitModel.coefficentsMagnitude;
                  var bitsDecoded = bitModel.bitsDecoded;
                  var magnitudeCorrection = reversible ? 0 : 0.5;
                  var k, n, nb;
                  position = 0;
                  var interleave = subband.type !== "LL";
                  for (j = 0; j < blockHeight; j++) {
                    var row = offset / width | 0;
                    var levelOffset = 2 * row * (levelWidth - width) + right + bottom;
                    for (k = 0; k < blockWidth; k++) {
                      n = magnitude[position];
                      if (n !== 0) {
                        n = (n + magnitudeCorrection) * delta;
                        if (sign[position] !== 0) {
                          n = -n;
                        }
                        nb = bitsDecoded[position];
                        var pos = interleave ? levelOffset + (offset << 1) : offset;
                        if (reversible && nb >= mb) {
                          coefficients[pos] = n;
                        } else {
                          coefficients[pos] = n * (1 << mb - nb);
                        }
                      }
                      offset++;
                      position++;
                    }
                    offset += width - blockWidth;
                  }
                }
              }
              function transformTile(context, tile, c) {
                var component = tile.components[c];
                var codingStyleParameters = component.codingStyleParameters;
                var quantizationParameters = component.quantizationParameters;
                var decompositionLevelsCount = codingStyleParameters.decompositionLevelsCount;
                var spqcds = quantizationParameters.SPqcds;
                var scalarExpounded = quantizationParameters.scalarExpounded;
                var guardBits = quantizationParameters.guardBits;
                var segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
                var precision = context.components[c].precision;
                var reversible = codingStyleParameters.reversibleTransformation;
                var transform = reversible ? new ReversibleTransform() : new IrreversibleTransform();
                var subbandCoefficients = [];
                var b = 0;
                for (var i = 0; i <= decompositionLevelsCount; i++) {
                  var resolution = component.resolutions[i];
                  var width = resolution.trx1 - resolution.trx0;
                  var height = resolution.try1 - resolution.try0;
                  var coefficients = new Float32Array(width * height);
                  for (var j = 0, jj = resolution.subbands.length; j < jj; j++) {
                    var mu, epsilon;
                    if (!scalarExpounded) {
                      mu = spqcds[0].mu;
                      epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
                    } else {
                      mu = spqcds[b].mu;
                      epsilon = spqcds[b].epsilon;
                      b++;
                    }
                    var subband = resolution.subbands[j];
                    var gainLog2 = SubbandsGainLog2[subband.type];
                    var delta = reversible ? 1 : Math.pow(2, precision + gainLog2 - epsilon) * (1 + mu / 2048);
                    var mb = guardBits + epsilon - 1;
                    copyCoefficients(coefficients, width, height, subband, delta, mb, reversible, segmentationSymbolUsed);
                  }
                  subbandCoefficients.push({
                    width,
                    height,
                    items: coefficients
                  });
                }
                var result = transform.calculate(subbandCoefficients, component.tcx0, component.tcy0);
                return {
                  left: component.tcx0,
                  top: component.tcy0,
                  width: result.width,
                  height: result.height,
                  items: result.items
                };
              }
              function transformComponents(context) {
                var siz = context.SIZ;
                var components = context.components;
                var componentsCount = siz.Csiz;
                var resultImages = [];
                for (var i = 0, ii = context.tiles.length; i < ii; i++) {
                  var tile = context.tiles[i];
                  var transformedTiles = [];
                  var c;
                  for (c = 0; c < componentsCount; c++) {
                    transformedTiles[c] = transformTile(context, tile, c);
                  }
                  var tile0 = transformedTiles[0];
                  var out = new Uint8ClampedArray(tile0.items.length * componentsCount);
                  var result = {
                    left: tile0.left,
                    top: tile0.top,
                    width: tile0.width,
                    height: tile0.height,
                    items: out
                  };
                  var shift, offset;
                  var pos = 0, j, jj, y0, y1, y2;
                  if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
                    var fourComponents = componentsCount === 4;
                    var y0items = transformedTiles[0].items;
                    var y1items = transformedTiles[1].items;
                    var y2items = transformedTiles[2].items;
                    var y3items = fourComponents ? transformedTiles[3].items : null;
                    shift = components[0].precision - 8;
                    offset = (128 << shift) + 0.5;
                    var component0 = tile.components[0];
                    var alpha01 = componentsCount - 3;
                    jj = y0items.length;
                    if (!component0.codingStyleParameters.reversibleTransformation) {
                      for (j = 0; j < jj; j++, pos += alpha01) {
                        y0 = y0items[j] + offset;
                        y1 = y1items[j];
                        y2 = y2items[j];
                        out[pos++] = y0 + 1.402 * y2 >> shift;
                        out[pos++] = y0 - 0.34413 * y1 - 0.71414 * y2 >> shift;
                        out[pos++] = y0 + 1.772 * y1 >> shift;
                      }
                    } else {
                      for (j = 0; j < jj; j++, pos += alpha01) {
                        y0 = y0items[j] + offset;
                        y1 = y1items[j];
                        y2 = y2items[j];
                        var g = y0 - (y2 + y1 >> 2);
                        out[pos++] = g + y2 >> shift;
                        out[pos++] = g >> shift;
                        out[pos++] = g + y1 >> shift;
                      }
                    }
                    if (fourComponents) {
                      for (j = 0, pos = 3; j < jj; j++, pos += 4) {
                        out[pos] = y3items[j] + offset >> shift;
                      }
                    }
                  } else {
                    for (c = 0; c < componentsCount; c++) {
                      var items = transformedTiles[c].items;
                      shift = components[c].precision - 8;
                      offset = (128 << shift) + 0.5;
                      for (pos = c, j = 0, jj = items.length; j < jj; j++) {
                        out[pos] = items[j] + offset >> shift;
                        pos += componentsCount;
                      }
                    }
                  }
                  resultImages.push(result);
                }
                return resultImages;
              }
              function initializeTile(context, tileIndex) {
                var siz = context.SIZ;
                var componentsCount = siz.Csiz;
                var tile = context.tiles[tileIndex];
                for (var c = 0; c < componentsCount; c++) {
                  var component = tile.components[c];
                  var qcdOrQcc = context.currentTile.QCC[c] !== void 0 ? context.currentTile.QCC[c] : context.currentTile.QCD;
                  component.quantizationParameters = qcdOrQcc;
                  var codOrCoc = context.currentTile.COC[c] !== void 0 ? context.currentTile.COC[c] : context.currentTile.COD;
                  component.codingStyleParameters = codOrCoc;
                }
                tile.codingStyleDefaultParameters = context.currentTile.COD;
              }
              var TagTree = function TagTreeClosure() {
                function TagTree2(width, height) {
                  var levelsLength = (0, _util.log2)(Math.max(width, height)) + 1;
                  this.levels = [];
                  for (var i = 0; i < levelsLength; i++) {
                    var level = {
                      width,
                      height,
                      items: []
                    };
                    this.levels.push(level);
                    width = Math.ceil(width / 2);
                    height = Math.ceil(height / 2);
                  }
                }
                TagTree2.prototype = {
                  reset: function TagTree_reset(i, j) {
                    var currentLevel = 0, value = 0, level;
                    while (currentLevel < this.levels.length) {
                      level = this.levels[currentLevel];
                      var index = i + j * level.width;
                      if (level.items[index] !== void 0) {
                        value = level.items[index];
                        break;
                      }
                      level.index = index;
                      i >>= 1;
                      j >>= 1;
                      currentLevel++;
                    }
                    currentLevel--;
                    level = this.levels[currentLevel];
                    level.items[level.index] = value;
                    this.currentLevel = currentLevel;
                    delete this.value;
                  },
                  incrementValue: function TagTree_incrementValue() {
                    var level = this.levels[this.currentLevel];
                    level.items[level.index]++;
                  },
                  nextLevel: function TagTree_nextLevel() {
                    var currentLevel = this.currentLevel;
                    var level = this.levels[currentLevel];
                    var value = level.items[level.index];
                    currentLevel--;
                    if (currentLevel < 0) {
                      this.value = value;
                      return false;
                    }
                    this.currentLevel = currentLevel;
                    level = this.levels[currentLevel];
                    level.items[level.index] = value;
                    return true;
                  }
                };
                return TagTree2;
              }();
              var InclusionTree = function InclusionTreeClosure() {
                function InclusionTree2(width, height, defaultValue) {
                  var levelsLength = (0, _util.log2)(Math.max(width, height)) + 1;
                  this.levels = [];
                  for (var i = 0; i < levelsLength; i++) {
                    var items = new Uint8Array(width * height);
                    for (var j = 0, jj = items.length; j < jj; j++) {
                      items[j] = defaultValue;
                    }
                    var level = {
                      width,
                      height,
                      items
                    };
                    this.levels.push(level);
                    width = Math.ceil(width / 2);
                    height = Math.ceil(height / 2);
                  }
                }
                InclusionTree2.prototype = {
                  reset: function InclusionTree_reset(i, j, stopValue) {
                    var currentLevel = 0;
                    while (currentLevel < this.levels.length) {
                      var level = this.levels[currentLevel];
                      var index = i + j * level.width;
                      level.index = index;
                      var value = level.items[index];
                      if (value === 255) {
                        break;
                      }
                      if (value > stopValue) {
                        this.currentLevel = currentLevel;
                        this.propagateValues();
                        return false;
                      }
                      i >>= 1;
                      j >>= 1;
                      currentLevel++;
                    }
                    this.currentLevel = currentLevel - 1;
                    return true;
                  },
                  incrementValue: function InclusionTree_incrementValue(stopValue) {
                    var level = this.levels[this.currentLevel];
                    level.items[level.index] = stopValue + 1;
                    this.propagateValues();
                  },
                  propagateValues: function InclusionTree_propagateValues() {
                    var levelIndex = this.currentLevel;
                    var level = this.levels[levelIndex];
                    var currentValue = level.items[level.index];
                    while (--levelIndex >= 0) {
                      level = this.levels[levelIndex];
                      level.items[level.index] = currentValue;
                    }
                  },
                  nextLevel: function InclusionTree_nextLevel() {
                    var currentLevel = this.currentLevel;
                    var level = this.levels[currentLevel];
                    var value = level.items[level.index];
                    level.items[level.index] = 255;
                    currentLevel--;
                    if (currentLevel < 0) {
                      return false;
                    }
                    this.currentLevel = currentLevel;
                    level = this.levels[currentLevel];
                    level.items[level.index] = value;
                    return true;
                  }
                };
                return InclusionTree2;
              }();
              var BitModel = function BitModelClosure() {
                var UNIFORM_CONTEXT = 17;
                var RUNLENGTH_CONTEXT = 18;
                var LLAndLHContextsLabel = new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]);
                var HLContextLabel = new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]);
                var HHContextLabel = new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]);
                function BitModel2(width, height, subband, zeroBitPlanes, mb) {
                  this.width = width;
                  this.height = height;
                  this.contextLabelTable = subband === "HH" ? HHContextLabel : subband === "HL" ? HLContextLabel : LLAndLHContextsLabel;
                  var coefficientCount = width * height;
                  this.neighborsSignificance = new Uint8Array(coefficientCount);
                  this.coefficentsSign = new Uint8Array(coefficientCount);
                  this.coefficentsMagnitude = mb > 14 ? new Uint32Array(coefficientCount) : mb > 6 ? new Uint16Array(coefficientCount) : new Uint8Array(coefficientCount);
                  this.processingFlags = new Uint8Array(coefficientCount);
                  var bitsDecoded = new Uint8Array(coefficientCount);
                  if (zeroBitPlanes !== 0) {
                    for (var i = 0; i < coefficientCount; i++) {
                      bitsDecoded[i] = zeroBitPlanes;
                    }
                  }
                  this.bitsDecoded = bitsDecoded;
                  this.reset();
                }
                BitModel2.prototype = {
                  setDecoder: function BitModel_setDecoder(decoder) {
                    this.decoder = decoder;
                  },
                  reset: function BitModel_reset() {
                    this.contexts = new Int8Array(19);
                    this.contexts[0] = 4 << 1 | 0;
                    this.contexts[UNIFORM_CONTEXT] = 46 << 1 | 0;
                    this.contexts[RUNLENGTH_CONTEXT] = 3 << 1 | 0;
                  },
                  setNeighborsSignificance: function BitModel_setNeighborsSignificance(row, column, index) {
                    var neighborsSignificance = this.neighborsSignificance;
                    var width = this.width, height = this.height;
                    var left = column > 0;
                    var right = column + 1 < width;
                    var i;
                    if (row > 0) {
                      i = index - width;
                      if (left) {
                        neighborsSignificance[i - 1] += 16;
                      }
                      if (right) {
                        neighborsSignificance[i + 1] += 16;
                      }
                      neighborsSignificance[i] += 4;
                    }
                    if (row + 1 < height) {
                      i = index + width;
                      if (left) {
                        neighborsSignificance[i - 1] += 16;
                      }
                      if (right) {
                        neighborsSignificance[i + 1] += 16;
                      }
                      neighborsSignificance[i] += 4;
                    }
                    if (left) {
                      neighborsSignificance[index - 1] += 1;
                    }
                    if (right) {
                      neighborsSignificance[index + 1] += 1;
                    }
                    neighborsSignificance[index] |= 128;
                  },
                  runSignificancePropagationPass: function BitModel_runSignificancePropagationPass() {
                    var decoder = this.decoder;
                    var width = this.width, height = this.height;
                    var coefficentsMagnitude = this.coefficentsMagnitude;
                    var coefficentsSign = this.coefficentsSign;
                    var neighborsSignificance = this.neighborsSignificance;
                    var processingFlags = this.processingFlags;
                    var contexts = this.contexts;
                    var labels = this.contextLabelTable;
                    var bitsDecoded = this.bitsDecoded;
                    var processedInverseMask = ~1;
                    var processedMask = 1;
                    var firstMagnitudeBitMask = 2;
                    for (var i0 = 0; i0 < height; i0 += 4) {
                      for (var j = 0; j < width; j++) {
                        var index = i0 * width + j;
                        for (var i1 = 0; i1 < 4; i1++, index += width) {
                          var i = i0 + i1;
                          if (i >= height) {
                            break;
                          }
                          processingFlags[index] &= processedInverseMask;
                          if (coefficentsMagnitude[index] || !neighborsSignificance[index]) {
                            continue;
                          }
                          var contextLabel = labels[neighborsSignificance[index]];
                          var decision = decoder.readBit(contexts, contextLabel);
                          if (decision) {
                            var sign = this.decodeSignBit(i, j, index);
                            coefficentsSign[index] = sign;
                            coefficentsMagnitude[index] = 1;
                            this.setNeighborsSignificance(i, j, index);
                            processingFlags[index] |= firstMagnitudeBitMask;
                          }
                          bitsDecoded[index]++;
                          processingFlags[index] |= processedMask;
                        }
                      }
                    }
                  },
                  decodeSignBit: function BitModel_decodeSignBit(row, column, index) {
                    var width = this.width, height = this.height;
                    var coefficentsMagnitude = this.coefficentsMagnitude;
                    var coefficentsSign = this.coefficentsSign;
                    var contribution, sign0, sign1, significance1;
                    var contextLabel, decoded;
                    significance1 = column > 0 && coefficentsMagnitude[index - 1] !== 0;
                    if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
                      sign1 = coefficentsSign[index + 1];
                      if (significance1) {
                        sign0 = coefficentsSign[index - 1];
                        contribution = 1 - sign1 - sign0;
                      } else {
                        contribution = 1 - sign1 - sign1;
                      }
                    } else if (significance1) {
                      sign0 = coefficentsSign[index - 1];
                      contribution = 1 - sign0 - sign0;
                    } else {
                      contribution = 0;
                    }
                    var horizontalContribution = 3 * contribution;
                    significance1 = row > 0 && coefficentsMagnitude[index - width] !== 0;
                    if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
                      sign1 = coefficentsSign[index + width];
                      if (significance1) {
                        sign0 = coefficentsSign[index - width];
                        contribution = 1 - sign1 - sign0 + horizontalContribution;
                      } else {
                        contribution = 1 - sign1 - sign1 + horizontalContribution;
                      }
                    } else if (significance1) {
                      sign0 = coefficentsSign[index - width];
                      contribution = 1 - sign0 - sign0 + horizontalContribution;
                    } else {
                      contribution = horizontalContribution;
                    }
                    if (contribution >= 0) {
                      contextLabel = 9 + contribution;
                      decoded = this.decoder.readBit(this.contexts, contextLabel);
                    } else {
                      contextLabel = 9 - contribution;
                      decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
                    }
                    return decoded;
                  },
                  runMagnitudeRefinementPass: function BitModel_runMagnitudeRefinementPass() {
                    var decoder = this.decoder;
                    var width = this.width, height = this.height;
                    var coefficentsMagnitude = this.coefficentsMagnitude;
                    var neighborsSignificance = this.neighborsSignificance;
                    var contexts = this.contexts;
                    var bitsDecoded = this.bitsDecoded;
                    var processingFlags = this.processingFlags;
                    var processedMask = 1;
                    var firstMagnitudeBitMask = 2;
                    var length = width * height;
                    var width4 = width * 4;
                    for (var index0 = 0, indexNext; index0 < length; index0 = indexNext) {
                      indexNext = Math.min(length, index0 + width4);
                      for (var j = 0; j < width; j++) {
                        for (var index = index0 + j; index < indexNext; index += width) {
                          if (!coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
                            continue;
                          }
                          var contextLabel = 16;
                          if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
                            processingFlags[index] ^= firstMagnitudeBitMask;
                            var significance = neighborsSignificance[index] & 127;
                            contextLabel = significance === 0 ? 15 : 14;
                          }
                          var bit = decoder.readBit(contexts, contextLabel);
                          coefficentsMagnitude[index] = coefficentsMagnitude[index] << 1 | bit;
                          bitsDecoded[index]++;
                          processingFlags[index] |= processedMask;
                        }
                      }
                    }
                  },
                  runCleanupPass: function BitModel_runCleanupPass() {
                    var decoder = this.decoder;
                    var width = this.width, height = this.height;
                    var neighborsSignificance = this.neighborsSignificance;
                    var coefficentsMagnitude = this.coefficentsMagnitude;
                    var coefficentsSign = this.coefficentsSign;
                    var contexts = this.contexts;
                    var labels = this.contextLabelTable;
                    var bitsDecoded = this.bitsDecoded;
                    var processingFlags = this.processingFlags;
                    var processedMask = 1;
                    var firstMagnitudeBitMask = 2;
                    var oneRowDown = width;
                    var twoRowsDown = width * 2;
                    var threeRowsDown = width * 3;
                    var iNext;
                    for (var i0 = 0; i0 < height; i0 = iNext) {
                      iNext = Math.min(i0 + 4, height);
                      var indexBase = i0 * width;
                      var checkAllEmpty = i0 + 3 < height;
                      for (var j = 0; j < width; j++) {
                        var index0 = indexBase + j;
                        var allEmpty = checkAllEmpty && processingFlags[index0] === 0 && processingFlags[index0 + oneRowDown] === 0 && processingFlags[index0 + twoRowsDown] === 0 && processingFlags[index0 + threeRowsDown] === 0 && neighborsSignificance[index0] === 0 && neighborsSignificance[index0 + oneRowDown] === 0 && neighborsSignificance[index0 + twoRowsDown] === 0 && neighborsSignificance[index0 + threeRowsDown] === 0;
                        var i1 = 0, index = index0;
                        var i = i0, sign;
                        if (allEmpty) {
                          var hasSignificantCoefficent = decoder.readBit(contexts, RUNLENGTH_CONTEXT);
                          if (!hasSignificantCoefficent) {
                            bitsDecoded[index0]++;
                            bitsDecoded[index0 + oneRowDown]++;
                            bitsDecoded[index0 + twoRowsDown]++;
                            bitsDecoded[index0 + threeRowsDown]++;
                            continue;
                          }
                          i1 = decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);
                          if (i1 !== 0) {
                            i = i0 + i1;
                            index += i1 * width;
                          }
                          sign = this.decodeSignBit(i, j, index);
                          coefficentsSign[index] = sign;
                          coefficentsMagnitude[index] = 1;
                          this.setNeighborsSignificance(i, j, index);
                          processingFlags[index] |= firstMagnitudeBitMask;
                          index = index0;
                          for (var i2 = i0; i2 <= i; i2++, index += width) {
                            bitsDecoded[index]++;
                          }
                          i1++;
                        }
                        for (i = i0 + i1; i < iNext; i++, index += width) {
                          if (coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
                            continue;
                          }
                          var contextLabel = labels[neighborsSignificance[index]];
                          var decision = decoder.readBit(contexts, contextLabel);
                          if (decision === 1) {
                            sign = this.decodeSignBit(i, j, index);
                            coefficentsSign[index] = sign;
                            coefficentsMagnitude[index] = 1;
                            this.setNeighborsSignificance(i, j, index);
                            processingFlags[index] |= firstMagnitudeBitMask;
                          }
                          bitsDecoded[index]++;
                        }
                      }
                    }
                  },
                  checkSegmentationSymbol: function BitModel_checkSegmentationSymbol() {
                    var decoder = this.decoder;
                    var contexts = this.contexts;
                    var symbol = decoder.readBit(contexts, UNIFORM_CONTEXT) << 3 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 2 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);
                    if (symbol !== 10) {
                      throw new JpxError("Invalid segmentation symbol");
                    }
                  }
                };
                return BitModel2;
              }();
              var Transform = function TransformClosure() {
                function Transform2() {
                }
                Transform2.prototype.calculate = function transformCalculate(subbands, u0, v0) {
                  var ll = subbands[0];
                  for (var i = 1, ii = subbands.length; i < ii; i++) {
                    ll = this.iterate(ll, subbands[i], u0, v0);
                  }
                  return ll;
                };
                Transform2.prototype.extend = function extend(buffer, offset, size) {
                  var i1 = offset - 1, j1 = offset + 1;
                  var i2 = offset + size - 2, j2 = offset + size;
                  buffer[i1--] = buffer[j1++];
                  buffer[j2++] = buffer[i2--];
                  buffer[i1--] = buffer[j1++];
                  buffer[j2++] = buffer[i2--];
                  buffer[i1--] = buffer[j1++];
                  buffer[j2++] = buffer[i2--];
                  buffer[i1] = buffer[j1];
                  buffer[j2] = buffer[i2];
                };
                Transform2.prototype.iterate = function Transform_iterate(ll, hl_lh_hh, u0, v0) {
                  var llWidth = ll.width, llHeight = ll.height, llItems = ll.items;
                  var width = hl_lh_hh.width;
                  var height = hl_lh_hh.height;
                  var items = hl_lh_hh.items;
                  var i, j, k, l, u, v;
                  for (k = 0, i = 0; i < llHeight; i++) {
                    l = i * 2 * width;
                    for (j = 0; j < llWidth; j++, k++, l += 2) {
                      items[l] = llItems[k];
                    }
                  }
                  llItems = ll.items = null;
                  var bufferPadding = 4;
                  var rowBuffer = new Float32Array(width + 2 * bufferPadding);
                  if (width === 1) {
                    if ((u0 & 1) !== 0) {
                      for (v = 0, k = 0; v < height; v++, k += width) {
                        items[k] *= 0.5;
                      }
                    }
                  } else {
                    for (v = 0, k = 0; v < height; v++, k += width) {
                      rowBuffer.set(items.subarray(k, k + width), bufferPadding);
                      this.extend(rowBuffer, bufferPadding, width);
                      this.filter(rowBuffer, bufferPadding, width);
                      items.set(rowBuffer.subarray(bufferPadding, bufferPadding + width), k);
                    }
                  }
                  var numBuffers = 16;
                  var colBuffers = [];
                  for (i = 0; i < numBuffers; i++) {
                    colBuffers.push(new Float32Array(height + 2 * bufferPadding));
                  }
                  var b, currentBuffer = 0;
                  ll = bufferPadding + height;
                  if (height === 1) {
                    if ((v0 & 1) !== 0) {
                      for (u = 0; u < width; u++) {
                        items[u] *= 0.5;
                      }
                    }
                  } else {
                    for (u = 0; u < width; u++) {
                      if (currentBuffer === 0) {
                        numBuffers = Math.min(width - u, numBuffers);
                        for (k = u, l = bufferPadding; l < ll; k += width, l++) {
                          for (b = 0; b < numBuffers; b++) {
                            colBuffers[b][l] = items[k + b];
                          }
                        }
                        currentBuffer = numBuffers;
                      }
                      currentBuffer--;
                      var buffer = colBuffers[currentBuffer];
                      this.extend(buffer, bufferPadding, height);
                      this.filter(buffer, bufferPadding, height);
                      if (currentBuffer === 0) {
                        k = u - numBuffers + 1;
                        for (l = bufferPadding; l < ll; k += width, l++) {
                          for (b = 0; b < numBuffers; b++) {
                            items[k + b] = colBuffers[b][l];
                          }
                        }
                      }
                    }
                  }
                  return {
                    width,
                    height,
                    items
                  };
                };
                return Transform2;
              }();
              var IrreversibleTransform = function IrreversibleTransformClosure() {
                function IrreversibleTransform2() {
                  Transform.call(this);
                }
                IrreversibleTransform2.prototype = Object.create(Transform.prototype);
                IrreversibleTransform2.prototype.filter = function irreversibleTransformFilter(x, offset, length) {
                  var len = length >> 1;
                  offset = offset | 0;
                  var j, n, current, next;
                  var alpha = -1.586134342059924;
                  var beta = -0.052980118572961;
                  var gamma = 0.882911075530934;
                  var delta = 0.443506852043971;
                  var K = 1.230174104914001;
                  var K_ = 1 / K;
                  j = offset - 3;
                  for (n = len + 4; n--; j += 2) {
                    x[j] *= K_;
                  }
                  j = offset - 2;
                  current = delta * x[j - 1];
                  for (n = len + 3; n--; j += 2) {
                    next = delta * x[j + 1];
                    x[j] = K * x[j] - current - next;
                    if (n--) {
                      j += 2;
                      current = delta * x[j + 1];
                      x[j] = K * x[j] - current - next;
                    } else {
                      break;
                    }
                  }
                  j = offset - 1;
                  current = gamma * x[j - 1];
                  for (n = len + 2; n--; j += 2) {
                    next = gamma * x[j + 1];
                    x[j] -= current + next;
                    if (n--) {
                      j += 2;
                      current = gamma * x[j + 1];
                      x[j] -= current + next;
                    } else {
                      break;
                    }
                  }
                  j = offset;
                  current = beta * x[j - 1];
                  for (n = len + 1; n--; j += 2) {
                    next = beta * x[j + 1];
                    x[j] -= current + next;
                    if (n--) {
                      j += 2;
                      current = beta * x[j + 1];
                      x[j] -= current + next;
                    } else {
                      break;
                    }
                  }
                  if (len !== 0) {
                    j = offset + 1;
                    current = alpha * x[j - 1];
                    for (n = len; n--; j += 2) {
                      next = alpha * x[j + 1];
                      x[j] -= current + next;
                      if (n--) {
                        j += 2;
                        current = alpha * x[j + 1];
                        x[j] -= current + next;
                      } else {
                        break;
                      }
                    }
                  }
                };
                return IrreversibleTransform2;
              }();
              var ReversibleTransform = function ReversibleTransformClosure() {
                function ReversibleTransform2() {
                  Transform.call(this);
                }
                ReversibleTransform2.prototype = Object.create(Transform.prototype);
                ReversibleTransform2.prototype.filter = function reversibleTransformFilter(x, offset, length) {
                  var len = length >> 1;
                  offset = offset | 0;
                  var j, n;
                  for (j = offset, n = len + 1; n--; j += 2) {
                    x[j] -= x[j - 1] + x[j + 1] + 2 >> 2;
                  }
                  for (j = offset + 1, n = len; n--; j += 2) {
                    x[j] += x[j - 1] + x[j + 1] >> 1;
                  }
                };
                return ReversibleTransform2;
              }();
              return JpxImage2;
            }();
            exports3.JpxImage = JpxImage;
          },
          /* 131 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.calculateSHA512 = exports3.calculateSHA384 = exports3.calculateSHA256 = exports3.calculateMD5 = exports3.PDF20 = exports3.PDF17 = exports3.CipherTransformFactory = exports3.ARCFourCipher = exports3.AES256Cipher = exports3.AES128Cipher = void 0;
            var _createClass = /* @__PURE__ */ function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _util = __w_pdfjs_require__(2);
            var _primitives = __w_pdfjs_require__(119);
            var _stream = __w_pdfjs_require__(121);
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var ARCFourCipher = function ARCFourCipherClosure() {
              function ARCFourCipher2(key) {
                this.a = 0;
                this.b = 0;
                var s = new Uint8Array(256);
                var i, j = 0, tmp, keyLength = key.length;
                for (i = 0; i < 256; ++i) {
                  s[i] = i;
                }
                for (i = 0; i < 256; ++i) {
                  tmp = s[i];
                  j = j + tmp + key[i % keyLength] & 255;
                  s[i] = s[j];
                  s[j] = tmp;
                }
                this.s = s;
              }
              ARCFourCipher2.prototype = {
                encryptBlock: function ARCFourCipher_encryptBlock(data) {
                  var i, n = data.length, tmp, tmp2;
                  var a = this.a, b = this.b, s = this.s;
                  var output = new Uint8Array(n);
                  for (i = 0; i < n; ++i) {
                    a = a + 1 & 255;
                    tmp = s[a];
                    b = b + tmp & 255;
                    tmp2 = s[b];
                    s[a] = tmp2;
                    s[b] = tmp;
                    output[i] = data[i] ^ s[tmp + tmp2 & 255];
                  }
                  this.a = a;
                  this.b = b;
                  return output;
                }
              };
              ARCFourCipher2.prototype.decryptBlock = ARCFourCipher2.prototype.encryptBlock;
              return ARCFourCipher2;
            }();
            var calculateMD5 = function calculateMD5Closure() {
              var r = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);
              var k = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
              function hash(data, offset, length) {
                var h0 = 1732584193, h1 = -271733879, h2 = -1732584194, h3 = 271733878;
                var paddedLength = length + 72 & ~63;
                var padded = new Uint8Array(paddedLength);
                var i, j, n;
                for (i = 0; i < length; ++i) {
                  padded[i] = data[offset++];
                }
                padded[i++] = 128;
                n = paddedLength - 8;
                while (i < n) {
                  padded[i++] = 0;
                }
                padded[i++] = length << 3 & 255;
                padded[i++] = length >> 5 & 255;
                padded[i++] = length >> 13 & 255;
                padded[i++] = length >> 21 & 255;
                padded[i++] = length >>> 29 & 255;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                var w = new Int32Array(16);
                for (i = 0; i < paddedLength; ) {
                  for (j = 0; j < 16; ++j, i += 4) {
                    w[j] = padded[i] | padded[i + 1] << 8 | padded[i + 2] << 16 | padded[i + 3] << 24;
                  }
                  var a = h0, b = h1, c = h2, d = h3, f, g;
                  for (j = 0; j < 64; ++j) {
                    if (j < 16) {
                      f = b & c | ~b & d;
                      g = j;
                    } else if (j < 32) {
                      f = d & b | ~d & c;
                      g = 5 * j + 1 & 15;
                    } else if (j < 48) {
                      f = b ^ c ^ d;
                      g = 3 * j + 5 & 15;
                    } else {
                      f = c ^ (b | ~d);
                      g = 7 * j & 15;
                    }
                    var tmp = d, rotateArg = a + f + k[j] + w[g] | 0, rotate = r[j];
                    d = c;
                    c = b;
                    b = b + (rotateArg << rotate | rotateArg >>> 32 - rotate) | 0;
                    a = tmp;
                  }
                  h0 = h0 + a | 0;
                  h1 = h1 + b | 0;
                  h2 = h2 + c | 0;
                  h3 = h3 + d | 0;
                }
                return new Uint8Array([h0 & 255, h0 >> 8 & 255, h0 >> 16 & 255, h0 >>> 24 & 255, h1 & 255, h1 >> 8 & 255, h1 >> 16 & 255, h1 >>> 24 & 255, h2 & 255, h2 >> 8 & 255, h2 >> 16 & 255, h2 >>> 24 & 255, h3 & 255, h3 >> 8 & 255, h3 >> 16 & 255, h3 >>> 24 & 255]);
              }
              return hash;
            }();
            var Word64 = function Word64Closure() {
              function Word642(highInteger, lowInteger) {
                this.high = highInteger | 0;
                this.low = lowInteger | 0;
              }
              Word642.prototype = {
                and: function Word64_and(word) {
                  this.high &= word.high;
                  this.low &= word.low;
                },
                xor: function Word64_xor(word) {
                  this.high ^= word.high;
                  this.low ^= word.low;
                },
                or: function Word64_or(word) {
                  this.high |= word.high;
                  this.low |= word.low;
                },
                shiftRight: function Word64_shiftRight(places) {
                  if (places >= 32) {
                    this.low = this.high >>> places - 32 | 0;
                    this.high = 0;
                  } else {
                    this.low = this.low >>> places | this.high << 32 - places;
                    this.high = this.high >>> places | 0;
                  }
                },
                shiftLeft: function Word64_shiftLeft(places) {
                  if (places >= 32) {
                    this.high = this.low << places - 32;
                    this.low = 0;
                  } else {
                    this.high = this.high << places | this.low >>> 32 - places;
                    this.low = this.low << places;
                  }
                },
                rotateRight: function Word64_rotateRight(places) {
                  var low, high;
                  if (places & 32) {
                    high = this.low;
                    low = this.high;
                  } else {
                    low = this.low;
                    high = this.high;
                  }
                  places &= 31;
                  this.low = low >>> places | high << 32 - places;
                  this.high = high >>> places | low << 32 - places;
                },
                not: function Word64_not() {
                  this.high = ~this.high;
                  this.low = ~this.low;
                },
                add: function Word64_add(word) {
                  var lowAdd = (this.low >>> 0) + (word.low >>> 0);
                  var highAdd = (this.high >>> 0) + (word.high >>> 0);
                  if (lowAdd > 4294967295) {
                    highAdd += 1;
                  }
                  this.low = lowAdd | 0;
                  this.high = highAdd | 0;
                },
                copyTo: function Word64_copyTo(bytes, offset) {
                  bytes[offset] = this.high >>> 24 & 255;
                  bytes[offset + 1] = this.high >> 16 & 255;
                  bytes[offset + 2] = this.high >> 8 & 255;
                  bytes[offset + 3] = this.high & 255;
                  bytes[offset + 4] = this.low >>> 24 & 255;
                  bytes[offset + 5] = this.low >> 16 & 255;
                  bytes[offset + 6] = this.low >> 8 & 255;
                  bytes[offset + 7] = this.low & 255;
                },
                assign: function Word64_assign(word) {
                  this.high = word.high;
                  this.low = word.low;
                }
              };
              return Word642;
            }();
            var calculateSHA256 = /* @__PURE__ */ function calculateSHA256Closure() {
              function rotr(x, n) {
                return x >>> n | x << 32 - n;
              }
              function ch(x, y, z) {
                return x & y ^ ~x & z;
              }
              function maj(x, y, z) {
                return x & y ^ x & z ^ y & z;
              }
              function sigma(x) {
                return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
              }
              function sigmaPrime(x) {
                return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
              }
              function littleSigma(x) {
                return rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;
              }
              function littleSigmaPrime(x) {
                return rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;
              }
              var k = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
              function hash(data, offset, length) {
                var h0 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762, h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
                var paddedLength = Math.ceil((length + 9) / 64) * 64;
                var padded = new Uint8Array(paddedLength);
                var i, j, n;
                for (i = 0; i < length; ++i) {
                  padded[i] = data[offset++];
                }
                padded[i++] = 128;
                n = paddedLength - 8;
                while (i < n) {
                  padded[i++] = 0;
                }
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = length >>> 29 & 255;
                padded[i++] = length >> 21 & 255;
                padded[i++] = length >> 13 & 255;
                padded[i++] = length >> 5 & 255;
                padded[i++] = length << 3 & 255;
                var w = new Uint32Array(64);
                for (i = 0; i < paddedLength; ) {
                  for (j = 0; j < 16; ++j) {
                    w[j] = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
                    i += 4;
                  }
                  for (j = 16; j < 64; ++j) {
                    w[j] = littleSigmaPrime(w[j - 2]) + w[j - 7] + littleSigma(w[j - 15]) + w[j - 16] | 0;
                  }
                  var a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, t1, t2;
                  for (j = 0; j < 64; ++j) {
                    t1 = h + sigmaPrime(e) + ch(e, f, g) + k[j] + w[j];
                    t2 = sigma(a) + maj(a, b, c);
                    h = g;
                    g = f;
                    f = e;
                    e = d + t1 | 0;
                    d = c;
                    c = b;
                    b = a;
                    a = t1 + t2 | 0;
                  }
                  h0 = h0 + a | 0;
                  h1 = h1 + b | 0;
                  h2 = h2 + c | 0;
                  h3 = h3 + d | 0;
                  h4 = h4 + e | 0;
                  h5 = h5 + f | 0;
                  h6 = h6 + g | 0;
                  h7 = h7 + h | 0;
                }
                return new Uint8Array([h0 >> 24 & 255, h0 >> 16 & 255, h0 >> 8 & 255, h0 & 255, h1 >> 24 & 255, h1 >> 16 & 255, h1 >> 8 & 255, h1 & 255, h2 >> 24 & 255, h2 >> 16 & 255, h2 >> 8 & 255, h2 & 255, h3 >> 24 & 255, h3 >> 16 & 255, h3 >> 8 & 255, h3 & 255, h4 >> 24 & 255, h4 >> 16 & 255, h4 >> 8 & 255, h4 & 255, h5 >> 24 & 255, h5 >> 16 & 255, h5 >> 8 & 255, h5 & 255, h6 >> 24 & 255, h6 >> 16 & 255, h6 >> 8 & 255, h6 & 255, h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255]);
              }
              return hash;
            }();
            var calculateSHA512 = function calculateSHA512Closure() {
              function ch(result, x, y, z, tmp) {
                result.assign(x);
                result.and(y);
                tmp.assign(x);
                tmp.not();
                tmp.and(z);
                result.xor(tmp);
              }
              function maj(result, x, y, z, tmp) {
                result.assign(x);
                result.and(y);
                tmp.assign(x);
                tmp.and(z);
                result.xor(tmp);
                tmp.assign(y);
                tmp.and(z);
                result.xor(tmp);
              }
              function sigma(result, x, tmp) {
                result.assign(x);
                result.rotateRight(28);
                tmp.assign(x);
                tmp.rotateRight(34);
                result.xor(tmp);
                tmp.assign(x);
                tmp.rotateRight(39);
                result.xor(tmp);
              }
              function sigmaPrime(result, x, tmp) {
                result.assign(x);
                result.rotateRight(14);
                tmp.assign(x);
                tmp.rotateRight(18);
                result.xor(tmp);
                tmp.assign(x);
                tmp.rotateRight(41);
                result.xor(tmp);
              }
              function littleSigma(result, x, tmp) {
                result.assign(x);
                result.rotateRight(1);
                tmp.assign(x);
                tmp.rotateRight(8);
                result.xor(tmp);
                tmp.assign(x);
                tmp.shiftRight(7);
                result.xor(tmp);
              }
              function littleSigmaPrime(result, x, tmp) {
                result.assign(x);
                result.rotateRight(19);
                tmp.assign(x);
                tmp.rotateRight(61);
                result.xor(tmp);
                tmp.assign(x);
                tmp.shiftRight(6);
                result.xor(tmp);
              }
              var k = [new Word64(1116352408, 3609767458), new Word64(1899447441, 602891725), new Word64(3049323471, 3964484399), new Word64(3921009573, 2173295548), new Word64(961987163, 4081628472), new Word64(1508970993, 3053834265), new Word64(2453635748, 2937671579), new Word64(2870763221, 3664609560), new Word64(3624381080, 2734883394), new Word64(310598401, 1164996542), new Word64(607225278, 1323610764), new Word64(1426881987, 3590304994), new Word64(1925078388, 4068182383), new Word64(2162078206, 991336113), new Word64(2614888103, 633803317), new Word64(3248222580, 3479774868), new Word64(3835390401, 2666613458), new Word64(4022224774, 944711139), new Word64(264347078, 2341262773), new Word64(604807628, 2007800933), new Word64(770255983, 1495990901), new Word64(1249150122, 1856431235), new Word64(1555081692, 3175218132), new Word64(1996064986, 2198950837), new Word64(2554220882, 3999719339), new Word64(2821834349, 766784016), new Word64(2952996808, 2566594879), new Word64(3210313671, 3203337956), new Word64(3336571891, 1034457026), new Word64(3584528711, 2466948901), new Word64(113926993, 3758326383), new Word64(338241895, 168717936), new Word64(666307205, 1188179964), new Word64(773529912, 1546045734), new Word64(1294757372, 1522805485), new Word64(1396182291, 2643833823), new Word64(1695183700, 2343527390), new Word64(1986661051, 1014477480), new Word64(2177026350, 1206759142), new Word64(2456956037, 344077627), new Word64(2730485921, 1290863460), new Word64(2820302411, 3158454273), new Word64(3259730800, 3505952657), new Word64(3345764771, 106217008), new Word64(3516065817, 3606008344), new Word64(3600352804, 1432725776), new Word64(4094571909, 1467031594), new Word64(275423344, 851169720), new Word64(430227734, 3100823752), new Word64(506948616, 1363258195), new Word64(659060556, 3750685593), new Word64(883997877, 3785050280), new Word64(958139571, 3318307427), new Word64(1322822218, 3812723403), new Word64(1537002063, 2003034995), new Word64(1747873779, 3602036899), new Word64(1955562222, 1575990012), new Word64(2024104815, 1125592928), new Word64(2227730452, 2716904306), new Word64(2361852424, 442776044), new Word64(2428436474, 593698344), new Word64(2756734187, 3733110249), new Word64(3204031479, 2999351573), new Word64(3329325298, 3815920427), new Word64(3391569614, 3928383900), new Word64(3515267271, 566280711), new Word64(3940187606, 3454069534), new Word64(4118630271, 4000239992), new Word64(116418474, 1914138554), new Word64(174292421, 2731055270), new Word64(289380356, 3203993006), new Word64(460393269, 320620315), new Word64(685471733, 587496836), new Word64(852142971, 1086792851), new Word64(1017036298, 365543100), new Word64(1126000580, 2618297676), new Word64(1288033470, 3409855158), new Word64(1501505948, 4234509866), new Word64(1607167915, 987167468), new Word64(1816402316, 1246189591)];
              function hash(data, offset, length, mode384) {
                mode384 = !!mode384;
                var h0, h1, h2, h3, h4, h5, h6, h7;
                if (!mode384) {
                  h0 = new Word64(1779033703, 4089235720);
                  h1 = new Word64(3144134277, 2227873595);
                  h2 = new Word64(1013904242, 4271175723);
                  h3 = new Word64(2773480762, 1595750129);
                  h4 = new Word64(1359893119, 2917565137);
                  h5 = new Word64(2600822924, 725511199);
                  h6 = new Word64(528734635, 4215389547);
                  h7 = new Word64(1541459225, 327033209);
                } else {
                  h0 = new Word64(3418070365, 3238371032);
                  h1 = new Word64(1654270250, 914150663);
                  h2 = new Word64(2438529370, 812702999);
                  h3 = new Word64(355462360, 4144912697);
                  h4 = new Word64(1731405415, 4290775857);
                  h5 = new Word64(2394180231, 1750603025);
                  h6 = new Word64(3675008525, 1694076839);
                  h7 = new Word64(1203062813, 3204075428);
                }
                var paddedLength = Math.ceil((length + 17) / 128) * 128;
                var padded = new Uint8Array(paddedLength);
                var i, j, n;
                for (i = 0; i < length; ++i) {
                  padded[i] = data[offset++];
                }
                padded[i++] = 128;
                n = paddedLength - 16;
                while (i < n) {
                  padded[i++] = 0;
                }
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = length >>> 29 & 255;
                padded[i++] = length >> 21 & 255;
                padded[i++] = length >> 13 & 255;
                padded[i++] = length >> 5 & 255;
                padded[i++] = length << 3 & 255;
                var w = new Array(80);
                for (i = 0; i < 80; i++) {
                  w[i] = new Word64(0, 0);
                }
                var a = new Word64(0, 0), b = new Word64(0, 0), c = new Word64(0, 0);
                var d = new Word64(0, 0), e = new Word64(0, 0), f = new Word64(0, 0);
                var g = new Word64(0, 0), h = new Word64(0, 0);
                var t1 = new Word64(0, 0), t2 = new Word64(0, 0);
                var tmp1 = new Word64(0, 0), tmp2 = new Word64(0, 0), tmp3;
                for (i = 0; i < paddedLength; ) {
                  for (j = 0; j < 16; ++j) {
                    w[j].high = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
                    w[j].low = padded[i + 4] << 24 | padded[i + 5] << 16 | padded[i + 6] << 8 | padded[i + 7];
                    i += 8;
                  }
                  for (j = 16; j < 80; ++j) {
                    tmp3 = w[j];
                    littleSigmaPrime(tmp3, w[j - 2], tmp2);
                    tmp3.add(w[j - 7]);
                    littleSigma(tmp1, w[j - 15], tmp2);
                    tmp3.add(tmp1);
                    tmp3.add(w[j - 16]);
                  }
                  a.assign(h0);
                  b.assign(h1);
                  c.assign(h2);
                  d.assign(h3);
                  e.assign(h4);
                  f.assign(h5);
                  g.assign(h6);
                  h.assign(h7);
                  for (j = 0; j < 80; ++j) {
                    t1.assign(h);
                    sigmaPrime(tmp1, e, tmp2);
                    t1.add(tmp1);
                    ch(tmp1, e, f, g, tmp2);
                    t1.add(tmp1);
                    t1.add(k[j]);
                    t1.add(w[j]);
                    sigma(t2, a, tmp2);
                    maj(tmp1, a, b, c, tmp2);
                    t2.add(tmp1);
                    tmp3 = h;
                    h = g;
                    g = f;
                    f = e;
                    d.add(t1);
                    e = d;
                    d = c;
                    c = b;
                    b = a;
                    tmp3.assign(t1);
                    tmp3.add(t2);
                    a = tmp3;
                  }
                  h0.add(a);
                  h1.add(b);
                  h2.add(c);
                  h3.add(d);
                  h4.add(e);
                  h5.add(f);
                  h6.add(g);
                  h7.add(h);
                }
                var result;
                if (!mode384) {
                  result = new Uint8Array(64);
                  h0.copyTo(result, 0);
                  h1.copyTo(result, 8);
                  h2.copyTo(result, 16);
                  h3.copyTo(result, 24);
                  h4.copyTo(result, 32);
                  h5.copyTo(result, 40);
                  h6.copyTo(result, 48);
                  h7.copyTo(result, 56);
                } else {
                  result = new Uint8Array(48);
                  h0.copyTo(result, 0);
                  h1.copyTo(result, 8);
                  h2.copyTo(result, 16);
                  h3.copyTo(result, 24);
                  h4.copyTo(result, 32);
                  h5.copyTo(result, 40);
                }
                return result;
              }
              return hash;
            }();
            var calculateSHA384 = /* @__PURE__ */ function calculateSHA384Closure() {
              function hash(data, offset, length) {
                return calculateSHA512(data, offset, length, true);
              }
              return hash;
            }();
            var NullCipher = function NullCipherClosure() {
              function NullCipher2() {
              }
              NullCipher2.prototype = {
                decryptBlock: function NullCipher_decryptBlock(data) {
                  return data;
                }
              };
              return NullCipher2;
            }();
            var AESBaseCipher = function() {
              function AESBaseCipher2() {
                _classCallCheck(this, AESBaseCipher2);
                if (this.constructor === AESBaseCipher2) {
                  (0, _util.unreachable)("Cannot initialize AESBaseCipher.");
                }
                this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]);
                this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]);
                this._mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]);
                this._mixCol = new Uint8Array(256);
                for (var i = 0; i < 256; i++) {
                  if (i < 128) {
                    this._mixCol[i] = i << 1;
                  } else {
                    this._mixCol[i] = i << 1 ^ 27;
                  }
                }
                this.buffer = new Uint8Array(16);
                this.bufferPosition = 0;
              }
              _createClass(AESBaseCipher2, [{
                key: "_expandKey",
                value: function _expandKey(cipherKey) {
                  (0, _util.unreachable)("Cannot call `_expandKey` on the base class");
                }
              }, {
                key: "_decrypt",
                value: function _decrypt(input, key) {
                  var t = void 0, u = void 0, v = void 0;
                  var state = new Uint8Array(16);
                  state.set(input);
                  for (var j = 0, k = this._keySize; j < 16; ++j, ++k) {
                    state[j] ^= key[k];
                  }
                  for (var i = this._cyclesOfRepetition - 1; i >= 1; --i) {
                    t = state[13];
                    state[13] = state[9];
                    state[9] = state[5];
                    state[5] = state[1];
                    state[1] = t;
                    t = state[14];
                    u = state[10];
                    state[14] = state[6];
                    state[10] = state[2];
                    state[6] = t;
                    state[2] = u;
                    t = state[15];
                    u = state[11];
                    v = state[7];
                    state[15] = state[3];
                    state[11] = t;
                    state[7] = u;
                    state[3] = v;
                    for (var _j = 0; _j < 16; ++_j) {
                      state[_j] = this._inv_s[state[_j]];
                    }
                    for (var _j2 = 0, _k = i * 16; _j2 < 16; ++_j2, ++_k) {
                      state[_j2] ^= key[_k];
                    }
                    for (var _j3 = 0; _j3 < 16; _j3 += 4) {
                      var s0 = this._mix[state[_j3]];
                      var s1 = this._mix[state[_j3 + 1]];
                      var s2 = this._mix[state[_j3 + 2]];
                      var s3 = this._mix[state[_j3 + 3]];
                      t = s0 ^ s1 >>> 8 ^ s1 << 24 ^ s2 >>> 16 ^ s2 << 16 ^ s3 >>> 24 ^ s3 << 8;
                      state[_j3] = t >>> 24 & 255;
                      state[_j3 + 1] = t >> 16 & 255;
                      state[_j3 + 2] = t >> 8 & 255;
                      state[_j3 + 3] = t & 255;
                    }
                  }
                  t = state[13];
                  state[13] = state[9];
                  state[9] = state[5];
                  state[5] = state[1];
                  state[1] = t;
                  t = state[14];
                  u = state[10];
                  state[14] = state[6];
                  state[10] = state[2];
                  state[6] = t;
                  state[2] = u;
                  t = state[15];
                  u = state[11];
                  v = state[7];
                  state[15] = state[3];
                  state[11] = t;
                  state[7] = u;
                  state[3] = v;
                  for (var _j4 = 0; _j4 < 16; ++_j4) {
                    state[_j4] = this._inv_s[state[_j4]];
                    state[_j4] ^= key[_j4];
                  }
                  return state;
                }
              }, {
                key: "_encrypt",
                value: function _encrypt(input, key) {
                  var s = this._s;
                  var t = void 0, u = void 0, v = void 0;
                  var state = new Uint8Array(16);
                  state.set(input);
                  for (var j = 0; j < 16; ++j) {
                    state[j] ^= key[j];
                  }
                  for (var i = 1; i < this._cyclesOfRepetition; i++) {
                    for (var _j5 = 0; _j5 < 16; ++_j5) {
                      state[_j5] = s[state[_j5]];
                    }
                    v = state[1];
                    state[1] = state[5];
                    state[5] = state[9];
                    state[9] = state[13];
                    state[13] = v;
                    v = state[2];
                    u = state[6];
                    state[2] = state[10];
                    state[6] = state[14];
                    state[10] = v;
                    state[14] = u;
                    v = state[3];
                    u = state[7];
                    t = state[11];
                    state[3] = state[15];
                    state[7] = v;
                    state[11] = u;
                    state[15] = t;
                    for (var _j6 = 0; _j6 < 16; _j6 += 4) {
                      var s0 = state[_j6 + 0];
                      var s1 = state[_j6 + 1];
                      var s2 = state[_j6 + 2];
                      var s3 = state[_j6 + 3];
                      t = s0 ^ s1 ^ s2 ^ s3;
                      state[_j6 + 0] ^= t ^ this._mixCol[s0 ^ s1];
                      state[_j6 + 1] ^= t ^ this._mixCol[s1 ^ s2];
                      state[_j6 + 2] ^= t ^ this._mixCol[s2 ^ s3];
                      state[_j6 + 3] ^= t ^ this._mixCol[s3 ^ s0];
                    }
                    for (var _j7 = 0, k = i * 16; _j7 < 16; ++_j7, ++k) {
                      state[_j7] ^= key[k];
                    }
                  }
                  for (var _j8 = 0; _j8 < 16; ++_j8) {
                    state[_j8] = s[state[_j8]];
                  }
                  v = state[1];
                  state[1] = state[5];
                  state[5] = state[9];
                  state[9] = state[13];
                  state[13] = v;
                  v = state[2];
                  u = state[6];
                  state[2] = state[10];
                  state[6] = state[14];
                  state[10] = v;
                  state[14] = u;
                  v = state[3];
                  u = state[7];
                  t = state[11];
                  state[3] = state[15];
                  state[7] = v;
                  state[11] = u;
                  state[15] = t;
                  for (var _j9 = 0, _k2 = this._keySize; _j9 < 16; ++_j9, ++_k2) {
                    state[_j9] ^= key[_k2];
                  }
                  return state;
                }
              }, {
                key: "_decryptBlock2",
                value: function _decryptBlock2(data, finalize) {
                  var sourceLength = data.length;
                  var buffer = this.buffer, bufferLength = this.bufferPosition;
                  var result = [], iv = this.iv;
                  for (var i = 0; i < sourceLength; ++i) {
                    buffer[bufferLength] = data[i];
                    ++bufferLength;
                    if (bufferLength < 16) {
                      continue;
                    }
                    var plain = this._decrypt(buffer, this._key);
                    for (var j = 0; j < 16; ++j) {
                      plain[j] ^= iv[j];
                    }
                    iv = buffer;
                    result.push(plain);
                    buffer = new Uint8Array(16);
                    bufferLength = 0;
                  }
                  this.buffer = buffer;
                  this.bufferLength = bufferLength;
                  this.iv = iv;
                  if (result.length === 0) {
                    return new Uint8Array(0);
                  }
                  var outputLength = 16 * result.length;
                  if (finalize) {
                    var lastBlock = result[result.length - 1];
                    var psLen = lastBlock[15];
                    if (psLen <= 16) {
                      for (var _i = 15, ii = 16 - psLen; _i >= ii; --_i) {
                        if (lastBlock[_i] !== psLen) {
                          psLen = 0;
                          break;
                        }
                      }
                      outputLength -= psLen;
                      result[result.length - 1] = lastBlock.subarray(0, 16 - psLen);
                    }
                  }
                  var output = new Uint8Array(outputLength);
                  for (var _i2 = 0, _j10 = 0, _ii = result.length; _i2 < _ii; ++_i2, _j10 += 16) {
                    output.set(result[_i2], _j10);
                  }
                  return output;
                }
              }, {
                key: "decryptBlock",
                value: function decryptBlock(data, finalize) {
                  var iv = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                  var sourceLength = data.length;
                  var buffer = this.buffer, bufferLength = this.bufferPosition;
                  if (iv) {
                    this.iv = iv;
                  } else {
                    for (var i = 0; bufferLength < 16 && i < sourceLength; ++i, ++bufferLength) {
                      buffer[bufferLength] = data[i];
                    }
                    if (bufferLength < 16) {
                      this.bufferLength = bufferLength;
                      return new Uint8Array(0);
                    }
                    this.iv = buffer;
                    data = data.subarray(16);
                  }
                  this.buffer = new Uint8Array(16);
                  this.bufferLength = 0;
                  this.decryptBlock = this._decryptBlock2;
                  return this.decryptBlock(data, finalize);
                }
              }, {
                key: "encrypt",
                value: function encrypt(data, iv) {
                  var sourceLength = data.length;
                  var buffer = this.buffer, bufferLength = this.bufferPosition;
                  var result = [];
                  if (!iv) {
                    iv = new Uint8Array(16);
                  }
                  for (var i = 0; i < sourceLength; ++i) {
                    buffer[bufferLength] = data[i];
                    ++bufferLength;
                    if (bufferLength < 16) {
                      continue;
                    }
                    for (var j = 0; j < 16; ++j) {
                      buffer[j] ^= iv[j];
                    }
                    var cipher = this._encrypt(buffer, this._key);
                    iv = cipher;
                    result.push(cipher);
                    buffer = new Uint8Array(16);
                    bufferLength = 0;
                  }
                  this.buffer = buffer;
                  this.bufferLength = bufferLength;
                  this.iv = iv;
                  if (result.length === 0) {
                    return new Uint8Array(0);
                  }
                  var outputLength = 16 * result.length;
                  var output = new Uint8Array(outputLength);
                  for (var _i3 = 0, _j11 = 0, ii = result.length; _i3 < ii; ++_i3, _j11 += 16) {
                    output.set(result[_i3], _j11);
                  }
                  return output;
                }
              }]);
              return AESBaseCipher2;
            }();
            var AES128Cipher = function(_AESBaseCipher) {
              _inherits(AES128Cipher2, _AESBaseCipher);
              function AES128Cipher2(key) {
                _classCallCheck(this, AES128Cipher2);
                var _this = _possibleConstructorReturn(this, (AES128Cipher2.__proto__ || Object.getPrototypeOf(AES128Cipher2)).call(this));
                _this._cyclesOfRepetition = 10;
                _this._keySize = 160;
                _this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]);
                _this._key = _this._expandKey(key);
                return _this;
              }
              _createClass(AES128Cipher2, [{
                key: "_expandKey",
                value: function _expandKey(cipherKey) {
                  var b = 176;
                  var s = this._s;
                  var rcon = this._rcon;
                  var result = new Uint8Array(b);
                  result.set(cipherKey);
                  for (var j = 16, i = 1; j < b; ++i) {
                    var t1 = result[j - 3];
                    var t2 = result[j - 2];
                    var t3 = result[j - 1];
                    var t4 = result[j - 4];
                    t1 = s[t1];
                    t2 = s[t2];
                    t3 = s[t3];
                    t4 = s[t4];
                    t1 = t1 ^ rcon[i];
                    for (var n = 0; n < 4; ++n) {
                      result[j] = t1 ^= result[j - 16];
                      j++;
                      result[j] = t2 ^= result[j - 16];
                      j++;
                      result[j] = t3 ^= result[j - 16];
                      j++;
                      result[j] = t4 ^= result[j - 16];
                      j++;
                    }
                  }
                  return result;
                }
              }]);
              return AES128Cipher2;
            }(AESBaseCipher);
            var AES256Cipher = function(_AESBaseCipher2) {
              _inherits(AES256Cipher2, _AESBaseCipher2);
              function AES256Cipher2(key) {
                _classCallCheck(this, AES256Cipher2);
                var _this2 = _possibleConstructorReturn(this, (AES256Cipher2.__proto__ || Object.getPrototypeOf(AES256Cipher2)).call(this));
                _this2._cyclesOfRepetition = 14;
                _this2._keySize = 224;
                _this2._key = _this2._expandKey(key);
                return _this2;
              }
              _createClass(AES256Cipher2, [{
                key: "_expandKey",
                value: function _expandKey(cipherKey) {
                  var b = 240;
                  var s = this._s;
                  var result = new Uint8Array(b);
                  result.set(cipherKey);
                  var r = 1;
                  var t1 = void 0, t2 = void 0, t3 = void 0, t4 = void 0;
                  for (var j = 32, i = 1; j < b; ++i) {
                    if (j % 32 === 16) {
                      t1 = s[t1];
                      t2 = s[t2];
                      t3 = s[t3];
                      t4 = s[t4];
                    } else if (j % 32 === 0) {
                      t1 = result[j - 3];
                      t2 = result[j - 2];
                      t3 = result[j - 1];
                      t4 = result[j - 4];
                      t1 = s[t1];
                      t2 = s[t2];
                      t3 = s[t3];
                      t4 = s[t4];
                      t1 = t1 ^ r;
                      if ((r <<= 1) >= 256) {
                        r = (r ^ 27) & 255;
                      }
                    }
                    for (var n = 0; n < 4; ++n) {
                      result[j] = t1 ^= result[j - 32];
                      j++;
                      result[j] = t2 ^= result[j - 32];
                      j++;
                      result[j] = t3 ^= result[j - 32];
                      j++;
                      result[j] = t4 ^= result[j - 32];
                      j++;
                    }
                  }
                  return result;
                }
              }]);
              return AES256Cipher2;
            }(AESBaseCipher);
            var PDF17 = function PDF17Closure() {
              function compareByteArrays(array1, array2) {
                if (array1.length !== array2.length) {
                  return false;
                }
                for (var i = 0; i < array1.length; i++) {
                  if (array1[i] !== array2[i]) {
                    return false;
                  }
                }
                return true;
              }
              function PDF172() {
              }
              PDF172.prototype = {
                checkOwnerPassword: function PDF17_checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
                  var hashData = new Uint8Array(password.length + 56);
                  hashData.set(password, 0);
                  hashData.set(ownerValidationSalt, password.length);
                  hashData.set(userBytes, password.length + ownerValidationSalt.length);
                  var result = calculateSHA256(hashData, 0, hashData.length);
                  return compareByteArrays(result, ownerPassword);
                },
                checkUserPassword: function PDF17_checkUserPassword(password, userValidationSalt, userPassword) {
                  var hashData = new Uint8Array(password.length + 8);
                  hashData.set(password, 0);
                  hashData.set(userValidationSalt, password.length);
                  var result = calculateSHA256(hashData, 0, hashData.length);
                  return compareByteArrays(result, userPassword);
                },
                getOwnerKey: function PDF17_getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
                  var hashData = new Uint8Array(password.length + 56);
                  hashData.set(password, 0);
                  hashData.set(ownerKeySalt, password.length);
                  hashData.set(userBytes, password.length + ownerKeySalt.length);
                  var key = calculateSHA256(hashData, 0, hashData.length);
                  var cipher = new AES256Cipher(key);
                  return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
                },
                getUserKey: function PDF17_getUserKey(password, userKeySalt, userEncryption) {
                  var hashData = new Uint8Array(password.length + 8);
                  hashData.set(password, 0);
                  hashData.set(userKeySalt, password.length);
                  var key = calculateSHA256(hashData, 0, hashData.length);
                  var cipher = new AES256Cipher(key);
                  return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
                }
              };
              return PDF172;
            }();
            var PDF20 = function PDF20Closure() {
              function concatArrays(array1, array2) {
                var t = new Uint8Array(array1.length + array2.length);
                t.set(array1, 0);
                t.set(array2, array1.length);
                return t;
              }
              function calculatePDF20Hash(password, input, userBytes) {
                var k = calculateSHA256(input, 0, input.length).subarray(0, 32);
                var e = [0];
                var i = 0;
                while (i < 64 || e[e.length - 1] > i - 32) {
                  var arrayLength = password.length + k.length + userBytes.length;
                  var k1 = new Uint8Array(arrayLength * 64);
                  var array = concatArrays(password, k);
                  array = concatArrays(array, userBytes);
                  for (var j = 0, pos = 0; j < 64; j++, pos += arrayLength) {
                    k1.set(array, pos);
                  }
                  var cipher = new AES128Cipher(k.subarray(0, 16));
                  e = cipher.encrypt(k1, k.subarray(16, 32));
                  var remainder = 0;
                  for (var z = 0; z < 16; z++) {
                    remainder *= 256 % 3;
                    remainder %= 3;
                    remainder += (e[z] >>> 0) % 3;
                    remainder %= 3;
                  }
                  if (remainder === 0) {
                    k = calculateSHA256(e, 0, e.length);
                  } else if (remainder === 1) {
                    k = calculateSHA384(e, 0, e.length);
                  } else if (remainder === 2) {
                    k = calculateSHA512(e, 0, e.length);
                  }
                  i++;
                }
                return k.subarray(0, 32);
              }
              function PDF202() {
              }
              function compareByteArrays(array1, array2) {
                if (array1.length !== array2.length) {
                  return false;
                }
                for (var i = 0; i < array1.length; i++) {
                  if (array1[i] !== array2[i]) {
                    return false;
                  }
                }
                return true;
              }
              PDF202.prototype = {
                hash: function PDF20_hash(password, concatBytes, userBytes) {
                  return calculatePDF20Hash(password, concatBytes, userBytes);
                },
                checkOwnerPassword: function PDF20_checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
                  var hashData = new Uint8Array(password.length + 56);
                  hashData.set(password, 0);
                  hashData.set(ownerValidationSalt, password.length);
                  hashData.set(userBytes, password.length + ownerValidationSalt.length);
                  var result = calculatePDF20Hash(password, hashData, userBytes);
                  return compareByteArrays(result, ownerPassword);
                },
                checkUserPassword: function PDF20_checkUserPassword(password, userValidationSalt, userPassword) {
                  var hashData = new Uint8Array(password.length + 8);
                  hashData.set(password, 0);
                  hashData.set(userValidationSalt, password.length);
                  var result = calculatePDF20Hash(password, hashData, []);
                  return compareByteArrays(result, userPassword);
                },
                getOwnerKey: function PDF20_getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
                  var hashData = new Uint8Array(password.length + 56);
                  hashData.set(password, 0);
                  hashData.set(ownerKeySalt, password.length);
                  hashData.set(userBytes, password.length + ownerKeySalt.length);
                  var key = calculatePDF20Hash(password, hashData, userBytes);
                  var cipher = new AES256Cipher(key);
                  return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
                },
                getUserKey: function PDF20_getUserKey(password, userKeySalt, userEncryption) {
                  var hashData = new Uint8Array(password.length + 8);
                  hashData.set(password, 0);
                  hashData.set(userKeySalt, password.length);
                  var key = calculatePDF20Hash(password, hashData, []);
                  var cipher = new AES256Cipher(key);
                  return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
                }
              };
              return PDF202;
            }();
            var CipherTransform = function CipherTransformClosure() {
              function CipherTransform2(stringCipherConstructor, streamCipherConstructor) {
                this.StringCipherConstructor = stringCipherConstructor;
                this.StreamCipherConstructor = streamCipherConstructor;
              }
              CipherTransform2.prototype = {
                createStream: function CipherTransform_createStream(stream2, length) {
                  var cipher = new this.StreamCipherConstructor();
                  return new _stream.DecryptStream(stream2, length, function cipherTransformDecryptStream(data, finalize) {
                    return cipher.decryptBlock(data, finalize);
                  });
                },
                decryptString: function CipherTransform_decryptString(s) {
                  var cipher = new this.StringCipherConstructor();
                  var data = (0, _util.stringToBytes)(s);
                  data = cipher.decryptBlock(data, true);
                  return (0, _util.bytesToString)(data);
                }
              };
              return CipherTransform2;
            }();
            var CipherTransformFactory = function CipherTransformFactoryClosure() {
              var defaultPasswordBytes = new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]);
              function createEncryptionKey20(revision, password, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms) {
                if (password) {
                  var passwordLength = Math.min(127, password.length);
                  password = password.subarray(0, passwordLength);
                } else {
                  password = [];
                }
                var pdfAlgorithm;
                if (revision === 6) {
                  pdfAlgorithm = new PDF20();
                } else {
                  pdfAlgorithm = new PDF17();
                }
                if (pdfAlgorithm.checkUserPassword(password, userValidationSalt, userPassword)) {
                  return pdfAlgorithm.getUserKey(password, userKeySalt, userEncryption);
                } else if (password.length && pdfAlgorithm.checkOwnerPassword(password, ownerValidationSalt, uBytes, ownerPassword)) {
                  return pdfAlgorithm.getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption);
                }
                return null;
              }
              function prepareKeyData(fileId, password, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata) {
                var hashDataSize = 40 + ownerPassword.length + fileId.length;
                var hashData = new Uint8Array(hashDataSize), i = 0, j, n;
                if (password) {
                  n = Math.min(32, password.length);
                  for (; i < n; ++i) {
                    hashData[i] = password[i];
                  }
                }
                j = 0;
                while (i < 32) {
                  hashData[i++] = defaultPasswordBytes[j++];
                }
                for (j = 0, n = ownerPassword.length; j < n; ++j) {
                  hashData[i++] = ownerPassword[j];
                }
                hashData[i++] = flags & 255;
                hashData[i++] = flags >> 8 & 255;
                hashData[i++] = flags >> 16 & 255;
                hashData[i++] = flags >>> 24 & 255;
                for (j = 0, n = fileId.length; j < n; ++j) {
                  hashData[i++] = fileId[j];
                }
                if (revision >= 4 && !encryptMetadata) {
                  hashData[i++] = 255;
                  hashData[i++] = 255;
                  hashData[i++] = 255;
                  hashData[i++] = 255;
                }
                var hash = calculateMD5(hashData, 0, i);
                var keyLengthInBytes = keyLength >> 3;
                if (revision >= 3) {
                  for (j = 0; j < 50; ++j) {
                    hash = calculateMD5(hash, 0, keyLengthInBytes);
                  }
                }
                var encryptionKey = hash.subarray(0, keyLengthInBytes);
                var cipher, checkData;
                if (revision >= 3) {
                  for (i = 0; i < 32; ++i) {
                    hashData[i] = defaultPasswordBytes[i];
                  }
                  for (j = 0, n = fileId.length; j < n; ++j) {
                    hashData[i++] = fileId[j];
                  }
                  cipher = new ARCFourCipher(encryptionKey);
                  checkData = cipher.encryptBlock(calculateMD5(hashData, 0, i));
                  n = encryptionKey.length;
                  var derivedKey = new Uint8Array(n), k;
                  for (j = 1; j <= 19; ++j) {
                    for (k = 0; k < n; ++k) {
                      derivedKey[k] = encryptionKey[k] ^ j;
                    }
                    cipher = new ARCFourCipher(derivedKey);
                    checkData = cipher.encryptBlock(checkData);
                  }
                  for (j = 0, n = checkData.length; j < n; ++j) {
                    if (userPassword[j] !== checkData[j]) {
                      return null;
                    }
                  }
                } else {
                  cipher = new ARCFourCipher(encryptionKey);
                  checkData = cipher.encryptBlock(defaultPasswordBytes);
                  for (j = 0, n = checkData.length; j < n; ++j) {
                    if (userPassword[j] !== checkData[j]) {
                      return null;
                    }
                  }
                }
                return encryptionKey;
              }
              function decodeUserPassword(password, ownerPassword, revision, keyLength) {
                var hashData = new Uint8Array(32), i = 0, j, n;
                n = Math.min(32, password.length);
                for (; i < n; ++i) {
                  hashData[i] = password[i];
                }
                j = 0;
                while (i < 32) {
                  hashData[i++] = defaultPasswordBytes[j++];
                }
                var hash = calculateMD5(hashData, 0, i);
                var keyLengthInBytes = keyLength >> 3;
                if (revision >= 3) {
                  for (j = 0; j < 50; ++j) {
                    hash = calculateMD5(hash, 0, hash.length);
                  }
                }
                var cipher, userPassword;
                if (revision >= 3) {
                  userPassword = ownerPassword;
                  var derivedKey = new Uint8Array(keyLengthInBytes), k;
                  for (j = 19; j >= 0; j--) {
                    for (k = 0; k < keyLengthInBytes; ++k) {
                      derivedKey[k] = hash[k] ^ j;
                    }
                    cipher = new ARCFourCipher(derivedKey);
                    userPassword = cipher.encryptBlock(userPassword);
                  }
                } else {
                  cipher = new ARCFourCipher(hash.subarray(0, keyLengthInBytes));
                  userPassword = cipher.encryptBlock(ownerPassword);
                }
                return userPassword;
              }
              var identityName = _primitives.Name.get("Identity");
              function CipherTransformFactory2(dict, fileId, password) {
                var filter = dict.get("Filter");
                if (!(0, _primitives.isName)(filter, "Standard")) {
                  throw new _util.FormatError("unknown encryption method");
                }
                this.dict = dict;
                var algorithm = dict.get("V");
                if (!Number.isInteger(algorithm) || algorithm !== 1 && algorithm !== 2 && algorithm !== 4 && algorithm !== 5) {
                  throw new _util.FormatError("unsupported encryption algorithm");
                }
                this.algorithm = algorithm;
                var keyLength = dict.get("Length");
                if (!keyLength) {
                  if (algorithm <= 3) {
                    keyLength = 40;
                  } else {
                    var cfDict = dict.get("CF");
                    var streamCryptoName = dict.get("StmF");
                    if ((0, _primitives.isDict)(cfDict) && (0, _primitives.isName)(streamCryptoName)) {
                      cfDict.suppressEncryption = true;
                      var handlerDict = cfDict.get(streamCryptoName.name);
                      keyLength = handlerDict && handlerDict.get("Length") || 128;
                      if (keyLength < 40) {
                        keyLength <<= 3;
                      }
                    }
                  }
                }
                if (!Number.isInteger(keyLength) || keyLength < 40 || keyLength % 8 !== 0) {
                  throw new _util.FormatError("invalid key length");
                }
                var ownerPassword = (0, _util.stringToBytes)(dict.get("O")).subarray(0, 32);
                var userPassword = (0, _util.stringToBytes)(dict.get("U")).subarray(0, 32);
                var flags = dict.get("P");
                var revision = dict.get("R");
                var encryptMetadata = (algorithm === 4 || algorithm === 5) && dict.get("EncryptMetadata") !== false;
                this.encryptMetadata = encryptMetadata;
                var fileIdBytes = (0, _util.stringToBytes)(fileId);
                var passwordBytes;
                if (password) {
                  if (revision === 6) {
                    try {
                      password = (0, _util.utf8StringToString)(password);
                    } catch (ex) {
                      (0, _util.warn)("CipherTransformFactory: Unable to convert UTF8 encoded password.");
                    }
                  }
                  passwordBytes = (0, _util.stringToBytes)(password);
                }
                var encryptionKey;
                if (algorithm !== 5) {
                  encryptionKey = prepareKeyData(fileIdBytes, passwordBytes, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
                } else {
                  var ownerValidationSalt = (0, _util.stringToBytes)(dict.get("O")).subarray(32, 40);
                  var ownerKeySalt = (0, _util.stringToBytes)(dict.get("O")).subarray(40, 48);
                  var uBytes = (0, _util.stringToBytes)(dict.get("U")).subarray(0, 48);
                  var userValidationSalt = (0, _util.stringToBytes)(dict.get("U")).subarray(32, 40);
                  var userKeySalt = (0, _util.stringToBytes)(dict.get("U")).subarray(40, 48);
                  var ownerEncryption = (0, _util.stringToBytes)(dict.get("OE"));
                  var userEncryption = (0, _util.stringToBytes)(dict.get("UE"));
                  var perms = (0, _util.stringToBytes)(dict.get("Perms"));
                  encryptionKey = createEncryptionKey20(revision, passwordBytes, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms);
                }
                if (!encryptionKey && !password) {
                  throw new _util.PasswordException("No password given", _util.PasswordResponses.NEED_PASSWORD);
                } else if (!encryptionKey && password) {
                  var decodedPassword = decodeUserPassword(passwordBytes, ownerPassword, revision, keyLength);
                  encryptionKey = prepareKeyData(fileIdBytes, decodedPassword, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
                }
                if (!encryptionKey) {
                  throw new _util.PasswordException("Incorrect Password", _util.PasswordResponses.INCORRECT_PASSWORD);
                }
                this.encryptionKey = encryptionKey;
                if (algorithm >= 4) {
                  var cf = dict.get("CF");
                  if ((0, _primitives.isDict)(cf)) {
                    cf.suppressEncryption = true;
                  }
                  this.cf = cf;
                  this.stmf = dict.get("StmF") || identityName;
                  this.strf = dict.get("StrF") || identityName;
                  this.eff = dict.get("EFF") || this.stmf;
                }
              }
              function buildObjectKey(num, gen, encryptionKey, isAes) {
                var key = new Uint8Array(encryptionKey.length + 9), i, n;
                for (i = 0, n = encryptionKey.length; i < n; ++i) {
                  key[i] = encryptionKey[i];
                }
                key[i++] = num & 255;
                key[i++] = num >> 8 & 255;
                key[i++] = num >> 16 & 255;
                key[i++] = gen & 255;
                key[i++] = gen >> 8 & 255;
                if (isAes) {
                  key[i++] = 115;
                  key[i++] = 65;
                  key[i++] = 108;
                  key[i++] = 84;
                }
                var hash = calculateMD5(key, 0, i);
                return hash.subarray(0, Math.min(encryptionKey.length + 5, 16));
              }
              function buildCipherConstructor(cf, name, num, gen, key) {
                if (!(0, _primitives.isName)(name)) {
                  throw new _util.FormatError("Invalid crypt filter name.");
                }
                var cryptFilter = cf.get(name.name);
                var cfm;
                if (cryptFilter !== null && cryptFilter !== void 0) {
                  cfm = cryptFilter.get("CFM");
                }
                if (!cfm || cfm.name === "None") {
                  return function cipherTransformFactoryBuildCipherConstructorNone() {
                    return new NullCipher();
                  };
                }
                if (cfm.name === "V2") {
                  return function cipherTransformFactoryBuildCipherConstructorV2() {
                    return new ARCFourCipher(buildObjectKey(num, gen, key, false));
                  };
                }
                if (cfm.name === "AESV2") {
                  return function cipherTransformFactoryBuildCipherConstructorAESV2() {
                    return new AES128Cipher(buildObjectKey(num, gen, key, true));
                  };
                }
                if (cfm.name === "AESV3") {
                  return function cipherTransformFactoryBuildCipherConstructorAESV3() {
                    return new AES256Cipher(key);
                  };
                }
                throw new _util.FormatError("Unknown crypto method");
              }
              CipherTransformFactory2.prototype = {
                createCipherTransform: function CipherTransformFactory_createCipherTransform(num, gen) {
                  if (this.algorithm === 4 || this.algorithm === 5) {
                    return new CipherTransform(buildCipherConstructor(this.cf, this.stmf, num, gen, this.encryptionKey), buildCipherConstructor(this.cf, this.strf, num, gen, this.encryptionKey));
                  }
                  var key = buildObjectKey(num, gen, this.encryptionKey, false);
                  var cipherConstructor = function buildCipherCipherConstructor() {
                    return new ARCFourCipher(key);
                  };
                  return new CipherTransform(cipherConstructor, cipherConstructor);
                }
              };
              return CipherTransformFactory2;
            }();
            exports3.AES128Cipher = AES128Cipher;
            exports3.AES256Cipher = AES256Cipher;
            exports3.ARCFourCipher = ARCFourCipher;
            exports3.CipherTransformFactory = CipherTransformFactory;
            exports3.PDF17 = PDF17;
            exports3.PDF20 = PDF20;
            exports3.calculateMD5 = calculateMD5;
            exports3.calculateSHA256 = calculateSHA256;
            exports3.calculateSHA384 = calculateSHA384;
            exports3.calculateSHA512 = calculateSHA512;
          },
          /* 132 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.ColorSpace = void 0;
            var _util = __w_pdfjs_require__(2);
            var _primitives = __w_pdfjs_require__(119);
            var ColorSpace = function ColorSpaceClosure() {
              function resizeRgbImage(src, bpc, w1, h1, w2, h2, alpha01, dest) {
                var COMPONENTS = 3;
                alpha01 = alpha01 !== 1 ? 0 : alpha01;
                var xRatio = w1 / w2;
                var yRatio = h1 / h2;
                var i, j, py, newIndex = 0, oldIndex;
                var xScaled = new Uint16Array(w2);
                var w1Scanline = w1 * COMPONENTS;
                for (i = 0; i < w2; i++) {
                  xScaled[i] = Math.floor(i * xRatio) * COMPONENTS;
                }
                for (i = 0; i < h2; i++) {
                  py = Math.floor(i * yRatio) * w1Scanline;
                  for (j = 0; j < w2; j++) {
                    oldIndex = py + xScaled[j];
                    dest[newIndex++] = src[oldIndex++];
                    dest[newIndex++] = src[oldIndex++];
                    dest[newIndex++] = src[oldIndex++];
                    newIndex += alpha01;
                  }
                }
              }
              function ColorSpace2() {
                (0, _util.unreachable)("should not call ColorSpace constructor");
              }
              ColorSpace2.prototype = {
                getRgb: function ColorSpace_getRgb(src, srcOffset) {
                  var rgb = new Uint8Array(3);
                  this.getRgbItem(src, srcOffset, rgb, 0);
                  return rgb;
                },
                getRgbItem: function ColorSpace_getRgbItem(src, srcOffset, dest, destOffset) {
                  (0, _util.unreachable)("Should not call ColorSpace.getRgbItem");
                },
                getRgbBuffer: function ColorSpace_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  (0, _util.unreachable)("Should not call ColorSpace.getRgbBuffer");
                },
                getOutputLength: function ColorSpace_getOutputLength(inputLength, alpha01) {
                  (0, _util.unreachable)("Should not call ColorSpace.getOutputLength");
                },
                isPassthrough: function ColorSpace_isPassthrough(bits) {
                  return false;
                },
                fillRgb: function ColorSpace_fillRgb(dest, originalWidth, originalHeight, width, height, actualHeight, bpc, comps, alpha01) {
                  var count = originalWidth * originalHeight;
                  var rgbBuf = null;
                  var numComponentColors = 1 << bpc;
                  var needsResizing = originalHeight !== height || originalWidth !== width;
                  var i, ii;
                  if (this.isPassthrough(bpc)) {
                    rgbBuf = comps;
                  } else if (this.numComps === 1 && count > numComponentColors && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
                    var allColors = bpc <= 8 ? new Uint8Array(numComponentColors) : new Uint16Array(numComponentColors);
                    var key;
                    for (i = 0; i < numComponentColors; i++) {
                      allColors[i] = i;
                    }
                    var colorMap = new Uint8Array(numComponentColors * 3);
                    this.getRgbBuffer(allColors, 0, numComponentColors, colorMap, 0, bpc, 0);
                    var destPos, rgbPos;
                    if (!needsResizing) {
                      destPos = 0;
                      for (i = 0; i < count; ++i) {
                        key = comps[i] * 3;
                        dest[destPos++] = colorMap[key];
                        dest[destPos++] = colorMap[key + 1];
                        dest[destPos++] = colorMap[key + 2];
                        destPos += alpha01;
                      }
                    } else {
                      rgbBuf = new Uint8Array(count * 3);
                      rgbPos = 0;
                      for (i = 0; i < count; ++i) {
                        key = comps[i] * 3;
                        rgbBuf[rgbPos++] = colorMap[key];
                        rgbBuf[rgbPos++] = colorMap[key + 1];
                        rgbBuf[rgbPos++] = colorMap[key + 2];
                      }
                    }
                  } else {
                    if (!needsResizing) {
                      this.getRgbBuffer(comps, 0, width * actualHeight, dest, 0, bpc, alpha01);
                    } else {
                      rgbBuf = new Uint8Array(count * 3);
                      this.getRgbBuffer(comps, 0, count, rgbBuf, 0, bpc, 0);
                    }
                  }
                  if (rgbBuf) {
                    if (needsResizing) {
                      resizeRgbImage(rgbBuf, bpc, originalWidth, originalHeight, width, height, alpha01, dest);
                    } else {
                      rgbPos = 0;
                      destPos = 0;
                      for (i = 0, ii = width * actualHeight; i < ii; i++) {
                        dest[destPos++] = rgbBuf[rgbPos++];
                        dest[destPos++] = rgbBuf[rgbPos++];
                        dest[destPos++] = rgbBuf[rgbPos++];
                        destPos += alpha01;
                      }
                    }
                  }
                },
                usesZeroToOneRange: true
              };
              ColorSpace2.parse = function(cs, xref, res, pdfFunctionFactory) {
                var IR = ColorSpace2.parseToIR(cs, xref, res, pdfFunctionFactory);
                return ColorSpace2.fromIR(IR);
              };
              ColorSpace2.fromIR = function(IR) {
                var name = Array.isArray(IR) ? IR[0] : IR;
                var whitePoint, blackPoint, gamma;
                switch (name) {
                  case "DeviceGrayCS":
                    return this.singletons.gray;
                  case "DeviceRgbCS":
                    return this.singletons.rgb;
                  case "DeviceCmykCS":
                    return this.singletons.cmyk;
                  case "CalGrayCS":
                    whitePoint = IR[1];
                    blackPoint = IR[2];
                    gamma = IR[3];
                    return new CalGrayCS(whitePoint, blackPoint, gamma);
                  case "CalRGBCS":
                    whitePoint = IR[1];
                    blackPoint = IR[2];
                    gamma = IR[3];
                    var matrix = IR[4];
                    return new CalRGBCS(whitePoint, blackPoint, gamma, matrix);
                  case "PatternCS":
                    var basePatternCS = IR[1];
                    if (basePatternCS) {
                      basePatternCS = ColorSpace2.fromIR(basePatternCS);
                    }
                    return new PatternCS(basePatternCS);
                  case "IndexedCS":
                    var baseIndexedCS = IR[1];
                    var hiVal = IR[2];
                    var lookup = IR[3];
                    return new IndexedCS(ColorSpace2.fromIR(baseIndexedCS), hiVal, lookup);
                  case "AlternateCS":
                    var numComps = IR[1];
                    var alt = IR[2];
                    var tintFn = IR[3];
                    return new AlternateCS(numComps, ColorSpace2.fromIR(alt), tintFn);
                  case "LabCS":
                    whitePoint = IR[1];
                    blackPoint = IR[2];
                    var range = IR[3];
                    return new LabCS(whitePoint, blackPoint, range);
                  default:
                    throw new _util.FormatError("Unknown colorspace name: " + name);
                }
              };
              ColorSpace2.parseToIR = function(cs, xref) {
                var res = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                var pdfFunctionFactory = arguments[3];
                cs = xref.fetchIfRef(cs);
                if ((0, _primitives.isName)(cs)) {
                  switch (cs.name) {
                    case "DeviceGray":
                    case "G":
                      return "DeviceGrayCS";
                    case "DeviceRGB":
                    case "RGB":
                      return "DeviceRgbCS";
                    case "DeviceCMYK":
                    case "CMYK":
                      return "DeviceCmykCS";
                    case "Pattern":
                      return ["PatternCS", null];
                    default:
                      if ((0, _primitives.isDict)(res)) {
                        var colorSpaces = res.get("ColorSpace");
                        if ((0, _primitives.isDict)(colorSpaces)) {
                          var resCS = colorSpaces.get(cs.name);
                          if (resCS) {
                            if ((0, _primitives.isName)(resCS)) {
                              return ColorSpace2.parseToIR(resCS, xref, res, pdfFunctionFactory);
                            }
                            cs = resCS;
                            break;
                          }
                        }
                      }
                      throw new _util.FormatError("unrecognized colorspace " + cs.name);
                  }
                }
                if (Array.isArray(cs)) {
                  var mode = xref.fetchIfRef(cs[0]).name;
                  var numComps, params, alt, whitePoint, blackPoint, gamma;
                  switch (mode) {
                    case "DeviceGray":
                    case "G":
                      return "DeviceGrayCS";
                    case "DeviceRGB":
                    case "RGB":
                      return "DeviceRgbCS";
                    case "DeviceCMYK":
                    case "CMYK":
                      return "DeviceCmykCS";
                    case "CalGray":
                      params = xref.fetchIfRef(cs[1]);
                      whitePoint = params.getArray("WhitePoint");
                      blackPoint = params.getArray("BlackPoint");
                      gamma = params.get("Gamma");
                      return ["CalGrayCS", whitePoint, blackPoint, gamma];
                    case "CalRGB":
                      params = xref.fetchIfRef(cs[1]);
                      whitePoint = params.getArray("WhitePoint");
                      blackPoint = params.getArray("BlackPoint");
                      gamma = params.getArray("Gamma");
                      var matrix = params.getArray("Matrix");
                      return ["CalRGBCS", whitePoint, blackPoint, gamma, matrix];
                    case "ICCBased":
                      var stream2 = xref.fetchIfRef(cs[1]);
                      var dict = stream2.dict;
                      numComps = dict.get("N");
                      alt = dict.get("Alternate");
                      if (alt) {
                        var altIR = ColorSpace2.parseToIR(alt, xref, res, pdfFunctionFactory);
                        var altCS = ColorSpace2.fromIR(altIR, pdfFunctionFactory);
                        if (altCS.numComps === numComps) {
                          return altIR;
                        }
                        (0, _util.warn)("ICCBased color space: Ignoring incorrect /Alternate entry.");
                      }
                      if (numComps === 1) {
                        return "DeviceGrayCS";
                      } else if (numComps === 3) {
                        return "DeviceRgbCS";
                      } else if (numComps === 4) {
                        return "DeviceCmykCS";
                      }
                      break;
                    case "Pattern":
                      var basePatternCS = cs[1] || null;
                      if (basePatternCS) {
                        basePatternCS = ColorSpace2.parseToIR(basePatternCS, xref, res, pdfFunctionFactory);
                      }
                      return ["PatternCS", basePatternCS];
                    case "Indexed":
                    case "I":
                      var baseIndexedCS = ColorSpace2.parseToIR(cs[1], xref, res, pdfFunctionFactory);
                      var hiVal = xref.fetchIfRef(cs[2]) + 1;
                      var lookup = xref.fetchIfRef(cs[3]);
                      if ((0, _primitives.isStream)(lookup)) {
                        lookup = lookup.getBytes();
                      }
                      return ["IndexedCS", baseIndexedCS, hiVal, lookup];
                    case "Separation":
                    case "DeviceN":
                      var name = xref.fetchIfRef(cs[1]);
                      numComps = Array.isArray(name) ? name.length : 1;
                      alt = ColorSpace2.parseToIR(cs[2], xref, res, pdfFunctionFactory);
                      var tintFn = pdfFunctionFactory.create(xref.fetchIfRef(cs[3]));
                      return ["AlternateCS", numComps, alt, tintFn];
                    case "Lab":
                      params = xref.fetchIfRef(cs[1]);
                      whitePoint = params.getArray("WhitePoint");
                      blackPoint = params.getArray("BlackPoint");
                      var range = params.getArray("Range");
                      return ["LabCS", whitePoint, blackPoint, range];
                    default:
                      throw new _util.FormatError('unimplemented color space object "' + mode + '"');
                  }
                }
                throw new _util.FormatError('unrecognized color space object: "' + cs + '"');
              };
              ColorSpace2.isDefaultDecode = function ColorSpace_isDefaultDecode(decode, n) {
                if (!Array.isArray(decode)) {
                  return true;
                }
                if (n * 2 !== decode.length) {
                  (0, _util.warn)("The decode map is not the correct length");
                  return true;
                }
                for (var i = 0, ii = decode.length; i < ii; i += 2) {
                  if (decode[i] !== 0 || decode[i + 1] !== 1) {
                    return false;
                  }
                }
                return true;
              };
              ColorSpace2.singletons = {
                get gray() {
                  return (0, _util.shadow)(this, "gray", new DeviceGrayCS());
                },
                get rgb() {
                  return (0, _util.shadow)(this, "rgb", new DeviceRgbCS());
                },
                get cmyk() {
                  return (0, _util.shadow)(this, "cmyk", new DeviceCmykCS());
                }
              };
              return ColorSpace2;
            }();
            var AlternateCS = function AlternateCSClosure() {
              function AlternateCS2(numComps, base, tintFn) {
                this.name = "Alternate";
                this.numComps = numComps;
                this.defaultColor = new Float32Array(numComps);
                for (var i = 0; i < numComps; ++i) {
                  this.defaultColor[i] = 1;
                }
                this.base = base;
                this.tintFn = tintFn;
                this.tmpBuf = new Float32Array(base.numComps);
              }
              AlternateCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function AlternateCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  var tmpBuf = this.tmpBuf;
                  this.tintFn(src, srcOffset, tmpBuf, 0);
                  this.base.getRgbItem(tmpBuf, 0, dest, destOffset);
                },
                getRgbBuffer: function AlternateCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var tintFn = this.tintFn;
                  var base = this.base;
                  var scale = 1 / ((1 << bits) - 1);
                  var baseNumComps = base.numComps;
                  var usesZeroToOneRange = base.usesZeroToOneRange;
                  var isPassthrough = (base.isPassthrough(8) || !usesZeroToOneRange) && alpha01 === 0;
                  var pos = isPassthrough ? destOffset : 0;
                  var baseBuf = isPassthrough ? dest : new Uint8Array(baseNumComps * count);
                  var numComps = this.numComps;
                  var scaled = new Float32Array(numComps);
                  var tinted = new Float32Array(baseNumComps);
                  var i, j;
                  for (i = 0; i < count; i++) {
                    for (j = 0; j < numComps; j++) {
                      scaled[j] = src[srcOffset++] * scale;
                    }
                    tintFn(scaled, 0, tinted, 0);
                    if (usesZeroToOneRange) {
                      for (j = 0; j < baseNumComps; j++) {
                        baseBuf[pos++] = tinted[j] * 255;
                      }
                    } else {
                      base.getRgbItem(tinted, 0, baseBuf, pos);
                      pos += baseNumComps;
                    }
                  }
                  if (!isPassthrough) {
                    base.getRgbBuffer(baseBuf, 0, count, dest, destOffset, 8, alpha01);
                  }
                },
                getOutputLength: function AlternateCS_getOutputLength(inputLength, alpha01) {
                  return this.base.getOutputLength(inputLength * this.base.numComps / this.numComps, alpha01);
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function AlternateCS_isDefaultDecode(decodeMap) {
                  return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                },
                usesZeroToOneRange: true
              };
              return AlternateCS2;
            }();
            var PatternCS = function PatternCSClosure() {
              function PatternCS2(baseCS) {
                this.name = "Pattern";
                this.base = baseCS;
              }
              PatternCS2.prototype = {};
              return PatternCS2;
            }();
            var IndexedCS = function IndexedCSClosure() {
              function IndexedCS2(base, highVal, lookup) {
                this.name = "Indexed";
                this.numComps = 1;
                this.defaultColor = new Uint8Array(this.numComps);
                this.base = base;
                this.highVal = highVal;
                var baseNumComps = base.numComps;
                var length = baseNumComps * highVal;
                if ((0, _primitives.isStream)(lookup)) {
                  this.lookup = new Uint8Array(length);
                  var bytes = lookup.getBytes(length);
                  this.lookup.set(bytes);
                } else if ((0, _util.isString)(lookup)) {
                  this.lookup = new Uint8Array(length);
                  for (var i = 0; i < length; ++i) {
                    this.lookup[i] = lookup.charCodeAt(i);
                  }
                } else if (lookup instanceof Uint8Array) {
                  this.lookup = lookup;
                } else {
                  throw new _util.FormatError("Unrecognized lookup table: " + lookup);
                }
              }
              IndexedCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function IndexedCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  var numComps = this.base.numComps;
                  var start = src[srcOffset] * numComps;
                  this.base.getRgbBuffer(this.lookup, start, 1, dest, destOffset, 8, 0);
                },
                getRgbBuffer: function IndexedCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var base = this.base;
                  var numComps = base.numComps;
                  var outputDelta = base.getOutputLength(numComps, alpha01);
                  var lookup = this.lookup;
                  for (var i = 0; i < count; ++i) {
                    var lookupPos = src[srcOffset++] * numComps;
                    base.getRgbBuffer(lookup, lookupPos, 1, dest, destOffset, 8, alpha01);
                    destOffset += outputDelta;
                  }
                },
                getOutputLength: function IndexedCS_getOutputLength(inputLength, alpha01) {
                  return this.base.getOutputLength(inputLength * this.base.numComps, alpha01);
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function IndexedCS_isDefaultDecode(decodeMap) {
                  return true;
                },
                usesZeroToOneRange: true
              };
              return IndexedCS2;
            }();
            var DeviceGrayCS = function DeviceGrayCSClosure() {
              function DeviceGrayCS2() {
                this.name = "DeviceGray";
                this.numComps = 1;
                this.defaultColor = new Float32Array(this.numComps);
              }
              DeviceGrayCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function DeviceGrayCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  var c = src[srcOffset] * 255 | 0;
                  c = c < 0 ? 0 : c > 255 ? 255 : c;
                  dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = c;
                },
                getRgbBuffer: function DeviceGrayCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var scale = 255 / ((1 << bits) - 1);
                  var j = srcOffset, q = destOffset;
                  for (var i = 0; i < count; ++i) {
                    var c = scale * src[j++] | 0;
                    dest[q++] = c;
                    dest[q++] = c;
                    dest[q++] = c;
                    q += alpha01;
                  }
                },
                getOutputLength: function DeviceGrayCS_getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01);
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function DeviceGrayCS_isDefaultDecode(decodeMap) {
                  return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                },
                usesZeroToOneRange: true
              };
              return DeviceGrayCS2;
            }();
            var DeviceRgbCS = function DeviceRgbCSClosure() {
              function DeviceRgbCS2() {
                this.name = "DeviceRGB";
                this.numComps = 3;
                this.defaultColor = new Float32Array(this.numComps);
              }
              DeviceRgbCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function DeviceRgbCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  var r = src[srcOffset] * 255 | 0;
                  var g = src[srcOffset + 1] * 255 | 0;
                  var b = src[srcOffset + 2] * 255 | 0;
                  dest[destOffset] = r < 0 ? 0 : r > 255 ? 255 : r;
                  dest[destOffset + 1] = g < 0 ? 0 : g > 255 ? 255 : g;
                  dest[destOffset + 2] = b < 0 ? 0 : b > 255 ? 255 : b;
                },
                getRgbBuffer: function DeviceRgbCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  if (bits === 8 && alpha01 === 0) {
                    dest.set(src.subarray(srcOffset, srcOffset + count * 3), destOffset);
                    return;
                  }
                  var scale = 255 / ((1 << bits) - 1);
                  var j = srcOffset, q = destOffset;
                  for (var i = 0; i < count; ++i) {
                    dest[q++] = scale * src[j++] | 0;
                    dest[q++] = scale * src[j++] | 0;
                    dest[q++] = scale * src[j++] | 0;
                    q += alpha01;
                  }
                },
                getOutputLength: function DeviceRgbCS_getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01) / 3 | 0;
                },
                isPassthrough: function DeviceRgbCS_isPassthrough(bits) {
                  return bits === 8;
                },
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function DeviceRgbCS_isDefaultDecode(decodeMap) {
                  return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                },
                usesZeroToOneRange: true
              };
              return DeviceRgbCS2;
            }();
            var DeviceCmykCS = function DeviceCmykCSClosure() {
              function convertToRgb(src, srcOffset, srcScale, dest, destOffset) {
                var c = src[srcOffset + 0] * srcScale;
                var m = src[srcOffset + 1] * srcScale;
                var y = src[srcOffset + 2] * srcScale;
                var k = src[srcOffset + 3] * srcScale;
                var r = c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k + -285.2331026137004) + m * (1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 17.5119270841813) + k * (-21.86122147463605 * k - 189.48180835922747) + 255 | 0;
                var g = c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k + -79.2970844816548) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 190.9453302588951) + y * (4.444339102852739 * y + 9.8632861493405 * k - 24.86741582555878) + k * (-20.737325471181034 * k - 187.80453709719578) + 255 | 0;
                var b = c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k + -14.183576799673286) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 112.23884253719248) + y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505) + k * (-22.33816807309886 * k - 180.12613974708367) + 255 | 0;
                dest[destOffset] = r > 255 ? 255 : r < 0 ? 0 : r;
                dest[destOffset + 1] = g > 255 ? 255 : g < 0 ? 0 : g;
                dest[destOffset + 2] = b > 255 ? 255 : b < 0 ? 0 : b;
              }
              function DeviceCmykCS2() {
                this.name = "DeviceCMYK";
                this.numComps = 4;
                this.defaultColor = new Float32Array(this.numComps);
                this.defaultColor[3] = 1;
              }
              DeviceCmykCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function DeviceCmykCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  convertToRgb(src, srcOffset, 1, dest, destOffset);
                },
                getRgbBuffer: function DeviceCmykCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var scale = 1 / ((1 << bits) - 1);
                  for (var i = 0; i < count; i++) {
                    convertToRgb(src, srcOffset, scale, dest, destOffset);
                    srcOffset += 4;
                    destOffset += 3 + alpha01;
                  }
                },
                getOutputLength: function DeviceCmykCS_getOutputLength(inputLength, alpha01) {
                  return inputLength / 4 * (3 + alpha01) | 0;
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function DeviceCmykCS_isDefaultDecode(decodeMap) {
                  return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                },
                usesZeroToOneRange: true
              };
              return DeviceCmykCS2;
            }();
            var CalGrayCS = function CalGrayCSClosure() {
              function CalGrayCS2(whitePoint, blackPoint, gamma) {
                this.name = "CalGray";
                this.numComps = 1;
                this.defaultColor = new Float32Array(this.numComps);
                if (!whitePoint) {
                  throw new _util.FormatError("WhitePoint missing - required for color space CalGray");
                }
                blackPoint = blackPoint || [0, 0, 0];
                gamma = gamma || 1;
                this.XW = whitePoint[0];
                this.YW = whitePoint[1];
                this.ZW = whitePoint[2];
                this.XB = blackPoint[0];
                this.YB = blackPoint[1];
                this.ZB = blackPoint[2];
                this.G = gamma;
                if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
                  throw new _util.FormatError("Invalid WhitePoint components for " + this.name + ", no fallback available");
                }
                if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
                  (0, _util.info)("Invalid BlackPoint for " + this.name + ", falling back to default");
                  this.XB = this.YB = this.ZB = 0;
                }
                if (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) {
                  (0, _util.warn)(this.name + ", BlackPoint: XB: " + this.XB + ", YB: " + this.YB + ", ZB: " + this.ZB + ", only default values are supported.");
                }
                if (this.G < 1) {
                  (0, _util.info)("Invalid Gamma: " + this.G + " for " + this.name + ", falling back to default");
                  this.G = 1;
                }
              }
              function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
                var A = src[srcOffset] * scale;
                var AG = Math.pow(A, cs.G);
                var L = cs.YW * AG;
                var val = Math.max(295.8 * Math.pow(L, 0.3333333333333333) - 40.8, 0) | 0;
                dest[destOffset] = val;
                dest[destOffset + 1] = val;
                dest[destOffset + 2] = val;
              }
              CalGrayCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function CalGrayCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  convertToRgb(this, src, srcOffset, dest, destOffset, 1);
                },
                getRgbBuffer: function CalGrayCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var scale = 1 / ((1 << bits) - 1);
                  for (var i = 0; i < count; ++i) {
                    convertToRgb(this, src, srcOffset, dest, destOffset, scale);
                    srcOffset += 1;
                    destOffset += 3 + alpha01;
                  }
                },
                getOutputLength: function CalGrayCS_getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01);
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function CalGrayCS_isDefaultDecode(decodeMap) {
                  return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                },
                usesZeroToOneRange: true
              };
              return CalGrayCS2;
            }();
            var CalRGBCS = function CalRGBCSClosure() {
              var BRADFORD_SCALE_MATRIX = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]);
              var BRADFORD_SCALE_INVERSE_MATRIX = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]);
              var SRGB_D65_XYZ_TO_RGB_MATRIX = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]);
              var FLAT_WHITEPOINT_MATRIX = new Float32Array([1, 1, 1]);
              var tempNormalizeMatrix = new Float32Array(3);
              var tempConvertMatrix1 = new Float32Array(3);
              var tempConvertMatrix2 = new Float32Array(3);
              var DECODE_L_CONSTANT = Math.pow((8 + 16) / 116, 3) / 8;
              function CalRGBCS2(whitePoint, blackPoint, gamma, matrix) {
                this.name = "CalRGB";
                this.numComps = 3;
                this.defaultColor = new Float32Array(this.numComps);
                if (!whitePoint) {
                  throw new _util.FormatError("WhitePoint missing - required for color space CalRGB");
                }
                blackPoint = blackPoint || new Float32Array(3);
                gamma = gamma || new Float32Array([1, 1, 1]);
                matrix = matrix || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                var XW = whitePoint[0];
                var YW = whitePoint[1];
                var ZW = whitePoint[2];
                this.whitePoint = whitePoint;
                var XB = blackPoint[0];
                var YB = blackPoint[1];
                var ZB = blackPoint[2];
                this.blackPoint = blackPoint;
                this.GR = gamma[0];
                this.GG = gamma[1];
                this.GB = gamma[2];
                this.MXA = matrix[0];
                this.MYA = matrix[1];
                this.MZA = matrix[2];
                this.MXB = matrix[3];
                this.MYB = matrix[4];
                this.MZB = matrix[5];
                this.MXC = matrix[6];
                this.MYC = matrix[7];
                this.MZC = matrix[8];
                if (XW < 0 || ZW < 0 || YW !== 1) {
                  throw new _util.FormatError("Invalid WhitePoint components for " + this.name + ", no fallback available");
                }
                if (XB < 0 || YB < 0 || ZB < 0) {
                  (0, _util.info)("Invalid BlackPoint for " + this.name + " [" + XB + ", " + YB + ", " + ZB + "], falling back to default");
                  this.blackPoint = new Float32Array(3);
                }
                if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
                  (0, _util.info)("Invalid Gamma [" + this.GR + ", " + this.GG + ", " + this.GB + "] for " + this.name + ", falling back to default");
                  this.GR = this.GG = this.GB = 1;
                }
                if (this.MXA < 0 || this.MYA < 0 || this.MZA < 0 || this.MXB < 0 || this.MYB < 0 || this.MZB < 0 || this.MXC < 0 || this.MYC < 0 || this.MZC < 0) {
                  (0, _util.info)("Invalid Matrix for " + this.name + " [" + this.MXA + ", " + this.MYA + ", " + this.MZA + this.MXB + ", " + this.MYB + ", " + this.MZB + this.MXC + ", " + this.MYC + ", " + this.MZC + "], falling back to default");
                  this.MXA = this.MYB = this.MZC = 1;
                  this.MXB = this.MYA = this.MZA = this.MXC = this.MYC = this.MZB = 0;
                }
              }
              function matrixProduct(a, b, result) {
                result[0] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
                result[1] = a[3] * b[0] + a[4] * b[1] + a[5] * b[2];
                result[2] = a[6] * b[0] + a[7] * b[1] + a[8] * b[2];
              }
              function convertToFlat(sourceWhitePoint, LMS, result) {
                result[0] = LMS[0] * 1 / sourceWhitePoint[0];
                result[1] = LMS[1] * 1 / sourceWhitePoint[1];
                result[2] = LMS[2] * 1 / sourceWhitePoint[2];
              }
              function convertToD65(sourceWhitePoint, LMS, result) {
                var D65X = 0.95047;
                var D65Y = 1;
                var D65Z = 1.08883;
                result[0] = LMS[0] * D65X / sourceWhitePoint[0];
                result[1] = LMS[1] * D65Y / sourceWhitePoint[1];
                result[2] = LMS[2] * D65Z / sourceWhitePoint[2];
              }
              function sRGBTransferFunction(color) {
                if (color <= 31308e-7) {
                  return adjustToRange(0, 1, 12.92 * color);
                }
                return adjustToRange(0, 1, (1 + 0.055) * Math.pow(color, 1 / 2.4) - 0.055);
              }
              function adjustToRange(min, max, value) {
                return Math.max(min, Math.min(max, value));
              }
              function decodeL(L) {
                if (L < 0) {
                  return -decodeL(-L);
                }
                if (L > 8) {
                  return Math.pow((L + 16) / 116, 3);
                }
                return L * DECODE_L_CONSTANT;
              }
              function compensateBlackPoint(sourceBlackPoint, XYZ_Flat, result) {
                if (sourceBlackPoint[0] === 0 && sourceBlackPoint[1] === 0 && sourceBlackPoint[2] === 0) {
                  result[0] = XYZ_Flat[0];
                  result[1] = XYZ_Flat[1];
                  result[2] = XYZ_Flat[2];
                  return;
                }
                var zeroDecodeL = decodeL(0);
                var X_DST = zeroDecodeL;
                var X_SRC = decodeL(sourceBlackPoint[0]);
                var Y_DST = zeroDecodeL;
                var Y_SRC = decodeL(sourceBlackPoint[1]);
                var Z_DST = zeroDecodeL;
                var Z_SRC = decodeL(sourceBlackPoint[2]);
                var X_Scale = (1 - X_DST) / (1 - X_SRC);
                var X_Offset = 1 - X_Scale;
                var Y_Scale = (1 - Y_DST) / (1 - Y_SRC);
                var Y_Offset = 1 - Y_Scale;
                var Z_Scale = (1 - Z_DST) / (1 - Z_SRC);
                var Z_Offset = 1 - Z_Scale;
                result[0] = XYZ_Flat[0] * X_Scale + X_Offset;
                result[1] = XYZ_Flat[1] * Y_Scale + Y_Offset;
                result[2] = XYZ_Flat[2] * Z_Scale + Z_Offset;
              }
              function normalizeWhitePointToFlat(sourceWhitePoint, XYZ_In, result) {
                if (sourceWhitePoint[0] === 1 && sourceWhitePoint[2] === 1) {
                  result[0] = XYZ_In[0];
                  result[1] = XYZ_In[1];
                  result[2] = XYZ_In[2];
                  return;
                }
                var LMS = result;
                matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
                var LMS_Flat = tempNormalizeMatrix;
                convertToFlat(sourceWhitePoint, LMS, LMS_Flat);
                matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_Flat, result);
              }
              function normalizeWhitePointToD65(sourceWhitePoint, XYZ_In, result) {
                var LMS = result;
                matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
                var LMS_D65 = tempNormalizeMatrix;
                convertToD65(sourceWhitePoint, LMS, LMS_D65);
                matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_D65, result);
              }
              function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
                var A = adjustToRange(0, 1, src[srcOffset] * scale);
                var B = adjustToRange(0, 1, src[srcOffset + 1] * scale);
                var C = adjustToRange(0, 1, src[srcOffset + 2] * scale);
                var AGR = Math.pow(A, cs.GR);
                var BGG = Math.pow(B, cs.GG);
                var CGB = Math.pow(C, cs.GB);
                var X = cs.MXA * AGR + cs.MXB * BGG + cs.MXC * CGB;
                var Y = cs.MYA * AGR + cs.MYB * BGG + cs.MYC * CGB;
                var Z = cs.MZA * AGR + cs.MZB * BGG + cs.MZC * CGB;
                var XYZ = tempConvertMatrix1;
                XYZ[0] = X;
                XYZ[1] = Y;
                XYZ[2] = Z;
                var XYZ_Flat = tempConvertMatrix2;
                normalizeWhitePointToFlat(cs.whitePoint, XYZ, XYZ_Flat);
                var XYZ_Black = tempConvertMatrix1;
                compensateBlackPoint(cs.blackPoint, XYZ_Flat, XYZ_Black);
                var XYZ_D65 = tempConvertMatrix2;
                normalizeWhitePointToD65(FLAT_WHITEPOINT_MATRIX, XYZ_Black, XYZ_D65);
                var SRGB = tempConvertMatrix1;
                matrixProduct(SRGB_D65_XYZ_TO_RGB_MATRIX, XYZ_D65, SRGB);
                var sR = sRGBTransferFunction(SRGB[0]);
                var sG = sRGBTransferFunction(SRGB[1]);
                var sB = sRGBTransferFunction(SRGB[2]);
                dest[destOffset] = Math.round(sR * 255);
                dest[destOffset + 1] = Math.round(sG * 255);
                dest[destOffset + 2] = Math.round(sB * 255);
              }
              CalRGBCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function CalRGBCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  convertToRgb(this, src, srcOffset, dest, destOffset, 1);
                },
                getRgbBuffer: function CalRGBCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var scale = 1 / ((1 << bits) - 1);
                  for (var i = 0; i < count; ++i) {
                    convertToRgb(this, src, srcOffset, dest, destOffset, scale);
                    srcOffset += 3;
                    destOffset += 3 + alpha01;
                  }
                },
                getOutputLength: function CalRGBCS_getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01) / 3 | 0;
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function CalRGBCS_isDefaultDecode(decodeMap) {
                  return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                },
                usesZeroToOneRange: true
              };
              return CalRGBCS2;
            }();
            var LabCS = function LabCSClosure() {
              function LabCS2(whitePoint, blackPoint, range) {
                this.name = "Lab";
                this.numComps = 3;
                this.defaultColor = new Float32Array(this.numComps);
                if (!whitePoint) {
                  throw new _util.FormatError("WhitePoint missing - required for color space Lab");
                }
                blackPoint = blackPoint || [0, 0, 0];
                range = range || [-100, 100, -100, 100];
                this.XW = whitePoint[0];
                this.YW = whitePoint[1];
                this.ZW = whitePoint[2];
                this.amin = range[0];
                this.amax = range[1];
                this.bmin = range[2];
                this.bmax = range[3];
                this.XB = blackPoint[0];
                this.YB = blackPoint[1];
                this.ZB = blackPoint[2];
                if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
                  throw new _util.FormatError("Invalid WhitePoint components, no fallback available");
                }
                if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
                  (0, _util.info)("Invalid BlackPoint, falling back to default");
                  this.XB = this.YB = this.ZB = 0;
                }
                if (this.amin > this.amax || this.bmin > this.bmax) {
                  (0, _util.info)("Invalid Range, falling back to defaults");
                  this.amin = -100;
                  this.amax = 100;
                  this.bmin = -100;
                  this.bmax = 100;
                }
              }
              function fn_g(x) {
                var result;
                if (x >= 6 / 29) {
                  result = x * x * x;
                } else {
                  result = 108 / 841 * (x - 4 / 29);
                }
                return result;
              }
              function decode(value, high1, low2, high2) {
                return low2 + value * (high2 - low2) / high1;
              }
              function convertToRgb(cs, src, srcOffset, maxVal, dest, destOffset) {
                var Ls = src[srcOffset];
                var as = src[srcOffset + 1];
                var bs = src[srcOffset + 2];
                if (maxVal !== false) {
                  Ls = decode(Ls, maxVal, 0, 100);
                  as = decode(as, maxVal, cs.amin, cs.amax);
                  bs = decode(bs, maxVal, cs.bmin, cs.bmax);
                }
                as = as > cs.amax ? cs.amax : as < cs.amin ? cs.amin : as;
                bs = bs > cs.bmax ? cs.bmax : bs < cs.bmin ? cs.bmin : bs;
                var M = (Ls + 16) / 116;
                var L = M + as / 500;
                var N = M - bs / 200;
                var X = cs.XW * fn_g(L);
                var Y = cs.YW * fn_g(M);
                var Z = cs.ZW * fn_g(N);
                var r, g, b;
                if (cs.ZW < 1) {
                  r = X * 3.1339 + Y * -1.617 + Z * -0.4906;
                  g = X * -0.9785 + Y * 1.916 + Z * 0.0333;
                  b = X * 0.072 + Y * -0.229 + Z * 1.4057;
                } else {
                  r = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
                  g = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
                  b = X * 0.0557 + Y * -0.204 + Z * 1.057;
                }
                dest[destOffset] = r <= 0 ? 0 : r >= 1 ? 255 : Math.sqrt(r) * 255 | 0;
                dest[destOffset + 1] = g <= 0 ? 0 : g >= 1 ? 255 : Math.sqrt(g) * 255 | 0;
                dest[destOffset + 2] = b <= 0 ? 0 : b >= 1 ? 255 : Math.sqrt(b) * 255 | 0;
              }
              LabCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function LabCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  convertToRgb(this, src, srcOffset, false, dest, destOffset);
                },
                getRgbBuffer: function LabCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var maxVal = (1 << bits) - 1;
                  for (var i = 0; i < count; i++) {
                    convertToRgb(this, src, srcOffset, maxVal, dest, destOffset);
                    srcOffset += 3;
                    destOffset += 3 + alpha01;
                  }
                },
                getOutputLength: function LabCS_getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01) / 3 | 0;
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function LabCS_isDefaultDecode(decodeMap) {
                  return true;
                },
                usesZeroToOneRange: false
              };
              return LabCS2;
            }();
            exports3.ColorSpace = ColorSpace;
          },
          /* 133 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.AnnotationFactory = exports3.AnnotationBorderStyle = exports3.Annotation = void 0;
            var _get = function get(object, property, receiver) {
              if (object === null) object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _createClass = /* @__PURE__ */ function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _util = __w_pdfjs_require__(2);
            var _obj = __w_pdfjs_require__(118);
            var _primitives = __w_pdfjs_require__(119);
            var _colorspace = __w_pdfjs_require__(132);
            var _operator_list = __w_pdfjs_require__(134);
            var _stream = __w_pdfjs_require__(121);
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var AnnotationFactory = function() {
              function AnnotationFactory2() {
                _classCallCheck(this, AnnotationFactory2);
              }
              _createClass(AnnotationFactory2, null, [{
                key: "create",
                value: function create(xref, ref, pdfManager, idFactory) {
                  var dict = xref.fetchIfRef(ref);
                  if (!(0, _primitives.isDict)(dict)) {
                    return;
                  }
                  var id = (0, _primitives.isRef)(ref) ? ref.toString() : "annot_" + idFactory.createObjId();
                  var subtype = dict.get("Subtype");
                  subtype = (0, _primitives.isName)(subtype) ? subtype.name : null;
                  var parameters = {
                    xref,
                    dict,
                    ref: (0, _primitives.isRef)(ref) ? ref : null,
                    subtype,
                    id,
                    pdfManager
                  };
                  switch (subtype) {
                    case "Link":
                      return new LinkAnnotation(parameters);
                    case "Text":
                      return new TextAnnotation(parameters);
                    case "Widget":
                      var fieldType = (0, _util.getInheritableProperty)({
                        dict,
                        key: "FT"
                      });
                      fieldType = (0, _primitives.isName)(fieldType) ? fieldType.name : null;
                      switch (fieldType) {
                        case "Tx":
                          return new TextWidgetAnnotation(parameters);
                        case "Btn":
                          return new ButtonWidgetAnnotation(parameters);
                        case "Ch":
                          return new ChoiceWidgetAnnotation(parameters);
                      }
                      (0, _util.warn)('Unimplemented widget field type "' + fieldType + '", falling back to base field type.');
                      return new WidgetAnnotation(parameters);
                    case "Popup":
                      return new PopupAnnotation(parameters);
                    case "Line":
                      return new LineAnnotation(parameters);
                    case "Square":
                      return new SquareAnnotation(parameters);
                    case "Circle":
                      return new CircleAnnotation(parameters);
                    case "PolyLine":
                      return new PolylineAnnotation(parameters);
                    case "Polygon":
                      return new PolygonAnnotation(parameters);
                    case "Highlight":
                      return new HighlightAnnotation(parameters);
                    case "Underline":
                      return new UnderlineAnnotation(parameters);
                    case "Squiggly":
                      return new SquigglyAnnotation(parameters);
                    case "StrikeOut":
                      return new StrikeOutAnnotation(parameters);
                    case "Stamp":
                      return new StampAnnotation(parameters);
                    case "FileAttachment":
                      return new FileAttachmentAnnotation(parameters);
                    default:
                      if (!subtype) {
                        (0, _util.warn)("Annotation is missing the required /Subtype.");
                      } else {
                        (0, _util.warn)('Unimplemented annotation type "' + subtype + '", falling back to base annotation.');
                      }
                      return new Annotation(parameters);
                  }
                }
              }]);
              return AnnotationFactory2;
            }();
            function getTransformMatrix(rect, bbox, matrix) {
              var bounds = _util.Util.getAxialAlignedBoundingBox(bbox, matrix);
              var minX = bounds[0];
              var minY = bounds[1];
              var maxX = bounds[2];
              var maxY = bounds[3];
              if (minX === maxX || minY === maxY) {
                return [1, 0, 0, 1, rect[0], rect[1]];
              }
              var xRatio = (rect[2] - rect[0]) / (maxX - minX);
              var yRatio = (rect[3] - rect[1]) / (maxY - minY);
              return [xRatio, 0, 0, yRatio, rect[0] - minX * xRatio, rect[1] - minY * yRatio];
            }
            var Annotation = function() {
              function Annotation2(params) {
                _classCallCheck(this, Annotation2);
                var dict = params.dict;
                this.setFlags(dict.get("F"));
                this.setRectangle(dict.getArray("Rect"));
                this.setColor(dict.getArray("C"));
                this.setBorderStyle(dict);
                this.setAppearance(dict);
                this.data = {
                  annotationFlags: this.flags,
                  borderStyle: this.borderStyle,
                  color: this.color,
                  hasAppearance: !!this.appearance,
                  id: params.id,
                  rect: this.rectangle,
                  subtype: params.subtype
                };
              }
              _createClass(Annotation2, [{
                key: "_hasFlag",
                value: function _hasFlag(flags, flag) {
                  return !!(flags & flag);
                }
              }, {
                key: "_isViewable",
                value: function _isViewable(flags) {
                  return !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, _util.AnnotationFlag.HIDDEN) && !this._hasFlag(flags, _util.AnnotationFlag.NOVIEW);
                }
              }, {
                key: "_isPrintable",
                value: function _isPrintable(flags) {
                  return this._hasFlag(flags, _util.AnnotationFlag.PRINT) && !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, _util.AnnotationFlag.HIDDEN);
                }
              }, {
                key: "setFlags",
                value: function setFlags(flags) {
                  this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;
                }
              }, {
                key: "hasFlag",
                value: function hasFlag(flag) {
                  return this._hasFlag(this.flags, flag);
                }
              }, {
                key: "setRectangle",
                value: function setRectangle(rectangle) {
                  if (Array.isArray(rectangle) && rectangle.length === 4) {
                    this.rectangle = _util.Util.normalizeRect(rectangle);
                  } else {
                    this.rectangle = [0, 0, 0, 0];
                  }
                }
              }, {
                key: "setColor",
                value: function setColor(color) {
                  var rgbColor = new Uint8Array(3);
                  if (!Array.isArray(color)) {
                    this.color = rgbColor;
                    return;
                  }
                  switch (color.length) {
                    case 0:
                      this.color = null;
                      break;
                    case 1:
                      _colorspace.ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);
                      this.color = rgbColor;
                      break;
                    case 3:
                      _colorspace.ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);
                      this.color = rgbColor;
                      break;
                    case 4:
                      _colorspace.ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);
                      this.color = rgbColor;
                      break;
                    default:
                      this.color = rgbColor;
                      break;
                  }
                }
              }, {
                key: "setBorderStyle",
                value: function setBorderStyle(borderStyle) {
                  this.borderStyle = new AnnotationBorderStyle();
                  if (!(0, _primitives.isDict)(borderStyle)) {
                    return;
                  }
                  if (borderStyle.has("BS")) {
                    var dict = borderStyle.get("BS");
                    var dictType = dict.get("Type");
                    if (!dictType || (0, _primitives.isName)(dictType, "Border")) {
                      this.borderStyle.setWidth(dict.get("W"));
                      this.borderStyle.setStyle(dict.get("S"));
                      this.borderStyle.setDashArray(dict.getArray("D"));
                    }
                  } else if (borderStyle.has("Border")) {
                    var array = borderStyle.getArray("Border");
                    if (Array.isArray(array) && array.length >= 3) {
                      this.borderStyle.setHorizontalCornerRadius(array[0]);
                      this.borderStyle.setVerticalCornerRadius(array[1]);
                      this.borderStyle.setWidth(array[2]);
                      if (array.length === 4) {
                        this.borderStyle.setDashArray(array[3]);
                      }
                    }
                  } else {
                    this.borderStyle.setWidth(0);
                  }
                }
              }, {
                key: "setAppearance",
                value: function setAppearance(dict) {
                  this.appearance = null;
                  var appearanceStates = dict.get("AP");
                  if (!(0, _primitives.isDict)(appearanceStates)) {
                    return;
                  }
                  var normalAppearanceState = appearanceStates.get("N");
                  if ((0, _primitives.isStream)(normalAppearanceState)) {
                    this.appearance = normalAppearanceState;
                    return;
                  }
                  if (!(0, _primitives.isDict)(normalAppearanceState)) {
                    return;
                  }
                  var as = dict.get("AS");
                  if (!(0, _primitives.isName)(as) || !normalAppearanceState.has(as.name)) {
                    return;
                  }
                  this.appearance = normalAppearanceState.get(as.name);
                }
              }, {
                key: "_preparePopup",
                value: function _preparePopup(dict) {
                  if (!dict.has("C")) {
                    this.data.color = null;
                  }
                  this.data.hasPopup = dict.has("Popup");
                  this.data.title = (0, _util.stringToPDFString)(dict.get("T") || "");
                  this.data.contents = (0, _util.stringToPDFString)(dict.get("Contents") || "");
                }
              }, {
                key: "loadResources",
                value: function loadResources(keys) {
                  return this.appearance.dict.getAsync("Resources").then(function(resources) {
                    if (!resources) {
                      return;
                    }
                    var objectLoader = new _obj.ObjectLoader(resources, keys, resources.xref);
                    return objectLoader.load().then(function() {
                      return resources;
                    });
                  });
                }
              }, {
                key: "getOperatorList",
                value: function getOperatorList(evaluator, task, renderForms) {
                  var _this = this;
                  if (!this.appearance) {
                    return Promise.resolve(new _operator_list.OperatorList());
                  }
                  var data = this.data;
                  var appearanceDict = this.appearance.dict;
                  var resourcesPromise = this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"]);
                  var bbox = appearanceDict.getArray("BBox") || [0, 0, 1, 1];
                  var matrix = appearanceDict.getArray("Matrix") || [1, 0, 0, 1, 0, 0];
                  var transform = getTransformMatrix(data.rect, bbox, matrix);
                  return resourcesPromise.then(function(resources) {
                    var opList = new _operator_list.OperatorList();
                    opList.addOp(_util.OPS.beginAnnotation, [data.rect, transform, matrix]);
                    return evaluator.getOperatorList({
                      stream: _this.appearance,
                      task,
                      resources,
                      operatorList: opList
                    }).then(function() {
                      opList.addOp(_util.OPS.endAnnotation, []);
                      _this.appearance.reset();
                      return opList;
                    });
                  });
                }
              }, {
                key: "viewable",
                get: function get() {
                  if (this.flags === 0) {
                    return true;
                  }
                  return this._isViewable(this.flags);
                }
              }, {
                key: "printable",
                get: function get() {
                  if (this.flags === 0) {
                    return false;
                  }
                  return this._isPrintable(this.flags);
                }
              }]);
              return Annotation2;
            }();
            var AnnotationBorderStyle = function() {
              function AnnotationBorderStyle2() {
                _classCallCheck(this, AnnotationBorderStyle2);
                this.width = 1;
                this.style = _util.AnnotationBorderStyleType.SOLID;
                this.dashArray = [3];
                this.horizontalCornerRadius = 0;
                this.verticalCornerRadius = 0;
              }
              _createClass(AnnotationBorderStyle2, [{
                key: "setWidth",
                value: function setWidth(width) {
                  if (Number.isInteger(width)) {
                    this.width = width;
                  }
                }
              }, {
                key: "setStyle",
                value: function setStyle(style) {
                  if (!style) {
                    return;
                  }
                  switch (style.name) {
                    case "S":
                      this.style = _util.AnnotationBorderStyleType.SOLID;
                      break;
                    case "D":
                      this.style = _util.AnnotationBorderStyleType.DASHED;
                      break;
                    case "B":
                      this.style = _util.AnnotationBorderStyleType.BEVELED;
                      break;
                    case "I":
                      this.style = _util.AnnotationBorderStyleType.INSET;
                      break;
                    case "U":
                      this.style = _util.AnnotationBorderStyleType.UNDERLINE;
                      break;
                    default:
                      break;
                  }
                }
              }, {
                key: "setDashArray",
                value: function setDashArray(dashArray) {
                  if (Array.isArray(dashArray) && dashArray.length > 0) {
                    var isValid = true;
                    var allZeros = true;
                    for (var i = 0, len = dashArray.length; i < len; i++) {
                      var element = dashArray[i];
                      var validNumber = +element >= 0;
                      if (!validNumber) {
                        isValid = false;
                        break;
                      } else if (element > 0) {
                        allZeros = false;
                      }
                    }
                    if (isValid && !allZeros) {
                      this.dashArray = dashArray;
                    } else {
                      this.width = 0;
                    }
                  } else if (dashArray) {
                    this.width = 0;
                  }
                }
              }, {
                key: "setHorizontalCornerRadius",
                value: function setHorizontalCornerRadius(radius) {
                  if (Number.isInteger(radius)) {
                    this.horizontalCornerRadius = radius;
                  }
                }
              }, {
                key: "setVerticalCornerRadius",
                value: function setVerticalCornerRadius(radius) {
                  if (Number.isInteger(radius)) {
                    this.verticalCornerRadius = radius;
                  }
                }
              }]);
              return AnnotationBorderStyle2;
            }();
            var WidgetAnnotation = function(_Annotation) {
              _inherits(WidgetAnnotation2, _Annotation);
              function WidgetAnnotation2(params) {
                _classCallCheck(this, WidgetAnnotation2);
                var _this2 = _possibleConstructorReturn(this, (WidgetAnnotation2.__proto__ || Object.getPrototypeOf(WidgetAnnotation2)).call(this, params));
                var dict = params.dict;
                var data = _this2.data;
                data.annotationType = _util.AnnotationType.WIDGET;
                data.fieldName = _this2._constructFieldName(dict);
                data.fieldValue = (0, _util.getInheritableProperty)({
                  dict,
                  key: "V",
                  getArray: true
                });
                data.alternativeText = (0, _util.stringToPDFString)(dict.get("TU") || "");
                data.defaultAppearance = (0, _util.getInheritableProperty)({
                  dict,
                  key: "DA"
                }) || "";
                var fieldType = (0, _util.getInheritableProperty)({
                  dict,
                  key: "FT"
                });
                data.fieldType = (0, _primitives.isName)(fieldType) ? fieldType.name : null;
                _this2.fieldResources = (0, _util.getInheritableProperty)({
                  dict,
                  key: "DR"
                }) || _primitives.Dict.empty;
                data.fieldFlags = (0, _util.getInheritableProperty)({
                  dict,
                  key: "Ff"
                });
                if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
                  data.fieldFlags = 0;
                }
                data.readOnly = _this2.hasFieldFlag(_util.AnnotationFieldFlag.READONLY);
                if (data.fieldType === "Sig") {
                  _this2.setFlags(_util.AnnotationFlag.HIDDEN);
                }
                return _this2;
              }
              _createClass(WidgetAnnotation2, [{
                key: "_constructFieldName",
                value: function _constructFieldName(dict) {
                  if (!dict.has("T") && !dict.has("Parent")) {
                    (0, _util.warn)("Unknown field name, falling back to empty field name.");
                    return "";
                  }
                  if (!dict.has("Parent")) {
                    return (0, _util.stringToPDFString)(dict.get("T"));
                  }
                  var fieldName = [];
                  if (dict.has("T")) {
                    fieldName.unshift((0, _util.stringToPDFString)(dict.get("T")));
                  }
                  var loopDict = dict;
                  while (loopDict.has("Parent")) {
                    loopDict = loopDict.get("Parent");
                    if (!(0, _primitives.isDict)(loopDict)) {
                      break;
                    }
                    if (loopDict.has("T")) {
                      fieldName.unshift((0, _util.stringToPDFString)(loopDict.get("T")));
                    }
                  }
                  return fieldName.join(".");
                }
              }, {
                key: "hasFieldFlag",
                value: function hasFieldFlag(flag) {
                  return !!(this.data.fieldFlags & flag);
                }
              }, {
                key: "getOperatorList",
                value: function getOperatorList(evaluator, task, renderForms) {
                  if (renderForms) {
                    return Promise.resolve(new _operator_list.OperatorList());
                  }
                  return _get(WidgetAnnotation2.prototype.__proto__ || Object.getPrototypeOf(WidgetAnnotation2.prototype), "getOperatorList", this).call(this, evaluator, task, renderForms);
                }
              }]);
              return WidgetAnnotation2;
            }(Annotation);
            var TextWidgetAnnotation = function(_WidgetAnnotation) {
              _inherits(TextWidgetAnnotation2, _WidgetAnnotation);
              function TextWidgetAnnotation2(params) {
                _classCallCheck(this, TextWidgetAnnotation2);
                var _this3 = _possibleConstructorReturn(this, (TextWidgetAnnotation2.__proto__ || Object.getPrototypeOf(TextWidgetAnnotation2)).call(this, params));
                var dict = params.dict;
                _this3.data.fieldValue = (0, _util.stringToPDFString)(_this3.data.fieldValue || "");
                var alignment = (0, _util.getInheritableProperty)({
                  dict,
                  key: "Q"
                });
                if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {
                  alignment = null;
                }
                _this3.data.textAlignment = alignment;
                var maximumLength = (0, _util.getInheritableProperty)({
                  dict,
                  key: "MaxLen"
                });
                if (!Number.isInteger(maximumLength) || maximumLength < 0) {
                  maximumLength = null;
                }
                _this3.data.maxLen = maximumLength;
                _this3.data.multiLine = _this3.hasFieldFlag(_util.AnnotationFieldFlag.MULTILINE);
                _this3.data.comb = _this3.hasFieldFlag(_util.AnnotationFieldFlag.COMB) && !_this3.hasFieldFlag(_util.AnnotationFieldFlag.MULTILINE) && !_this3.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD) && !_this3.hasFieldFlag(_util.AnnotationFieldFlag.FILESELECT) && _this3.data.maxLen !== null;
                return _this3;
              }
              _createClass(TextWidgetAnnotation2, [{
                key: "getOperatorList",
                value: function getOperatorList(evaluator, task, renderForms) {
                  if (renderForms || this.appearance) {
                    return _get(TextWidgetAnnotation2.prototype.__proto__ || Object.getPrototypeOf(TextWidgetAnnotation2.prototype), "getOperatorList", this).call(this, evaluator, task, renderForms);
                  }
                  var operatorList = new _operator_list.OperatorList();
                  if (!this.data.defaultAppearance) {
                    return Promise.resolve(operatorList);
                  }
                  var stream2 = new _stream.Stream((0, _util.stringToBytes)(this.data.defaultAppearance));
                  return evaluator.getOperatorList({
                    stream: stream2,
                    task,
                    resources: this.fieldResources,
                    operatorList
                  }).then(function() {
                    return operatorList;
                  });
                }
              }]);
              return TextWidgetAnnotation2;
            }(WidgetAnnotation);
            var ButtonWidgetAnnotation = function(_WidgetAnnotation2) {
              _inherits(ButtonWidgetAnnotation2, _WidgetAnnotation2);
              function ButtonWidgetAnnotation2(params) {
                _classCallCheck(this, ButtonWidgetAnnotation2);
                var _this4 = _possibleConstructorReturn(this, (ButtonWidgetAnnotation2.__proto__ || Object.getPrototypeOf(ButtonWidgetAnnotation2)).call(this, params));
                _this4.data.checkBox = !_this4.hasFieldFlag(_util.AnnotationFieldFlag.RADIO) && !_this4.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
                _this4.data.radioButton = _this4.hasFieldFlag(_util.AnnotationFieldFlag.RADIO) && !_this4.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
                _this4.data.pushButton = _this4.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
                if (_this4.data.checkBox) {
                  _this4._processCheckBox();
                } else if (_this4.data.radioButton) {
                  _this4._processRadioButton(params);
                } else if (_this4.data.pushButton) {
                  _this4._processPushButton(params);
                } else {
                  (0, _util.warn)("Invalid field flags for button widget annotation");
                }
                return _this4;
              }
              _createClass(ButtonWidgetAnnotation2, [{
                key: "_processCheckBox",
                value: function _processCheckBox() {
                  if (!(0, _primitives.isName)(this.data.fieldValue)) {
                    return;
                  }
                  this.data.fieldValue = this.data.fieldValue.name;
                }
              }, {
                key: "_processRadioButton",
                value: function _processRadioButton(params) {
                  this.data.fieldValue = this.data.buttonValue = null;
                  var fieldParent = params.dict.get("Parent");
                  if ((0, _primitives.isDict)(fieldParent) && fieldParent.has("V")) {
                    var fieldParentValue = fieldParent.get("V");
                    if ((0, _primitives.isName)(fieldParentValue)) {
                      this.data.fieldValue = fieldParentValue.name;
                    }
                  }
                  var appearanceStates = params.dict.get("AP");
                  if (!(0, _primitives.isDict)(appearanceStates)) {
                    return;
                  }
                  var normalAppearanceState = appearanceStates.get("N");
                  if (!(0, _primitives.isDict)(normalAppearanceState)) {
                    return;
                  }
                  var keys = normalAppearanceState.getKeys();
                  for (var i = 0, ii = keys.length; i < ii; i++) {
                    if (keys[i] !== "Off") {
                      this.data.buttonValue = keys[i];
                      break;
                    }
                  }
                }
              }, {
                key: "_processPushButton",
                value: function _processPushButton(params) {
                  if (!params.dict.has("A")) {
                    (0, _util.warn)("Push buttons without action dictionaries are not supported");
                    return;
                  }
                  _obj.Catalog.parseDestDictionary({
                    destDict: params.dict,
                    resultObj: this.data,
                    docBaseUrl: params.pdfManager.docBaseUrl
                  });
                }
              }]);
              return ButtonWidgetAnnotation2;
            }(WidgetAnnotation);
            var ChoiceWidgetAnnotation = function(_WidgetAnnotation3) {
              _inherits(ChoiceWidgetAnnotation2, _WidgetAnnotation3);
              function ChoiceWidgetAnnotation2(params) {
                _classCallCheck(this, ChoiceWidgetAnnotation2);
                var _this5 = _possibleConstructorReturn(this, (ChoiceWidgetAnnotation2.__proto__ || Object.getPrototypeOf(ChoiceWidgetAnnotation2)).call(this, params));
                _this5.data.options = [];
                var options2 = (0, _util.getInheritableProperty)({
                  dict: params.dict,
                  key: "Opt"
                });
                if (Array.isArray(options2)) {
                  var xref = params.xref;
                  for (var i = 0, ii = options2.length; i < ii; i++) {
                    var option = xref.fetchIfRef(options2[i]);
                    var isOptionArray = Array.isArray(option);
                    _this5.data.options[i] = {
                      exportValue: isOptionArray ? xref.fetchIfRef(option[0]) : option,
                      displayValue: (0, _util.stringToPDFString)(isOptionArray ? xref.fetchIfRef(option[1]) : option)
                    };
                  }
                }
                if (!Array.isArray(_this5.data.fieldValue)) {
                  _this5.data.fieldValue = [_this5.data.fieldValue];
                }
                _this5.data.combo = _this5.hasFieldFlag(_util.AnnotationFieldFlag.COMBO);
                _this5.data.multiSelect = _this5.hasFieldFlag(_util.AnnotationFieldFlag.MULTISELECT);
                return _this5;
              }
              return ChoiceWidgetAnnotation2;
            }(WidgetAnnotation);
            var TextAnnotation = function(_Annotation2) {
              _inherits(TextAnnotation2, _Annotation2);
              function TextAnnotation2(parameters) {
                _classCallCheck(this, TextAnnotation2);
                var DEFAULT_ICON_SIZE = 22;
                var _this6 = _possibleConstructorReturn(this, (TextAnnotation2.__proto__ || Object.getPrototypeOf(TextAnnotation2)).call(this, parameters));
                _this6.data.annotationType = _util.AnnotationType.TEXT;
                if (_this6.data.hasAppearance) {
                  _this6.data.name = "NoIcon";
                } else {
                  _this6.data.rect[1] = _this6.data.rect[3] - DEFAULT_ICON_SIZE;
                  _this6.data.rect[2] = _this6.data.rect[0] + DEFAULT_ICON_SIZE;
                  _this6.data.name = parameters.dict.has("Name") ? parameters.dict.get("Name").name : "Note";
                }
                _this6._preparePopup(parameters.dict);
                return _this6;
              }
              return TextAnnotation2;
            }(Annotation);
            var LinkAnnotation = function(_Annotation3) {
              _inherits(LinkAnnotation2, _Annotation3);
              function LinkAnnotation2(params) {
                _classCallCheck(this, LinkAnnotation2);
                var _this7 = _possibleConstructorReturn(this, (LinkAnnotation2.__proto__ || Object.getPrototypeOf(LinkAnnotation2)).call(this, params));
                _this7.data.annotationType = _util.AnnotationType.LINK;
                _obj.Catalog.parseDestDictionary({
                  destDict: params.dict,
                  resultObj: _this7.data,
                  docBaseUrl: params.pdfManager.docBaseUrl
                });
                return _this7;
              }
              return LinkAnnotation2;
            }(Annotation);
            var PopupAnnotation = function(_Annotation4) {
              _inherits(PopupAnnotation2, _Annotation4);
              function PopupAnnotation2(parameters) {
                _classCallCheck(this, PopupAnnotation2);
                var _this8 = _possibleConstructorReturn(this, (PopupAnnotation2.__proto__ || Object.getPrototypeOf(PopupAnnotation2)).call(this, parameters));
                _this8.data.annotationType = _util.AnnotationType.POPUP;
                var dict = parameters.dict;
                var parentItem = dict.get("Parent");
                if (!parentItem) {
                  (0, _util.warn)("Popup annotation has a missing or invalid parent annotation.");
                  return _possibleConstructorReturn(_this8);
                }
                var parentSubtype = parentItem.get("Subtype");
                _this8.data.parentType = (0, _primitives.isName)(parentSubtype) ? parentSubtype.name : null;
                _this8.data.parentId = dict.getRaw("Parent").toString();
                _this8.data.title = (0, _util.stringToPDFString)(parentItem.get("T") || "");
                _this8.data.contents = (0, _util.stringToPDFString)(parentItem.get("Contents") || "");
                if (!parentItem.has("C")) {
                  _this8.data.color = null;
                } else {
                  _this8.setColor(parentItem.getArray("C"));
                  _this8.data.color = _this8.color;
                }
                if (!_this8.viewable) {
                  var parentFlags = parentItem.get("F");
                  if (_this8._isViewable(parentFlags)) {
                    _this8.setFlags(parentFlags);
                  }
                }
                return _this8;
              }
              return PopupAnnotation2;
            }(Annotation);
            var LineAnnotation = function(_Annotation5) {
              _inherits(LineAnnotation2, _Annotation5);
              function LineAnnotation2(parameters) {
                _classCallCheck(this, LineAnnotation2);
                var _this9 = _possibleConstructorReturn(this, (LineAnnotation2.__proto__ || Object.getPrototypeOf(LineAnnotation2)).call(this, parameters));
                _this9.data.annotationType = _util.AnnotationType.LINE;
                var dict = parameters.dict;
                _this9.data.lineCoordinates = _util.Util.normalizeRect(dict.getArray("L"));
                _this9._preparePopup(dict);
                return _this9;
              }
              return LineAnnotation2;
            }(Annotation);
            var SquareAnnotation = function(_Annotation6) {
              _inherits(SquareAnnotation2, _Annotation6);
              function SquareAnnotation2(parameters) {
                _classCallCheck(this, SquareAnnotation2);
                var _this10 = _possibleConstructorReturn(this, (SquareAnnotation2.__proto__ || Object.getPrototypeOf(SquareAnnotation2)).call(this, parameters));
                _this10.data.annotationType = _util.AnnotationType.SQUARE;
                _this10._preparePopup(parameters.dict);
                return _this10;
              }
              return SquareAnnotation2;
            }(Annotation);
            var CircleAnnotation = function(_Annotation7) {
              _inherits(CircleAnnotation2, _Annotation7);
              function CircleAnnotation2(parameters) {
                _classCallCheck(this, CircleAnnotation2);
                var _this11 = _possibleConstructorReturn(this, (CircleAnnotation2.__proto__ || Object.getPrototypeOf(CircleAnnotation2)).call(this, parameters));
                _this11.data.annotationType = _util.AnnotationType.CIRCLE;
                _this11._preparePopup(parameters.dict);
                return _this11;
              }
              return CircleAnnotation2;
            }(Annotation);
            var PolylineAnnotation = function(_Annotation8) {
              _inherits(PolylineAnnotation2, _Annotation8);
              function PolylineAnnotation2(parameters) {
                _classCallCheck(this, PolylineAnnotation2);
                var _this12 = _possibleConstructorReturn(this, (PolylineAnnotation2.__proto__ || Object.getPrototypeOf(PolylineAnnotation2)).call(this, parameters));
                _this12.data.annotationType = _util.AnnotationType.POLYLINE;
                var dict = parameters.dict;
                var rawVertices = dict.getArray("Vertices");
                _this12.data.vertices = [];
                for (var i = 0, ii = rawVertices.length; i < ii; i += 2) {
                  _this12.data.vertices.push({
                    x: rawVertices[i],
                    y: rawVertices[i + 1]
                  });
                }
                _this12._preparePopup(dict);
                return _this12;
              }
              return PolylineAnnotation2;
            }(Annotation);
            var PolygonAnnotation = function(_PolylineAnnotation) {
              _inherits(PolygonAnnotation2, _PolylineAnnotation);
              function PolygonAnnotation2(parameters) {
                _classCallCheck(this, PolygonAnnotation2);
                var _this13 = _possibleConstructorReturn(this, (PolygonAnnotation2.__proto__ || Object.getPrototypeOf(PolygonAnnotation2)).call(this, parameters));
                _this13.data.annotationType = _util.AnnotationType.POLYGON;
                return _this13;
              }
              return PolygonAnnotation2;
            }(PolylineAnnotation);
            var HighlightAnnotation = function(_Annotation9) {
              _inherits(HighlightAnnotation2, _Annotation9);
              function HighlightAnnotation2(parameters) {
                _classCallCheck(this, HighlightAnnotation2);
                var _this14 = _possibleConstructorReturn(this, (HighlightAnnotation2.__proto__ || Object.getPrototypeOf(HighlightAnnotation2)).call(this, parameters));
                _this14.data.annotationType = _util.AnnotationType.HIGHLIGHT;
                _this14._preparePopup(parameters.dict);
                return _this14;
              }
              return HighlightAnnotation2;
            }(Annotation);
            var UnderlineAnnotation = function(_Annotation10) {
              _inherits(UnderlineAnnotation2, _Annotation10);
              function UnderlineAnnotation2(parameters) {
                _classCallCheck(this, UnderlineAnnotation2);
                var _this15 = _possibleConstructorReturn(this, (UnderlineAnnotation2.__proto__ || Object.getPrototypeOf(UnderlineAnnotation2)).call(this, parameters));
                _this15.data.annotationType = _util.AnnotationType.UNDERLINE;
                _this15._preparePopup(parameters.dict);
                return _this15;
              }
              return UnderlineAnnotation2;
            }(Annotation);
            var SquigglyAnnotation = function(_Annotation11) {
              _inherits(SquigglyAnnotation2, _Annotation11);
              function SquigglyAnnotation2(parameters) {
                _classCallCheck(this, SquigglyAnnotation2);
                var _this16 = _possibleConstructorReturn(this, (SquigglyAnnotation2.__proto__ || Object.getPrototypeOf(SquigglyAnnotation2)).call(this, parameters));
                _this16.data.annotationType = _util.AnnotationType.SQUIGGLY;
                _this16._preparePopup(parameters.dict);
                return _this16;
              }
              return SquigglyAnnotation2;
            }(Annotation);
            var StrikeOutAnnotation = function(_Annotation12) {
              _inherits(StrikeOutAnnotation2, _Annotation12);
              function StrikeOutAnnotation2(parameters) {
                _classCallCheck(this, StrikeOutAnnotation2);
                var _this17 = _possibleConstructorReturn(this, (StrikeOutAnnotation2.__proto__ || Object.getPrototypeOf(StrikeOutAnnotation2)).call(this, parameters));
                _this17.data.annotationType = _util.AnnotationType.STRIKEOUT;
                _this17._preparePopup(parameters.dict);
                return _this17;
              }
              return StrikeOutAnnotation2;
            }(Annotation);
            var StampAnnotation = function(_Annotation13) {
              _inherits(StampAnnotation2, _Annotation13);
              function StampAnnotation2(parameters) {
                _classCallCheck(this, StampAnnotation2);
                var _this18 = _possibleConstructorReturn(this, (StampAnnotation2.__proto__ || Object.getPrototypeOf(StampAnnotation2)).call(this, parameters));
                _this18.data.annotationType = _util.AnnotationType.STAMP;
                _this18._preparePopup(parameters.dict);
                return _this18;
              }
              return StampAnnotation2;
            }(Annotation);
            var FileAttachmentAnnotation = function(_Annotation14) {
              _inherits(FileAttachmentAnnotation2, _Annotation14);
              function FileAttachmentAnnotation2(parameters) {
                _classCallCheck(this, FileAttachmentAnnotation2);
                var _this19 = _possibleConstructorReturn(this, (FileAttachmentAnnotation2.__proto__ || Object.getPrototypeOf(FileAttachmentAnnotation2)).call(this, parameters));
                var file = new _obj.FileSpec(parameters.dict.get("FS"), parameters.xref);
                _this19.data.annotationType = _util.AnnotationType.FILEATTACHMENT;
                _this19.data.file = file.serializable;
                _this19._preparePopup(parameters.dict);
                return _this19;
              }
              return FileAttachmentAnnotation2;
            }(Annotation);
            exports3.Annotation = Annotation;
            exports3.AnnotationBorderStyle = AnnotationBorderStyle;
            exports3.AnnotationFactory = AnnotationFactory;
          },
          /* 134 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.OperatorList = void 0;
            var _util = __w_pdfjs_require__(2);
            var QueueOptimizer = function QueueOptimizerClosure() {
              function addState(parentState, pattern, checkFn, iterateFn, processFn) {
                var state = parentState;
                for (var i = 0, ii = pattern.length - 1; i < ii; i++) {
                  var item = pattern[i];
                  state = state[item] || (state[item] = []);
                }
                state[pattern[pattern.length - 1]] = {
                  checkFn,
                  iterateFn,
                  processFn
                };
              }
              function handlePaintSolidColorImageMask(iFirstSave, count, fnArray, argsArray) {
                var iFirstPIMXO = iFirstSave + 2;
                for (var i = 0; i < count; i++) {
                  var arg = argsArray[iFirstPIMXO + 4 * i];
                  var imageMask = arg.length === 1 && arg[0];
                  if (imageMask && imageMask.width === 1 && imageMask.height === 1 && (!imageMask.data.length || imageMask.data.length === 1 && imageMask.data[0] === 0)) {
                    fnArray[iFirstPIMXO + 4 * i] = _util.OPS.paintSolidColorImageMask;
                    continue;
                  }
                  break;
                }
                return count - i;
              }
              var InitialState = [];
              addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintInlineImageXObject, _util.OPS.restore], null, function iterateInlineImageGroup(context, i) {
                var fnArray = context.fnArray;
                var iFirstSave = context.iCurr - 3;
                var pos = (i - iFirstSave) % 4;
                switch (pos) {
                  case 0:
                    return fnArray[i] === _util.OPS.save;
                  case 1:
                    return fnArray[i] === _util.OPS.transform;
                  case 2:
                    return fnArray[i] === _util.OPS.paintInlineImageXObject;
                  case 3:
                    return fnArray[i] === _util.OPS.restore;
                }
              }, function foundInlineImageGroup(context, i) {
                var MIN_IMAGES_IN_INLINE_IMAGES_BLOCK = 10;
                var MAX_IMAGES_IN_INLINE_IMAGES_BLOCK = 200;
                var MAX_WIDTH = 1e3;
                var IMAGE_PADDING = 1;
                var fnArray = context.fnArray, argsArray = context.argsArray;
                var curr = context.iCurr;
                var iFirstSave = curr - 3;
                var iFirstTransform = curr - 2;
                var iFirstPIIXO = curr - 1;
                var count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_INLINE_IMAGES_BLOCK);
                if (count < MIN_IMAGES_IN_INLINE_IMAGES_BLOCK) {
                  return i - (i - iFirstSave) % 4;
                }
                var maxX = 0;
                var map = [], maxLineHeight = 0;
                var currentX = IMAGE_PADDING, currentY = IMAGE_PADDING;
                var q;
                for (q = 0; q < count; q++) {
                  var transform = argsArray[iFirstTransform + (q << 2)];
                  var img = argsArray[iFirstPIIXO + (q << 2)][0];
                  if (currentX + img.width > MAX_WIDTH) {
                    maxX = Math.max(maxX, currentX);
                    currentY += maxLineHeight + 2 * IMAGE_PADDING;
                    currentX = 0;
                    maxLineHeight = 0;
                  }
                  map.push({
                    transform,
                    x: currentX,
                    y: currentY,
                    w: img.width,
                    h: img.height
                  });
                  currentX += img.width + 2 * IMAGE_PADDING;
                  maxLineHeight = Math.max(maxLineHeight, img.height);
                }
                var imgWidth = Math.max(maxX, currentX) + IMAGE_PADDING;
                var imgHeight = currentY + maxLineHeight + IMAGE_PADDING;
                var imgData = new Uint8Array(imgWidth * imgHeight * 4);
                var imgRowSize = imgWidth << 2;
                for (q = 0; q < count; q++) {
                  var data = argsArray[iFirstPIIXO + (q << 2)][0].data;
                  var rowSize = map[q].w << 2;
                  var dataOffset = 0;
                  var offset = map[q].x + map[q].y * imgWidth << 2;
                  imgData.set(data.subarray(0, rowSize), offset - imgRowSize);
                  for (var k = 0, kk = map[q].h; k < kk; k++) {
                    imgData.set(data.subarray(dataOffset, dataOffset + rowSize), offset);
                    dataOffset += rowSize;
                    offset += imgRowSize;
                  }
                  imgData.set(data.subarray(dataOffset - rowSize, dataOffset), offset);
                  while (offset >= 0) {
                    data[offset - 4] = data[offset];
                    data[offset - 3] = data[offset + 1];
                    data[offset - 2] = data[offset + 2];
                    data[offset - 1] = data[offset + 3];
                    data[offset + rowSize] = data[offset + rowSize - 4];
                    data[offset + rowSize + 1] = data[offset + rowSize - 3];
                    data[offset + rowSize + 2] = data[offset + rowSize - 2];
                    data[offset + rowSize + 3] = data[offset + rowSize - 1];
                    offset -= imgRowSize;
                  }
                }
                fnArray.splice(iFirstSave, count * 4, _util.OPS.paintInlineImageXObjectGroup);
                argsArray.splice(iFirstSave, count * 4, [{
                  width: imgWidth,
                  height: imgHeight,
                  kind: _util.ImageKind.RGBA_32BPP,
                  data: imgData
                }, map]);
                return iFirstSave + 1;
              });
              addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintImageMaskXObject, _util.OPS.restore], null, function iterateImageMaskGroup(context, i) {
                var fnArray = context.fnArray;
                var iFirstSave = context.iCurr - 3;
                var pos = (i - iFirstSave) % 4;
                switch (pos) {
                  case 0:
                    return fnArray[i] === _util.OPS.save;
                  case 1:
                    return fnArray[i] === _util.OPS.transform;
                  case 2:
                    return fnArray[i] === _util.OPS.paintImageMaskXObject;
                  case 3:
                    return fnArray[i] === _util.OPS.restore;
                }
              }, function foundImageMaskGroup(context, i) {
                var MIN_IMAGES_IN_MASKS_BLOCK = 10;
                var MAX_IMAGES_IN_MASKS_BLOCK = 100;
                var MAX_SAME_IMAGES_IN_MASKS_BLOCK = 1e3;
                var fnArray = context.fnArray, argsArray = context.argsArray;
                var curr = context.iCurr;
                var iFirstSave = curr - 3;
                var iFirstTransform = curr - 2;
                var iFirstPIMXO = curr - 1;
                var count = Math.floor((i - iFirstSave) / 4);
                count = handlePaintSolidColorImageMask(iFirstSave, count, fnArray, argsArray);
                if (count < MIN_IMAGES_IN_MASKS_BLOCK) {
                  return i - (i - iFirstSave) % 4;
                }
                var q;
                var isSameImage = false;
                var iTransform, transformArgs;
                var firstPIMXOArg0 = argsArray[iFirstPIMXO][0];
                if (argsArray[iFirstTransform][1] === 0 && argsArray[iFirstTransform][2] === 0) {
                  isSameImage = true;
                  var firstTransformArg0 = argsArray[iFirstTransform][0];
                  var firstTransformArg3 = argsArray[iFirstTransform][3];
                  iTransform = iFirstTransform + 4;
                  var iPIMXO = iFirstPIMXO + 4;
                  for (q = 1; q < count; q++, iTransform += 4, iPIMXO += 4) {
                    transformArgs = argsArray[iTransform];
                    if (argsArray[iPIMXO][0] !== firstPIMXOArg0 || transformArgs[0] !== firstTransformArg0 || transformArgs[1] !== 0 || transformArgs[2] !== 0 || transformArgs[3] !== firstTransformArg3) {
                      if (q < MIN_IMAGES_IN_MASKS_BLOCK) {
                        isSameImage = false;
                      } else {
                        count = q;
                      }
                      break;
                    }
                  }
                }
                if (isSameImage) {
                  count = Math.min(count, MAX_SAME_IMAGES_IN_MASKS_BLOCK);
                  var positions = new Float32Array(count * 2);
                  iTransform = iFirstTransform;
                  for (q = 0; q < count; q++, iTransform += 4) {
                    transformArgs = argsArray[iTransform];
                    positions[q << 1] = transformArgs[4];
                    positions[(q << 1) + 1] = transformArgs[5];
                  }
                  fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageMaskXObjectRepeat);
                  argsArray.splice(iFirstSave, count * 4, [firstPIMXOArg0, firstTransformArg0, firstTransformArg3, positions]);
                } else {
                  count = Math.min(count, MAX_IMAGES_IN_MASKS_BLOCK);
                  var images = [];
                  for (q = 0; q < count; q++) {
                    transformArgs = argsArray[iFirstTransform + (q << 2)];
                    var maskParams = argsArray[iFirstPIMXO + (q << 2)][0];
                    images.push({
                      data: maskParams.data,
                      width: maskParams.width,
                      height: maskParams.height,
                      transform: transformArgs
                    });
                  }
                  fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageMaskXObjectGroup);
                  argsArray.splice(iFirstSave, count * 4, [images]);
                }
                return iFirstSave + 1;
              });
              addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintImageXObject, _util.OPS.restore], function(context) {
                var argsArray = context.argsArray;
                var iFirstTransform = context.iCurr - 2;
                return argsArray[iFirstTransform][1] === 0 && argsArray[iFirstTransform][2] === 0;
              }, function(context, i) {
                var fnArray = context.fnArray, argsArray = context.argsArray;
                var iFirstSave = context.iCurr - 3;
                var pos = (i - iFirstSave) % 4;
                switch (pos) {
                  case 0:
                    return fnArray[i] === _util.OPS.save;
                  case 1:
                    if (fnArray[i] !== _util.OPS.transform) {
                      return false;
                    }
                    var iFirstTransform = context.iCurr - 2;
                    var firstTransformArg0 = argsArray[iFirstTransform][0];
                    var firstTransformArg3 = argsArray[iFirstTransform][3];
                    if (argsArray[i][0] !== firstTransformArg0 || argsArray[i][1] !== 0 || argsArray[i][2] !== 0 || argsArray[i][3] !== firstTransformArg3) {
                      return false;
                    }
                    return true;
                  case 2:
                    if (fnArray[i] !== _util.OPS.paintImageXObject) {
                      return false;
                    }
                    var iFirstPIXO = context.iCurr - 1;
                    var firstPIXOArg0 = argsArray[iFirstPIXO][0];
                    if (argsArray[i][0] !== firstPIXOArg0) {
                      return false;
                    }
                    return true;
                  case 3:
                    return fnArray[i] === _util.OPS.restore;
                }
              }, function(context, i) {
                var MIN_IMAGES_IN_BLOCK = 3;
                var MAX_IMAGES_IN_BLOCK = 1e3;
                var fnArray = context.fnArray, argsArray = context.argsArray;
                var curr = context.iCurr;
                var iFirstSave = curr - 3;
                var iFirstTransform = curr - 2;
                var iFirstPIXO = curr - 1;
                var firstPIXOArg0 = argsArray[iFirstPIXO][0];
                var firstTransformArg0 = argsArray[iFirstTransform][0];
                var firstTransformArg3 = argsArray[iFirstTransform][3];
                var count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_BLOCK);
                if (count < MIN_IMAGES_IN_BLOCK) {
                  return i - (i - iFirstSave) % 4;
                }
                var positions = new Float32Array(count * 2);
                var iTransform = iFirstTransform;
                for (var q = 0; q < count; q++, iTransform += 4) {
                  var transformArgs = argsArray[iTransform];
                  positions[q << 1] = transformArgs[4];
                  positions[(q << 1) + 1] = transformArgs[5];
                }
                var args = [firstPIXOArg0, firstTransformArg0, firstTransformArg3, positions];
                fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageXObjectRepeat);
                argsArray.splice(iFirstSave, count * 4, args);
                return iFirstSave + 1;
              });
              addState(InitialState, [_util.OPS.beginText, _util.OPS.setFont, _util.OPS.setTextMatrix, _util.OPS.showText, _util.OPS.endText], null, function(context, i) {
                var fnArray = context.fnArray, argsArray = context.argsArray;
                var iFirstSave = context.iCurr - 4;
                var pos = (i - iFirstSave) % 5;
                switch (pos) {
                  case 0:
                    return fnArray[i] === _util.OPS.beginText;
                  case 1:
                    return fnArray[i] === _util.OPS.setFont;
                  case 2:
                    return fnArray[i] === _util.OPS.setTextMatrix;
                  case 3:
                    if (fnArray[i] !== _util.OPS.showText) {
                      return false;
                    }
                    var iFirstSetFont = context.iCurr - 3;
                    var firstSetFontArg0 = argsArray[iFirstSetFont][0];
                    var firstSetFontArg1 = argsArray[iFirstSetFont][1];
                    if (argsArray[i][0] !== firstSetFontArg0 || argsArray[i][1] !== firstSetFontArg1) {
                      return false;
                    }
                    return true;
                  case 4:
                    return fnArray[i] === _util.OPS.endText;
                }
              }, function(context, i) {
                var MIN_CHARS_IN_BLOCK = 3;
                var MAX_CHARS_IN_BLOCK = 1e3;
                var fnArray = context.fnArray, argsArray = context.argsArray;
                var curr = context.iCurr;
                var iFirstBeginText = curr - 4;
                var iFirstSetFont = curr - 3;
                var iFirstSetTextMatrix = curr - 2;
                var iFirstShowText = curr - 1;
                var iFirstEndText = curr;
                var firstSetFontArg0 = argsArray[iFirstSetFont][0];
                var firstSetFontArg1 = argsArray[iFirstSetFont][1];
                var count = Math.min(Math.floor((i - iFirstBeginText) / 5), MAX_CHARS_IN_BLOCK);
                if (count < MIN_CHARS_IN_BLOCK) {
                  return i - (i - iFirstBeginText) % 5;
                }
                var iFirst = iFirstBeginText;
                if (iFirstBeginText >= 4 && fnArray[iFirstBeginText - 4] === fnArray[iFirstSetFont] && fnArray[iFirstBeginText - 3] === fnArray[iFirstSetTextMatrix] && fnArray[iFirstBeginText - 2] === fnArray[iFirstShowText] && fnArray[iFirstBeginText - 1] === fnArray[iFirstEndText] && argsArray[iFirstBeginText - 4][0] === firstSetFontArg0 && argsArray[iFirstBeginText - 4][1] === firstSetFontArg1) {
                  count++;
                  iFirst -= 5;
                }
                var iEndText = iFirst + 4;
                for (var q = 1; q < count; q++) {
                  fnArray.splice(iEndText, 3);
                  argsArray.splice(iEndText, 3);
                  iEndText += 2;
                }
                return iEndText + 1;
              });
              function QueueOptimizer2(queue) {
                this.queue = queue;
                this.state = null;
                this.context = {
                  iCurr: 0,
                  fnArray: queue.fnArray,
                  argsArray: queue.argsArray
                };
                this.match = null;
                this.lastProcessed = 0;
              }
              QueueOptimizer2.prototype = {
                _optimize: function _optimize() {
                  var fnArray = this.queue.fnArray;
                  var i = this.lastProcessed, ii = fnArray.length;
                  var state = this.state;
                  var match = this.match;
                  if (!state && !match && i + 1 === ii && !InitialState[fnArray[i]]) {
                    this.lastProcessed = ii;
                    return;
                  }
                  var context = this.context;
                  while (i < ii) {
                    if (match) {
                      var iterate = (0, match.iterateFn)(context, i);
                      if (iterate) {
                        i++;
                        continue;
                      }
                      i = (0, match.processFn)(context, i + 1);
                      ii = fnArray.length;
                      match = null;
                      state = null;
                      if (i >= ii) {
                        break;
                      }
                    }
                    state = (state || InitialState)[fnArray[i]];
                    if (!state || Array.isArray(state)) {
                      i++;
                      continue;
                    }
                    context.iCurr = i;
                    i++;
                    if (state.checkFn && !(0, state.checkFn)(context)) {
                      state = null;
                      continue;
                    }
                    match = state;
                    state = null;
                  }
                  this.state = state;
                  this.match = match;
                  this.lastProcessed = i;
                },
                push: function push(fn, args) {
                  this.queue.fnArray.push(fn);
                  this.queue.argsArray.push(args);
                  this._optimize();
                },
                flush: function flush() {
                  while (this.match) {
                    var length = this.queue.fnArray.length;
                    this.lastProcessed = (0, this.match.processFn)(this.context, length);
                    this.match = null;
                    this.state = null;
                    this._optimize();
                  }
                },
                reset: function reset() {
                  this.state = null;
                  this.match = null;
                  this.lastProcessed = 0;
                }
              };
              return QueueOptimizer2;
            }();
            var NullOptimizer = function NullOptimizerClosure() {
              function NullOptimizer2(queue) {
                this.queue = queue;
              }
              NullOptimizer2.prototype = {
                push: function push(fn, args) {
                  this.queue.fnArray.push(fn);
                  this.queue.argsArray.push(args);
                },
                flush: function flush() {
                }
              };
              return NullOptimizer2;
            }();
            var OperatorList = function OperatorListClosure() {
              var CHUNK_SIZE = 1e3;
              var CHUNK_SIZE_ABOUT = CHUNK_SIZE - 5;
              function getTransfers(queue) {
                var transfers = [];
                var fnArray = queue.fnArray, argsArray = queue.argsArray;
                for (var i = 0, ii = queue.length; i < ii; i++) {
                  switch (fnArray[i]) {
                    case _util.OPS.paintInlineImageXObject:
                    case _util.OPS.paintInlineImageXObjectGroup:
                    case _util.OPS.paintImageMaskXObject:
                      var arg = argsArray[i][0];
                      if (!arg.cached) {
                        transfers.push(arg.data.buffer);
                      }
                      break;
                  }
                }
                return transfers;
              }
              function OperatorList2(intent, messageHandler, pageIndex) {
                this.messageHandler = messageHandler;
                this.fnArray = [];
                this.argsArray = [];
                if (messageHandler && this.intent !== "oplist") {
                  this.optimizer = new QueueOptimizer(this);
                } else {
                  this.optimizer = new NullOptimizer(this);
                }
                this.dependencies = /* @__PURE__ */ Object.create(null);
                this._totalLength = 0;
                this.pageIndex = pageIndex;
                this.intent = intent;
                this.weight = 0;
              }
              OperatorList2.prototype = {
                get length() {
                  return this.argsArray.length;
                },
                get totalLength() {
                  return this._totalLength + this.length;
                },
                addOp: function addOp(fn, args) {
                  this.optimizer.push(fn, args);
                  this.weight++;
                  if (this.messageHandler) {
                    if (this.weight >= CHUNK_SIZE) {
                      this.flush();
                    } else if (this.weight >= CHUNK_SIZE_ABOUT && (fn === _util.OPS.restore || fn === _util.OPS.endText)) {
                      this.flush();
                    }
                  }
                },
                addDependency: function addDependency(dependency) {
                  if (dependency in this.dependencies) {
                    return;
                  }
                  this.dependencies[dependency] = true;
                  this.addOp(_util.OPS.dependency, [dependency]);
                },
                addDependencies: function addDependencies(dependencies) {
                  for (var key in dependencies) {
                    this.addDependency(key);
                  }
                },
                addOpList: function addOpList(opList) {
                  _util.Util.extendObj(this.dependencies, opList.dependencies);
                  for (var i = 0, ii = opList.length; i < ii; i++) {
                    this.addOp(opList.fnArray[i], opList.argsArray[i]);
                  }
                },
                getIR: function getIR() {
                  return {
                    fnArray: this.fnArray,
                    argsArray: this.argsArray,
                    length: this.length
                  };
                },
                flush: function flush(lastChunk) {
                  this.optimizer.flush();
                  var transfers = getTransfers(this);
                  var length = this.length;
                  this._totalLength += length;
                  this.messageHandler.send("RenderPageChunk", {
                    operatorList: {
                      fnArray: this.fnArray,
                      argsArray: this.argsArray,
                      lastChunk,
                      length
                    },
                    pageIndex: this.pageIndex,
                    intent: this.intent
                  }, transfers);
                  this.dependencies = /* @__PURE__ */ Object.create(null);
                  this.fnArray.length = 0;
                  this.argsArray.length = 0;
                  this.weight = 0;
                  this.optimizer.reset();
                }
              };
              return OperatorList2;
            }();
            exports3.OperatorList = OperatorList;
          },
          /* 135 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.PartialEvaluator = void 0;
            var _util = __w_pdfjs_require__(2);
            var _cmap = __w_pdfjs_require__(136);
            var _stream = __w_pdfjs_require__(121);
            var _primitives = __w_pdfjs_require__(119);
            var _fonts = __w_pdfjs_require__(137);
            var _encodings = __w_pdfjs_require__(140);
            var _unicode = __w_pdfjs_require__(143);
            var _standard_fonts = __w_pdfjs_require__(142);
            var _pattern = __w_pdfjs_require__(146);
            var _parser = __w_pdfjs_require__(120);
            var _bidi = __w_pdfjs_require__(147);
            var _colorspace = __w_pdfjs_require__(132);
            var _glyphlist = __w_pdfjs_require__(141);
            var _metrics = __w_pdfjs_require__(148);
            var _function = __w_pdfjs_require__(149);
            var _jpeg_stream = __w_pdfjs_require__(127);
            var _murmurhash = __w_pdfjs_require__(151);
            var _operator_list = __w_pdfjs_require__(134);
            var _image = __w_pdfjs_require__(152);
            var PartialEvaluator = function PartialEvaluatorClosure() {
              var DefaultPartialEvaluatorOptions = {
                forceDataSchema: false,
                maxImageSize: -1,
                disableFontFace: false,
                nativeImageDecoderSupport: _util.NativeImageDecoding.DECODE,
                ignoreErrors: false,
                isEvalSupported: true
              };
              function NativeImageDecoder(_ref) {
                var xref = _ref.xref, resources = _ref.resources, handler = _ref.handler, _ref$forceDataSchema = _ref.forceDataSchema, forceDataSchema = _ref$forceDataSchema === void 0 ? false : _ref$forceDataSchema, pdfFunctionFactory = _ref.pdfFunctionFactory;
                this.xref = xref;
                this.resources = resources;
                this.handler = handler;
                this.forceDataSchema = forceDataSchema;
                this.pdfFunctionFactory = pdfFunctionFactory;
              }
              NativeImageDecoder.prototype = {
                canDecode: function canDecode(image) {
                  return image instanceof _jpeg_stream.JpegStream && NativeImageDecoder.isDecodable(image, this.xref, this.resources, this.pdfFunctionFactory);
                },
                decode: function decode(image) {
                  var dict = image.dict;
                  var colorSpace = dict.get("ColorSpace", "CS");
                  colorSpace = _colorspace.ColorSpace.parse(colorSpace, this.xref, this.resources, this.pdfFunctionFactory);
                  return this.handler.sendWithPromise("JpegDecode", [image.getIR(this.forceDataSchema), colorSpace.numComps]).then(function(_ref2) {
                    var data = _ref2.data, width = _ref2.width, height = _ref2.height;
                    return new _stream.Stream(data, 0, data.length, image.dict);
                  });
                }
              };
              NativeImageDecoder.isSupported = function(image, xref, res, pdfFunctionFactory) {
                var dict = image.dict;
                if (dict.has("DecodeParms") || dict.has("DP")) {
                  return false;
                }
                var cs = _colorspace.ColorSpace.parse(dict.get("ColorSpace", "CS"), xref, res, pdfFunctionFactory);
                return (cs.name === "DeviceGray" || cs.name === "DeviceRGB") && cs.isDefaultDecode(dict.getArray("Decode", "D"));
              };
              NativeImageDecoder.isDecodable = function(image, xref, res, pdfFunctionFactory) {
                var dict = image.dict;
                if (dict.has("DecodeParms") || dict.has("DP")) {
                  return false;
                }
                var cs = _colorspace.ColorSpace.parse(dict.get("ColorSpace", "CS"), xref, res, pdfFunctionFactory);
                return (cs.numComps === 1 || cs.numComps === 3) && cs.isDefaultDecode(dict.getArray("Decode", "D"));
              };
              function PartialEvaluator2(_ref3) {
                var _this = this;
                var pdfManager = _ref3.pdfManager, xref = _ref3.xref, handler = _ref3.handler, pageIndex = _ref3.pageIndex, idFactory = _ref3.idFactory, fontCache = _ref3.fontCache, builtInCMapCache = _ref3.builtInCMapCache, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? null : _ref3$options, pdfFunctionFactory = _ref3.pdfFunctionFactory;
                this.pdfManager = pdfManager;
                this.xref = xref;
                this.handler = handler;
                this.pageIndex = pageIndex;
                this.idFactory = idFactory;
                this.fontCache = fontCache;
                this.builtInCMapCache = builtInCMapCache;
                this.options = options2 || DefaultPartialEvaluatorOptions;
                this.pdfFunctionFactory = pdfFunctionFactory;
                this.fetchBuiltInCMap = function(name) {
                  var cachedCMap = _this.builtInCMapCache[name];
                  if (cachedCMap) {
                    return Promise.resolve(cachedCMap);
                  }
                  return _this.handler.sendWithPromise("FetchBuiltInCMap", { name }).then(function(data) {
                    if (data.compressionType !== _util.CMapCompressionType.NONE) {
                      _this.builtInCMapCache[name] = data;
                    }
                    return data;
                  });
                };
              }
              var TIME_SLOT_DURATION_MS = 20;
              var CHECK_TIME_EVERY = 100;
              function TimeSlotManager() {
                this.reset();
              }
              TimeSlotManager.prototype = {
                check: function TimeSlotManager_check() {
                  if (++this.checked < CHECK_TIME_EVERY) {
                    return false;
                  }
                  this.checked = 0;
                  return this.endTime <= Date.now();
                },
                reset: function TimeSlotManager_reset() {
                  this.endTime = Date.now() + TIME_SLOT_DURATION_MS;
                  this.checked = 0;
                }
              };
              function normalizeBlendMode(value) {
                if (!(0, _primitives.isName)(value)) {
                  return "source-over";
                }
                switch (value.name) {
                  case "Normal":
                  case "Compatible":
                    return "source-over";
                  case "Multiply":
                    return "multiply";
                  case "Screen":
                    return "screen";
                  case "Overlay":
                    return "overlay";
                  case "Darken":
                    return "darken";
                  case "Lighten":
                    return "lighten";
                  case "ColorDodge":
                    return "color-dodge";
                  case "ColorBurn":
                    return "color-burn";
                  case "HardLight":
                    return "hard-light";
                  case "SoftLight":
                    return "soft-light";
                  case "Difference":
                    return "difference";
                  case "Exclusion":
                    return "exclusion";
                  case "Hue":
                    return "hue";
                  case "Saturation":
                    return "saturation";
                  case "Color":
                    return "color";
                  case "Luminosity":
                    return "luminosity";
                }
                (0, _util.warn)("Unsupported blend mode: " + value.name);
                return "source-over";
              }
              var deferred = Promise.resolve();
              var TILING_PATTERN = 1, SHADING_PATTERN = 2;
              PartialEvaluator2.prototype = {
                clone: function clone() {
                  var newOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DefaultPartialEvaluatorOptions;
                  var newEvaluator = Object.create(this);
                  newEvaluator.options = newOptions;
                  return newEvaluator;
                },
                hasBlendModes: function PartialEvaluator_hasBlendModes(resources) {
                  if (!(0, _primitives.isDict)(resources)) {
                    return false;
                  }
                  var processed = /* @__PURE__ */ Object.create(null);
                  if (resources.objId) {
                    processed[resources.objId] = true;
                  }
                  var nodes = [resources], xref = this.xref;
                  while (nodes.length) {
                    var key, i, ii;
                    var node = nodes.shift();
                    var graphicStates = node.get("ExtGState");
                    if ((0, _primitives.isDict)(graphicStates)) {
                      var graphicStatesKeys = graphicStates.getKeys();
                      for (i = 0, ii = graphicStatesKeys.length; i < ii; i++) {
                        key = graphicStatesKeys[i];
                        var graphicState = graphicStates.get(key);
                        var bm = graphicState.get("BM");
                        if ((0, _primitives.isName)(bm) && bm.name !== "Normal") {
                          return true;
                        }
                      }
                    }
                    var xObjects = node.get("XObject");
                    if (!(0, _primitives.isDict)(xObjects)) {
                      continue;
                    }
                    var xObjectsKeys = xObjects.getKeys();
                    for (i = 0, ii = xObjectsKeys.length; i < ii; i++) {
                      key = xObjectsKeys[i];
                      var xObject = xObjects.getRaw(key);
                      if ((0, _primitives.isRef)(xObject)) {
                        if (processed[xObject.toString()]) {
                          continue;
                        }
                        xObject = xref.fetch(xObject);
                      }
                      if (!(0, _primitives.isStream)(xObject)) {
                        continue;
                      }
                      if (xObject.dict.objId) {
                        if (processed[xObject.dict.objId]) {
                          continue;
                        }
                        processed[xObject.dict.objId] = true;
                      }
                      var xResources = xObject.dict.get("Resources");
                      if ((0, _primitives.isDict)(xResources) && (!xResources.objId || !processed[xResources.objId])) {
                        nodes.push(xResources);
                        if (xResources.objId) {
                          processed[xResources.objId] = true;
                        }
                      }
                    }
                  }
                  return false;
                },
                buildFormXObject: function PartialEvaluator_buildFormXObject(resources, xobj, smask, operatorList, task, initialState) {
                  var dict = xobj.dict;
                  var matrix = dict.getArray("Matrix");
                  var bbox = dict.getArray("BBox");
                  var group = dict.get("Group");
                  if (group) {
                    var groupOptions = {
                      matrix,
                      bbox,
                      smask,
                      isolated: false,
                      knockout: false
                    };
                    var groupSubtype = group.get("S");
                    var colorSpace = null;
                    if ((0, _primitives.isName)(groupSubtype, "Transparency")) {
                      groupOptions.isolated = group.get("I") || false;
                      groupOptions.knockout = group.get("K") || false;
                      if (group.has("CS")) {
                        colorSpace = _colorspace.ColorSpace.parse(group.get("CS"), this.xref, resources, this.pdfFunctionFactory);
                      }
                    }
                    if (smask && smask.backdrop) {
                      colorSpace = colorSpace || _colorspace.ColorSpace.singletons.rgb;
                      smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
                    }
                    operatorList.addOp(_util.OPS.beginGroup, [groupOptions]);
                  }
                  operatorList.addOp(_util.OPS.paintFormXObjectBegin, [matrix, bbox]);
                  return this.getOperatorList({
                    stream: xobj,
                    task,
                    resources: dict.get("Resources") || resources,
                    operatorList,
                    initialState
                  }).then(function() {
                    operatorList.addOp(_util.OPS.paintFormXObjectEnd, []);
                    if (group) {
                      operatorList.addOp(_util.OPS.endGroup, [groupOptions]);
                    }
                  });
                },
                buildPaintImageXObject: function buildPaintImageXObject(_ref4) {
                  var _this2 = this;
                  var resources = _ref4.resources, image = _ref4.image, _ref4$isInline = _ref4.isInline, isInline = _ref4$isInline === void 0 ? false : _ref4$isInline, operatorList = _ref4.operatorList, cacheKey = _ref4.cacheKey, imageCache = _ref4.imageCache, _ref4$forceDisableNat = _ref4.forceDisableNativeImageDecoder, forceDisableNativeImageDecoder = _ref4$forceDisableNat === void 0 ? false : _ref4$forceDisableNat;
                  var dict = image.dict;
                  var w = dict.get("Width", "W");
                  var h = dict.get("Height", "H");
                  if (!(w && (0, _util.isNum)(w)) || !(h && (0, _util.isNum)(h))) {
                    (0, _util.warn)("Image dimensions are missing, or not numbers.");
                    return Promise.resolve();
                  }
                  var maxImageSize = this.options.maxImageSize;
                  if (maxImageSize !== -1 && w * h > maxImageSize) {
                    (0, _util.warn)("Image exceeded maximum allowed size and was removed.");
                    return Promise.resolve();
                  }
                  var imageMask = dict.get("ImageMask", "IM") || false;
                  var imgData, args;
                  if (imageMask) {
                    var width = dict.get("Width", "W");
                    var height = dict.get("Height", "H");
                    var bitStrideLength = width + 7 >> 3;
                    var imgArray = image.getBytes(bitStrideLength * height);
                    var decode = dict.getArray("Decode", "D");
                    imgData = _image.PDFImage.createMask({
                      imgArray,
                      width,
                      height,
                      imageIsFromDecodeStream: image instanceof _stream.DecodeStream,
                      inverseDecode: !!decode && decode[0] > 0
                    });
                    imgData.cached = true;
                    args = [imgData];
                    operatorList.addOp(_util.OPS.paintImageMaskXObject, args);
                    if (cacheKey) {
                      imageCache[cacheKey] = {
                        fn: _util.OPS.paintImageMaskXObject,
                        args
                      };
                    }
                    return Promise.resolve();
                  }
                  var softMask = dict.get("SMask", "SM") || false;
                  var mask = dict.get("Mask") || false;
                  var SMALL_IMAGE_DIMENSIONS = 200;
                  if (isInline && !softMask && !mask && !(image instanceof _jpeg_stream.JpegStream) && w + h < SMALL_IMAGE_DIMENSIONS) {
                    var imageObj = new _image.PDFImage({
                      xref: this.xref,
                      res: resources,
                      image,
                      isInline,
                      pdfFunctionFactory: this.pdfFunctionFactory
                    });
                    imgData = imageObj.createImageData(true);
                    operatorList.addOp(_util.OPS.paintInlineImageXObject, [imgData]);
                    return Promise.resolve();
                  }
                  var nativeImageDecoderSupport = forceDisableNativeImageDecoder ? _util.NativeImageDecoding.NONE : this.options.nativeImageDecoderSupport;
                  var objId = "img_" + this.idFactory.createObjId();
                  if (nativeImageDecoderSupport !== _util.NativeImageDecoding.NONE && !softMask && !mask && image instanceof _jpeg_stream.JpegStream && NativeImageDecoder.isSupported(image, this.xref, resources, this.pdfFunctionFactory)) {
                    return this.handler.sendWithPromise("obj", [objId, this.pageIndex, "JpegStream", image.getIR(this.options.forceDataSchema)]).then(function() {
                      operatorList.addDependency(objId);
                      args = [objId, w, h];
                      operatorList.addOp(_util.OPS.paintJpegXObject, args);
                      if (cacheKey) {
                        imageCache[cacheKey] = {
                          fn: _util.OPS.paintJpegXObject,
                          args
                        };
                      }
                    }, function(reason) {
                      (0, _util.warn)("Native JPEG decoding failed -- trying to recover: " + (reason && reason.message));
                      return _this2.buildPaintImageXObject({
                        resources,
                        image,
                        isInline,
                        operatorList,
                        cacheKey,
                        imageCache,
                        forceDisableNativeImageDecoder: true
                      });
                    });
                  }
                  var nativeImageDecoder = null;
                  if (nativeImageDecoderSupport === _util.NativeImageDecoding.DECODE && (image instanceof _jpeg_stream.JpegStream || mask instanceof _jpeg_stream.JpegStream || softMask instanceof _jpeg_stream.JpegStream)) {
                    nativeImageDecoder = new NativeImageDecoder({
                      xref: this.xref,
                      resources,
                      handler: this.handler,
                      forceDataSchema: this.options.forceDataSchema,
                      pdfFunctionFactory: this.pdfFunctionFactory
                    });
                  }
                  operatorList.addDependency(objId);
                  args = [objId, w, h];
                  _image.PDFImage.buildImage({
                    handler: this.handler,
                    xref: this.xref,
                    res: resources,
                    image,
                    isInline,
                    nativeDecoder: nativeImageDecoder,
                    pdfFunctionFactory: this.pdfFunctionFactory
                  }).then(function(imageObj2) {
                    var imgData2 = imageObj2.createImageData(false);
                    _this2.handler.send("obj", [objId, _this2.pageIndex, "Image", imgData2], [imgData2.data.buffer]);
                  }).catch(function(reason) {
                    (0, _util.warn)("Unable to decode image: " + reason);
                    _this2.handler.send("obj", [objId, _this2.pageIndex, "Image", null]);
                  });
                  operatorList.addOp(_util.OPS.paintImageXObject, args);
                  if (cacheKey) {
                    imageCache[cacheKey] = {
                      fn: _util.OPS.paintImageXObject,
                      args
                    };
                  }
                  return Promise.resolve();
                },
                handleSMask: function PartialEvaluator_handleSmask(smask, resources, operatorList, task, stateManager) {
                  var smaskContent = smask.get("G");
                  var smaskOptions = {
                    subtype: smask.get("S").name,
                    backdrop: smask.get("BC")
                  };
                  var transferObj = smask.get("TR");
                  if ((0, _function.isPDFFunction)(transferObj)) {
                    var transferFn = this.pdfFunctionFactory.create(transferObj);
                    var transferMap = new Uint8Array(256);
                    var tmp = new Float32Array(1);
                    for (var i = 0; i < 256; i++) {
                      tmp[0] = i / 255;
                      transferFn(tmp, 0, tmp, 0);
                      transferMap[i] = tmp[0] * 255 | 0;
                    }
                    smaskOptions.transferMap = transferMap;
                  }
                  return this.buildFormXObject(resources, smaskContent, smaskOptions, operatorList, task, stateManager.state.clone());
                },
                handleTilingType: function handleTilingType(fn, args, resources, pattern, patternDict, operatorList, task) {
                  var _this3 = this;
                  var tilingOpList = new _operator_list.OperatorList();
                  var resourcesArray = [patternDict.get("Resources"), resources];
                  var patternResources = _primitives.Dict.merge(this.xref, resourcesArray);
                  return this.getOperatorList({
                    stream: pattern,
                    task,
                    resources: patternResources,
                    operatorList: tilingOpList
                  }).then(function() {
                    return (0, _pattern.getTilingPatternIR)({
                      fnArray: tilingOpList.fnArray,
                      argsArray: tilingOpList.argsArray
                    }, patternDict, args);
                  }).then(function(tilingPatternIR) {
                    operatorList.addDependencies(tilingOpList.dependencies);
                    operatorList.addOp(fn, tilingPatternIR);
                  }, function(reason) {
                    if (_this3.options.ignoreErrors) {
                      _this3.handler.send("UnsupportedFeature", { featureId: _util.UNSUPPORTED_FEATURES.unknown });
                      (0, _util.warn)('handleTilingType - ignoring pattern: "' + reason + '".');
                      return;
                    }
                    throw reason;
                  });
                },
                handleSetFont: function PartialEvaluator_handleSetFont(resources, fontArgs, fontRef, operatorList, task, state) {
                  var _this4 = this;
                  var fontName;
                  if (fontArgs) {
                    fontArgs = fontArgs.slice();
                    fontName = fontArgs[0].name;
                  }
                  return this.loadFont(fontName, fontRef, resources).then(function(translated) {
                    if (!translated.font.isType3Font) {
                      return translated;
                    }
                    return translated.loadType3Data(_this4, resources, operatorList, task).then(function() {
                      return translated;
                    }).catch(function(reason) {
                      _this4.handler.send("UnsupportedFeature", { featureId: _util.UNSUPPORTED_FEATURES.font });
                      return new TranslatedFont("g_font_error", new _fonts.ErrorFont("Type3 font load error: " + reason), translated.font);
                    });
                  }).then(function(translated) {
                    state.font = translated.font;
                    translated.send(_this4.handler);
                    return translated.loadedName;
                  });
                },
                handleText: function PartialEvaluator_handleText(chars, state) {
                  var _this5 = this;
                  var font = state.font;
                  var glyphs = font.charsToGlyphs(chars);
                  var isAddToPathSet = !!(state.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
                  if (font.data && (isAddToPathSet || this.options.disableFontFace || state.fillColorSpace.name === "Pattern")) {
                    var buildPath = function buildPath2(fontChar) {
                      if (!font.renderer.hasBuiltPath(fontChar)) {
                        var path = font.renderer.getPathJs(fontChar);
                        _this5.handler.send("commonobj", [font.loadedName + "_path_" + fontChar, "FontPath", path]);
                      }
                    };
                    for (var i = 0, ii = glyphs.length; i < ii; i++) {
                      var glyph = glyphs[i];
                      buildPath(glyph.fontChar);
                      var accent = glyph.accent;
                      if (accent && accent.fontChar) {
                        buildPath(accent.fontChar);
                      }
                    }
                  }
                  return glyphs;
                },
                setGState: function PartialEvaluator_setGState(resources, gState, operatorList, task, stateManager) {
                  var _this6 = this;
                  var gStateObj = [];
                  var gStateKeys = gState.getKeys();
                  var promise = Promise.resolve();
                  var _loop = function _loop2() {
                    var key = gStateKeys[i];
                    var value = gState.get(key);
                    switch (key) {
                      case "Type":
                        break;
                      case "LW":
                      case "LC":
                      case "LJ":
                      case "ML":
                      case "D":
                      case "RI":
                      case "FL":
                      case "CA":
                      case "ca":
                        gStateObj.push([key, value]);
                        break;
                      case "Font":
                        promise = promise.then(function() {
                          return _this6.handleSetFont(resources, null, value[0], operatorList, task, stateManager.state).then(function(loadedName) {
                            operatorList.addDependency(loadedName);
                            gStateObj.push([key, [loadedName, value[1]]]);
                          });
                        });
                        break;
                      case "BM":
                        gStateObj.push([key, normalizeBlendMode(value)]);
                        break;
                      case "SMask":
                        if ((0, _primitives.isName)(value, "None")) {
                          gStateObj.push([key, false]);
                          break;
                        }
                        if ((0, _primitives.isDict)(value)) {
                          promise = promise.then(function() {
                            return _this6.handleSMask(value, resources, operatorList, task, stateManager);
                          });
                          gStateObj.push([key, true]);
                        } else {
                          (0, _util.warn)("Unsupported SMask type");
                        }
                        break;
                      case "OP":
                      case "op":
                      case "OPM":
                      case "BG":
                      case "BG2":
                      case "UCR":
                      case "UCR2":
                      case "TR":
                      case "TR2":
                      case "HT":
                      case "SM":
                      case "SA":
                      case "AIS":
                      case "TK":
                        (0, _util.info)("graphic state operator " + key);
                        break;
                      default:
                        (0, _util.info)("Unknown graphic state operator " + key);
                        break;
                    }
                  };
                  for (var i = 0, ii = gStateKeys.length; i < ii; i++) {
                    _loop();
                  }
                  return promise.then(function() {
                    if (gStateObj.length > 0) {
                      operatorList.addOp(_util.OPS.setGState, [gStateObj]);
                    }
                  });
                },
                loadFont: function PartialEvaluator_loadFont(fontName, font, resources) {
                  var _this7 = this;
                  function errorFont() {
                    return Promise.resolve(new TranslatedFont("g_font_error", new _fonts.ErrorFont("Font " + fontName + " is not available"), font));
                  }
                  var fontRef, xref = this.xref;
                  if (font) {
                    if (!(0, _primitives.isRef)(font)) {
                      throw new Error('The "font" object should be a reference.');
                    }
                    fontRef = font;
                  } else {
                    var fontRes = resources.get("Font");
                    if (fontRes) {
                      fontRef = fontRes.getRaw(fontName);
                    } else {
                      (0, _util.warn)("fontRes not available");
                      return errorFont();
                    }
                  }
                  if (!fontRef) {
                    (0, _util.warn)("fontRef not available");
                    return errorFont();
                  }
                  if (this.fontCache.has(fontRef)) {
                    return this.fontCache.get(fontRef);
                  }
                  font = xref.fetchIfRef(fontRef);
                  if (!(0, _primitives.isDict)(font)) {
                    return errorFont();
                  }
                  if (font.translated) {
                    return font.translated;
                  }
                  var fontCapability = (0, _util.createPromiseCapability)();
                  var preEvaluatedFont = this.preEvaluateFont(font);
                  var descriptor = preEvaluatedFont.descriptor;
                  var fontRefIsRef = (0, _primitives.isRef)(fontRef), fontID;
                  if (fontRefIsRef) {
                    fontID = fontRef.toString();
                  }
                  if ((0, _primitives.isDict)(descriptor)) {
                    if (!descriptor.fontAliases) {
                      descriptor.fontAliases = /* @__PURE__ */ Object.create(null);
                    }
                    var fontAliases = descriptor.fontAliases;
                    var hash = preEvaluatedFont.hash;
                    if (fontAliases[hash]) {
                      var aliasFontRef = fontAliases[hash].aliasRef;
                      if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
                        this.fontCache.putAlias(fontRef, aliasFontRef);
                        return this.fontCache.get(fontRef);
                      }
                    } else {
                      fontAliases[hash] = { fontID: _fonts.Font.getFontID() };
                    }
                    if (fontRefIsRef) {
                      fontAliases[hash].aliasRef = fontRef;
                    }
                    fontID = fontAliases[hash].fontID;
                  }
                  if (fontRefIsRef) {
                    this.fontCache.put(fontRef, fontCapability.promise);
                  } else {
                    if (!fontID) {
                      fontID = this.idFactory.createObjId();
                    }
                    this.fontCache.put("id_" + fontID, fontCapability.promise);
                  }
                  (0, _util.assert)(fontID, 'The "fontID" must be defined.');
                  font.loadedName = "g_" + this.pdfManager.docId + "_f" + fontID;
                  font.translated = fontCapability.promise;
                  var translatedPromise;
                  try {
                    translatedPromise = this.translateFont(preEvaluatedFont);
                  } catch (e) {
                    translatedPromise = Promise.reject(e);
                  }
                  translatedPromise.then(function(translatedFont) {
                    if (translatedFont.fontType !== void 0) {
                      var xrefFontStats = xref.stats.fontTypes;
                      xrefFontStats[translatedFont.fontType] = true;
                    }
                    fontCapability.resolve(new TranslatedFont(font.loadedName, translatedFont, font));
                  }).catch(function(reason) {
                    _this7.handler.send("UnsupportedFeature", { featureId: _util.UNSUPPORTED_FEATURES.font });
                    try {
                      var descriptor2 = preEvaluatedFont.descriptor;
                      var fontFile3 = descriptor2 && descriptor2.get("FontFile3");
                      var subtype = fontFile3 && fontFile3.get("Subtype");
                      var fontType = (0, _fonts.getFontType)(preEvaluatedFont.type, subtype && subtype.name);
                      var xrefFontStats = xref.stats.fontTypes;
                      xrefFontStats[fontType] = true;
                    } catch (ex) {
                    }
                    fontCapability.resolve(new TranslatedFont(font.loadedName, new _fonts.ErrorFont(reason instanceof Error ? reason.message : reason), font));
                  });
                  return fontCapability.promise;
                },
                buildPath: function PartialEvaluator_buildPath(operatorList, fn, args) {
                  var lastIndex = operatorList.length - 1;
                  if (!args) {
                    args = [];
                  }
                  if (lastIndex < 0 || operatorList.fnArray[lastIndex] !== _util.OPS.constructPath) {
                    operatorList.addOp(_util.OPS.constructPath, [[fn], args]);
                  } else {
                    var opArgs = operatorList.argsArray[lastIndex];
                    opArgs[0].push(fn);
                    Array.prototype.push.apply(opArgs[1], args);
                  }
                },
                handleColorN: function PartialEvaluator_handleColorN(operatorList, fn, args, cs, patterns, resources, task) {
                  var patternName = args[args.length - 1];
                  var pattern;
                  if ((0, _primitives.isName)(patternName) && (pattern = patterns.get(patternName.name))) {
                    var dict = (0, _primitives.isStream)(pattern) ? pattern.dict : pattern;
                    var typeNum = dict.get("PatternType");
                    if (typeNum === TILING_PATTERN) {
                      var color = cs.base ? cs.base.getRgb(args, 0) : null;
                      return this.handleTilingType(fn, color, resources, pattern, dict, operatorList, task);
                    } else if (typeNum === SHADING_PATTERN) {
                      var shading = dict.get("Shading");
                      var matrix = dict.getArray("Matrix");
                      pattern = _pattern.Pattern.parseShading(shading, matrix, this.xref, resources, this.handler, this.pdfFunctionFactory);
                      operatorList.addOp(fn, pattern.getIR());
                      return Promise.resolve();
                    }
                    return Promise.reject(new Error("Unknown PatternType: " + typeNum));
                  }
                  operatorList.addOp(fn, args);
                  return Promise.resolve();
                },
                getOperatorList: function getOperatorList(_ref5) {
                  var _this8 = this;
                  var stream2 = _ref5.stream, task = _ref5.task, resources = _ref5.resources, operatorList = _ref5.operatorList, _ref5$initialState = _ref5.initialState, initialState = _ref5$initialState === void 0 ? null : _ref5$initialState;
                  resources = resources || _primitives.Dict.empty;
                  initialState = initialState || new EvalState();
                  if (!operatorList) {
                    throw new Error('getOperatorList: missing "operatorList" parameter');
                  }
                  var self2 = this;
                  var xref = this.xref;
                  var imageCache = /* @__PURE__ */ Object.create(null);
                  var xobjs = resources.get("XObject") || _primitives.Dict.empty;
                  var patterns = resources.get("Pattern") || _primitives.Dict.empty;
                  var stateManager = new StateManager(initialState);
                  var preprocessor = new EvaluatorPreprocessor(stream2, xref, stateManager);
                  var timeSlotManager = new TimeSlotManager();
                  function closePendingRestoreOPS(argument) {
                    for (var i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
                      operatorList.addOp(_util.OPS.restore, []);
                    }
                  }
                  return new Promise(function promiseBody(resolve2, reject2) {
                    var next = function next2(promise) {
                      promise.then(function() {
                        try {
                          promiseBody(resolve2, reject2);
                        } catch (ex) {
                          reject2(ex);
                        }
                      }, reject2);
                    };
                    task.ensureNotTerminated();
                    timeSlotManager.reset();
                    var stop, operation = {}, i, ii, cs;
                    while (!(stop = timeSlotManager.check())) {
                      operation.args = null;
                      if (!preprocessor.read(operation)) {
                        break;
                      }
                      var args = operation.args;
                      var fn = operation.fn;
                      switch (fn | 0) {
                        case _util.OPS.paintXObject:
                          var name = args[0].name;
                          if (name && imageCache[name] !== void 0) {
                            operatorList.addOp(imageCache[name].fn, imageCache[name].args);
                            args = null;
                            continue;
                          }
                          next(new Promise(function(resolveXObject, rejectXObject) {
                            if (!name) {
                              throw new _util.FormatError("XObject must be referred to by name.");
                            }
                            var xobj = xobjs.get(name);
                            if (!xobj) {
                              operatorList.addOp(fn, args);
                              resolveXObject();
                              return;
                            }
                            if (!(0, _primitives.isStream)(xobj)) {
                              throw new _util.FormatError("XObject should be a stream");
                            }
                            var type = xobj.dict.get("Subtype");
                            if (!(0, _primitives.isName)(type)) {
                              throw new _util.FormatError("XObject should have a Name subtype");
                            }
                            if (type.name === "Form") {
                              stateManager.save();
                              self2.buildFormXObject(resources, xobj, null, operatorList, task, stateManager.state.clone()).then(function() {
                                stateManager.restore();
                                resolveXObject();
                              }, rejectXObject);
                              return;
                            } else if (type.name === "Image") {
                              self2.buildPaintImageXObject({
                                resources,
                                image: xobj,
                                operatorList,
                                cacheKey: name,
                                imageCache
                              }).then(resolveXObject, rejectXObject);
                              return;
                            } else if (type.name === "PS") {
                              (0, _util.info)("Ignored XObject subtype PS");
                            } else {
                              throw new _util.FormatError("Unhandled XObject subtype " + type.name);
                            }
                            resolveXObject();
                          }).catch(function(reason) {
                            if (self2.options.ignoreErrors) {
                              self2.handler.send("UnsupportedFeature", { featureId: _util.UNSUPPORTED_FEATURES.unknown });
                              (0, _util.warn)('getOperatorList - ignoring XObject: "' + reason + '".');
                              return;
                            }
                            throw reason;
                          }));
                          return;
                        case _util.OPS.setFont:
                          var fontSize = args[1];
                          next(self2.handleSetFont(resources, args, null, operatorList, task, stateManager.state).then(function(loadedName) {
                            operatorList.addDependency(loadedName);
                            operatorList.addOp(_util.OPS.setFont, [loadedName, fontSize]);
                          }));
                          return;
                        case _util.OPS.endInlineImage:
                          var cacheKey = args[0].cacheKey;
                          if (cacheKey) {
                            var cacheEntry = imageCache[cacheKey];
                            if (cacheEntry !== void 0) {
                              operatorList.addOp(cacheEntry.fn, cacheEntry.args);
                              args = null;
                              continue;
                            }
                          }
                          next(self2.buildPaintImageXObject({
                            resources,
                            image: args[0],
                            isInline: true,
                            operatorList,
                            cacheKey,
                            imageCache
                          }));
                          return;
                        case _util.OPS.showText:
                          args[0] = self2.handleText(args[0], stateManager.state);
                          break;
                        case _util.OPS.showSpacedText:
                          var arr = args[0];
                          var combinedGlyphs = [];
                          var arrLength = arr.length;
                          var state = stateManager.state;
                          for (i = 0; i < arrLength; ++i) {
                            var arrItem = arr[i];
                            if ((0, _util.isString)(arrItem)) {
                              Array.prototype.push.apply(combinedGlyphs, self2.handleText(arrItem, state));
                            } else if ((0, _util.isNum)(arrItem)) {
                              combinedGlyphs.push(arrItem);
                            }
                          }
                          args[0] = combinedGlyphs;
                          fn = _util.OPS.showText;
                          break;
                        case _util.OPS.nextLineShowText:
                          operatorList.addOp(_util.OPS.nextLine);
                          args[0] = self2.handleText(args[0], stateManager.state);
                          fn = _util.OPS.showText;
                          break;
                        case _util.OPS.nextLineSetSpacingShowText:
                          operatorList.addOp(_util.OPS.nextLine);
                          operatorList.addOp(_util.OPS.setWordSpacing, [args.shift()]);
                          operatorList.addOp(_util.OPS.setCharSpacing, [args.shift()]);
                          args[0] = self2.handleText(args[0], stateManager.state);
                          fn = _util.OPS.showText;
                          break;
                        case _util.OPS.setTextRenderingMode:
                          stateManager.state.textRenderingMode = args[0];
                          break;
                        case _util.OPS.setFillColorSpace:
                          stateManager.state.fillColorSpace = _colorspace.ColorSpace.parse(args[0], xref, resources, self2.pdfFunctionFactory);
                          continue;
                        case _util.OPS.setStrokeColorSpace:
                          stateManager.state.strokeColorSpace = _colorspace.ColorSpace.parse(args[0], xref, resources, self2.pdfFunctionFactory);
                          continue;
                        case _util.OPS.setFillColor:
                          cs = stateManager.state.fillColorSpace;
                          args = cs.getRgb(args, 0);
                          fn = _util.OPS.setFillRGBColor;
                          break;
                        case _util.OPS.setStrokeColor:
                          cs = stateManager.state.strokeColorSpace;
                          args = cs.getRgb(args, 0);
                          fn = _util.OPS.setStrokeRGBColor;
                          break;
                        case _util.OPS.setFillGray:
                          stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
                          args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
                          fn = _util.OPS.setFillRGBColor;
                          break;
                        case _util.OPS.setStrokeGray:
                          stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
                          args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
                          fn = _util.OPS.setStrokeRGBColor;
                          break;
                        case _util.OPS.setFillCMYKColor:
                          stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.cmyk;
                          args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
                          fn = _util.OPS.setFillRGBColor;
                          break;
                        case _util.OPS.setStrokeCMYKColor:
                          stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.cmyk;
                          args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
                          fn = _util.OPS.setStrokeRGBColor;
                          break;
                        case _util.OPS.setFillRGBColor:
                          stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.rgb;
                          args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
                          break;
                        case _util.OPS.setStrokeRGBColor:
                          stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.rgb;
                          args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
                          break;
                        case _util.OPS.setFillColorN:
                          cs = stateManager.state.fillColorSpace;
                          if (cs.name === "Pattern") {
                            next(self2.handleColorN(operatorList, _util.OPS.setFillColorN, args, cs, patterns, resources, task));
                            return;
                          }
                          args = cs.getRgb(args, 0);
                          fn = _util.OPS.setFillRGBColor;
                          break;
                        case _util.OPS.setStrokeColorN:
                          cs = stateManager.state.strokeColorSpace;
                          if (cs.name === "Pattern") {
                            next(self2.handleColorN(operatorList, _util.OPS.setStrokeColorN, args, cs, patterns, resources, task));
                            return;
                          }
                          args = cs.getRgb(args, 0);
                          fn = _util.OPS.setStrokeRGBColor;
                          break;
                        case _util.OPS.shadingFill:
                          var shadingRes = resources.get("Shading");
                          if (!shadingRes) {
                            throw new _util.FormatError("No shading resource found");
                          }
                          var shading = shadingRes.get(args[0].name);
                          if (!shading) {
                            throw new _util.FormatError("No shading object found");
                          }
                          var shadingFill = _pattern.Pattern.parseShading(shading, null, xref, resources, self2.handler, self2.pdfFunctionFactory);
                          var patternIR = shadingFill.getIR();
                          args = [patternIR];
                          fn = _util.OPS.shadingFill;
                          break;
                        case _util.OPS.setGState:
                          var dictName = args[0];
                          var extGState = resources.get("ExtGState");
                          if (!(0, _primitives.isDict)(extGState) || !extGState.has(dictName.name)) {
                            break;
                          }
                          var gState = extGState.get(dictName.name);
                          next(self2.setGState(resources, gState, operatorList, task, stateManager));
                          return;
                        case _util.OPS.moveTo:
                        case _util.OPS.lineTo:
                        case _util.OPS.curveTo:
                        case _util.OPS.curveTo2:
                        case _util.OPS.curveTo3:
                        case _util.OPS.closePath:
                          self2.buildPath(operatorList, fn, args);
                          continue;
                        case _util.OPS.rectangle:
                          self2.buildPath(operatorList, fn, args);
                          continue;
                        case _util.OPS.markPoint:
                        case _util.OPS.markPointProps:
                        case _util.OPS.beginMarkedContent:
                        case _util.OPS.beginMarkedContentProps:
                        case _util.OPS.endMarkedContent:
                        case _util.OPS.beginCompat:
                        case _util.OPS.endCompat:
                          continue;
                        default:
                          if (args !== null) {
                            for (i = 0, ii = args.length; i < ii; i++) {
                              if (args[i] instanceof _primitives.Dict) {
                                break;
                              }
                            }
                            if (i < ii) {
                              (0, _util.warn)("getOperatorList - ignoring operator: " + fn);
                              continue;
                            }
                          }
                      }
                      operatorList.addOp(fn, args);
                    }
                    if (stop) {
                      next(deferred);
                      return;
                    }
                    closePendingRestoreOPS();
                    resolve2();
                  }).catch(function(reason) {
                    if (_this8.options.ignoreErrors) {
                      _this8.handler.send("UnsupportedFeature", { featureId: _util.UNSUPPORTED_FEATURES.unknown });
                      (0, _util.warn)("getOperatorList - ignoring errors during task: " + task.name);
                      closePendingRestoreOPS();
                      return;
                    }
                    throw reason;
                  });
                },
                getTextContent: function getTextContent(_ref6) {
                  var _this9 = this;
                  var stream2 = _ref6.stream, task = _ref6.task, resources = _ref6.resources, _ref6$stateManager = _ref6.stateManager, stateManager = _ref6$stateManager === void 0 ? null : _ref6$stateManager, _ref6$normalizeWhites = _ref6.normalizeWhitespace, normalizeWhitespace = _ref6$normalizeWhites === void 0 ? false : _ref6$normalizeWhites, _ref6$combineTextItem = _ref6.combineTextItems, combineTextItems = _ref6$combineTextItem === void 0 ? false : _ref6$combineTextItem, sink = _ref6.sink, _ref6$seenStyles = _ref6.seenStyles, seenStyles = _ref6$seenStyles === void 0 ? /* @__PURE__ */ Object.create(null) : _ref6$seenStyles;
                  resources = resources || _primitives.Dict.empty;
                  stateManager = stateManager || new StateManager(new TextState());
                  var WhitespaceRegexp = /\s/g;
                  var textContent = {
                    items: [],
                    styles: /* @__PURE__ */ Object.create(null)
                  };
                  var textContentItem = {
                    initialized: false,
                    str: [],
                    width: 0,
                    height: 0,
                    vertical: false,
                    lastAdvanceWidth: 0,
                    lastAdvanceHeight: 0,
                    textAdvanceScale: 0,
                    spaceWidth: 0,
                    fakeSpaceMin: Infinity,
                    fakeMultiSpaceMin: Infinity,
                    fakeMultiSpaceMax: -0,
                    textRunBreakAllowed: false,
                    transform: null,
                    fontName: null
                  };
                  var SPACE_FACTOR = 0.3;
                  var MULTI_SPACE_FACTOR = 1.5;
                  var MULTI_SPACE_FACTOR_MAX = 4;
                  var self2 = this;
                  var xref = this.xref;
                  var xobjs = null;
                  var skipEmptyXObjs = /* @__PURE__ */ Object.create(null);
                  var preprocessor = new EvaluatorPreprocessor(stream2, xref, stateManager);
                  var textState;
                  function ensureTextContentItem() {
                    if (textContentItem.initialized) {
                      return textContentItem;
                    }
                    var font = textState.font;
                    if (!(font.loadedName in seenStyles)) {
                      seenStyles[font.loadedName] = true;
                      textContent.styles[font.loadedName] = {
                        fontFamily: font.fallbackName,
                        ascent: font.ascent,
                        descent: font.descent,
                        vertical: font.vertical
                      };
                    }
                    textContentItem.fontName = font.loadedName;
                    var tsm = [textState.fontSize * textState.textHScale, 0, 0, textState.fontSize, 0, textState.textRise];
                    if (font.isType3Font && textState.fontMatrix !== _util.FONT_IDENTITY_MATRIX && textState.fontSize === 1) {
                      var glyphHeight = font.bbox[3] - font.bbox[1];
                      if (glyphHeight > 0) {
                        glyphHeight = glyphHeight * textState.fontMatrix[3];
                        tsm[3] *= glyphHeight;
                      }
                    }
                    var trm = _util.Util.transform(textState.ctm, _util.Util.transform(textState.textMatrix, tsm));
                    textContentItem.transform = trm;
                    if (!font.vertical) {
                      textContentItem.width = 0;
                      textContentItem.height = Math.sqrt(trm[2] * trm[2] + trm[3] * trm[3]);
                      textContentItem.vertical = false;
                    } else {
                      textContentItem.width = Math.sqrt(trm[0] * trm[0] + trm[1] * trm[1]);
                      textContentItem.height = 0;
                      textContentItem.vertical = true;
                    }
                    var a = textState.textLineMatrix[0];
                    var b = textState.textLineMatrix[1];
                    var scaleLineX = Math.sqrt(a * a + b * b);
                    a = textState.ctm[0];
                    b = textState.ctm[1];
                    var scaleCtmX = Math.sqrt(a * a + b * b);
                    textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
                    textContentItem.lastAdvanceWidth = 0;
                    textContentItem.lastAdvanceHeight = 0;
                    var spaceWidth = font.spaceWidth / 1e3 * textState.fontSize;
                    if (spaceWidth) {
                      textContentItem.spaceWidth = spaceWidth;
                      textContentItem.fakeSpaceMin = spaceWidth * SPACE_FACTOR;
                      textContentItem.fakeMultiSpaceMin = spaceWidth * MULTI_SPACE_FACTOR;
                      textContentItem.fakeMultiSpaceMax = spaceWidth * MULTI_SPACE_FACTOR_MAX;
                      textContentItem.textRunBreakAllowed = !font.isMonospace;
                    } else {
                      textContentItem.spaceWidth = 0;
                      textContentItem.fakeSpaceMin = Infinity;
                      textContentItem.fakeMultiSpaceMin = Infinity;
                      textContentItem.fakeMultiSpaceMax = 0;
                      textContentItem.textRunBreakAllowed = false;
                    }
                    textContentItem.initialized = true;
                    return textContentItem;
                  }
                  function replaceWhitespace(str) {
                    var i = 0, ii = str.length, code;
                    while (i < ii && (code = str.charCodeAt(i)) >= 32 && code <= 127) {
                      i++;
                    }
                    return i < ii ? str.replace(WhitespaceRegexp, " ") : str;
                  }
                  function runBidiTransform(textChunk) {
                    var str = textChunk.str.join("");
                    var bidiResult = (0, _bidi.bidi)(str, -1, textChunk.vertical);
                    return {
                      str: normalizeWhitespace ? replaceWhitespace(bidiResult.str) : bidiResult.str,
                      dir: bidiResult.dir,
                      width: textChunk.width,
                      height: textChunk.height,
                      transform: textChunk.transform,
                      fontName: textChunk.fontName
                    };
                  }
                  function handleSetFont(fontName, fontRef) {
                    return self2.loadFont(fontName, fontRef, resources).then(function(translated) {
                      textState.font = translated.font;
                      textState.fontMatrix = translated.font.fontMatrix || _util.FONT_IDENTITY_MATRIX;
                    });
                  }
                  function buildTextContentItem(chars) {
                    var font = textState.font;
                    var textChunk = ensureTextContentItem();
                    var width = 0;
                    var height = 0;
                    var glyphs = font.charsToGlyphs(chars);
                    for (var i = 0; i < glyphs.length; i++) {
                      var glyph = glyphs[i];
                      var glyphWidth = null;
                      if (font.vertical && glyph.vmetric) {
                        glyphWidth = glyph.vmetric[0];
                      } else {
                        glyphWidth = glyph.width;
                      }
                      var glyphUnicode = glyph.unicode;
                      var NormalizedUnicodes = (0, _unicode.getNormalizedUnicodes)();
                      if (NormalizedUnicodes[glyphUnicode] !== void 0) {
                        glyphUnicode = NormalizedUnicodes[glyphUnicode];
                      }
                      glyphUnicode = (0, _unicode.reverseIfRtl)(glyphUnicode);
                      var charSpacing = textState.charSpacing;
                      if (glyph.isSpace) {
                        var wordSpacing = textState.wordSpacing;
                        charSpacing += wordSpacing;
                        if (wordSpacing > 0) {
                          addFakeSpaces(wordSpacing, textChunk.str);
                        }
                      }
                      var tx = 0;
                      var ty = 0;
                      if (!font.vertical) {
                        var w0 = glyphWidth * textState.fontMatrix[0];
                        tx = (w0 * textState.fontSize + charSpacing) * textState.textHScale;
                        width += tx;
                      } else {
                        var w1 = glyphWidth * textState.fontMatrix[0];
                        ty = w1 * textState.fontSize + charSpacing;
                        height += ty;
                      }
                      textState.translateTextMatrix(tx, ty);
                      textChunk.str.push(glyphUnicode);
                    }
                    if (!font.vertical) {
                      textChunk.lastAdvanceWidth = width;
                      textChunk.width += width;
                    } else {
                      textChunk.lastAdvanceHeight = height;
                      textChunk.height += Math.abs(height);
                    }
                    return textChunk;
                  }
                  function addFakeSpaces(width, strBuf) {
                    if (width < textContentItem.fakeSpaceMin) {
                      return;
                    }
                    if (width < textContentItem.fakeMultiSpaceMin) {
                      strBuf.push(" ");
                      return;
                    }
                    var fakeSpaces = Math.round(width / textContentItem.spaceWidth);
                    while (fakeSpaces-- > 0) {
                      strBuf.push(" ");
                    }
                  }
                  function flushTextContentItem() {
                    if (!textContentItem.initialized) {
                      return;
                    }
                    textContentItem.width *= textContentItem.textAdvanceScale;
                    textContentItem.height *= textContentItem.textAdvanceScale;
                    textContent.items.push(runBidiTransform(textContentItem));
                    textContentItem.initialized = false;
                    textContentItem.str.length = 0;
                  }
                  function enqueueChunk() {
                    var length = textContent.items.length;
                    if (length > 0) {
                      sink.enqueue(textContent, length);
                      textContent.items = [];
                      textContent.styles = /* @__PURE__ */ Object.create(null);
                    }
                  }
                  var timeSlotManager = new TimeSlotManager();
                  return new Promise(function promiseBody(resolve2, reject2) {
                    var next = function next2(promise) {
                      enqueueChunk();
                      Promise.all([promise, sink.ready]).then(function() {
                        try {
                          promiseBody(resolve2, reject2);
                        } catch (ex) {
                          reject2(ex);
                        }
                      }, reject2);
                    };
                    task.ensureNotTerminated();
                    timeSlotManager.reset();
                    var stop, operation = {}, args = [];
                    while (!(stop = timeSlotManager.check())) {
                      args.length = 0;
                      operation.args = args;
                      if (!preprocessor.read(operation)) {
                        break;
                      }
                      textState = stateManager.state;
                      var fn = operation.fn;
                      args = operation.args;
                      var advance, diff;
                      switch (fn | 0) {
                        case _util.OPS.setFont:
                          var fontNameArg = args[0].name, fontSizeArg = args[1];
                          if (textState.font && fontNameArg === textState.fontName && fontSizeArg === textState.fontSize) {
                            break;
                          }
                          flushTextContentItem();
                          textState.fontName = fontNameArg;
                          textState.fontSize = fontSizeArg;
                          next(handleSetFont(fontNameArg, null));
                          return;
                        case _util.OPS.setTextRise:
                          flushTextContentItem();
                          textState.textRise = args[0];
                          break;
                        case _util.OPS.setHScale:
                          flushTextContentItem();
                          textState.textHScale = args[0] / 100;
                          break;
                        case _util.OPS.setLeading:
                          flushTextContentItem();
                          textState.leading = args[0];
                          break;
                        case _util.OPS.moveText:
                          var isSameTextLine = !textState.font ? false : (textState.font.vertical ? args[0] : args[1]) === 0;
                          advance = args[0] - args[1];
                          if (combineTextItems && isSameTextLine && textContentItem.initialized && advance > 0 && advance <= textContentItem.fakeMultiSpaceMax) {
                            textState.translateTextLineMatrix(args[0], args[1]);
                            textContentItem.width += args[0] - textContentItem.lastAdvanceWidth;
                            textContentItem.height += args[1] - textContentItem.lastAdvanceHeight;
                            diff = args[0] - textContentItem.lastAdvanceWidth - (args[1] - textContentItem.lastAdvanceHeight);
                            addFakeSpaces(diff, textContentItem.str);
                            break;
                          }
                          flushTextContentItem();
                          textState.translateTextLineMatrix(args[0], args[1]);
                          textState.textMatrix = textState.textLineMatrix.slice();
                          break;
                        case _util.OPS.setLeadingMoveText:
                          flushTextContentItem();
                          textState.leading = -args[1];
                          textState.translateTextLineMatrix(args[0], args[1]);
                          textState.textMatrix = textState.textLineMatrix.slice();
                          break;
                        case _util.OPS.nextLine:
                          flushTextContentItem();
                          textState.carriageReturn();
                          break;
                        case _util.OPS.setTextMatrix:
                          advance = textState.calcTextLineMatrixAdvance(args[0], args[1], args[2], args[3], args[4], args[5]);
                          if (combineTextItems && advance !== null && textContentItem.initialized && advance.value > 0 && advance.value <= textContentItem.fakeMultiSpaceMax) {
                            textState.translateTextLineMatrix(advance.width, advance.height);
                            textContentItem.width += advance.width - textContentItem.lastAdvanceWidth;
                            textContentItem.height += advance.height - textContentItem.lastAdvanceHeight;
                            diff = advance.width - textContentItem.lastAdvanceWidth - (advance.height - textContentItem.lastAdvanceHeight);
                            addFakeSpaces(diff, textContentItem.str);
                            break;
                          }
                          flushTextContentItem();
                          textState.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                          textState.setTextLineMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                          break;
                        case _util.OPS.setCharSpacing:
                          textState.charSpacing = args[0];
                          break;
                        case _util.OPS.setWordSpacing:
                          textState.wordSpacing = args[0];
                          break;
                        case _util.OPS.beginText:
                          flushTextContentItem();
                          textState.textMatrix = _util.IDENTITY_MATRIX.slice();
                          textState.textLineMatrix = _util.IDENTITY_MATRIX.slice();
                          break;
                        case _util.OPS.showSpacedText:
                          var items = args[0];
                          var offset;
                          for (var j = 0, jj = items.length; j < jj; j++) {
                            if (typeof items[j] === "string") {
                              buildTextContentItem(items[j]);
                            } else if ((0, _util.isNum)(items[j])) {
                              ensureTextContentItem();
                              advance = items[j] * textState.fontSize / 1e3;
                              var breakTextRun = false;
                              if (textState.font.vertical) {
                                offset = advance;
                                textState.translateTextMatrix(0, offset);
                                breakTextRun = textContentItem.textRunBreakAllowed && advance > textContentItem.fakeMultiSpaceMax;
                                if (!breakTextRun) {
                                  textContentItem.height += offset;
                                }
                              } else {
                                advance = -advance;
                                offset = advance * textState.textHScale;
                                textState.translateTextMatrix(offset, 0);
                                breakTextRun = textContentItem.textRunBreakAllowed && advance > textContentItem.fakeMultiSpaceMax;
                                if (!breakTextRun) {
                                  textContentItem.width += offset;
                                }
                              }
                              if (breakTextRun) {
                                flushTextContentItem();
                              } else if (advance > 0) {
                                addFakeSpaces(advance, textContentItem.str);
                              }
                            }
                          }
                          break;
                        case _util.OPS.showText:
                          buildTextContentItem(args[0]);
                          break;
                        case _util.OPS.nextLineShowText:
                          flushTextContentItem();
                          textState.carriageReturn();
                          buildTextContentItem(args[0]);
                          break;
                        case _util.OPS.nextLineSetSpacingShowText:
                          flushTextContentItem();
                          textState.wordSpacing = args[0];
                          textState.charSpacing = args[1];
                          textState.carriageReturn();
                          buildTextContentItem(args[2]);
                          break;
                        case _util.OPS.paintXObject:
                          flushTextContentItem();
                          if (!xobjs) {
                            xobjs = resources.get("XObject") || _primitives.Dict.empty;
                          }
                          var name = args[0].name;
                          if (name && skipEmptyXObjs[name] !== void 0) {
                            break;
                          }
                          next(new Promise(function(resolveXObject, rejectXObject) {
                            if (!name) {
                              throw new _util.FormatError("XObject must be referred to by name.");
                            }
                            var xobj = xobjs.get(name);
                            if (!xobj) {
                              resolveXObject();
                              return;
                            }
                            if (!(0, _primitives.isStream)(xobj)) {
                              throw new _util.FormatError("XObject should be a stream");
                            }
                            var type = xobj.dict.get("Subtype");
                            if (!(0, _primitives.isName)(type)) {
                              throw new _util.FormatError("XObject should have a Name subtype");
                            }
                            if (type.name !== "Form") {
                              skipEmptyXObjs[name] = true;
                              resolveXObject();
                              return;
                            }
                            var currentState = stateManager.state.clone();
                            var xObjStateManager = new StateManager(currentState);
                            var matrix = xobj.dict.getArray("Matrix");
                            if (Array.isArray(matrix) && matrix.length === 6) {
                              xObjStateManager.transform(matrix);
                            }
                            enqueueChunk();
                            var sinkWrapper = {
                              enqueueInvoked: false,
                              enqueue: function enqueue(chunk, size) {
                                this.enqueueInvoked = true;
                                sink.enqueue(chunk, size);
                              },
                              get desiredSize() {
                                return sink.desiredSize;
                              },
                              get ready() {
                                return sink.ready;
                              }
                            };
                            self2.getTextContent({
                              stream: xobj,
                              task,
                              resources: xobj.dict.get("Resources") || resources,
                              stateManager: xObjStateManager,
                              normalizeWhitespace,
                              combineTextItems,
                              sink: sinkWrapper,
                              seenStyles
                            }).then(function() {
                              if (!sinkWrapper.enqueueInvoked) {
                                skipEmptyXObjs[name] = true;
                              }
                              resolveXObject();
                            }, rejectXObject);
                          }).catch(function(reason) {
                            if (reason instanceof _util.AbortException) {
                              return;
                            }
                            if (self2.options.ignoreErrors) {
                              (0, _util.warn)('getTextContent - ignoring XObject: "' + reason + '".');
                              return;
                            }
                            throw reason;
                          }));
                          return;
                        case _util.OPS.setGState:
                          flushTextContentItem();
                          var dictName = args[0];
                          var extGState = resources.get("ExtGState");
                          if (!(0, _primitives.isDict)(extGState) || !(0, _primitives.isName)(dictName)) {
                            break;
                          }
                          var gState = extGState.get(dictName.name);
                          if (!(0, _primitives.isDict)(gState)) {
                            break;
                          }
                          var gStateFont = gState.get("Font");
                          if (gStateFont) {
                            textState.fontName = null;
                            textState.fontSize = gStateFont[1];
                            next(handleSetFont(null, gStateFont[0]));
                            return;
                          }
                          break;
                      }
                      if (textContent.items.length >= sink.desiredSize) {
                        stop = true;
                        break;
                      }
                    }
                    if (stop) {
                      next(deferred);
                      return;
                    }
                    flushTextContentItem();
                    enqueueChunk();
                    resolve2();
                  }).catch(function(reason) {
                    if (reason instanceof _util.AbortException) {
                      return;
                    }
                    if (_this9.options.ignoreErrors) {
                      (0, _util.warn)("getTextContent - ignoring errors during task: " + task.name);
                      flushTextContentItem();
                      enqueueChunk();
                      return;
                    }
                    throw reason;
                  });
                },
                extractDataStructures: function PartialEvaluator_extractDataStructures(dict, baseDict, properties) {
                  var _this10 = this;
                  var xref = this.xref;
                  var toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
                  var toUnicodePromise = toUnicode ? this.readToUnicode(toUnicode) : Promise.resolve(void 0);
                  if (properties.composite) {
                    var cidSystemInfo = dict.get("CIDSystemInfo");
                    if ((0, _primitives.isDict)(cidSystemInfo)) {
                      properties.cidSystemInfo = {
                        registry: cidSystemInfo.get("Registry"),
                        ordering: cidSystemInfo.get("Ordering"),
                        supplement: cidSystemInfo.get("Supplement")
                      };
                    }
                    var cidToGidMap = dict.get("CIDToGIDMap");
                    if ((0, _primitives.isStream)(cidToGidMap)) {
                      properties.cidToGidMap = this.readCidToGidMap(cidToGidMap);
                    }
                  }
                  var differences = [];
                  var baseEncodingName = null;
                  var encoding;
                  if (dict.has("Encoding")) {
                    encoding = dict.get("Encoding");
                    if ((0, _primitives.isDict)(encoding)) {
                      baseEncodingName = encoding.get("BaseEncoding");
                      baseEncodingName = (0, _primitives.isName)(baseEncodingName) ? baseEncodingName.name : null;
                      if (encoding.has("Differences")) {
                        var diffEncoding = encoding.get("Differences");
                        var index = 0;
                        for (var j = 0, jj = diffEncoding.length; j < jj; j++) {
                          var data = xref.fetchIfRef(diffEncoding[j]);
                          if ((0, _util.isNum)(data)) {
                            index = data;
                          } else if ((0, _primitives.isName)(data)) {
                            differences[index++] = data.name;
                          } else {
                            throw new _util.FormatError("Invalid entry in 'Differences' array: " + data);
                          }
                        }
                      }
                    } else if ((0, _primitives.isName)(encoding)) {
                      baseEncodingName = encoding.name;
                    } else {
                      throw new _util.FormatError("Encoding is not a Name nor a Dict");
                    }
                    if (baseEncodingName !== "MacRomanEncoding" && baseEncodingName !== "MacExpertEncoding" && baseEncodingName !== "WinAnsiEncoding") {
                      baseEncodingName = null;
                    }
                  }
                  if (baseEncodingName) {
                    properties.defaultEncoding = (0, _encodings.getEncoding)(baseEncodingName).slice();
                  } else {
                    var isSymbolicFont = !!(properties.flags & _fonts.FontFlags.Symbolic);
                    var isNonsymbolicFont = !!(properties.flags & _fonts.FontFlags.Nonsymbolic);
                    encoding = _encodings.StandardEncoding;
                    if (properties.type === "TrueType" && !isNonsymbolicFont) {
                      encoding = _encodings.WinAnsiEncoding;
                    }
                    if (isSymbolicFont) {
                      encoding = _encodings.MacRomanEncoding;
                      if (!properties.file) {
                        if (/Symbol/i.test(properties.name)) {
                          encoding = _encodings.SymbolSetEncoding;
                        } else if (/Dingbats/i.test(properties.name)) {
                          encoding = _encodings.ZapfDingbatsEncoding;
                        }
                      }
                    }
                    properties.defaultEncoding = encoding;
                  }
                  properties.differences = differences;
                  properties.baseEncodingName = baseEncodingName;
                  properties.hasEncoding = !!baseEncodingName || differences.length > 0;
                  properties.dict = dict;
                  return toUnicodePromise.then(function(toUnicode2) {
                    properties.toUnicode = toUnicode2;
                    return _this10.buildToUnicode(properties);
                  }).then(function(toUnicode2) {
                    properties.toUnicode = toUnicode2;
                    return properties;
                  });
                },
                _buildSimpleFontToUnicode: function _buildSimpleFontToUnicode(properties) {
                  (0, _util.assert)(!properties.composite, "Must be a simple font.");
                  var toUnicode = [], charcode = void 0, glyphName = void 0;
                  var encoding = properties.defaultEncoding.slice();
                  var baseEncodingName = properties.baseEncodingName;
                  var differences = properties.differences;
                  for (charcode in differences) {
                    glyphName = differences[charcode];
                    if (glyphName === ".notdef") {
                      continue;
                    }
                    encoding[charcode] = glyphName;
                  }
                  var glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                  for (charcode in encoding) {
                    glyphName = encoding[charcode];
                    if (glyphName === "") {
                      continue;
                    } else if (glyphsUnicodeMap[glyphName] === void 0) {
                      var code = 0;
                      switch (glyphName[0]) {
                        case "G":
                          if (glyphName.length === 3) {
                            code = parseInt(glyphName.substr(1), 16);
                          }
                          break;
                        case "g":
                          if (glyphName.length === 5) {
                            code = parseInt(glyphName.substr(1), 16);
                          }
                          break;
                        case "C":
                        case "c":
                          if (glyphName.length >= 3) {
                            code = +glyphName.substr(1);
                          }
                          break;
                        default:
                          var unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
                          if (unicode !== -1) {
                            code = unicode;
                          }
                      }
                      if (code) {
                        if (baseEncodingName && code === +charcode) {
                          var baseEncoding = (0, _encodings.getEncoding)(baseEncodingName);
                          if (baseEncoding && (glyphName = baseEncoding[charcode])) {
                            toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);
                            continue;
                          }
                        }
                        toUnicode[charcode] = String.fromCharCode(code);
                      }
                      continue;
                    }
                    toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);
                  }
                  return new _fonts.ToUnicodeMap(toUnicode);
                },
                buildToUnicode: function buildToUnicode(properties) {
                  properties.hasIncludedToUnicodeMap = !!properties.toUnicode && properties.toUnicode.length > 0;
                  if (properties.hasIncludedToUnicodeMap) {
                    if (!properties.composite && properties.hasEncoding) {
                      properties.fallbackToUnicode = this._buildSimpleFontToUnicode(properties);
                    }
                    return Promise.resolve(properties.toUnicode);
                  }
                  if (!properties.composite) {
                    return Promise.resolve(this._buildSimpleFontToUnicode(properties));
                  }
                  if (properties.composite && (properties.cMap.builtInCMap && !(properties.cMap instanceof _cmap.IdentityCMap) || properties.cidSystemInfo.registry === "Adobe" && (properties.cidSystemInfo.ordering === "GB1" || properties.cidSystemInfo.ordering === "CNS1" || properties.cidSystemInfo.ordering === "Japan1" || properties.cidSystemInfo.ordering === "Korea1"))) {
                    var registry = properties.cidSystemInfo.registry;
                    var ordering = properties.cidSystemInfo.ordering;
                    var ucs2CMapName = _primitives.Name.get(registry + "-" + ordering + "-UCS2");
                    return _cmap.CMapFactory.create({
                      encoding: ucs2CMapName,
                      fetchBuiltInCMap: this.fetchBuiltInCMap,
                      useCMap: null
                    }).then(function(ucs2CMap) {
                      var cMap = properties.cMap;
                      var toUnicode = [];
                      cMap.forEach(function(charcode, cid) {
                        if (cid > 65535) {
                          throw new _util.FormatError("Max size of CID is 65,535");
                        }
                        var ucs2 = ucs2CMap.lookup(cid);
                        if (ucs2) {
                          toUnicode[charcode] = String.fromCharCode((ucs2.charCodeAt(0) << 8) + ucs2.charCodeAt(1));
                        }
                      });
                      return new _fonts.ToUnicodeMap(toUnicode);
                    });
                  }
                  return Promise.resolve(new _fonts.IdentityToUnicodeMap(properties.firstChar, properties.lastChar));
                },
                readToUnicode: function PartialEvaluator_readToUnicode(toUnicode) {
                  var cmapObj = toUnicode;
                  if ((0, _primitives.isName)(cmapObj)) {
                    return _cmap.CMapFactory.create({
                      encoding: cmapObj,
                      fetchBuiltInCMap: this.fetchBuiltInCMap,
                      useCMap: null
                    }).then(function(cmap) {
                      if (cmap instanceof _cmap.IdentityCMap) {
                        return new _fonts.IdentityToUnicodeMap(0, 65535);
                      }
                      return new _fonts.ToUnicodeMap(cmap.getMap());
                    });
                  } else if ((0, _primitives.isStream)(cmapObj)) {
                    return _cmap.CMapFactory.create({
                      encoding: cmapObj,
                      fetchBuiltInCMap: this.fetchBuiltInCMap,
                      useCMap: null
                    }).then(function(cmap) {
                      if (cmap instanceof _cmap.IdentityCMap) {
                        return new _fonts.IdentityToUnicodeMap(0, 65535);
                      }
                      var map = new Array(cmap.length);
                      cmap.forEach(function(charCode, token) {
                        var str = [];
                        for (var k = 0; k < token.length; k += 2) {
                          var w1 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
                          if ((w1 & 63488) !== 55296) {
                            str.push(w1);
                            continue;
                          }
                          k += 2;
                          var w2 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
                          str.push(((w1 & 1023) << 10) + (w2 & 1023) + 65536);
                        }
                        map[charCode] = String.fromCharCode.apply(String, str);
                      });
                      return new _fonts.ToUnicodeMap(map);
                    });
                  }
                  return Promise.resolve(null);
                },
                readCidToGidMap: function PartialEvaluator_readCidToGidMap(cidToGidStream) {
                  var glyphsData = cidToGidStream.getBytes();
                  var result = [];
                  for (var j = 0, jj = glyphsData.length; j < jj; j++) {
                    var glyphID = glyphsData[j++] << 8 | glyphsData[j];
                    if (glyphID === 0) {
                      continue;
                    }
                    var code = j >> 1;
                    result[code] = glyphID;
                  }
                  return result;
                },
                extractWidths: function PartialEvaluator_extractWidths(dict, descriptor, properties) {
                  var xref = this.xref;
                  var glyphsWidths = [];
                  var defaultWidth = 0;
                  var glyphsVMetrics = [];
                  var defaultVMetrics;
                  var i, ii, j, jj, start, code, widths;
                  if (properties.composite) {
                    defaultWidth = dict.has("DW") ? dict.get("DW") : 1e3;
                    widths = dict.get("W");
                    if (widths) {
                      for (i = 0, ii = widths.length; i < ii; i++) {
                        start = xref.fetchIfRef(widths[i++]);
                        code = xref.fetchIfRef(widths[i]);
                        if (Array.isArray(code)) {
                          for (j = 0, jj = code.length; j < jj; j++) {
                            glyphsWidths[start++] = xref.fetchIfRef(code[j]);
                          }
                        } else {
                          var width = xref.fetchIfRef(widths[++i]);
                          for (j = start; j <= code; j++) {
                            glyphsWidths[j] = width;
                          }
                        }
                      }
                    }
                    if (properties.vertical) {
                      var vmetrics = dict.getArray("DW2") || [880, -1e3];
                      defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
                      vmetrics = dict.get("W2");
                      if (vmetrics) {
                        for (i = 0, ii = vmetrics.length; i < ii; i++) {
                          start = xref.fetchIfRef(vmetrics[i++]);
                          code = xref.fetchIfRef(vmetrics[i]);
                          if (Array.isArray(code)) {
                            for (j = 0, jj = code.length; j < jj; j++) {
                              glyphsVMetrics[start++] = [xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j])];
                            }
                          } else {
                            var vmetric = [xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i])];
                            for (j = start; j <= code; j++) {
                              glyphsVMetrics[j] = vmetric;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    var firstChar = properties.firstChar;
                    widths = dict.get("Widths");
                    if (widths) {
                      j = firstChar;
                      for (i = 0, ii = widths.length; i < ii; i++) {
                        glyphsWidths[j++] = xref.fetchIfRef(widths[i]);
                      }
                      defaultWidth = parseFloat(descriptor.get("MissingWidth")) || 0;
                    } else {
                      var baseFontName = dict.get("BaseFont");
                      if ((0, _primitives.isName)(baseFontName)) {
                        var metrics = this.getBaseFontMetrics(baseFontName.name);
                        glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
                        defaultWidth = metrics.defaultWidth;
                      }
                    }
                  }
                  var isMonospace = true;
                  var firstWidth = defaultWidth;
                  for (var glyph in glyphsWidths) {
                    var glyphWidth = glyphsWidths[glyph];
                    if (!glyphWidth) {
                      continue;
                    }
                    if (!firstWidth) {
                      firstWidth = glyphWidth;
                      continue;
                    }
                    if (firstWidth !== glyphWidth) {
                      isMonospace = false;
                      break;
                    }
                  }
                  if (isMonospace) {
                    properties.flags |= _fonts.FontFlags.FixedPitch;
                  }
                  properties.defaultWidth = defaultWidth;
                  properties.widths = glyphsWidths;
                  properties.defaultVMetrics = defaultVMetrics;
                  properties.vmetrics = glyphsVMetrics;
                },
                isSerifFont: function PartialEvaluator_isSerifFont(baseFontName) {
                  var fontNameWoStyle = baseFontName.split("-")[0];
                  return fontNameWoStyle in (0, _standard_fonts.getSerifFonts)() || fontNameWoStyle.search(/serif/gi) !== -1;
                },
                getBaseFontMetrics: function PartialEvaluator_getBaseFontMetrics(name) {
                  var defaultWidth = 0;
                  var widths = [];
                  var monospace = false;
                  var stdFontMap = (0, _standard_fonts.getStdFontMap)();
                  var lookupName = stdFontMap[name] || name;
                  var Metrics = (0, _metrics.getMetrics)();
                  if (!(lookupName in Metrics)) {
                    if (this.isSerifFont(name)) {
                      lookupName = "Times-Roman";
                    } else {
                      lookupName = "Helvetica";
                    }
                  }
                  var glyphWidths = Metrics[lookupName];
                  if ((0, _util.isNum)(glyphWidths)) {
                    defaultWidth = glyphWidths;
                    monospace = true;
                  } else {
                    widths = glyphWidths();
                  }
                  return {
                    defaultWidth,
                    monospace,
                    widths
                  };
                },
                buildCharCodeToWidth: function PartialEvaluator_bulildCharCodeToWidth(widthsByGlyphName, properties) {
                  var widths = /* @__PURE__ */ Object.create(null);
                  var differences = properties.differences;
                  var encoding = properties.defaultEncoding;
                  for (var charCode = 0; charCode < 256; charCode++) {
                    if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
                      widths[charCode] = widthsByGlyphName[differences[charCode]];
                      continue;
                    }
                    if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
                      widths[charCode] = widthsByGlyphName[encoding[charCode]];
                      continue;
                    }
                  }
                  return widths;
                },
                preEvaluateFont: function PartialEvaluator_preEvaluateFont(dict) {
                  var baseDict = dict;
                  var type = dict.get("Subtype");
                  if (!(0, _primitives.isName)(type)) {
                    throw new _util.FormatError("invalid font Subtype");
                  }
                  var composite = false;
                  var uint8array;
                  if (type.name === "Type0") {
                    var df = dict.get("DescendantFonts");
                    if (!df) {
                      throw new _util.FormatError("Descendant fonts are not specified");
                    }
                    dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
                    type = dict.get("Subtype");
                    if (!(0, _primitives.isName)(type)) {
                      throw new _util.FormatError("invalid font Subtype");
                    }
                    composite = true;
                  }
                  var descriptor = dict.get("FontDescriptor");
                  if (descriptor) {
                    var hash = new _murmurhash.MurmurHash3_64();
                    var encoding = baseDict.getRaw("Encoding");
                    if ((0, _primitives.isName)(encoding)) {
                      hash.update(encoding.name);
                    } else if ((0, _primitives.isRef)(encoding)) {
                      hash.update(encoding.toString());
                    } else if ((0, _primitives.isDict)(encoding)) {
                      var keys = encoding.getKeys();
                      for (var i = 0, ii = keys.length; i < ii; i++) {
                        var entry = encoding.getRaw(keys[i]);
                        if ((0, _primitives.isName)(entry)) {
                          hash.update(entry.name);
                        } else if ((0, _primitives.isRef)(entry)) {
                          hash.update(entry.toString());
                        } else if (Array.isArray(entry)) {
                          var diffLength = entry.length, diffBuf = new Array(diffLength);
                          for (var j = 0; j < diffLength; j++) {
                            var diffEntry = entry[j];
                            if ((0, _primitives.isName)(diffEntry)) {
                              diffBuf[j] = diffEntry.name;
                            } else if ((0, _util.isNum)(diffEntry) || (0, _primitives.isRef)(diffEntry)) {
                              diffBuf[j] = diffEntry.toString();
                            }
                          }
                          hash.update(diffBuf.join());
                        }
                      }
                    }
                    var toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
                    if ((0, _primitives.isStream)(toUnicode)) {
                      var stream2 = toUnicode.str || toUnicode;
                      uint8array = stream2.buffer ? new Uint8Array(stream2.buffer.buffer, 0, stream2.bufferLength) : new Uint8Array(stream2.bytes.buffer, stream2.start, stream2.end - stream2.start);
                      hash.update(uint8array);
                    } else if ((0, _primitives.isName)(toUnicode)) {
                      hash.update(toUnicode.name);
                    }
                    var widths = dict.get("Widths") || baseDict.get("Widths");
                    if (widths) {
                      uint8array = new Uint8Array(new Uint32Array(widths).buffer);
                      hash.update(uint8array);
                    }
                  }
                  return {
                    descriptor,
                    dict,
                    baseDict,
                    composite,
                    type: type.name,
                    hash: hash ? hash.hexdigest() : ""
                  };
                },
                translateFont: function PartialEvaluator_translateFont(preEvaluatedFont) {
                  var _this11 = this;
                  var baseDict = preEvaluatedFont.baseDict;
                  var dict = preEvaluatedFont.dict;
                  var composite = preEvaluatedFont.composite;
                  var descriptor = preEvaluatedFont.descriptor;
                  var type = preEvaluatedFont.type;
                  var maxCharIndex = composite ? 65535 : 255;
                  var properties;
                  if (!descriptor) {
                    if (type === "Type3") {
                      descriptor = new _primitives.Dict(null);
                      descriptor.set("FontName", _primitives.Name.get(type));
                      descriptor.set("FontBBox", dict.getArray("FontBBox"));
                    } else {
                      var baseFontName = dict.get("BaseFont");
                      if (!(0, _primitives.isName)(baseFontName)) {
                        throw new _util.FormatError("Base font is not specified");
                      }
                      baseFontName = baseFontName.name.replace(/[,_]/g, "-");
                      var metrics = this.getBaseFontMetrics(baseFontName);
                      var fontNameWoStyle = baseFontName.split("-")[0];
                      var flags = (this.isSerifFont(fontNameWoStyle) ? _fonts.FontFlags.Serif : 0) | (metrics.monospace ? _fonts.FontFlags.FixedPitch : 0) | ((0, _standard_fonts.getSymbolsFonts)()[fontNameWoStyle] ? _fonts.FontFlags.Symbolic : _fonts.FontFlags.Nonsymbolic);
                      properties = {
                        type,
                        name: baseFontName,
                        widths: metrics.widths,
                        defaultWidth: metrics.defaultWidth,
                        flags,
                        firstChar: 0,
                        lastChar: maxCharIndex
                      };
                      return this.extractDataStructures(dict, dict, properties).then(function(properties2) {
                        properties2.widths = _this11.buildCharCodeToWidth(metrics.widths, properties2);
                        return new _fonts.Font(baseFontName, null, properties2);
                      });
                    }
                  }
                  var firstChar = dict.get("FirstChar") || 0;
                  var lastChar = dict.get("LastChar") || maxCharIndex;
                  var fontName = descriptor.get("FontName");
                  var baseFont = dict.get("BaseFont");
                  if ((0, _util.isString)(fontName)) {
                    fontName = _primitives.Name.get(fontName);
                  }
                  if ((0, _util.isString)(baseFont)) {
                    baseFont = _primitives.Name.get(baseFont);
                  }
                  if (type !== "Type3") {
                    var fontNameStr = fontName && fontName.name;
                    var baseFontStr = baseFont && baseFont.name;
                    if (fontNameStr !== baseFontStr) {
                      (0, _util.info)(`The FontDescriptor's FontName is "` + fontNameStr + `" but should be the same as the Font's BaseFont "` + baseFontStr + '"');
                      if (fontNameStr && baseFontStr && baseFontStr.indexOf(fontNameStr) === 0) {
                        fontName = baseFont;
                      }
                    }
                  }
                  fontName = fontName || baseFont;
                  if (!(0, _primitives.isName)(fontName)) {
                    throw new _util.FormatError("invalid font name");
                  }
                  var fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
                  if (fontFile) {
                    if (fontFile.dict) {
                      var subtype = fontFile.dict.get("Subtype");
                      if (subtype) {
                        subtype = subtype.name;
                      }
                      var length1 = fontFile.dict.get("Length1");
                      var length2 = fontFile.dict.get("Length2");
                      var length3 = fontFile.dict.get("Length3");
                    }
                  }
                  properties = {
                    type,
                    name: fontName.name,
                    subtype,
                    file: fontFile,
                    length1,
                    length2,
                    length3,
                    loadedName: baseDict.loadedName,
                    composite,
                    wideChars: composite,
                    fixedPitch: false,
                    fontMatrix: dict.getArray("FontMatrix") || _util.FONT_IDENTITY_MATRIX,
                    firstChar: firstChar || 0,
                    lastChar: lastChar || maxCharIndex,
                    bbox: descriptor.getArray("FontBBox"),
                    ascent: descriptor.get("Ascent"),
                    descent: descriptor.get("Descent"),
                    xHeight: descriptor.get("XHeight"),
                    capHeight: descriptor.get("CapHeight"),
                    flags: descriptor.get("Flags"),
                    italicAngle: descriptor.get("ItalicAngle"),
                    isType3Font: false
                  };
                  var cMapPromise;
                  if (composite) {
                    var cidEncoding = baseDict.get("Encoding");
                    if ((0, _primitives.isName)(cidEncoding)) {
                      properties.cidEncoding = cidEncoding.name;
                    }
                    cMapPromise = _cmap.CMapFactory.create({
                      encoding: cidEncoding,
                      fetchBuiltInCMap: this.fetchBuiltInCMap,
                      useCMap: null
                    }).then(function(cMap) {
                      properties.cMap = cMap;
                      properties.vertical = properties.cMap.vertical;
                    });
                  } else {
                    cMapPromise = Promise.resolve(void 0);
                  }
                  return cMapPromise.then(function() {
                    return _this11.extractDataStructures(dict, baseDict, properties);
                  }).then(function(properties2) {
                    _this11.extractWidths(dict, descriptor, properties2);
                    if (type === "Type3") {
                      properties2.isType3Font = true;
                    }
                    return new _fonts.Font(fontName.name, fontFile, properties2);
                  });
                }
              };
              return PartialEvaluator2;
            }();
            var TranslatedFont = function TranslatedFontClosure() {
              function TranslatedFont2(loadedName, font, dict) {
                this.loadedName = loadedName;
                this.font = font;
                this.dict = dict;
                this.type3Loaded = null;
                this.sent = false;
              }
              TranslatedFont2.prototype = {
                send: function send(handler) {
                  if (this.sent) {
                    return;
                  }
                  var fontData = this.font.exportData();
                  handler.send("commonobj", [this.loadedName, "Font", fontData]);
                  this.sent = true;
                },
                loadType3Data: function loadType3Data(evaluator, resources, parentOperatorList, task) {
                  if (!this.font.isType3Font) {
                    throw new Error("Must be a Type3 font.");
                  }
                  if (this.type3Loaded) {
                    return this.type3Loaded;
                  }
                  var type3Options = Object.create(evaluator.options);
                  type3Options.ignoreErrors = false;
                  var type3Evaluator = evaluator.clone(type3Options);
                  var translatedFont = this.font;
                  var loadCharProcsPromise = Promise.resolve();
                  var charProcs = this.dict.get("CharProcs");
                  var fontResources = this.dict.get("Resources") || resources;
                  var charProcKeys = charProcs.getKeys();
                  var charProcOperatorList = /* @__PURE__ */ Object.create(null);
                  var _loop2 = function _loop22() {
                    var key = charProcKeys[i];
                    loadCharProcsPromise = loadCharProcsPromise.then(function() {
                      var glyphStream = charProcs.get(key);
                      var operatorList = new _operator_list.OperatorList();
                      return type3Evaluator.getOperatorList({
                        stream: glyphStream,
                        task,
                        resources: fontResources,
                        operatorList
                      }).then(function() {
                        charProcOperatorList[key] = operatorList.getIR();
                        parentOperatorList.addDependencies(operatorList.dependencies);
                      }).catch(function(reason) {
                        (0, _util.warn)('Type3 font resource "' + key + '" is not available.');
                        var operatorList2 = new _operator_list.OperatorList();
                        charProcOperatorList[key] = operatorList2.getIR();
                      });
                    });
                  };
                  for (var i = 0, n = charProcKeys.length; i < n; ++i) {
                    _loop2();
                  }
                  this.type3Loaded = loadCharProcsPromise.then(function() {
                    translatedFont.charProcOperatorList = charProcOperatorList;
                  });
                  return this.type3Loaded;
                }
              };
              return TranslatedFont2;
            }();
            var StateManager = function StateManagerClosure() {
              function StateManager2(initialState) {
                this.state = initialState;
                this.stateStack = [];
              }
              StateManager2.prototype = {
                save: function save() {
                  var old = this.state;
                  this.stateStack.push(this.state);
                  this.state = old.clone();
                },
                restore: function restore() {
                  var prev = this.stateStack.pop();
                  if (prev) {
                    this.state = prev;
                  }
                },
                transform: function transform(args) {
                  this.state.ctm = _util.Util.transform(this.state.ctm, args);
                }
              };
              return StateManager2;
            }();
            var TextState = function TextStateClosure() {
              function TextState2() {
                this.ctm = new Float32Array(_util.IDENTITY_MATRIX);
                this.fontName = null;
                this.fontSize = 0;
                this.font = null;
                this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
                this.textMatrix = _util.IDENTITY_MATRIX.slice();
                this.textLineMatrix = _util.IDENTITY_MATRIX.slice();
                this.charSpacing = 0;
                this.wordSpacing = 0;
                this.leading = 0;
                this.textHScale = 1;
                this.textRise = 0;
              }
              TextState2.prototype = {
                setTextMatrix: function TextState_setTextMatrix(a, b, c, d, e, f) {
                  var m = this.textMatrix;
                  m[0] = a;
                  m[1] = b;
                  m[2] = c;
                  m[3] = d;
                  m[4] = e;
                  m[5] = f;
                },
                setTextLineMatrix: function TextState_setTextMatrix(a, b, c, d, e, f) {
                  var m = this.textLineMatrix;
                  m[0] = a;
                  m[1] = b;
                  m[2] = c;
                  m[3] = d;
                  m[4] = e;
                  m[5] = f;
                },
                translateTextMatrix: function TextState_translateTextMatrix(x, y) {
                  var m = this.textMatrix;
                  m[4] = m[0] * x + m[2] * y + m[4];
                  m[5] = m[1] * x + m[3] * y + m[5];
                },
                translateTextLineMatrix: function TextState_translateTextMatrix(x, y) {
                  var m = this.textLineMatrix;
                  m[4] = m[0] * x + m[2] * y + m[4];
                  m[5] = m[1] * x + m[3] * y + m[5];
                },
                calcTextLineMatrixAdvance: function TextState_calcTextLineMatrixAdvance(a, b, c, d, e, f) {
                  var font = this.font;
                  if (!font) {
                    return null;
                  }
                  var m = this.textLineMatrix;
                  if (!(a === m[0] && b === m[1] && c === m[2] && d === m[3])) {
                    return null;
                  }
                  var txDiff = e - m[4], tyDiff = f - m[5];
                  if (font.vertical && txDiff !== 0 || !font.vertical && tyDiff !== 0) {
                    return null;
                  }
                  var tx, ty, denominator = a * d - b * c;
                  if (font.vertical) {
                    tx = -tyDiff * c / denominator;
                    ty = tyDiff * a / denominator;
                  } else {
                    tx = txDiff * d / denominator;
                    ty = -txDiff * b / denominator;
                  }
                  return {
                    width: tx,
                    height: ty,
                    value: font.vertical ? ty : tx
                  };
                },
                calcRenderMatrix: function TextState_calcRendeMatrix(ctm) {
                  var tsm = [this.fontSize * this.textHScale, 0, 0, this.fontSize, 0, this.textRise];
                  return _util.Util.transform(ctm, _util.Util.transform(this.textMatrix, tsm));
                },
                carriageReturn: function TextState_carriageReturn() {
                  this.translateTextLineMatrix(0, -this.leading);
                  this.textMatrix = this.textLineMatrix.slice();
                },
                clone: function TextState_clone() {
                  var clone = Object.create(this);
                  clone.textMatrix = this.textMatrix.slice();
                  clone.textLineMatrix = this.textLineMatrix.slice();
                  clone.fontMatrix = this.fontMatrix.slice();
                  return clone;
                }
              };
              return TextState2;
            }();
            var EvalState = function EvalStateClosure() {
              function EvalState2() {
                this.ctm = new Float32Array(_util.IDENTITY_MATRIX);
                this.font = null;
                this.textRenderingMode = _util.TextRenderingMode.FILL;
                this.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
                this.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
              }
              EvalState2.prototype = {
                clone: function CanvasExtraState_clone() {
                  return Object.create(this);
                }
              };
              return EvalState2;
            }();
            var EvaluatorPreprocessor = function EvaluatorPreprocessorClosure() {
              var getOPMap = (0, _util.getLookupTableFactory)(function(t) {
                t["w"] = {
                  id: _util.OPS.setLineWidth,
                  numArgs: 1,
                  variableArgs: false
                };
                t["J"] = {
                  id: _util.OPS.setLineCap,
                  numArgs: 1,
                  variableArgs: false
                };
                t["j"] = {
                  id: _util.OPS.setLineJoin,
                  numArgs: 1,
                  variableArgs: false
                };
                t["M"] = {
                  id: _util.OPS.setMiterLimit,
                  numArgs: 1,
                  variableArgs: false
                };
                t["d"] = {
                  id: _util.OPS.setDash,
                  numArgs: 2,
                  variableArgs: false
                };
                t["ri"] = {
                  id: _util.OPS.setRenderingIntent,
                  numArgs: 1,
                  variableArgs: false
                };
                t["i"] = {
                  id: _util.OPS.setFlatness,
                  numArgs: 1,
                  variableArgs: false
                };
                t["gs"] = {
                  id: _util.OPS.setGState,
                  numArgs: 1,
                  variableArgs: false
                };
                t["q"] = {
                  id: _util.OPS.save,
                  numArgs: 0,
                  variableArgs: false
                };
                t["Q"] = {
                  id: _util.OPS.restore,
                  numArgs: 0,
                  variableArgs: false
                };
                t["cm"] = {
                  id: _util.OPS.transform,
                  numArgs: 6,
                  variableArgs: false
                };
                t["m"] = {
                  id: _util.OPS.moveTo,
                  numArgs: 2,
                  variableArgs: false
                };
                t["l"] = {
                  id: _util.OPS.lineTo,
                  numArgs: 2,
                  variableArgs: false
                };
                t["c"] = {
                  id: _util.OPS.curveTo,
                  numArgs: 6,
                  variableArgs: false
                };
                t["v"] = {
                  id: _util.OPS.curveTo2,
                  numArgs: 4,
                  variableArgs: false
                };
                t["y"] = {
                  id: _util.OPS.curveTo3,
                  numArgs: 4,
                  variableArgs: false
                };
                t["h"] = {
                  id: _util.OPS.closePath,
                  numArgs: 0,
                  variableArgs: false
                };
                t["re"] = {
                  id: _util.OPS.rectangle,
                  numArgs: 4,
                  variableArgs: false
                };
                t["S"] = {
                  id: _util.OPS.stroke,
                  numArgs: 0,
                  variableArgs: false
                };
                t["s"] = {
                  id: _util.OPS.closeStroke,
                  numArgs: 0,
                  variableArgs: false
                };
                t["f"] = {
                  id: _util.OPS.fill,
                  numArgs: 0,
                  variableArgs: false
                };
                t["F"] = {
                  id: _util.OPS.fill,
                  numArgs: 0,
                  variableArgs: false
                };
                t["f*"] = {
                  id: _util.OPS.eoFill,
                  numArgs: 0,
                  variableArgs: false
                };
                t["B"] = {
                  id: _util.OPS.fillStroke,
                  numArgs: 0,
                  variableArgs: false
                };
                t["B*"] = {
                  id: _util.OPS.eoFillStroke,
                  numArgs: 0,
                  variableArgs: false
                };
                t["b"] = {
                  id: _util.OPS.closeFillStroke,
                  numArgs: 0,
                  variableArgs: false
                };
                t["b*"] = {
                  id: _util.OPS.closeEOFillStroke,
                  numArgs: 0,
                  variableArgs: false
                };
                t["n"] = {
                  id: _util.OPS.endPath,
                  numArgs: 0,
                  variableArgs: false
                };
                t["W"] = {
                  id: _util.OPS.clip,
                  numArgs: 0,
                  variableArgs: false
                };
                t["W*"] = {
                  id: _util.OPS.eoClip,
                  numArgs: 0,
                  variableArgs: false
                };
                t["BT"] = {
                  id: _util.OPS.beginText,
                  numArgs: 0,
                  variableArgs: false
                };
                t["ET"] = {
                  id: _util.OPS.endText,
                  numArgs: 0,
                  variableArgs: false
                };
                t["Tc"] = {
                  id: _util.OPS.setCharSpacing,
                  numArgs: 1,
                  variableArgs: false
                };
                t["Tw"] = {
                  id: _util.OPS.setWordSpacing,
                  numArgs: 1,
                  variableArgs: false
                };
                t["Tz"] = {
                  id: _util.OPS.setHScale,
                  numArgs: 1,
                  variableArgs: false
                };
                t["TL"] = {
                  id: _util.OPS.setLeading,
                  numArgs: 1,
                  variableArgs: false
                };
                t["Tf"] = {
                  id: _util.OPS.setFont,
                  numArgs: 2,
                  variableArgs: false
                };
                t["Tr"] = {
                  id: _util.OPS.setTextRenderingMode,
                  numArgs: 1,
                  variableArgs: false
                };
                t["Ts"] = {
                  id: _util.OPS.setTextRise,
                  numArgs: 1,
                  variableArgs: false
                };
                t["Td"] = {
                  id: _util.OPS.moveText,
                  numArgs: 2,
                  variableArgs: false
                };
                t["TD"] = {
                  id: _util.OPS.setLeadingMoveText,
                  numArgs: 2,
                  variableArgs: false
                };
                t["Tm"] = {
                  id: _util.OPS.setTextMatrix,
                  numArgs: 6,
                  variableArgs: false
                };
                t["T*"] = {
                  id: _util.OPS.nextLine,
                  numArgs: 0,
                  variableArgs: false
                };
                t["Tj"] = {
                  id: _util.OPS.showText,
                  numArgs: 1,
                  variableArgs: false
                };
                t["TJ"] = {
                  id: _util.OPS.showSpacedText,
                  numArgs: 1,
                  variableArgs: false
                };
                t["'"] = {
                  id: _util.OPS.nextLineShowText,
                  numArgs: 1,
                  variableArgs: false
                };
                t['"'] = {
                  id: _util.OPS.nextLineSetSpacingShowText,
                  numArgs: 3,
                  variableArgs: false
                };
                t["d0"] = {
                  id: _util.OPS.setCharWidth,
                  numArgs: 2,
                  variableArgs: false
                };
                t["d1"] = {
                  id: _util.OPS.setCharWidthAndBounds,
                  numArgs: 6,
                  variableArgs: false
                };
                t["CS"] = {
                  id: _util.OPS.setStrokeColorSpace,
                  numArgs: 1,
                  variableArgs: false
                };
                t["cs"] = {
                  id: _util.OPS.setFillColorSpace,
                  numArgs: 1,
                  variableArgs: false
                };
                t["SC"] = {
                  id: _util.OPS.setStrokeColor,
                  numArgs: 4,
                  variableArgs: true
                };
                t["SCN"] = {
                  id: _util.OPS.setStrokeColorN,
                  numArgs: 33,
                  variableArgs: true
                };
                t["sc"] = {
                  id: _util.OPS.setFillColor,
                  numArgs: 4,
                  variableArgs: true
                };
                t["scn"] = {
                  id: _util.OPS.setFillColorN,
                  numArgs: 33,
                  variableArgs: true
                };
                t["G"] = {
                  id: _util.OPS.setStrokeGray,
                  numArgs: 1,
                  variableArgs: false
                };
                t["g"] = {
                  id: _util.OPS.setFillGray,
                  numArgs: 1,
                  variableArgs: false
                };
                t["RG"] = {
                  id: _util.OPS.setStrokeRGBColor,
                  numArgs: 3,
                  variableArgs: false
                };
                t["rg"] = {
                  id: _util.OPS.setFillRGBColor,
                  numArgs: 3,
                  variableArgs: false
                };
                t["K"] = {
                  id: _util.OPS.setStrokeCMYKColor,
                  numArgs: 4,
                  variableArgs: false
                };
                t["k"] = {
                  id: _util.OPS.setFillCMYKColor,
                  numArgs: 4,
                  variableArgs: false
                };
                t["sh"] = {
                  id: _util.OPS.shadingFill,
                  numArgs: 1,
                  variableArgs: false
                };
                t["BI"] = {
                  id: _util.OPS.beginInlineImage,
                  numArgs: 0,
                  variableArgs: false
                };
                t["ID"] = {
                  id: _util.OPS.beginImageData,
                  numArgs: 0,
                  variableArgs: false
                };
                t["EI"] = {
                  id: _util.OPS.endInlineImage,
                  numArgs: 1,
                  variableArgs: false
                };
                t["Do"] = {
                  id: _util.OPS.paintXObject,
                  numArgs: 1,
                  variableArgs: false
                };
                t["MP"] = {
                  id: _util.OPS.markPoint,
                  numArgs: 1,
                  variableArgs: false
                };
                t["DP"] = {
                  id: _util.OPS.markPointProps,
                  numArgs: 2,
                  variableArgs: false
                };
                t["BMC"] = {
                  id: _util.OPS.beginMarkedContent,
                  numArgs: 1,
                  variableArgs: false
                };
                t["BDC"] = {
                  id: _util.OPS.beginMarkedContentProps,
                  numArgs: 2,
                  variableArgs: false
                };
                t["EMC"] = {
                  id: _util.OPS.endMarkedContent,
                  numArgs: 0,
                  variableArgs: false
                };
                t["BX"] = {
                  id: _util.OPS.beginCompat,
                  numArgs: 0,
                  variableArgs: false
                };
                t["EX"] = {
                  id: _util.OPS.endCompat,
                  numArgs: 0,
                  variableArgs: false
                };
                t["BM"] = null;
                t["BD"] = null;
                t["true"] = null;
                t["fa"] = null;
                t["fal"] = null;
                t["fals"] = null;
                t["false"] = null;
                t["nu"] = null;
                t["nul"] = null;
                t["null"] = null;
              });
              function EvaluatorPreprocessor2(stream2, xref, stateManager) {
                this.opMap = getOPMap();
                this.parser = new _parser.Parser(new _parser.Lexer(stream2, this.opMap), false, xref);
                this.stateManager = stateManager;
                this.nonProcessedArgs = [];
              }
              EvaluatorPreprocessor2.prototype = {
                get savedStatesDepth() {
                  return this.stateManager.stateStack.length;
                },
                read: function EvaluatorPreprocessor_read(operation) {
                  var args = operation.args;
                  while (true) {
                    var obj = this.parser.getObj();
                    if ((0, _primitives.isCmd)(obj)) {
                      var cmd = obj.cmd;
                      var opSpec = this.opMap[cmd];
                      if (!opSpec) {
                        (0, _util.warn)('Unknown command "' + cmd + '"');
                        continue;
                      }
                      var fn = opSpec.id;
                      var numArgs = opSpec.numArgs;
                      var argsLength = args !== null ? args.length : 0;
                      if (!opSpec.variableArgs) {
                        if (argsLength !== numArgs) {
                          var nonProcessedArgs = this.nonProcessedArgs;
                          while (argsLength > numArgs) {
                            nonProcessedArgs.push(args.shift());
                            argsLength--;
                          }
                          while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
                            if (args === null) {
                              args = [];
                            }
                            args.unshift(nonProcessedArgs.pop());
                            argsLength++;
                          }
                        }
                        if (argsLength < numArgs) {
                          (0, _util.warn)("Skipping command " + fn + ": expected " + numArgs + " args, but received " + argsLength + " args.");
                          if (args !== null) {
                            args.length = 0;
                          }
                          continue;
                        }
                      } else if (argsLength > numArgs) {
                        (0, _util.info)("Command " + fn + ": expected [0," + numArgs + "] args, but received " + argsLength + " args.");
                      }
                      this.preprocessCommand(fn, args);
                      operation.fn = fn;
                      operation.args = args;
                      return true;
                    }
                    if ((0, _primitives.isEOF)(obj)) {
                      return false;
                    }
                    if (obj !== null) {
                      if (args === null) {
                        args = [];
                      }
                      args.push(obj);
                      if (args.length > 33) {
                        throw new _util.FormatError("Too many arguments");
                      }
                    }
                  }
                },
                preprocessCommand: function EvaluatorPreprocessor_preprocessCommand(fn, args) {
                  switch (fn | 0) {
                    case _util.OPS.save:
                      this.stateManager.save();
                      break;
                    case _util.OPS.restore:
                      this.stateManager.restore();
                      break;
                    case _util.OPS.transform:
                      this.stateManager.transform(args);
                      break;
                  }
                }
              };
              return EvaluatorPreprocessor2;
            }();
            exports3.PartialEvaluator = PartialEvaluator;
          },
          /* 136 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.CMapFactory = exports3.IdentityCMap = exports3.CMap = void 0;
            var _util = __w_pdfjs_require__(2);
            var _primitives = __w_pdfjs_require__(119);
            var _parser = __w_pdfjs_require__(120);
            var _stream = __w_pdfjs_require__(121);
            var BUILT_IN_CMAPS = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"];
            var CMap = function CMapClosure() {
              function CMap2(builtInCMap) {
                this.codespaceRanges = [[], [], [], []];
                this.numCodespaceRanges = 0;
                this._map = [];
                this.name = "";
                this.vertical = false;
                this.useCMap = null;
                this.builtInCMap = builtInCMap;
              }
              CMap2.prototype = {
                addCodespaceRange: function addCodespaceRange(n, low, high) {
                  this.codespaceRanges[n - 1].push(low, high);
                  this.numCodespaceRanges++;
                },
                mapCidRange: function mapCidRange(low, high, dstLow) {
                  while (low <= high) {
                    this._map[low++] = dstLow++;
                  }
                },
                mapBfRange: function mapBfRange(low, high, dstLow) {
                  var lastByte = dstLow.length - 1;
                  while (low <= high) {
                    this._map[low++] = dstLow;
                    dstLow = dstLow.substr(0, lastByte) + String.fromCharCode(dstLow.charCodeAt(lastByte) + 1);
                  }
                },
                mapBfRangeToArray: function mapBfRangeToArray(low, high, array) {
                  var i = 0, ii = array.length;
                  while (low <= high && i < ii) {
                    this._map[low] = array[i++];
                    ++low;
                  }
                },
                mapOne: function mapOne(src, dst) {
                  this._map[src] = dst;
                },
                lookup: function lookup(code) {
                  return this._map[code];
                },
                contains: function contains(code) {
                  return this._map[code] !== void 0;
                },
                forEach: function forEach(callback) {
                  var map = this._map;
                  var length = map.length;
                  if (length <= 65536) {
                    for (var i = 0; i < length; i++) {
                      if (map[i] !== void 0) {
                        callback(i, map[i]);
                      }
                    }
                  } else {
                    for (var _i in map) {
                      callback(_i, map[_i]);
                    }
                  }
                },
                charCodeOf: function charCodeOf(value) {
                  var map = this._map;
                  if (map.length <= 65536) {
                    return map.indexOf(value);
                  }
                  for (var charCode in map) {
                    if (map[charCode] === value) {
                      return charCode | 0;
                    }
                  }
                  return -1;
                },
                getMap: function getMap() {
                  return this._map;
                },
                readCharCode: function readCharCode(str, offset, out) {
                  var c = 0;
                  var codespaceRanges = this.codespaceRanges;
                  var codespaceRangesLen = this.codespaceRanges.length;
                  for (var n = 0; n < codespaceRangesLen; n++) {
                    c = (c << 8 | str.charCodeAt(offset + n)) >>> 0;
                    var codespaceRange = codespaceRanges[n];
                    for (var k = 0, kk = codespaceRange.length; k < kk; ) {
                      var low = codespaceRange[k++];
                      var high = codespaceRange[k++];
                      if (c >= low && c <= high) {
                        out.charcode = c;
                        out.length = n + 1;
                        return;
                      }
                    }
                  }
                  out.charcode = 0;
                  out.length = 1;
                },
                get length() {
                  return this._map.length;
                },
                get isIdentityCMap() {
                  if (!(this.name === "Identity-H" || this.name === "Identity-V")) {
                    return false;
                  }
                  if (this._map.length !== 65536) {
                    return false;
                  }
                  for (var i = 0; i < 65536; i++) {
                    if (this._map[i] !== i) {
                      return false;
                    }
                  }
                  return true;
                }
              };
              return CMap2;
            }();
            var IdentityCMap = function IdentityCMapClosure() {
              function IdentityCMap2(vertical, n) {
                CMap.call(this);
                this.vertical = vertical;
                this.addCodespaceRange(n, 0, 65535);
              }
              _util.Util.inherit(IdentityCMap2, CMap, {});
              IdentityCMap2.prototype = {
                addCodespaceRange: CMap.prototype.addCodespaceRange,
                mapCidRange: function mapCidRange(low, high, dstLow) {
                  (0, _util.unreachable)("should not call mapCidRange");
                },
                mapBfRange: function mapBfRange(low, high, dstLow) {
                  (0, _util.unreachable)("should not call mapBfRange");
                },
                mapBfRangeToArray: function mapBfRangeToArray(low, high, array) {
                  (0, _util.unreachable)("should not call mapBfRangeToArray");
                },
                mapOne: function mapOne(src, dst) {
                  (0, _util.unreachable)("should not call mapCidOne");
                },
                lookup: function lookup(code) {
                  return Number.isInteger(code) && code <= 65535 ? code : void 0;
                },
                contains: function contains(code) {
                  return Number.isInteger(code) && code <= 65535;
                },
                forEach: function forEach(callback) {
                  for (var i = 0; i <= 65535; i++) {
                    callback(i, i);
                  }
                },
                charCodeOf: function charCodeOf(value) {
                  return Number.isInteger(value) && value <= 65535 ? value : -1;
                },
                getMap: function getMap() {
                  var map = new Array(65536);
                  for (var i = 0; i <= 65535; i++) {
                    map[i] = i;
                  }
                  return map;
                },
                readCharCode: CMap.prototype.readCharCode,
                get length() {
                  return 65536;
                },
                get isIdentityCMap() {
                  (0, _util.unreachable)("should not access .isIdentityCMap");
                }
              };
              return IdentityCMap2;
            }();
            var BinaryCMapReader = function BinaryCMapReaderClosure() {
              function hexToInt(a, size) {
                var n = 0;
                for (var i = 0; i <= size; i++) {
                  n = n << 8 | a[i];
                }
                return n >>> 0;
              }
              function hexToStr(a, size) {
                if (size === 1) {
                  return String.fromCharCode(a[0], a[1]);
                }
                if (size === 3) {
                  return String.fromCharCode(a[0], a[1], a[2], a[3]);
                }
                return String.fromCharCode.apply(null, a.subarray(0, size + 1));
              }
              function addHex(a, b, size) {
                var c = 0;
                for (var i = size; i >= 0; i--) {
                  c += a[i] + b[i];
                  a[i] = c & 255;
                  c >>= 8;
                }
              }
              function incHex(a, size) {
                var c = 1;
                for (var i = size; i >= 0 && c > 0; i--) {
                  c += a[i];
                  a[i] = c & 255;
                  c >>= 8;
                }
              }
              var MAX_NUM_SIZE = 16;
              var MAX_ENCODED_NUM_SIZE = 19;
              function BinaryCMapStream(data) {
                this.buffer = data;
                this.pos = 0;
                this.end = data.length;
                this.tmpBuf = new Uint8Array(MAX_ENCODED_NUM_SIZE);
              }
              BinaryCMapStream.prototype = {
                readByte: function readByte() {
                  if (this.pos >= this.end) {
                    return -1;
                  }
                  return this.buffer[this.pos++];
                },
                readNumber: function readNumber() {
                  var n = 0;
                  var last;
                  do {
                    var b = this.readByte();
                    if (b < 0) {
                      throw new _util.FormatError("unexpected EOF in bcmap");
                    }
                    last = !(b & 128);
                    n = n << 7 | b & 127;
                  } while (!last);
                  return n;
                },
                readSigned: function readSigned() {
                  var n = this.readNumber();
                  return n & 1 ? ~(n >>> 1) : n >>> 1;
                },
                readHex: function readHex(num, size) {
                  num.set(this.buffer.subarray(this.pos, this.pos + size + 1));
                  this.pos += size + 1;
                },
                readHexNumber: function readHexNumber(num, size) {
                  var last;
                  var stack = this.tmpBuf, sp = 0;
                  do {
                    var b = this.readByte();
                    if (b < 0) {
                      throw new _util.FormatError("unexpected EOF in bcmap");
                    }
                    last = !(b & 128);
                    stack[sp++] = b & 127;
                  } while (!last);
                  var i = size, buffer = 0, bufferSize = 0;
                  while (i >= 0) {
                    while (bufferSize < 8 && stack.length > 0) {
                      buffer = stack[--sp] << bufferSize | buffer;
                      bufferSize += 7;
                    }
                    num[i] = buffer & 255;
                    i--;
                    buffer >>= 8;
                    bufferSize -= 8;
                  }
                },
                readHexSigned: function readHexSigned(num, size) {
                  this.readHexNumber(num, size);
                  var sign = num[size] & 1 ? 255 : 0;
                  var c = 0;
                  for (var i = 0; i <= size; i++) {
                    c = (c & 1) << 8 | num[i];
                    num[i] = c >> 1 ^ sign;
                  }
                },
                readString: function readString() {
                  var len = this.readNumber();
                  var s = "";
                  for (var i = 0; i < len; i++) {
                    s += String.fromCharCode(this.readNumber());
                  }
                  return s;
                }
              };
              function processBinaryCMap(data, cMap, extend) {
                return new Promise(function(resolve2, reject2) {
                  var stream2 = new BinaryCMapStream(data);
                  var header = stream2.readByte();
                  cMap.vertical = !!(header & 1);
                  var useCMap = null;
                  var start = new Uint8Array(MAX_NUM_SIZE);
                  var end = new Uint8Array(MAX_NUM_SIZE);
                  var char = new Uint8Array(MAX_NUM_SIZE);
                  var charCode = new Uint8Array(MAX_NUM_SIZE);
                  var tmp = new Uint8Array(MAX_NUM_SIZE);
                  var code;
                  var b;
                  while ((b = stream2.readByte()) >= 0) {
                    var type = b >> 5;
                    if (type === 7) {
                      switch (b & 31) {
                        case 0:
                          stream2.readString();
                          break;
                        case 1:
                          useCMap = stream2.readString();
                          break;
                      }
                      continue;
                    }
                    var sequence = !!(b & 16);
                    var dataSize = b & 15;
                    if (dataSize + 1 > MAX_NUM_SIZE) {
                      throw new Error("processBinaryCMap: Invalid dataSize.");
                    }
                    var ucs2DataSize = 1;
                    var subitemsCount = stream2.readNumber();
                    var i;
                    switch (type) {
                      case 0:
                        stream2.readHex(start, dataSize);
                        stream2.readHexNumber(end, dataSize);
                        addHex(end, start, dataSize);
                        cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
                        for (i = 1; i < subitemsCount; i++) {
                          incHex(end, dataSize);
                          stream2.readHexNumber(start, dataSize);
                          addHex(start, end, dataSize);
                          stream2.readHexNumber(end, dataSize);
                          addHex(end, start, dataSize);
                          cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
                        }
                        break;
                      case 1:
                        stream2.readHex(start, dataSize);
                        stream2.readHexNumber(end, dataSize);
                        addHex(end, start, dataSize);
                        stream2.readNumber();
                        for (i = 1; i < subitemsCount; i++) {
                          incHex(end, dataSize);
                          stream2.readHexNumber(start, dataSize);
                          addHex(start, end, dataSize);
                          stream2.readHexNumber(end, dataSize);
                          addHex(end, start, dataSize);
                          stream2.readNumber();
                        }
                        break;
                      case 2:
                        stream2.readHex(char, dataSize);
                        code = stream2.readNumber();
                        cMap.mapOne(hexToInt(char, dataSize), code);
                        for (i = 1; i < subitemsCount; i++) {
                          incHex(char, dataSize);
                          if (!sequence) {
                            stream2.readHexNumber(tmp, dataSize);
                            addHex(char, tmp, dataSize);
                          }
                          code = stream2.readSigned() + (code + 1);
                          cMap.mapOne(hexToInt(char, dataSize), code);
                        }
                        break;
                      case 3:
                        stream2.readHex(start, dataSize);
                        stream2.readHexNumber(end, dataSize);
                        addHex(end, start, dataSize);
                        code = stream2.readNumber();
                        cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
                        for (i = 1; i < subitemsCount; i++) {
                          incHex(end, dataSize);
                          if (!sequence) {
                            stream2.readHexNumber(start, dataSize);
                            addHex(start, end, dataSize);
                          } else {
                            start.set(end);
                          }
                          stream2.readHexNumber(end, dataSize);
                          addHex(end, start, dataSize);
                          code = stream2.readNumber();
                          cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
                        }
                        break;
                      case 4:
                        stream2.readHex(char, ucs2DataSize);
                        stream2.readHex(charCode, dataSize);
                        cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
                        for (i = 1; i < subitemsCount; i++) {
                          incHex(char, ucs2DataSize);
                          if (!sequence) {
                            stream2.readHexNumber(tmp, ucs2DataSize);
                            addHex(char, tmp, ucs2DataSize);
                          }
                          incHex(charCode, dataSize);
                          stream2.readHexSigned(tmp, dataSize);
                          addHex(charCode, tmp, dataSize);
                          cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
                        }
                        break;
                      case 5:
                        stream2.readHex(start, ucs2DataSize);
                        stream2.readHexNumber(end, ucs2DataSize);
                        addHex(end, start, ucs2DataSize);
                        stream2.readHex(charCode, dataSize);
                        cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
                        for (i = 1; i < subitemsCount; i++) {
                          incHex(end, ucs2DataSize);
                          if (!sequence) {
                            stream2.readHexNumber(start, ucs2DataSize);
                            addHex(start, end, ucs2DataSize);
                          } else {
                            start.set(end);
                          }
                          stream2.readHexNumber(end, ucs2DataSize);
                          addHex(end, start, ucs2DataSize);
                          stream2.readHex(charCode, dataSize);
                          cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
                        }
                        break;
                      default:
                        reject2(new Error("processBinaryCMap: Unknown type: " + type));
                        return;
                    }
                  }
                  if (useCMap) {
                    resolve2(extend(useCMap));
                    return;
                  }
                  resolve2(cMap);
                });
              }
              function BinaryCMapReader2() {
              }
              BinaryCMapReader2.prototype = { process: processBinaryCMap };
              return BinaryCMapReader2;
            }();
            var CMapFactory = /* @__PURE__ */ function CMapFactoryClosure() {
              function strToInt(str) {
                var a = 0;
                for (var i = 0; i < str.length; i++) {
                  a = a << 8 | str.charCodeAt(i);
                }
                return a >>> 0;
              }
              function expectString(obj) {
                if (!(0, _util.isString)(obj)) {
                  throw new _util.FormatError("Malformed CMap: expected string.");
                }
              }
              function expectInt(obj) {
                if (!Number.isInteger(obj)) {
                  throw new _util.FormatError("Malformed CMap: expected int.");
                }
              }
              function parseBfChar(cMap, lexer) {
                while (true) {
                  var obj = lexer.getObj();
                  if ((0, _primitives.isEOF)(obj)) {
                    break;
                  }
                  if ((0, _primitives.isCmd)(obj, "endbfchar")) {
                    return;
                  }
                  expectString(obj);
                  var src = strToInt(obj);
                  obj = lexer.getObj();
                  expectString(obj);
                  var dst = obj;
                  cMap.mapOne(src, dst);
                }
              }
              function parseBfRange(cMap, lexer) {
                while (true) {
                  var obj = lexer.getObj();
                  if ((0, _primitives.isEOF)(obj)) {
                    break;
                  }
                  if ((0, _primitives.isCmd)(obj, "endbfrange")) {
                    return;
                  }
                  expectString(obj);
                  var low = strToInt(obj);
                  obj = lexer.getObj();
                  expectString(obj);
                  var high = strToInt(obj);
                  obj = lexer.getObj();
                  if (Number.isInteger(obj) || (0, _util.isString)(obj)) {
                    var dstLow = Number.isInteger(obj) ? String.fromCharCode(obj) : obj;
                    cMap.mapBfRange(low, high, dstLow);
                  } else if ((0, _primitives.isCmd)(obj, "[")) {
                    obj = lexer.getObj();
                    var array = [];
                    while (!(0, _primitives.isCmd)(obj, "]") && !(0, _primitives.isEOF)(obj)) {
                      array.push(obj);
                      obj = lexer.getObj();
                    }
                    cMap.mapBfRangeToArray(low, high, array);
                  } else {
                    break;
                  }
                }
                throw new _util.FormatError("Invalid bf range.");
              }
              function parseCidChar(cMap, lexer) {
                while (true) {
                  var obj = lexer.getObj();
                  if ((0, _primitives.isEOF)(obj)) {
                    break;
                  }
                  if ((0, _primitives.isCmd)(obj, "endcidchar")) {
                    return;
                  }
                  expectString(obj);
                  var src = strToInt(obj);
                  obj = lexer.getObj();
                  expectInt(obj);
                  var dst = obj;
                  cMap.mapOne(src, dst);
                }
              }
              function parseCidRange(cMap, lexer) {
                while (true) {
                  var obj = lexer.getObj();
                  if ((0, _primitives.isEOF)(obj)) {
                    break;
                  }
                  if ((0, _primitives.isCmd)(obj, "endcidrange")) {
                    return;
                  }
                  expectString(obj);
                  var low = strToInt(obj);
                  obj = lexer.getObj();
                  expectString(obj);
                  var high = strToInt(obj);
                  obj = lexer.getObj();
                  expectInt(obj);
                  var dstLow = obj;
                  cMap.mapCidRange(low, high, dstLow);
                }
              }
              function parseCodespaceRange(cMap, lexer) {
                while (true) {
                  var obj = lexer.getObj();
                  if ((0, _primitives.isEOF)(obj)) {
                    break;
                  }
                  if ((0, _primitives.isCmd)(obj, "endcodespacerange")) {
                    return;
                  }
                  if (!(0, _util.isString)(obj)) {
                    break;
                  }
                  var low = strToInt(obj);
                  obj = lexer.getObj();
                  if (!(0, _util.isString)(obj)) {
                    break;
                  }
                  var high = strToInt(obj);
                  cMap.addCodespaceRange(obj.length, low, high);
                }
                throw new _util.FormatError("Invalid codespace range.");
              }
              function parseWMode(cMap, lexer) {
                var obj = lexer.getObj();
                if (Number.isInteger(obj)) {
                  cMap.vertical = !!obj;
                }
              }
              function parseCMapName(cMap, lexer) {
                var obj = lexer.getObj();
                if ((0, _primitives.isName)(obj) && (0, _util.isString)(obj.name)) {
                  cMap.name = obj.name;
                }
              }
              function parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap) {
                var previous;
                var embeddedUseCMap;
                objLoop: while (true) {
                  try {
                    var obj = lexer.getObj();
                    if ((0, _primitives.isEOF)(obj)) {
                      break;
                    } else if ((0, _primitives.isName)(obj)) {
                      if (obj.name === "WMode") {
                        parseWMode(cMap, lexer);
                      } else if (obj.name === "CMapName") {
                        parseCMapName(cMap, lexer);
                      }
                      previous = obj;
                    } else if ((0, _primitives.isCmd)(obj)) {
                      switch (obj.cmd) {
                        case "endcmap":
                          break objLoop;
                        case "usecmap":
                          if ((0, _primitives.isName)(previous)) {
                            embeddedUseCMap = previous.name;
                          }
                          break;
                        case "begincodespacerange":
                          parseCodespaceRange(cMap, lexer);
                          break;
                        case "beginbfchar":
                          parseBfChar(cMap, lexer);
                          break;
                        case "begincidchar":
                          parseCidChar(cMap, lexer);
                          break;
                        case "beginbfrange":
                          parseBfRange(cMap, lexer);
                          break;
                        case "begincidrange":
                          parseCidRange(cMap, lexer);
                          break;
                      }
                    }
                  } catch (ex) {
                    if (ex instanceof _util.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)("Invalid cMap data: " + ex);
                    continue;
                  }
                }
                if (!useCMap && embeddedUseCMap) {
                  useCMap = embeddedUseCMap;
                }
                if (useCMap) {
                  return extendCMap(cMap, fetchBuiltInCMap, useCMap);
                }
                return Promise.resolve(cMap);
              }
              function extendCMap(cMap, fetchBuiltInCMap, useCMap) {
                return createBuiltInCMap(useCMap, fetchBuiltInCMap).then(function(newCMap) {
                  cMap.useCMap = newCMap;
                  if (cMap.numCodespaceRanges === 0) {
                    var useCodespaceRanges = cMap.useCMap.codespaceRanges;
                    for (var i = 0; i < useCodespaceRanges.length; i++) {
                      cMap.codespaceRanges[i] = useCodespaceRanges[i].slice();
                    }
                    cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges;
                  }
                  cMap.useCMap.forEach(function(key, value) {
                    if (!cMap.contains(key)) {
                      cMap.mapOne(key, cMap.useCMap.lookup(key));
                    }
                  });
                  return cMap;
                });
              }
              function createBuiltInCMap(name, fetchBuiltInCMap) {
                if (name === "Identity-H") {
                  return Promise.resolve(new IdentityCMap(false, 2));
                } else if (name === "Identity-V") {
                  return Promise.resolve(new IdentityCMap(true, 2));
                }
                if (!BUILT_IN_CMAPS.includes(name)) {
                  return Promise.reject(new Error("Unknown CMap name: " + name));
                }
                if (!fetchBuiltInCMap) {
                  return Promise.reject(new Error("Built-in CMap parameters are not provided."));
                }
                return fetchBuiltInCMap(name).then(function(data) {
                  var cMapData = data.cMapData, compressionType = data.compressionType;
                  var cMap = new CMap(true);
                  if (compressionType === _util.CMapCompressionType.BINARY) {
                    return new BinaryCMapReader().process(cMapData, cMap, function(useCMap) {
                      return extendCMap(cMap, fetchBuiltInCMap, useCMap);
                    });
                  }
                  if (compressionType === _util.CMapCompressionType.NONE) {
                    var lexer = new _parser.Lexer(new _stream.Stream(cMapData));
                    return parseCMap(cMap, lexer, fetchBuiltInCMap, null);
                  }
                  return Promise.reject(new Error("TODO: Only BINARY/NONE CMap compression is currently supported."));
                });
              }
              return {
                create: function create(params) {
                  var encoding = params.encoding;
                  var fetchBuiltInCMap = params.fetchBuiltInCMap;
                  var useCMap = params.useCMap;
                  if ((0, _primitives.isName)(encoding)) {
                    return createBuiltInCMap(encoding.name, fetchBuiltInCMap);
                  } else if ((0, _primitives.isStream)(encoding)) {
                    var cMap = new CMap();
                    var lexer = new _parser.Lexer(encoding);
                    return parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap).then(function(parsedCMap) {
                      if (parsedCMap.isIdentityCMap) {
                        return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);
                      }
                      return parsedCMap;
                    });
                  }
                  return Promise.reject(new Error("Encoding required."));
                }
              };
            }();
            exports3.CMap = CMap;
            exports3.IdentityCMap = IdentityCMap;
            exports3.CMapFactory = CMapFactory;
          },
          /* 137 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.getFontType = exports3.ProblematicCharRanges = exports3.IdentityToUnicodeMap = exports3.ToUnicodeMap = exports3.FontFlags = exports3.Font = exports3.ErrorFont = exports3.PRIVATE_USE_OFFSET_END = exports3.PRIVATE_USE_OFFSET_START = exports3.SEAC_ANALYSIS_ENABLED = void 0;
            var _util = __w_pdfjs_require__(2);
            var _cff_parser = __w_pdfjs_require__(138);
            var _glyphlist = __w_pdfjs_require__(141);
            var _encodings = __w_pdfjs_require__(140);
            var _standard_fonts = __w_pdfjs_require__(142);
            var _unicode = __w_pdfjs_require__(143);
            var _font_renderer = __w_pdfjs_require__(144);
            var _stream = __w_pdfjs_require__(121);
            var _type1_parser = __w_pdfjs_require__(145);
            var PRIVATE_USE_OFFSET_START = 57344;
            var PRIVATE_USE_OFFSET_END = 63743;
            var SKIP_PRIVATE_USE_RANGE_F000_TO_F01F = false;
            var PDF_GLYPH_SPACE_UNITS = 1e3;
            var SEAC_ANALYSIS_ENABLED = false;
            var FontFlags = {
              FixedPitch: 1,
              Serif: 2,
              Symbolic: 4,
              Script: 8,
              Nonsymbolic: 32,
              Italic: 64,
              AllCap: 65536,
              SmallCap: 131072,
              ForceBold: 262144
            };
            var MacStandardGlyphOrdering = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
            function adjustWidths(properties) {
              if (!properties.fontMatrix) {
                return;
              }
              if (properties.fontMatrix[0] === _util.FONT_IDENTITY_MATRIX[0]) {
                return;
              }
              var scale = 1e-3 / properties.fontMatrix[0];
              var glyphsWidths = properties.widths;
              for (var glyph in glyphsWidths) {
                glyphsWidths[glyph] *= scale;
              }
              properties.defaultWidth *= scale;
            }
            function adjustToUnicode(properties, builtInEncoding) {
              if (properties.hasIncludedToUnicodeMap) {
                return;
              }
              if (properties.hasEncoding) {
                return;
              }
              if (builtInEncoding === properties.defaultEncoding) {
                return;
              }
              if (properties.toUnicode instanceof IdentityToUnicodeMap) {
                return;
              }
              var toUnicode = [], glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
              for (var charCode in builtInEncoding) {
                var glyphName = builtInEncoding[charCode];
                var unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
                if (unicode !== -1) {
                  toUnicode[charCode] = String.fromCharCode(unicode);
                }
              }
              properties.toUnicode.amend(toUnicode);
            }
            function getFontType(type, subtype) {
              switch (type) {
                case "Type1":
                  return subtype === "Type1C" ? _util.FontType.TYPE1C : _util.FontType.TYPE1;
                case "CIDFontType0":
                  return subtype === "CIDFontType0C" ? _util.FontType.CIDFONTTYPE0C : _util.FontType.CIDFONTTYPE0;
                case "OpenType":
                  return _util.FontType.OPENTYPE;
                case "TrueType":
                  return _util.FontType.TRUETYPE;
                case "CIDFontType2":
                  return _util.FontType.CIDFONTTYPE2;
                case "MMType1":
                  return _util.FontType.MMTYPE1;
                case "Type0":
                  return _util.FontType.TYPE0;
                default:
                  return _util.FontType.UNKNOWN;
              }
            }
            function recoverGlyphName(name, glyphsUnicodeMap) {
              if (glyphsUnicodeMap[name] !== void 0) {
                return name;
              }
              var unicode = (0, _unicode.getUnicodeForGlyph)(name, glyphsUnicodeMap);
              if (unicode !== -1) {
                for (var key in glyphsUnicodeMap) {
                  if (glyphsUnicodeMap[key] === unicode) {
                    return key;
                  }
                }
              }
              (0, _util.info)("Unable to recover a standard glyph name for: " + name);
              return name;
            }
            var Glyph = function GlyphClosure() {
              function Glyph2(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {
                this.fontChar = fontChar;
                this.unicode = unicode;
                this.accent = accent;
                this.width = width;
                this.vmetric = vmetric;
                this.operatorListId = operatorListId;
                this.isSpace = isSpace;
                this.isInFont = isInFont;
              }
              Glyph2.prototype.matchesForCache = function(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {
                return this.fontChar === fontChar && this.unicode === unicode && this.accent === accent && this.width === width && this.vmetric === vmetric && this.operatorListId === operatorListId && this.isSpace === isSpace && this.isInFont === isInFont;
              };
              return Glyph2;
            }();
            var ToUnicodeMap = function ToUnicodeMapClosure() {
              function ToUnicodeMap2() {
                var cmap = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                this._map = cmap;
              }
              ToUnicodeMap2.prototype = {
                get length() {
                  return this._map.length;
                },
                forEach: function forEach(callback) {
                  for (var charCode in this._map) {
                    callback(charCode, this._map[charCode].charCodeAt(0));
                  }
                },
                has: function has(i) {
                  return this._map[i] !== void 0;
                },
                get: function get(i) {
                  return this._map[i];
                },
                charCodeOf: function charCodeOf(value) {
                  var map = this._map;
                  if (map.length <= 65536) {
                    return map.indexOf(value);
                  }
                  for (var charCode in map) {
                    if (map[charCode] === value) {
                      return charCode | 0;
                    }
                  }
                  return -1;
                },
                amend: function amend(map) {
                  for (var charCode in map) {
                    this._map[charCode] = map[charCode];
                  }
                }
              };
              return ToUnicodeMap2;
            }();
            var IdentityToUnicodeMap = function IdentityToUnicodeMapClosure() {
              function IdentityToUnicodeMap2(firstChar, lastChar) {
                this.firstChar = firstChar;
                this.lastChar = lastChar;
              }
              IdentityToUnicodeMap2.prototype = {
                get length() {
                  return this.lastChar + 1 - this.firstChar;
                },
                forEach: function forEach(callback) {
                  for (var i = this.firstChar, ii = this.lastChar; i <= ii; i++) {
                    callback(i, i);
                  }
                },
                has: function has(i) {
                  return this.firstChar <= i && i <= this.lastChar;
                },
                get: function get(i) {
                  if (this.firstChar <= i && i <= this.lastChar) {
                    return String.fromCharCode(i);
                  }
                  return void 0;
                },
                charCodeOf: function charCodeOf(v) {
                  return Number.isInteger(v) && v >= this.firstChar && v <= this.lastChar ? v : -1;
                },
                amend: function amend(map) {
                  (0, _util.unreachable)("Should not call amend()");
                }
              };
              return IdentityToUnicodeMap2;
            }();
            var OpenTypeFileBuilder = function OpenTypeFileBuilderClosure() {
              function writeInt16(dest, offset, num) {
                dest[offset] = num >> 8 & 255;
                dest[offset + 1] = num & 255;
              }
              function writeInt32(dest, offset, num) {
                dest[offset] = num >> 24 & 255;
                dest[offset + 1] = num >> 16 & 255;
                dest[offset + 2] = num >> 8 & 255;
                dest[offset + 3] = num & 255;
              }
              function writeData(dest, offset, data) {
                var i, ii;
                if (data instanceof Uint8Array) {
                  dest.set(data, offset);
                } else if (typeof data === "string") {
                  for (i = 0, ii = data.length; i < ii; i++) {
                    dest[offset++] = data.charCodeAt(i) & 255;
                  }
                } else {
                  for (i = 0, ii = data.length; i < ii; i++) {
                    dest[offset++] = data[i] & 255;
                  }
                }
              }
              function OpenTypeFileBuilder2(sfnt) {
                this.sfnt = sfnt;
                this.tables = /* @__PURE__ */ Object.create(null);
              }
              OpenTypeFileBuilder2.getSearchParams = function OpenTypeFileBuilder_getSearchParams(entriesCount, entrySize) {
                var maxPower2 = 1, log2 = 0;
                while ((maxPower2 ^ entriesCount) > maxPower2) {
                  maxPower2 <<= 1;
                  log2++;
                }
                var searchRange = maxPower2 * entrySize;
                return {
                  range: searchRange,
                  entry: log2,
                  rangeShift: entrySize * entriesCount - searchRange
                };
              };
              var OTF_HEADER_SIZE = 12;
              var OTF_TABLE_ENTRY_SIZE = 16;
              OpenTypeFileBuilder2.prototype = {
                toArray: function OpenTypeFileBuilder_toArray() {
                  var sfnt = this.sfnt;
                  var tables = this.tables;
                  var tablesNames = Object.keys(tables);
                  tablesNames.sort();
                  var numTables = tablesNames.length;
                  var i, j, jj, table, tableName;
                  var offset = OTF_HEADER_SIZE + numTables * OTF_TABLE_ENTRY_SIZE;
                  var tableOffsets = [offset];
                  for (i = 0; i < numTables; i++) {
                    table = tables[tablesNames[i]];
                    var paddedLength = (table.length + 3 & ~3) >>> 0;
                    offset += paddedLength;
                    tableOffsets.push(offset);
                  }
                  var file = new Uint8Array(offset);
                  for (i = 0; i < numTables; i++) {
                    table = tables[tablesNames[i]];
                    writeData(file, tableOffsets[i], table);
                  }
                  if (sfnt === "true") {
                    sfnt = (0, _util.string32)(65536);
                  }
                  file[0] = sfnt.charCodeAt(0) & 255;
                  file[1] = sfnt.charCodeAt(1) & 255;
                  file[2] = sfnt.charCodeAt(2) & 255;
                  file[3] = sfnt.charCodeAt(3) & 255;
                  writeInt16(file, 4, numTables);
                  var searchParams = OpenTypeFileBuilder2.getSearchParams(numTables, 16);
                  writeInt16(file, 6, searchParams.range);
                  writeInt16(file, 8, searchParams.entry);
                  writeInt16(file, 10, searchParams.rangeShift);
                  offset = OTF_HEADER_SIZE;
                  for (i = 0; i < numTables; i++) {
                    tableName = tablesNames[i];
                    file[offset] = tableName.charCodeAt(0) & 255;
                    file[offset + 1] = tableName.charCodeAt(1) & 255;
                    file[offset + 2] = tableName.charCodeAt(2) & 255;
                    file[offset + 3] = tableName.charCodeAt(3) & 255;
                    var checksum = 0;
                    for (j = tableOffsets[i], jj = tableOffsets[i + 1]; j < jj; j += 4) {
                      var quad = (0, _util.readUint32)(file, j);
                      checksum = checksum + quad >>> 0;
                    }
                    writeInt32(file, offset + 4, checksum);
                    writeInt32(file, offset + 8, tableOffsets[i]);
                    writeInt32(file, offset + 12, tables[tableName].length);
                    offset += OTF_TABLE_ENTRY_SIZE;
                  }
                  return file;
                },
                addTable: function OpenTypeFileBuilder_addTable(tag, data) {
                  if (tag in this.tables) {
                    throw new Error("Table " + tag + " already exists");
                  }
                  this.tables[tag] = data;
                }
              };
              return OpenTypeFileBuilder2;
            }();
            var ProblematicCharRanges = new Int32Array([0, 32, 127, 161, 173, 174, 1536, 1920, 2208, 4256, 6016, 6144, 7168, 7248, 8192, 8208, 8209, 8210, 8232, 8240, 8287, 8304, 9676, 9677, 12288, 12289, 12644, 12645, 43616, 43648, 55296, 57344, 65520, 65536]);
            var Font = function FontClosure() {
              function Font2(name, file, properties) {
                var charCode;
                this.name = name;
                this.loadedName = properties.loadedName;
                this.isType3Font = properties.isType3Font;
                this.sizes = [];
                this.missingFile = false;
                this.glyphCache = /* @__PURE__ */ Object.create(null);
                this.isSerifFont = !!(properties.flags & FontFlags.Serif);
                this.isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
                this.isMonospace = !!(properties.flags & FontFlags.FixedPitch);
                var type = properties.type;
                var subtype = properties.subtype;
                this.type = type;
                this.subtype = subtype;
                this.fallbackName = this.isMonospace ? "monospace" : this.isSerifFont ? "serif" : "sans-serif";
                this.differences = properties.differences;
                this.widths = properties.widths;
                this.defaultWidth = properties.defaultWidth;
                this.composite = properties.composite;
                this.wideChars = properties.wideChars;
                this.cMap = properties.cMap;
                this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
                this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
                this.fontMatrix = properties.fontMatrix;
                this.bbox = properties.bbox;
                this.defaultEncoding = properties.defaultEncoding;
                this.toUnicode = properties.toUnicode;
                this.fallbackToUnicode = properties.fallbackToUnicode || new ToUnicodeMap();
                this.toFontChar = [];
                if (properties.type === "Type3") {
                  for (charCode = 0; charCode < 256; charCode++) {
                    this.toFontChar[charCode] = this.differences[charCode] || properties.defaultEncoding[charCode];
                  }
                  this.fontType = _util.FontType.TYPE3;
                  return;
                }
                this.cidEncoding = properties.cidEncoding;
                this.vertical = properties.vertical;
                if (this.vertical) {
                  this.vmetrics = properties.vmetrics;
                  this.defaultVMetrics = properties.defaultVMetrics;
                }
                if (!file || file.isEmpty) {
                  if (file) {
                    (0, _util.warn)('Font file is empty in "' + name + '" (' + this.loadedName + ")");
                  }
                  this.fallbackToSystemFont();
                  return;
                }
                if (subtype === "Type1C") {
                  if (type !== "Type1" && type !== "MMType1") {
                    if (isTrueTypeFile(file)) {
                      subtype = "TrueType";
                    } else {
                      type = "Type1";
                    }
                  } else if (isOpenTypeFile(file)) {
                    subtype = "OpenType";
                  }
                }
                if (subtype === "CIDFontType0C" && type !== "CIDFontType0") {
                  type = "CIDFontType0";
                }
                if (type === "CIDFontType0") {
                  if (isType1File(file)) {
                    subtype = "CIDFontType0";
                  } else if (isOpenTypeFile(file)) {
                    subtype = "OpenType";
                  } else {
                    subtype = "CIDFontType0C";
                  }
                }
                if (subtype === "OpenType" && type !== "OpenType") {
                  type = "OpenType";
                }
                try {
                  var data;
                  switch (type) {
                    case "MMType1":
                      (0, _util.info)("MMType1 font (" + name + "), falling back to Type1.");
                    case "Type1":
                    case "CIDFontType0":
                      this.mimetype = "font/opentype";
                      var cff = subtype === "Type1C" || subtype === "CIDFontType0C" ? new CFFFont(file, properties) : new Type1Font(name, file, properties);
                      adjustWidths(properties);
                      data = this.convert(name, cff, properties);
                      break;
                    case "OpenType":
                    case "TrueType":
                    case "CIDFontType2":
                      this.mimetype = "font/opentype";
                      data = this.checkAndRepair(name, file, properties);
                      if (this.isOpenType) {
                        adjustWidths(properties);
                        type = "OpenType";
                      }
                      break;
                    default:
                      throw new _util.FormatError("Font " + type + " is not supported");
                  }
                } catch (e) {
                  if (!(e instanceof _util.FormatError)) {
                    throw e;
                  }
                  (0, _util.warn)(e);
                  this.fallbackToSystemFont();
                  return;
                }
                this.data = data;
                this.fontType = getFontType(type, subtype);
                this.fontMatrix = properties.fontMatrix;
                this.widths = properties.widths;
                this.defaultWidth = properties.defaultWidth;
                this.toUnicode = properties.toUnicode;
                this.encoding = properties.baseEncoding;
                this.seacMap = properties.seacMap;
                this.loading = true;
              }
              Font2.getFontID = /* @__PURE__ */ function() {
                var ID = 1;
                return function Font_getFontID() {
                  return String(ID++);
                };
              }();
              function int16(b0, b1) {
                return (b0 << 8) + b1;
              }
              function writeSignedInt16(bytes, index, value) {
                bytes[index + 1] = value;
                bytes[index] = value >>> 8;
              }
              function signedInt16(b0, b1) {
                var value = (b0 << 8) + b1;
                return value & 1 << 15 ? value - 65536 : value;
              }
              function int32(b0, b1, b2, b3) {
                return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
              }
              function string16(value) {
                return String.fromCharCode(value >> 8 & 255, value & 255);
              }
              function safeString16(value) {
                value = value > 32767 ? 32767 : value < -32768 ? -32768 : value;
                return String.fromCharCode(value >> 8 & 255, value & 255);
              }
              function isTrueTypeFile(file) {
                var header = file.peekBytes(4);
                return (0, _util.readUint32)(header, 0) === 65536;
              }
              function isTrueTypeCollectionFile(file) {
                var header = file.peekBytes(4);
                return (0, _util.bytesToString)(header) === "ttcf";
              }
              function isOpenTypeFile(file) {
                var header = file.peekBytes(4);
                return (0, _util.bytesToString)(header) === "OTTO";
              }
              function isType1File(file) {
                var header = file.peekBytes(2);
                if (header[0] === 37 && header[1] === 33) {
                  return true;
                }
                if (header[0] === 128 && header[1] === 1) {
                  return true;
                }
                return false;
              }
              function buildToFontChar(encoding, glyphsUnicodeMap, differences) {
                var toFontChar = [], unicode;
                for (var i = 0, ii = encoding.length; i < ii; i++) {
                  unicode = (0, _unicode.getUnicodeForGlyph)(encoding[i], glyphsUnicodeMap);
                  if (unicode !== -1) {
                    toFontChar[i] = unicode;
                  }
                }
                for (var charCode in differences) {
                  unicode = (0, _unicode.getUnicodeForGlyph)(differences[charCode], glyphsUnicodeMap);
                  if (unicode !== -1) {
                    toFontChar[+charCode] = unicode;
                  }
                }
                return toFontChar;
              }
              function isProblematicUnicodeLocation(code) {
                var i = 0, j = ProblematicCharRanges.length - 1;
                while (i < j) {
                  var c = i + j + 1 >> 1;
                  if (code < ProblematicCharRanges[c]) {
                    j = c - 1;
                  } else {
                    i = c;
                  }
                }
                return !(i & 1);
              }
              function adjustMapping(charCodeToGlyphId, properties, missingGlyphs) {
                var toUnicode = properties.toUnicode;
                var isSymbolic = !!(properties.flags & FontFlags.Symbolic);
                var isIdentityUnicode = properties.toUnicode instanceof IdentityToUnicodeMap;
                var newMap = /* @__PURE__ */ Object.create(null);
                var toFontChar = [];
                var usedFontCharCodes = [];
                var nextAvailableFontCharCode = PRIVATE_USE_OFFSET_START;
                for (var originalCharCode in charCodeToGlyphId) {
                  originalCharCode |= 0;
                  var glyphId = charCodeToGlyphId[originalCharCode];
                  if (missingGlyphs[glyphId]) {
                    continue;
                  }
                  var fontCharCode = originalCharCode;
                  var hasUnicodeValue = false;
                  if (!isIdentityUnicode && toUnicode.has(originalCharCode)) {
                    hasUnicodeValue = true;
                    var unicode = toUnicode.get(fontCharCode);
                    if (unicode.length === 1) {
                      fontCharCode = unicode.charCodeAt(0);
                    }
                  }
                  if (usedFontCharCodes[fontCharCode] !== void 0 || isProblematicUnicodeLocation(fontCharCode) || isSymbolic && !hasUnicodeValue) {
                    do {
                      if (nextAvailableFontCharCode > PRIVATE_USE_OFFSET_END) {
                        (0, _util.warn)("Ran out of space in font private use area.");
                        break;
                      }
                      fontCharCode = nextAvailableFontCharCode++;
                      if (SKIP_PRIVATE_USE_RANGE_F000_TO_F01F && fontCharCode === 61440) {
                        fontCharCode = 61472;
                        nextAvailableFontCharCode = fontCharCode + 1;
                      }
                    } while (usedFontCharCodes[fontCharCode] !== void 0);
                  }
                  newMap[fontCharCode] = glyphId;
                  toFontChar[originalCharCode] = fontCharCode;
                  usedFontCharCodes[fontCharCode] = true;
                }
                return {
                  toFontChar,
                  charCodeToGlyphId: newMap,
                  nextAvailableFontCharCode
                };
              }
              function getRanges(glyphs, numGlyphs) {
                var codes = [];
                for (var charCode in glyphs) {
                  if (glyphs[charCode] >= numGlyphs) {
                    continue;
                  }
                  codes.push({
                    fontCharCode: charCode | 0,
                    glyphId: glyphs[charCode]
                  });
                }
                if (codes.length === 0) {
                  codes.push({
                    fontCharCode: 0,
                    glyphId: 0
                  });
                }
                codes.sort(function fontGetRangesSort(a, b) {
                  return a.fontCharCode - b.fontCharCode;
                });
                var ranges = [];
                var length = codes.length;
                for (var n = 0; n < length; ) {
                  var start = codes[n].fontCharCode;
                  var codeIndices = [codes[n].glyphId];
                  ++n;
                  var end = start;
                  while (n < length && end + 1 === codes[n].fontCharCode) {
                    codeIndices.push(codes[n].glyphId);
                    ++end;
                    ++n;
                    if (end === 65535) {
                      break;
                    }
                  }
                  ranges.push([start, end, codeIndices]);
                }
                return ranges;
              }
              function createCmapTable(glyphs, numGlyphs) {
                var ranges = getRanges(glyphs, numGlyphs);
                var numTables = ranges[ranges.length - 1][1] > 65535 ? 2 : 1;
                var cmap = "\0\0" + string16(numTables) + "\0\0" + (0, _util.string32)(4 + numTables * 8);
                var i, ii, j, jj;
                for (i = ranges.length - 1; i >= 0; --i) {
                  if (ranges[i][0] <= 65535) {
                    break;
                  }
                }
                var bmpLength = i + 1;
                if (ranges[i][0] < 65535 && ranges[i][1] === 65535) {
                  ranges[i][1] = 65534;
                }
                var trailingRangesCount = ranges[i][1] < 65535 ? 1 : 0;
                var segCount = bmpLength + trailingRangesCount;
                var searchParams = OpenTypeFileBuilder.getSearchParams(segCount, 2);
                var startCount = "";
                var endCount = "";
                var idDeltas = "";
                var idRangeOffsets = "";
                var glyphsIds = "";
                var bias = 0;
                var range, start, end, codes;
                for (i = 0, ii = bmpLength; i < ii; i++) {
                  range = ranges[i];
                  start = range[0];
                  end = range[1];
                  startCount += string16(start);
                  endCount += string16(end);
                  codes = range[2];
                  var contiguous = true;
                  for (j = 1, jj = codes.length; j < jj; ++j) {
                    if (codes[j] !== codes[j - 1] + 1) {
                      contiguous = false;
                      break;
                    }
                  }
                  if (!contiguous) {
                    var offset = (segCount - i) * 2 + bias * 2;
                    bias += end - start + 1;
                    idDeltas += string16(0);
                    idRangeOffsets += string16(offset);
                    for (j = 0, jj = codes.length; j < jj; ++j) {
                      glyphsIds += string16(codes[j]);
                    }
                  } else {
                    var startCode = codes[0];
                    idDeltas += string16(startCode - start & 65535);
                    idRangeOffsets += string16(0);
                  }
                }
                if (trailingRangesCount > 0) {
                  endCount += "ÿÿ";
                  startCount += "ÿÿ";
                  idDeltas += "\0";
                  idRangeOffsets += "\0\0";
                }
                var format314 = "\0\0" + string16(2 * segCount) + string16(searchParams.range) + string16(searchParams.entry) + string16(searchParams.rangeShift) + endCount + "\0\0" + startCount + idDeltas + idRangeOffsets + glyphsIds;
                var format31012 = "";
                var header31012 = "";
                if (numTables > 1) {
                  cmap += "\0\0\n" + (0, _util.string32)(4 + numTables * 8 + 4 + format314.length);
                  format31012 = "";
                  for (i = 0, ii = ranges.length; i < ii; i++) {
                    range = ranges[i];
                    start = range[0];
                    codes = range[2];
                    var code = codes[0];
                    for (j = 1, jj = codes.length; j < jj; ++j) {
                      if (codes[j] !== codes[j - 1] + 1) {
                        end = range[0] + j - 1;
                        format31012 += (0, _util.string32)(start) + (0, _util.string32)(end) + (0, _util.string32)(code);
                        start = end + 1;
                        code = codes[j];
                      }
                    }
                    format31012 += (0, _util.string32)(start) + (0, _util.string32)(range[1]) + (0, _util.string32)(code);
                  }
                  header31012 = "\0\f\0\0" + (0, _util.string32)(format31012.length + 16) + "\0\0\0\0" + (0, _util.string32)(format31012.length / 12);
                }
                return cmap + "\0" + string16(format314.length + 4) + format314 + header31012 + format31012;
              }
              function validateOS2Table(os2) {
                var stream2 = new _stream.Stream(os2.data);
                var version = stream2.getUint16();
                stream2.getBytes(60);
                var selection = stream2.getUint16();
                if (version < 4 && selection & 768) {
                  return false;
                }
                var firstChar = stream2.getUint16();
                var lastChar = stream2.getUint16();
                if (firstChar > lastChar) {
                  return false;
                }
                stream2.getBytes(6);
                var usWinAscent = stream2.getUint16();
                if (usWinAscent === 0) {
                  return false;
                }
                os2.data[8] = os2.data[9] = 0;
                return true;
              }
              function createOS2Table(properties, charstrings, override) {
                override = override || {
                  unitsPerEm: 0,
                  yMax: 0,
                  yMin: 0,
                  ascent: 0,
                  descent: 0
                };
                var ulUnicodeRange1 = 0;
                var ulUnicodeRange2 = 0;
                var ulUnicodeRange3 = 0;
                var ulUnicodeRange4 = 0;
                var firstCharIndex = null;
                var lastCharIndex = 0;
                if (charstrings) {
                  for (var code in charstrings) {
                    code |= 0;
                    if (firstCharIndex > code || !firstCharIndex) {
                      firstCharIndex = code;
                    }
                    if (lastCharIndex < code) {
                      lastCharIndex = code;
                    }
                    var position = (0, _unicode.getUnicodeRangeFor)(code);
                    if (position < 32) {
                      ulUnicodeRange1 |= 1 << position;
                    } else if (position < 64) {
                      ulUnicodeRange2 |= 1 << position - 32;
                    } else if (position < 96) {
                      ulUnicodeRange3 |= 1 << position - 64;
                    } else if (position < 123) {
                      ulUnicodeRange4 |= 1 << position - 96;
                    } else {
                      throw new _util.FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
                    }
                  }
                } else {
                  firstCharIndex = 0;
                  lastCharIndex = 255;
                }
                var bbox = properties.bbox || [0, 0, 0, 0];
                var unitsPerEm = override.unitsPerEm || 1 / (properties.fontMatrix || _util.FONT_IDENTITY_MATRIX)[0];
                var scale = properties.ascentScaled ? 1 : unitsPerEm / PDF_GLYPH_SPACE_UNITS;
                var typoAscent = override.ascent || Math.round(scale * (properties.ascent || bbox[3]));
                var typoDescent = override.descent || Math.round(scale * (properties.descent || bbox[1]));
                if (typoDescent > 0 && properties.descent > 0 && bbox[1] < 0) {
                  typoDescent = -typoDescent;
                }
                var winAscent = override.yMax || typoAscent;
                var winDescent = -override.yMin || -typoDescent;
                return "\0$ô\0\0\0»\0\0\0»\0\0ß\x001\0\0\0\0" + String.fromCharCode(properties.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + (0, _util.string32)(ulUnicodeRange1) + (0, _util.string32)(ulUnicodeRange2) + (0, _util.string32)(ulUnicodeRange3) + (0, _util.string32)(ulUnicodeRange4) + "*21*" + string16(properties.italicAngle ? 1 : 0) + string16(firstCharIndex || properties.firstChar) + string16(lastCharIndex || properties.lastChar) + string16(typoAscent) + string16(typoDescent) + "\0d" + string16(winAscent) + string16(winDescent) + "\0\0\0\0\0\0\0\0" + string16(properties.xHeight) + string16(properties.capHeight) + string16(0) + string16(firstCharIndex || properties.firstChar) + "\0";
              }
              function createPostTable(properties) {
                var angle = Math.floor(properties.italicAngle * Math.pow(2, 16));
                return "\0\0\0" + (0, _util.string32)(angle) + "\0\0\0\0" + (0, _util.string32)(properties.fixedPitch) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
              }
              function createNameTable(name, proto) {
                if (!proto) {
                  proto = [[], []];
                }
                var strings = [proto[0][0] || "Original licence", proto[0][1] || name, proto[0][2] || "Unknown", proto[0][3] || "uniqueID", proto[0][4] || name, proto[0][5] || "Version 0.11", proto[0][6] || "", proto[0][7] || "Unknown", proto[0][8] || "Unknown", proto[0][9] || "Unknown"];
                var stringsUnicode = [];
                var i, ii, j, jj, str;
                for (i = 0, ii = strings.length; i < ii; i++) {
                  str = proto[1][i] || strings[i];
                  var strBufUnicode = [];
                  for (j = 0, jj = str.length; j < jj; j++) {
                    strBufUnicode.push(string16(str.charCodeAt(j)));
                  }
                  stringsUnicode.push(strBufUnicode.join(""));
                }
                var names = [strings, stringsUnicode];
                var platforms = ["\0", "\0"];
                var encodings = ["\0\0", "\0"];
                var languages = ["\0\0", "	"];
                var namesRecordCount = strings.length * platforms.length;
                var nameTable = "\0\0" + string16(namesRecordCount) + string16(namesRecordCount * 12 + 6);
                var strOffset = 0;
                for (i = 0, ii = platforms.length; i < ii; i++) {
                  var strs = names[i];
                  for (j = 0, jj = strs.length; j < jj; j++) {
                    str = strs[j];
                    var nameRecord = platforms[i] + encodings[i] + languages[i] + string16(j) + string16(str.length) + string16(strOffset);
                    nameTable += nameRecord;
                    strOffset += str.length;
                  }
                }
                nameTable += strings.join("") + stringsUnicode.join("");
                return nameTable;
              }
              Font2.prototype = {
                name: null,
                font: null,
                mimetype: null,
                encoding: null,
                get renderer() {
                  var renderer = _font_renderer.FontRendererFactory.create(this, SEAC_ANALYSIS_ENABLED);
                  return (0, _util.shadow)(this, "renderer", renderer);
                },
                exportData: function Font_exportData() {
                  var data = {};
                  for (var i in this) {
                    if (this.hasOwnProperty(i)) {
                      data[i] = this[i];
                    }
                  }
                  return data;
                },
                fallbackToSystemFont: function Font_fallbackToSystemFont() {
                  var _this = this;
                  this.missingFile = true;
                  var charCode, unicode;
                  var name = this.name;
                  var type = this.type;
                  var subtype = this.subtype;
                  var fontName = name.replace(/[,_]/g, "-");
                  var stdFontMap = (0, _standard_fonts.getStdFontMap)(), nonStdFontMap = (0, _standard_fonts.getNonStdFontMap)();
                  var isStandardFont = !!stdFontMap[fontName] || !!(nonStdFontMap[fontName] && stdFontMap[nonStdFontMap[fontName]]);
                  fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName;
                  this.bold = fontName.search(/bold/gi) !== -1;
                  this.italic = fontName.search(/oblique/gi) !== -1 || fontName.search(/italic/gi) !== -1;
                  this.black = name.search(/Black/g) !== -1;
                  this.remeasure = Object.keys(this.widths).length > 0;
                  if (isStandardFont && type === "CIDFontType2" && this.cidEncoding.indexOf("Identity-") === 0) {
                    var GlyphMapForStandardFonts = (0, _standard_fonts.getGlyphMapForStandardFonts)();
                    var map = [];
                    for (charCode in GlyphMapForStandardFonts) {
                      map[+charCode] = GlyphMapForStandardFonts[charCode];
                    }
                    if (/Arial-?Black/i.test(name)) {
                      var SupplementalGlyphMapForArialBlack = (0, _standard_fonts.getSupplementalGlyphMapForArialBlack)();
                      for (charCode in SupplementalGlyphMapForArialBlack) {
                        map[+charCode] = SupplementalGlyphMapForArialBlack[charCode];
                      }
                    } else if (/Calibri/i.test(name)) {
                      var SupplementalGlyphMapForCalibri = (0, _standard_fonts.getSupplementalGlyphMapForCalibri)();
                      for (charCode in SupplementalGlyphMapForCalibri) {
                        map[+charCode] = SupplementalGlyphMapForCalibri[charCode];
                      }
                    }
                    var isIdentityUnicode = this.toUnicode instanceof IdentityToUnicodeMap;
                    if (!isIdentityUnicode) {
                      this.toUnicode.forEach(function(charCode2, unicodeCharCode) {
                        map[+charCode2] = unicodeCharCode;
                      });
                    }
                    this.toFontChar = map;
                    this.toUnicode = new ToUnicodeMap(map);
                  } else if (/Symbol/i.test(fontName)) {
                    this.toFontChar = buildToFontChar(_encodings.SymbolSetEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences);
                  } else if (/Dingbats/i.test(fontName)) {
                    if (/Wingdings/i.test(name)) {
                      (0, _util.warn)("Non-embedded Wingdings font, falling back to ZapfDingbats.");
                    }
                    this.toFontChar = buildToFontChar(_encodings.ZapfDingbatsEncoding, (0, _glyphlist.getDingbatsGlyphsUnicode)(), this.differences);
                  } else if (isStandardFont) {
                    this.toFontChar = buildToFontChar(this.defaultEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences);
                  } else {
                    var glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                    this.toUnicode.forEach(function(charCode2, unicodeCharCode) {
                      if (!_this.composite) {
                        var glyphName = _this.differences[charCode2] || _this.defaultEncoding[charCode2];
                        unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
                        if (unicode !== -1) {
                          unicodeCharCode = unicode;
                        }
                      }
                      _this.toFontChar[charCode2] = unicodeCharCode;
                    });
                  }
                  this.loadedName = fontName.split("-")[0];
                  this.loading = false;
                  this.fontType = getFontType(type, subtype);
                },
                checkAndRepair: function Font_checkAndRepair(name, font, properties) {
                  var VALID_TABLES = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
                  function readTables(file, numTables) {
                    var tables2 = /* @__PURE__ */ Object.create(null);
                    tables2["OS/2"] = null;
                    tables2["cmap"] = null;
                    tables2["head"] = null;
                    tables2["hhea"] = null;
                    tables2["hmtx"] = null;
                    tables2["maxp"] = null;
                    tables2["name"] = null;
                    tables2["post"] = null;
                    for (var i2 = 0; i2 < numTables; i2++) {
                      var table = readTableEntry(font);
                      if (!VALID_TABLES.includes(table.tag)) {
                        continue;
                      }
                      if (table.length === 0) {
                        continue;
                      }
                      tables2[table.tag] = table;
                    }
                    return tables2;
                  }
                  function readTableEntry(file) {
                    var tag = (0, _util.bytesToString)(file.getBytes(4));
                    var checksum = file.getInt32() >>> 0;
                    var offset = file.getInt32() >>> 0;
                    var length = file.getInt32() >>> 0;
                    var previousPosition = file.pos;
                    file.pos = file.start ? file.start : 0;
                    file.skip(offset);
                    var data = file.getBytes(length);
                    file.pos = previousPosition;
                    if (tag === "head") {
                      data[8] = data[9] = data[10] = data[11] = 0;
                      data[17] |= 32;
                    }
                    return {
                      tag,
                      checksum,
                      length,
                      offset,
                      data
                    };
                  }
                  function readOpenTypeHeader(ttf) {
                    return {
                      version: (0, _util.bytesToString)(ttf.getBytes(4)),
                      numTables: ttf.getUint16(),
                      searchRange: ttf.getUint16(),
                      entrySelector: ttf.getUint16(),
                      rangeShift: ttf.getUint16()
                    };
                  }
                  function readTrueTypeCollectionHeader(ttc) {
                    var ttcTag = (0, _util.bytesToString)(ttc.getBytes(4));
                    (0, _util.assert)(ttcTag === "ttcf", "Must be a TrueType Collection font.");
                    var majorVersion = ttc.getUint16();
                    var minorVersion = ttc.getUint16();
                    var numFonts = ttc.getInt32() >>> 0;
                    var offsetTable = [];
                    for (var i2 = 0; i2 < numFonts; i2++) {
                      offsetTable.push(ttc.getInt32() >>> 0);
                    }
                    var header2 = {
                      ttcTag,
                      majorVersion,
                      minorVersion,
                      numFonts,
                      offsetTable
                    };
                    switch (majorVersion) {
                      case 1:
                        return header2;
                      case 2:
                        header2.dsigTag = ttc.getInt32() >>> 0;
                        header2.dsigLength = ttc.getInt32() >>> 0;
                        header2.dsigOffset = ttc.getInt32() >>> 0;
                        return header2;
                    }
                    throw new _util.FormatError("Invalid TrueType Collection majorVersion: " + majorVersion + ".");
                  }
                  function readTrueTypeCollectionData(ttc, fontName) {
                    var _readTrueTypeCollecti = readTrueTypeCollectionHeader(ttc), numFonts = _readTrueTypeCollecti.numFonts, offsetTable = _readTrueTypeCollecti.offsetTable;
                    for (var i2 = 0; i2 < numFonts; i2++) {
                      ttc.pos = (ttc.start || 0) + offsetTable[i2];
                      var potentialHeader = readOpenTypeHeader(ttc);
                      var potentialTables = readTables(ttc, potentialHeader.numTables);
                      if (!potentialTables["name"]) {
                        throw new _util.FormatError('TrueType Collection font must contain a "name" table.');
                      }
                      var nameTable = readNameTable(potentialTables["name"]);
                      for (var j = 0, jj = nameTable.length; j < jj; j++) {
                        for (var k = 0, kk = nameTable[j].length; k < kk; k++) {
                          var nameEntry = nameTable[j][k];
                          if (nameEntry && nameEntry.replace(/\s/g, "") === fontName) {
                            return {
                              header: potentialHeader,
                              tables: potentialTables
                            };
                          }
                        }
                      }
                    }
                    throw new _util.FormatError('TrueType Collection does not contain "' + fontName + '" font.');
                  }
                  function readCmapTable(cmap, font2, isSymbolicFont, hasEncoding) {
                    if (!cmap) {
                      (0, _util.warn)("No cmap table available.");
                      return {
                        platformId: -1,
                        encodingId: -1,
                        mappings: [],
                        hasShortCmap: false
                      };
                    }
                    var segment;
                    var start = (font2.start ? font2.start : 0) + cmap.offset;
                    font2.pos = start;
                    font2.getUint16();
                    var numTables = font2.getUint16();
                    var potentialTable;
                    var canBreak = false;
                    for (var i2 = 0; i2 < numTables; i2++) {
                      var platformId = font2.getUint16();
                      var encodingId = font2.getUint16();
                      var offset = font2.getInt32() >>> 0;
                      var useTable = false;
                      if (potentialTable && potentialTable.platformId === platformId && potentialTable.encodingId === encodingId) {
                        continue;
                      }
                      if (platformId === 0 && encodingId === 0) {
                        useTable = true;
                      } else if (platformId === 1 && encodingId === 0) {
                        useTable = true;
                      } else if (platformId === 3 && encodingId === 1 && (hasEncoding || !potentialTable)) {
                        useTable = true;
                        if (!isSymbolicFont) {
                          canBreak = true;
                        }
                      } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {
                        useTable = true;
                        canBreak = true;
                      }
                      if (useTable) {
                        potentialTable = {
                          platformId,
                          encodingId,
                          offset
                        };
                      }
                      if (canBreak) {
                        break;
                      }
                    }
                    if (potentialTable) {
                      font2.pos = start + potentialTable.offset;
                    }
                    if (!potentialTable || font2.peekByte() === -1) {
                      (0, _util.warn)("Could not find a preferred cmap table.");
                      return {
                        platformId: -1,
                        encodingId: -1,
                        mappings: [],
                        hasShortCmap: false
                      };
                    }
                    var format = font2.getUint16();
                    font2.getUint16();
                    font2.getUint16();
                    var hasShortCmap = false;
                    var mappings = [];
                    var j, glyphId2;
                    if (format === 0) {
                      for (j = 0; j < 256; j++) {
                        var index = font2.getByte();
                        if (!index) {
                          continue;
                        }
                        mappings.push({
                          charCode: j,
                          glyphId: index
                        });
                      }
                      hasShortCmap = true;
                    } else if (format === 4) {
                      var segCount = font2.getUint16() >> 1;
                      font2.getBytes(6);
                      var segIndex, segments = [];
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segments.push({ end: font2.getUint16() });
                      }
                      font2.getUint16();
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segments[segIndex].start = font2.getUint16();
                      }
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segments[segIndex].delta = font2.getUint16();
                      }
                      var offsetsCount = 0;
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segment = segments[segIndex];
                        var rangeOffset = font2.getUint16();
                        if (!rangeOffset) {
                          segment.offsetIndex = -1;
                          continue;
                        }
                        var offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
                        segment.offsetIndex = offsetIndex;
                        offsetsCount = Math.max(offsetsCount, offsetIndex + segment.end - segment.start + 1);
                      }
                      var offsets = [];
                      for (j = 0; j < offsetsCount; j++) {
                        offsets.push(font2.getUint16());
                      }
                      for (segIndex = 0; segIndex < segCount; segIndex++) {
                        segment = segments[segIndex];
                        start = segment.start;
                        var end = segment.end;
                        var delta = segment.delta;
                        offsetIndex = segment.offsetIndex;
                        for (j = start; j <= end; j++) {
                          if (j === 65535) {
                            continue;
                          }
                          glyphId2 = offsetIndex < 0 ? j : offsets[offsetIndex + j - start];
                          glyphId2 = glyphId2 + delta & 65535;
                          mappings.push({
                            charCode: j,
                            glyphId: glyphId2
                          });
                        }
                      }
                    } else if (format === 6) {
                      var firstCode = font2.getUint16();
                      var entryCount = font2.getUint16();
                      for (j = 0; j < entryCount; j++) {
                        glyphId2 = font2.getUint16();
                        var charCode2 = firstCode + j;
                        mappings.push({
                          charCode: charCode2,
                          glyphId: glyphId2
                        });
                      }
                    } else {
                      (0, _util.warn)("cmap table has unsupported format: " + format);
                      return {
                        platformId: -1,
                        encodingId: -1,
                        mappings: [],
                        hasShortCmap: false
                      };
                    }
                    mappings.sort(function(a, b) {
                      return a.charCode - b.charCode;
                    });
                    for (i2 = 1; i2 < mappings.length; i2++) {
                      if (mappings[i2 - 1].charCode === mappings[i2].charCode) {
                        mappings.splice(i2, 1);
                        i2--;
                      }
                    }
                    return {
                      platformId: potentialTable.platformId,
                      encodingId: potentialTable.encodingId,
                      mappings,
                      hasShortCmap
                    };
                  }
                  function sanitizeMetrics(font2, header2, metrics, numGlyphs2) {
                    if (!header2) {
                      if (metrics) {
                        metrics.data = null;
                      }
                      return;
                    }
                    font2.pos = (font2.start ? font2.start : 0) + header2.offset;
                    font2.pos += header2.length - 2;
                    var numOfMetrics = font2.getUint16();
                    if (numOfMetrics > numGlyphs2) {
                      (0, _util.info)("The numOfMetrics (" + numOfMetrics + ") should not be greater than the numGlyphs (" + numGlyphs2 + ")");
                      numOfMetrics = numGlyphs2;
                      header2.data[34] = (numOfMetrics & 65280) >> 8;
                      header2.data[35] = numOfMetrics & 255;
                    }
                    var numOfSidebearings = numGlyphs2 - numOfMetrics;
                    var numMissing = numOfSidebearings - (metrics.length - numOfMetrics * 4 >> 1);
                    if (numMissing > 0) {
                      var entries = new Uint8Array(metrics.length + numMissing * 2);
                      entries.set(metrics.data);
                      metrics.data = entries;
                    }
                  }
                  function sanitizeGlyph(source, sourceStart, sourceEnd, dest, destStart, hintsValid2) {
                    var glyphProfile = {
                      length: 0,
                      sizeOfInstructions: 0
                    };
                    if (sourceEnd - sourceStart <= 12) {
                      return glyphProfile;
                    }
                    var glyf = source.subarray(sourceStart, sourceEnd);
                    var contoursCount = signedInt16(glyf[0], glyf[1]);
                    if (contoursCount < 0) {
                      contoursCount = -1;
                      writeSignedInt16(glyf, 0, contoursCount);
                      dest.set(glyf, destStart);
                      glyphProfile.length = glyf.length;
                      return glyphProfile;
                    }
                    var i2, j = 10, flagsCount = 0;
                    for (i2 = 0; i2 < contoursCount; i2++) {
                      var endPoint = glyf[j] << 8 | glyf[j + 1];
                      flagsCount = endPoint + 1;
                      j += 2;
                    }
                    var instructionsStart = j;
                    var instructionsLength = glyf[j] << 8 | glyf[j + 1];
                    glyphProfile.sizeOfInstructions = instructionsLength;
                    j += 2 + instructionsLength;
                    var instructionsEnd = j;
                    var coordinatesLength = 0;
                    for (i2 = 0; i2 < flagsCount; i2++) {
                      var flag = glyf[j++];
                      if (flag & 192) {
                        glyf[j - 1] = flag & 63;
                      }
                      var xyLength = (flag & 2 ? 1 : flag & 16 ? 0 : 2) + (flag & 4 ? 1 : flag & 32 ? 0 : 2);
                      coordinatesLength += xyLength;
                      if (flag & 8) {
                        var repeat = glyf[j++];
                        i2 += repeat;
                        coordinatesLength += repeat * xyLength;
                      }
                    }
                    if (coordinatesLength === 0) {
                      return glyphProfile;
                    }
                    var glyphDataLength = j + coordinatesLength;
                    if (glyphDataLength > glyf.length) {
                      return glyphProfile;
                    }
                    if (!hintsValid2 && instructionsLength > 0) {
                      dest.set(glyf.subarray(0, instructionsStart), destStart);
                      dest.set([0, 0], destStart + instructionsStart);
                      dest.set(glyf.subarray(instructionsEnd, glyphDataLength), destStart + instructionsStart + 2);
                      glyphDataLength -= instructionsLength;
                      if (glyf.length - glyphDataLength > 3) {
                        glyphDataLength = glyphDataLength + 3 & ~3;
                      }
                      glyphProfile.length = glyphDataLength;
                      return glyphProfile;
                    }
                    if (glyf.length - glyphDataLength > 3) {
                      glyphDataLength = glyphDataLength + 3 & ~3;
                      dest.set(glyf.subarray(0, glyphDataLength), destStart);
                      glyphProfile.length = glyphDataLength;
                      return glyphProfile;
                    }
                    dest.set(glyf, destStart);
                    glyphProfile.length = glyf.length;
                    return glyphProfile;
                  }
                  function sanitizeHead(head, numGlyphs2, locaLength) {
                    var data = head.data;
                    var version2 = int32(data[0], data[1], data[2], data[3]);
                    if (version2 >> 16 !== 1) {
                      (0, _util.info)("Attempting to fix invalid version in head table: " + version2);
                      data[0] = 0;
                      data[1] = 1;
                      data[2] = 0;
                      data[3] = 0;
                    }
                    var indexToLocFormat = int16(data[50], data[51]);
                    if (indexToLocFormat < 0 || indexToLocFormat > 1) {
                      (0, _util.info)("Attempting to fix invalid indexToLocFormat in head table: " + indexToLocFormat);
                      var numGlyphsPlusOne = numGlyphs2 + 1;
                      if (locaLength === numGlyphsPlusOne << 1) {
                        data[50] = 0;
                        data[51] = 0;
                      } else if (locaLength === numGlyphsPlusOne << 2) {
                        data[50] = 0;
                        data[51] = 1;
                      } else {
                        throw new _util.FormatError("Could not fix indexToLocFormat: " + indexToLocFormat);
                      }
                    }
                  }
                  function sanitizeGlyphLocations(loca, glyf, numGlyphs2, isGlyphLocationsLong2, hintsValid2, dupFirstEntry2, maxSizeOfInstructions2) {
                    var itemSize, itemDecode, itemEncode;
                    if (isGlyphLocationsLong2) {
                      itemSize = 4;
                      itemDecode = function fontItemDecodeLong(data, offset) {
                        return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
                      };
                      itemEncode = function fontItemEncodeLong(data, offset, value) {
                        data[offset] = value >>> 24 & 255;
                        data[offset + 1] = value >> 16 & 255;
                        data[offset + 2] = value >> 8 & 255;
                        data[offset + 3] = value & 255;
                      };
                    } else {
                      itemSize = 2;
                      itemDecode = function fontItemDecode(data, offset) {
                        return data[offset] << 9 | data[offset + 1] << 1;
                      };
                      itemEncode = function fontItemEncode(data, offset, value) {
                        data[offset] = value >> 9 & 255;
                        data[offset + 1] = value >> 1 & 255;
                      };
                    }
                    var locaData = loca.data;
                    var locaDataSize = itemSize * (1 + numGlyphs2);
                    if (locaData.length !== locaDataSize) {
                      locaData = new Uint8Array(locaDataSize);
                      locaData.set(loca.data.subarray(0, locaDataSize));
                      loca.data = locaData;
                    }
                    var oldGlyfData = glyf.data;
                    var oldGlyfDataLength = oldGlyfData.length;
                    var newGlyfData = new Uint8Array(oldGlyfDataLength);
                    var startOffset = itemDecode(locaData, 0);
                    var writeOffset = 0;
                    var missingGlyphs2 = /* @__PURE__ */ Object.create(null);
                    itemEncode(locaData, 0, writeOffset);
                    var i2, j;
                    var locaCount = dupFirstEntry2 ? numGlyphs2 - 1 : numGlyphs2;
                    for (i2 = 0, j = itemSize; i2 < locaCount; i2++, j += itemSize) {
                      var endOffset = itemDecode(locaData, j);
                      if (endOffset === 0) {
                        endOffset = startOffset;
                      }
                      if (endOffset > oldGlyfDataLength && (oldGlyfDataLength + 3 & ~3) === endOffset) {
                        endOffset = oldGlyfDataLength;
                      }
                      if (endOffset > oldGlyfDataLength) {
                        startOffset = endOffset;
                      }
                      var glyphProfile = sanitizeGlyph(oldGlyfData, startOffset, endOffset, newGlyfData, writeOffset, hintsValid2);
                      var newLength = glyphProfile.length;
                      if (newLength === 0) {
                        missingGlyphs2[i2] = true;
                      }
                      if (glyphProfile.sizeOfInstructions > maxSizeOfInstructions2) {
                        maxSizeOfInstructions2 = glyphProfile.sizeOfInstructions;
                      }
                      writeOffset += newLength;
                      itemEncode(locaData, j, writeOffset);
                      startOffset = endOffset;
                    }
                    if (writeOffset === 0) {
                      var simpleGlyph = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
                      for (i2 = 0, j = itemSize; i2 < numGlyphs2; i2++, j += itemSize) {
                        itemEncode(locaData, j, simpleGlyph.length);
                      }
                      glyf.data = simpleGlyph;
                    } else if (dupFirstEntry2) {
                      var firstEntryLength = itemDecode(locaData, itemSize);
                      if (newGlyfData.length > firstEntryLength + writeOffset) {
                        glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
                      } else {
                        glyf.data = new Uint8Array(firstEntryLength + writeOffset);
                        glyf.data.set(newGlyfData.subarray(0, writeOffset));
                      }
                      glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
                      itemEncode(loca.data, locaData.length - itemSize, writeOffset + firstEntryLength);
                    } else {
                      glyf.data = newGlyfData.subarray(0, writeOffset);
                    }
                    return {
                      missingGlyphs: missingGlyphs2,
                      maxSizeOfInstructions: maxSizeOfInstructions2
                    };
                  }
                  function readPostScriptTable(post, properties2, maxpNumGlyphs) {
                    var start = (font.start ? font.start : 0) + post.offset;
                    font.pos = start;
                    var length = post.length, end = start + length;
                    var version2 = font.getInt32();
                    font.getBytes(28);
                    var glyphNames;
                    var valid2 = true;
                    var i2;
                    switch (version2) {
                      case 65536:
                        glyphNames = MacStandardGlyphOrdering;
                        break;
                      case 131072:
                        var numGlyphs2 = font.getUint16();
                        if (numGlyphs2 !== maxpNumGlyphs) {
                          valid2 = false;
                          break;
                        }
                        var glyphNameIndexes = [];
                        for (i2 = 0; i2 < numGlyphs2; ++i2) {
                          var index = font.getUint16();
                          if (index >= 32768) {
                            valid2 = false;
                            break;
                          }
                          glyphNameIndexes.push(index);
                        }
                        if (!valid2) {
                          break;
                        }
                        var customNames = [];
                        var strBuf = [];
                        while (font.pos < end) {
                          var stringLength = font.getByte();
                          strBuf.length = stringLength;
                          for (i2 = 0; i2 < stringLength; ++i2) {
                            strBuf[i2] = String.fromCharCode(font.getByte());
                          }
                          customNames.push(strBuf.join(""));
                        }
                        glyphNames = [];
                        for (i2 = 0; i2 < numGlyphs2; ++i2) {
                          var j = glyphNameIndexes[i2];
                          if (j < 258) {
                            glyphNames.push(MacStandardGlyphOrdering[j]);
                            continue;
                          }
                          glyphNames.push(customNames[j - 258]);
                        }
                        break;
                      case 196608:
                        break;
                      default:
                        (0, _util.warn)("Unknown/unsupported post table version " + version2);
                        valid2 = false;
                        if (properties2.defaultEncoding) {
                          glyphNames = properties2.defaultEncoding;
                        }
                        break;
                    }
                    properties2.glyphNames = glyphNames;
                    return valid2;
                  }
                  function readNameTable(nameTable) {
                    var start = (font.start ? font.start : 0) + nameTable.offset;
                    font.pos = start;
                    var names = [[], []];
                    var length = nameTable.length, end = start + length;
                    var format = font.getUint16();
                    var FORMAT_0_HEADER_LENGTH = 6;
                    if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {
                      return names;
                    }
                    var numRecords = font.getUint16();
                    var stringsStart = font.getUint16();
                    var records = [];
                    var NAME_RECORD_LENGTH = 12;
                    var i2, ii;
                    for (i2 = 0; i2 < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i2++) {
                      var r = {
                        platform: font.getUint16(),
                        encoding: font.getUint16(),
                        language: font.getUint16(),
                        name: font.getUint16(),
                        length: font.getUint16(),
                        offset: font.getUint16()
                      };
                      if (r.platform === 1 && r.encoding === 0 && r.language === 0 || r.platform === 3 && r.encoding === 1 && r.language === 1033) {
                        records.push(r);
                      }
                    }
                    for (i2 = 0, ii = records.length; i2 < ii; i2++) {
                      var record = records[i2];
                      if (record.length <= 0) {
                        continue;
                      }
                      var pos = start + stringsStart + record.offset;
                      if (pos + record.length > end) {
                        continue;
                      }
                      font.pos = pos;
                      var nameIndex = record.name;
                      if (record.encoding) {
                        var str = "";
                        for (var j = 0, jj = record.length; j < jj; j += 2) {
                          str += String.fromCharCode(font.getUint16());
                        }
                        names[1][nameIndex] = str;
                      } else {
                        names[0][nameIndex] = (0, _util.bytesToString)(font.getBytes(record.length));
                      }
                    }
                    return names;
                  }
                  var TTOpsStackDeltas = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
                  function sanitizeTTProgram(table, ttContext) {
                    var data = table.data;
                    var i2 = 0, j, n, b, funcId, pc, lastEndf = 0, lastDeff = 0;
                    var stack = [];
                    var callstack = [];
                    var functionsCalled = [];
                    var tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
                    var inFDEF = false, ifLevel = 0, inELSE = 0;
                    for (var ii = data.length; i2 < ii; ) {
                      var op = data[i2++];
                      if (op === 64) {
                        n = data[i2++];
                        if (inFDEF || inELSE) {
                          i2 += n;
                        } else {
                          for (j = 0; j < n; j++) {
                            stack.push(data[i2++]);
                          }
                        }
                      } else if (op === 65) {
                        n = data[i2++];
                        if (inFDEF || inELSE) {
                          i2 += n * 2;
                        } else {
                          for (j = 0; j < n; j++) {
                            b = data[i2++];
                            stack.push(b << 8 | data[i2++]);
                          }
                        }
                      } else if ((op & 248) === 176) {
                        n = op - 176 + 1;
                        if (inFDEF || inELSE) {
                          i2 += n;
                        } else {
                          for (j = 0; j < n; j++) {
                            stack.push(data[i2++]);
                          }
                        }
                      } else if ((op & 248) === 184) {
                        n = op - 184 + 1;
                        if (inFDEF || inELSE) {
                          i2 += n * 2;
                        } else {
                          for (j = 0; j < n; j++) {
                            b = data[i2++];
                            stack.push(b << 8 | data[i2++]);
                          }
                        }
                      } else if (op === 43 && !tooComplexToFollowFunctions) {
                        if (!inFDEF && !inELSE) {
                          funcId = stack[stack.length - 1];
                          ttContext.functionsUsed[funcId] = true;
                          if (funcId in ttContext.functionsStackDeltas) {
                            stack.length += ttContext.functionsStackDeltas[funcId];
                          } else if (funcId in ttContext.functionsDefined && !functionsCalled.includes(funcId)) {
                            callstack.push({
                              data,
                              i: i2,
                              stackTop: stack.length - 1
                            });
                            functionsCalled.push(funcId);
                            pc = ttContext.functionsDefined[funcId];
                            if (!pc) {
                              (0, _util.warn)("TT: CALL non-existent function");
                              ttContext.hintsValid = false;
                              return;
                            }
                            data = pc.data;
                            i2 = pc.i;
                          }
                        }
                      } else if (op === 44 && !tooComplexToFollowFunctions) {
                        if (inFDEF || inELSE) {
                          (0, _util.warn)("TT: nested FDEFs not allowed");
                          tooComplexToFollowFunctions = true;
                        }
                        inFDEF = true;
                        lastDeff = i2;
                        funcId = stack.pop();
                        ttContext.functionsDefined[funcId] = {
                          data,
                          i: i2
                        };
                      } else if (op === 45) {
                        if (inFDEF) {
                          inFDEF = false;
                          lastEndf = i2;
                        } else {
                          pc = callstack.pop();
                          if (!pc) {
                            (0, _util.warn)("TT: ENDF bad stack");
                            ttContext.hintsValid = false;
                            return;
                          }
                          funcId = functionsCalled.pop();
                          data = pc.data;
                          i2 = pc.i;
                          ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;
                        }
                      } else if (op === 137) {
                        if (inFDEF || inELSE) {
                          (0, _util.warn)("TT: nested IDEFs not allowed");
                          tooComplexToFollowFunctions = true;
                        }
                        inFDEF = true;
                        lastDeff = i2;
                      } else if (op === 88) {
                        ++ifLevel;
                      } else if (op === 27) {
                        inELSE = ifLevel;
                      } else if (op === 89) {
                        if (inELSE === ifLevel) {
                          inELSE = 0;
                        }
                        --ifLevel;
                      } else if (op === 28) {
                        if (!inFDEF && !inELSE) {
                          var offset = stack[stack.length - 1];
                          if (offset > 0) {
                            i2 += offset - 1;
                          }
                        }
                      }
                      if (!inFDEF && !inELSE) {
                        var stackDelta = op <= 142 ? TTOpsStackDeltas[op] : op >= 192 && op <= 223 ? -1 : op >= 224 ? -2 : 0;
                        if (op >= 113 && op <= 117) {
                          n = stack.pop();
                          if (!isNaN(n)) {
                            stackDelta = -n * 2;
                          }
                        }
                        while (stackDelta < 0 && stack.length > 0) {
                          stack.pop();
                          stackDelta++;
                        }
                        while (stackDelta > 0) {
                          stack.push(NaN);
                          stackDelta--;
                        }
                      }
                    }
                    ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
                    var content = [data];
                    if (i2 > data.length) {
                      content.push(new Uint8Array(i2 - data.length));
                    }
                    if (lastDeff > lastEndf) {
                      (0, _util.warn)("TT: complementing a missing function tail");
                      content.push(new Uint8Array([34, 45]));
                    }
                    foldTTTable(table, content);
                  }
                  function checkInvalidFunctions(ttContext, maxFunctionDefs2) {
                    if (ttContext.tooComplexToFollowFunctions) {
                      return;
                    }
                    if (ttContext.functionsDefined.length > maxFunctionDefs2) {
                      (0, _util.warn)("TT: more functions defined than expected");
                      ttContext.hintsValid = false;
                      return;
                    }
                    for (var j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {
                      if (j > maxFunctionDefs2) {
                        (0, _util.warn)("TT: invalid function id: " + j);
                        ttContext.hintsValid = false;
                        return;
                      }
                      if (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {
                        (0, _util.warn)("TT: undefined function: " + j);
                        ttContext.hintsValid = false;
                        return;
                      }
                    }
                  }
                  function foldTTTable(table, content) {
                    if (content.length > 1) {
                      var newLength = 0;
                      var j, jj;
                      for (j = 0, jj = content.length; j < jj; j++) {
                        newLength += content[j].length;
                      }
                      newLength = newLength + 3 & ~3;
                      var result = new Uint8Array(newLength);
                      var pos = 0;
                      for (j = 0, jj = content.length; j < jj; j++) {
                        result.set(content[j], pos);
                        pos += content[j].length;
                      }
                      table.data = result;
                      table.length = newLength;
                    }
                  }
                  function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs2) {
                    var ttContext = {
                      functionsDefined: [],
                      functionsUsed: [],
                      functionsStackDeltas: [],
                      tooComplexToFollowFunctions: false,
                      hintsValid: true
                    };
                    if (fpgm) {
                      sanitizeTTProgram(fpgm, ttContext);
                    }
                    if (prep) {
                      sanitizeTTProgram(prep, ttContext);
                    }
                    if (fpgm) {
                      checkInvalidFunctions(ttContext, maxFunctionDefs2);
                    }
                    if (cvt && cvt.length & 1) {
                      var cvtData = new Uint8Array(cvt.length + 1);
                      cvtData.set(cvt.data);
                      cvt.data = cvtData;
                    }
                    return ttContext.hintsValid;
                  }
                  font = new _stream.Stream(new Uint8Array(font.getBytes()));
                  var header = void 0, tables = void 0;
                  if (isTrueTypeCollectionFile(font)) {
                    var ttcData = readTrueTypeCollectionData(font, this.name);
                    header = ttcData.header;
                    tables = ttcData.tables;
                  } else {
                    header = readOpenTypeHeader(font);
                    tables = readTables(font, header.numTables);
                  }
                  var cff = void 0, cffFile = void 0;
                  var isTrueType = !tables["CFF "];
                  if (!isTrueType) {
                    if (header.version === "OTTO" && !(properties.composite && properties.cidToGidMap) || !tables["head"] || !tables["hhea"] || !tables["maxp"] || !tables["post"]) {
                      cffFile = new _stream.Stream(tables["CFF "].data);
                      cff = new CFFFont(cffFile, properties);
                      adjustWidths(properties);
                      return this.convert(name, cff, properties);
                    }
                    delete tables["glyf"];
                    delete tables["loca"];
                    delete tables["fpgm"];
                    delete tables["prep"];
                    delete tables["cvt "];
                    this.isOpenType = true;
                  } else {
                    if (!tables["loca"]) {
                      throw new _util.FormatError('Required "loca" table is not found');
                    }
                    if (!tables["glyf"]) {
                      (0, _util.warn)('Required "glyf" table is not found -- trying to recover.');
                      tables["glyf"] = {
                        tag: "glyf",
                        data: new Uint8Array(0)
                      };
                    }
                    this.isOpenType = false;
                  }
                  if (!tables["maxp"]) {
                    throw new _util.FormatError('Required "maxp" table is not found');
                  }
                  font.pos = (font.start || 0) + tables["maxp"].offset;
                  var version = font.getInt32();
                  var numGlyphs = font.getUint16();
                  var maxFunctionDefs = 0;
                  var maxSizeOfInstructions = 0;
                  if (version >= 65536 && tables["maxp"].length >= 22) {
                    font.pos += 8;
                    var maxZones = font.getUint16();
                    if (maxZones > 2) {
                      tables["maxp"].data[14] = 0;
                      tables["maxp"].data[15] = 2;
                    }
                    font.pos += 4;
                    maxFunctionDefs = font.getUint16();
                    font.pos += 4;
                    maxSizeOfInstructions = font.getUint16();
                  }
                  var dupFirstEntry = false;
                  if (properties.type === "CIDFontType2" && properties.toUnicode && properties.toUnicode.get(0) > "\0") {
                    dupFirstEntry = true;
                    numGlyphs++;
                    tables["maxp"].data[4] = numGlyphs >> 8;
                    tables["maxp"].data[5] = numGlyphs & 255;
                  }
                  var hintsValid = sanitizeTTPrograms(tables["fpgm"], tables["prep"], tables["cvt "], maxFunctionDefs);
                  if (!hintsValid) {
                    delete tables["fpgm"];
                    delete tables["prep"];
                    delete tables["cvt "];
                  }
                  sanitizeMetrics(font, tables["hhea"], tables["hmtx"], numGlyphs);
                  if (!tables["head"]) {
                    throw new _util.FormatError('Required "head" table is not found');
                  }
                  sanitizeHead(tables["head"], numGlyphs, isTrueType ? tables["loca"].length : 0);
                  var missingGlyphs = /* @__PURE__ */ Object.create(null);
                  if (isTrueType) {
                    var isGlyphLocationsLong = int16(tables["head"].data[50], tables["head"].data[51]);
                    var glyphsInfo = sanitizeGlyphLocations(tables["loca"], tables["glyf"], numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry, maxSizeOfInstructions);
                    missingGlyphs = glyphsInfo.missingGlyphs;
                    if (version >= 65536 && tables["maxp"].length >= 22) {
                      tables["maxp"].data[26] = glyphsInfo.maxSizeOfInstructions >> 8;
                      tables["maxp"].data[27] = glyphsInfo.maxSizeOfInstructions & 255;
                    }
                  }
                  if (!tables["hhea"]) {
                    throw new _util.FormatError('Required "hhea" table is not found');
                  }
                  if (tables["hhea"].data[10] === 0 && tables["hhea"].data[11] === 0) {
                    tables["hhea"].data[10] = 255;
                    tables["hhea"].data[11] = 255;
                  }
                  var metricsOverride = {
                    unitsPerEm: int16(tables["head"].data[18], tables["head"].data[19]),
                    yMax: int16(tables["head"].data[42], tables["head"].data[43]),
                    yMin: signedInt16(tables["head"].data[38], tables["head"].data[39]),
                    ascent: int16(tables["hhea"].data[4], tables["hhea"].data[5]),
                    descent: signedInt16(tables["hhea"].data[6], tables["hhea"].data[7])
                  };
                  this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
                  this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;
                  if (tables["post"]) {
                    var valid = readPostScriptTable(tables["post"], properties, numGlyphs);
                    if (!valid) {
                      tables["post"] = null;
                    }
                  }
                  var charCodeToGlyphId = [], charCode;
                  function hasGlyph(glyphId2) {
                    return !missingGlyphs[glyphId2];
                  }
                  if (properties.composite) {
                    var cidToGidMap = properties.cidToGidMap || [];
                    var isCidToGidMapEmpty = cidToGidMap.length === 0;
                    properties.cMap.forEach(function(charCode2, cid) {
                      if (cid > 65535) {
                        throw new _util.FormatError("Max size of CID is 65,535");
                      }
                      var glyphId2 = -1;
                      if (isCidToGidMapEmpty) {
                        glyphId2 = cid;
                      } else if (cidToGidMap[cid] !== void 0) {
                        glyphId2 = cidToGidMap[cid];
                      }
                      if (glyphId2 >= 0 && glyphId2 < numGlyphs && hasGlyph(glyphId2)) {
                        charCodeToGlyphId[charCode2] = glyphId2;
                      }
                    });
                    if (dupFirstEntry && (isCidToGidMapEmpty || !charCodeToGlyphId[0])) {
                      charCodeToGlyphId[0] = numGlyphs - 1;
                    }
                  } else {
                    var cmapTable = readCmapTable(tables["cmap"], font, this.isSymbolicFont, properties.hasEncoding);
                    var cmapPlatformId = cmapTable.platformId;
                    var cmapEncodingId = cmapTable.encodingId;
                    var cmapMappings = cmapTable.mappings;
                    var cmapMappingsLength = cmapMappings.length;
                    if (properties.hasEncoding && (cmapPlatformId === 3 && cmapEncodingId === 1 || cmapPlatformId === 1 && cmapEncodingId === 0) || cmapPlatformId === -1 && cmapEncodingId === -1 && !!(0, _encodings.getEncoding)(properties.baseEncodingName)) {
                      var baseEncoding = [];
                      if (properties.baseEncodingName === "MacRomanEncoding" || properties.baseEncodingName === "WinAnsiEncoding") {
                        baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName);
                      }
                      var glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                      for (charCode = 0; charCode < 256; charCode++) {
                        var glyphName, standardGlyphName;
                        if (this.differences && charCode in this.differences) {
                          glyphName = this.differences[charCode];
                        } else if (charCode in baseEncoding && baseEncoding[charCode] !== "") {
                          glyphName = baseEncoding[charCode];
                        } else {
                          glyphName = _encodings.StandardEncoding[charCode];
                        }
                        if (!glyphName) {
                          continue;
                        }
                        standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap);
                        var unicodeOrCharCode;
                        if (cmapPlatformId === 3 && cmapEncodingId === 1) {
                          unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];
                        } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {
                          unicodeOrCharCode = _encodings.MacRomanEncoding.indexOf(standardGlyphName);
                        }
                        var found = false;
                        for (var i = 0; i < cmapMappingsLength; ++i) {
                          if (cmapMappings[i].charCode !== unicodeOrCharCode) {
                            continue;
                          }
                          charCodeToGlyphId[charCode] = cmapMappings[i].glyphId;
                          found = true;
                          break;
                        }
                        if (!found && properties.glyphNames) {
                          var glyphId = properties.glyphNames.indexOf(glyphName);
                          if (glyphId === -1 && standardGlyphName !== glyphName) {
                            glyphId = properties.glyphNames.indexOf(standardGlyphName);
                          }
                          if (glyphId > 0 && hasGlyph(glyphId)) {
                            charCodeToGlyphId[charCode] = glyphId;
                          }
                        }
                      }
                    } else if (cmapPlatformId === 0 && cmapEncodingId === 0) {
                      for (var _i = 0; _i < cmapMappingsLength; ++_i) {
                        charCodeToGlyphId[cmapMappings[_i].charCode] = cmapMappings[_i].glyphId;
                      }
                    } else {
                      for (var _i2 = 0; _i2 < cmapMappingsLength; ++_i2) {
                        charCode = cmapMappings[_i2].charCode;
                        if (cmapPlatformId === 3 && charCode >= 61440 && charCode <= 61695) {
                          charCode &= 255;
                        }
                        charCodeToGlyphId[charCode] = cmapMappings[_i2].glyphId;
                      }
                    }
                  }
                  if (charCodeToGlyphId.length === 0) {
                    charCodeToGlyphId[0] = 0;
                  }
                  var newMapping = adjustMapping(charCodeToGlyphId, properties, missingGlyphs);
                  this.toFontChar = newMapping.toFontChar;
                  tables["cmap"] = {
                    tag: "cmap",
                    data: createCmapTable(newMapping.charCodeToGlyphId, numGlyphs)
                  };
                  if (!tables["OS/2"] || !validateOS2Table(tables["OS/2"])) {
                    tables["OS/2"] = {
                      tag: "OS/2",
                      data: createOS2Table(properties, newMapping.charCodeToGlyphId, metricsOverride)
                    };
                  }
                  if (!tables["post"]) {
                    tables["post"] = {
                      tag: "post",
                      data: createPostTable(properties)
                    };
                  }
                  if (!isTrueType) {
                    try {
                      cffFile = new _stream.Stream(tables["CFF "].data);
                      var parser = new _cff_parser.CFFParser(cffFile, properties, SEAC_ANALYSIS_ENABLED);
                      cff = parser.parse();
                      var compiler = new _cff_parser.CFFCompiler(cff);
                      tables["CFF "].data = compiler.compile();
                    } catch (e) {
                      (0, _util.warn)("Failed to compile font " + properties.loadedName);
                    }
                  }
                  if (!tables["name"]) {
                    tables["name"] = {
                      tag: "name",
                      data: createNameTable(this.name)
                    };
                  } else {
                    var namePrototype = readNameTable(tables["name"]);
                    tables["name"].data = createNameTable(name, namePrototype);
                  }
                  var builder = new OpenTypeFileBuilder(header.version);
                  for (var tableTag in tables) {
                    builder.addTable(tableTag, tables[tableTag].data);
                  }
                  return builder.toArray();
                },
                convert: function Font_convert(fontName, font, properties) {
                  properties.fixedPitch = false;
                  if (properties.builtInEncoding) {
                    adjustToUnicode(properties, properties.builtInEncoding);
                  }
                  var mapping = font.getGlyphMapping(properties);
                  var newMapping = adjustMapping(mapping, properties, /* @__PURE__ */ Object.create(null));
                  this.toFontChar = newMapping.toFontChar;
                  var numGlyphs = font.numGlyphs;
                  function getCharCodes(charCodeToGlyphId2, glyphId2) {
                    var charCodes2 = null;
                    for (var charCode2 in charCodeToGlyphId2) {
                      if (glyphId2 === charCodeToGlyphId2[charCode2]) {
                        if (!charCodes2) {
                          charCodes2 = [];
                        }
                        charCodes2.push(charCode2 | 0);
                      }
                    }
                    return charCodes2;
                  }
                  function createCharCode(charCodeToGlyphId2, glyphId2) {
                    for (var charCode2 in charCodeToGlyphId2) {
                      if (glyphId2 === charCodeToGlyphId2[charCode2]) {
                        return charCode2 | 0;
                      }
                    }
                    newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] = glyphId2;
                    return newMapping.nextAvailableFontCharCode++;
                  }
                  var seacs = font.seacs;
                  if (SEAC_ANALYSIS_ENABLED && seacs && seacs.length) {
                    var matrix = properties.fontMatrix || _util.FONT_IDENTITY_MATRIX;
                    var charset = font.getCharset();
                    var seacMap = /* @__PURE__ */ Object.create(null);
                    for (var glyphId in seacs) {
                      glyphId |= 0;
                      var seac = seacs[glyphId];
                      var baseGlyphName = _encodings.StandardEncoding[seac[2]];
                      var accentGlyphName = _encodings.StandardEncoding[seac[3]];
                      var baseGlyphId = charset.indexOf(baseGlyphName);
                      var accentGlyphId = charset.indexOf(accentGlyphName);
                      if (baseGlyphId < 0 || accentGlyphId < 0) {
                        continue;
                      }
                      var accentOffset = {
                        x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4],
                        y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5]
                      };
                      var charCodes = getCharCodes(mapping, glyphId);
                      if (!charCodes) {
                        continue;
                      }
                      for (var i = 0, ii = charCodes.length; i < ii; i++) {
                        var charCode = charCodes[i];
                        var charCodeToGlyphId = newMapping.charCodeToGlyphId;
                        var baseFontCharCode = createCharCode(charCodeToGlyphId, baseGlyphId);
                        var accentFontCharCode = createCharCode(charCodeToGlyphId, accentGlyphId);
                        seacMap[charCode] = {
                          baseFontCharCode,
                          accentFontCharCode,
                          accentOffset
                        };
                      }
                    }
                    properties.seacMap = seacMap;
                  }
                  var unitsPerEm = 1 / (properties.fontMatrix || _util.FONT_IDENTITY_MATRIX)[0];
                  var builder = new OpenTypeFileBuilder("OTTO");
                  builder.addTable("CFF ", font.data);
                  builder.addTable("OS/2", createOS2Table(properties, newMapping.charCodeToGlyphId));
                  builder.addTable("cmap", createCmapTable(newMapping.charCodeToGlyphId, numGlyphs));
                  builder.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<õ\0\0" + safeString16(unitsPerEm) + "\0\0\0\0\v~'\0\0\0\0\v~'\0\0" + safeString16(properties.descent) + "ÿ" + safeString16(properties.ascent) + string16(properties.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0");
                  builder.addTable("hhea", "\0\0\0" + safeString16(properties.ascent) + safeString16(properties.descent) + "\0\0ÿÿ\0\0\0\0\0\0" + safeString16(properties.capHeight) + safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + string16(numGlyphs));
                  builder.addTable("hmtx", function fontFieldsHmtx() {
                    var charstrings = font.charstrings;
                    var cffWidths = font.cff ? font.cff.widths : null;
                    var hmtx = "\0\0\0\0";
                    for (var i2 = 1, ii2 = numGlyphs; i2 < ii2; i2++) {
                      var width = 0;
                      if (charstrings) {
                        var charstring = charstrings[i2 - 1];
                        width = "width" in charstring ? charstring.width : 0;
                      } else if (cffWidths) {
                        width = Math.ceil(cffWidths[i2] || 0);
                      }
                      hmtx += string16(width) + string16(0);
                    }
                    return hmtx;
                  }());
                  builder.addTable("maxp", "\0\0P\0" + string16(numGlyphs));
                  builder.addTable("name", createNameTable(fontName));
                  builder.addTable("post", createPostTable(properties));
                  return builder.toArray();
                },
                get spaceWidth() {
                  if ("_shadowWidth" in this) {
                    return this._shadowWidth;
                  }
                  var possibleSpaceReplacements = ["space", "minus", "one", "i", "I"];
                  var width;
                  for (var i = 0, ii = possibleSpaceReplacements.length; i < ii; i++) {
                    var glyphName = possibleSpaceReplacements[i];
                    if (glyphName in this.widths) {
                      width = this.widths[glyphName];
                      break;
                    }
                    var glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                    var glyphUnicode = glyphsUnicodeMap[glyphName];
                    var charcode = 0;
                    if (this.composite) {
                      if (this.cMap.contains(glyphUnicode)) {
                        charcode = this.cMap.lookup(glyphUnicode);
                      }
                    }
                    if (!charcode && this.toUnicode) {
                      charcode = this.toUnicode.charCodeOf(glyphUnicode);
                    }
                    if (charcode <= 0) {
                      charcode = glyphUnicode;
                    }
                    width = this.widths[charcode];
                    if (width) {
                      break;
                    }
                  }
                  width = width || this.defaultWidth;
                  this._shadowWidth = width;
                  return width;
                },
                charToGlyph: function Font_charToGlyph(charcode, isSpace) {
                  var fontCharCode, width, operatorListId;
                  var widthCode = charcode;
                  if (this.cMap && this.cMap.contains(charcode)) {
                    widthCode = this.cMap.lookup(charcode);
                  }
                  width = this.widths[widthCode];
                  width = (0, _util.isNum)(width) ? width : this.defaultWidth;
                  var vmetric = this.vmetrics && this.vmetrics[widthCode];
                  var unicode = this.toUnicode.get(charcode) || this.fallbackToUnicode.get(charcode) || charcode;
                  if (typeof unicode === "number") {
                    unicode = String.fromCharCode(unicode);
                  }
                  var isInFont = charcode in this.toFontChar;
                  fontCharCode = this.toFontChar[charcode] || charcode;
                  if (this.missingFile) {
                    fontCharCode = (0, _unicode.mapSpecialUnicodeValues)(fontCharCode);
                  }
                  if (this.isType3Font) {
                    operatorListId = fontCharCode;
                  }
                  var accent = null;
                  if (this.seacMap && this.seacMap[charcode]) {
                    isInFont = true;
                    var seac = this.seacMap[charcode];
                    fontCharCode = seac.baseFontCharCode;
                    accent = {
                      fontChar: String.fromCharCode(seac.accentFontCharCode),
                      offset: seac.accentOffset
                    };
                  }
                  var fontChar = String.fromCharCode(fontCharCode);
                  var glyph = this.glyphCache[charcode];
                  if (!glyph || !glyph.matchesForCache(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont)) {
                    glyph = new Glyph(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont);
                    this.glyphCache[charcode] = glyph;
                  }
                  return glyph;
                },
                charsToGlyphs: function Font_charsToGlyphs(chars) {
                  var charsCache = this.charsCache;
                  var glyphs, glyph, charcode;
                  if (charsCache) {
                    glyphs = charsCache[chars];
                    if (glyphs) {
                      return glyphs;
                    }
                  }
                  if (!charsCache) {
                    charsCache = this.charsCache = /* @__PURE__ */ Object.create(null);
                  }
                  glyphs = [];
                  var charsCacheKey = chars;
                  var i = 0, ii;
                  if (this.cMap) {
                    var c = /* @__PURE__ */ Object.create(null);
                    while (i < chars.length) {
                      this.cMap.readCharCode(chars, i, c);
                      charcode = c.charcode;
                      var length = c.length;
                      i += length;
                      var isSpace = length === 1 && chars.charCodeAt(i - 1) === 32;
                      glyph = this.charToGlyph(charcode, isSpace);
                      glyphs.push(glyph);
                    }
                  } else {
                    for (i = 0, ii = chars.length; i < ii; ++i) {
                      charcode = chars.charCodeAt(i);
                      glyph = this.charToGlyph(charcode, charcode === 32);
                      glyphs.push(glyph);
                    }
                  }
                  return charsCache[charsCacheKey] = glyphs;
                }
              };
              return Font2;
            }();
            var ErrorFont = function ErrorFontClosure() {
              function ErrorFont2(error) {
                this.error = error;
                this.loadedName = "g_font_error";
                this.loading = false;
              }
              ErrorFont2.prototype = {
                charsToGlyphs: function ErrorFont_charsToGlyphs() {
                  return [];
                },
                exportData: function ErrorFont_exportData() {
                  return { error: this.error };
                }
              };
              return ErrorFont2;
            }();
            function type1FontGlyphMapping(properties, builtInEncoding, glyphNames) {
              var charCodeToGlyphId = /* @__PURE__ */ Object.create(null);
              var glyphId, charCode, baseEncoding;
              var isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
              if (properties.baseEncodingName) {
                baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName);
                for (charCode = 0; charCode < baseEncoding.length; charCode++) {
                  glyphId = glyphNames.indexOf(baseEncoding[charCode]);
                  if (glyphId >= 0) {
                    charCodeToGlyphId[charCode] = glyphId;
                  } else {
                    charCodeToGlyphId[charCode] = 0;
                  }
                }
              } else if (isSymbolicFont) {
                for (charCode in builtInEncoding) {
                  charCodeToGlyphId[charCode] = builtInEncoding[charCode];
                }
              } else {
                baseEncoding = _encodings.StandardEncoding;
                for (charCode = 0; charCode < baseEncoding.length; charCode++) {
                  glyphId = glyphNames.indexOf(baseEncoding[charCode]);
                  if (glyphId >= 0) {
                    charCodeToGlyphId[charCode] = glyphId;
                  } else {
                    charCodeToGlyphId[charCode] = 0;
                  }
                }
              }
              var differences = properties.differences, glyphsUnicodeMap;
              if (differences) {
                for (charCode in differences) {
                  var glyphName = differences[charCode];
                  glyphId = glyphNames.indexOf(glyphName);
                  if (glyphId === -1) {
                    if (!glyphsUnicodeMap) {
                      glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                    }
                    var standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap);
                    if (standardGlyphName !== glyphName) {
                      glyphId = glyphNames.indexOf(standardGlyphName);
                    }
                  }
                  if (glyphId >= 0) {
                    charCodeToGlyphId[charCode] = glyphId;
                  } else {
                    charCodeToGlyphId[charCode] = 0;
                  }
                }
              }
              return charCodeToGlyphId;
            }
            var Type1Font = function Type1FontClosure() {
              function findBlock(streamBytes, signature, startIndex) {
                var streamBytesLength = streamBytes.length;
                var signatureLength = signature.length;
                var scanLength = streamBytesLength - signatureLength;
                var i = startIndex, j, found = false;
                while (i < scanLength) {
                  j = 0;
                  while (j < signatureLength && streamBytes[i + j] === signature[j]) {
                    j++;
                  }
                  if (j >= signatureLength) {
                    i += j;
                    while (i < streamBytesLength && (0, _util.isSpace)(streamBytes[i])) {
                      i++;
                    }
                    found = true;
                    break;
                  }
                  i++;
                }
                return {
                  found,
                  length: i
                };
              }
              function getHeaderBlock(stream2, suggestedLength) {
                var EEXEC_SIGNATURE = [101, 101, 120, 101, 99];
                var streamStartPos = stream2.pos;
                var headerBytes, headerBytesLength, block;
                try {
                  headerBytes = stream2.getBytes(suggestedLength);
                  headerBytesLength = headerBytes.length;
                } catch (ex) {
                  if (ex instanceof _util.MissingDataException) {
                    throw ex;
                  }
                }
                if (headerBytesLength === suggestedLength) {
                  block = findBlock(headerBytes, EEXEC_SIGNATURE, suggestedLength - 2 * EEXEC_SIGNATURE.length);
                  if (block.found && block.length === suggestedLength) {
                    return {
                      stream: new _stream.Stream(headerBytes),
                      length: suggestedLength
                    };
                  }
                }
                (0, _util.warn)('Invalid "Length1" property in Type1 font -- trying to recover.');
                stream2.pos = streamStartPos;
                var SCAN_BLOCK_LENGTH = 2048;
                var actualLength;
                while (true) {
                  var scanBytes = stream2.peekBytes(SCAN_BLOCK_LENGTH);
                  block = findBlock(scanBytes, EEXEC_SIGNATURE, 0);
                  if (block.length === 0) {
                    break;
                  }
                  stream2.pos += block.length;
                  if (block.found) {
                    actualLength = stream2.pos - streamStartPos;
                    break;
                  }
                }
                stream2.pos = streamStartPos;
                if (actualLength) {
                  return {
                    stream: new _stream.Stream(stream2.getBytes(actualLength)),
                    length: actualLength
                  };
                }
                (0, _util.warn)('Unable to recover "Length1" property in Type1 font -- using as is.');
                return {
                  stream: new _stream.Stream(stream2.getBytes(suggestedLength)),
                  length: suggestedLength
                };
              }
              function getEexecBlock(stream2, suggestedLength) {
                var eexecBytes = stream2.getBytes();
                return {
                  stream: new _stream.Stream(eexecBytes),
                  length: eexecBytes.length
                };
              }
              function Type1Font2(name, file, properties) {
                var PFB_HEADER_SIZE = 6;
                var headerBlockLength = properties.length1;
                var eexecBlockLength = properties.length2;
                var pfbHeader = file.peekBytes(PFB_HEADER_SIZE);
                var pfbHeaderPresent = pfbHeader[0] === 128 && pfbHeader[1] === 1;
                if (pfbHeaderPresent) {
                  file.skip(PFB_HEADER_SIZE);
                  headerBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
                }
                var headerBlock = getHeaderBlock(file, headerBlockLength);
                var headerBlockParser = new _type1_parser.Type1Parser(headerBlock.stream, false, SEAC_ANALYSIS_ENABLED);
                headerBlockParser.extractFontHeader(properties);
                if (pfbHeaderPresent) {
                  pfbHeader = file.getBytes(PFB_HEADER_SIZE);
                  eexecBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
                }
                var eexecBlock = getEexecBlock(file, eexecBlockLength);
                var eexecBlockParser = new _type1_parser.Type1Parser(eexecBlock.stream, true, SEAC_ANALYSIS_ENABLED);
                var data = eexecBlockParser.extractFontProgram();
                for (var info in data.properties) {
                  properties[info] = data.properties[info];
                }
                var charstrings = data.charstrings;
                var type2Charstrings = this.getType2Charstrings(charstrings);
                var subrs = this.getType2Subrs(data.subrs);
                this.charstrings = charstrings;
                this.data = this.wrap(name, type2Charstrings, this.charstrings, subrs, properties);
                this.seacs = this.getSeacs(data.charstrings);
              }
              Type1Font2.prototype = {
                get numGlyphs() {
                  return this.charstrings.length + 1;
                },
                getCharset: function Type1Font_getCharset() {
                  var charset = [".notdef"];
                  var charstrings = this.charstrings;
                  for (var glyphId = 0; glyphId < charstrings.length; glyphId++) {
                    charset.push(charstrings[glyphId].glyphName);
                  }
                  return charset;
                },
                getGlyphMapping: function Type1Font_getGlyphMapping(properties) {
                  var charstrings = this.charstrings;
                  var glyphNames = [".notdef"], glyphId;
                  for (glyphId = 0; glyphId < charstrings.length; glyphId++) {
                    glyphNames.push(charstrings[glyphId].glyphName);
                  }
                  var encoding = properties.builtInEncoding;
                  if (encoding) {
                    var builtInEncoding = /* @__PURE__ */ Object.create(null);
                    for (var charCode in encoding) {
                      glyphId = glyphNames.indexOf(encoding[charCode]);
                      if (glyphId >= 0) {
                        builtInEncoding[charCode] = glyphId;
                      }
                    }
                  }
                  return type1FontGlyphMapping(properties, builtInEncoding, glyphNames);
                },
                getSeacs: function Type1Font_getSeacs(charstrings) {
                  var i, ii;
                  var seacMap = [];
                  for (i = 0, ii = charstrings.length; i < ii; i++) {
                    var charstring = charstrings[i];
                    if (charstring.seac) {
                      seacMap[i + 1] = charstring.seac;
                    }
                  }
                  return seacMap;
                },
                getType2Charstrings: function Type1Font_getType2Charstrings(type1Charstrings) {
                  var type2Charstrings = [];
                  for (var i = 0, ii = type1Charstrings.length; i < ii; i++) {
                    type2Charstrings.push(type1Charstrings[i].charstring);
                  }
                  return type2Charstrings;
                },
                getType2Subrs: function Type1Font_getType2Subrs(type1Subrs) {
                  var bias = 0;
                  var count = type1Subrs.length;
                  if (count < 1133) {
                    bias = 107;
                  } else if (count < 33769) {
                    bias = 1131;
                  } else {
                    bias = 32768;
                  }
                  var type2Subrs = [];
                  var i;
                  for (i = 0; i < bias; i++) {
                    type2Subrs.push([11]);
                  }
                  for (i = 0; i < count; i++) {
                    type2Subrs.push(type1Subrs[i]);
                  }
                  return type2Subrs;
                },
                wrap: function Type1Font_wrap(name, glyphs, charstrings, subrs, properties) {
                  var cff = new _cff_parser.CFF();
                  cff.header = new _cff_parser.CFFHeader(1, 0, 4, 4);
                  cff.names = [name];
                  var topDict = new _cff_parser.CFFTopDict();
                  topDict.setByName("version", 391);
                  topDict.setByName("Notice", 392);
                  topDict.setByName("FullName", 393);
                  topDict.setByName("FamilyName", 394);
                  topDict.setByName("Weight", 395);
                  topDict.setByName("Encoding", null);
                  topDict.setByName("FontMatrix", properties.fontMatrix);
                  topDict.setByName("FontBBox", properties.bbox);
                  topDict.setByName("charset", null);
                  topDict.setByName("CharStrings", null);
                  topDict.setByName("Private", null);
                  cff.topDict = topDict;
                  var strings = new _cff_parser.CFFStrings();
                  strings.add("Version 0.11");
                  strings.add("See original notice");
                  strings.add(name);
                  strings.add(name);
                  strings.add("Medium");
                  cff.strings = strings;
                  cff.globalSubrIndex = new _cff_parser.CFFIndex();
                  var count = glyphs.length;
                  var charsetArray = [0];
                  var i, ii;
                  for (i = 0; i < count; i++) {
                    var index = _cff_parser.CFFStandardStrings.indexOf(charstrings[i].glyphName);
                    if (index === -1) {
                      index = 0;
                    }
                    charsetArray.push(index >> 8 & 255, index & 255);
                  }
                  cff.charset = new _cff_parser.CFFCharset(false, 0, [], charsetArray);
                  var charStringsIndex = new _cff_parser.CFFIndex();
                  charStringsIndex.add([139, 14]);
                  for (i = 0; i < count; i++) {
                    var glyph = glyphs[i];
                    if (glyph.length === 0) {
                      charStringsIndex.add([139, 14]);
                      continue;
                    }
                    charStringsIndex.add(glyph);
                  }
                  cff.charStrings = charStringsIndex;
                  var privateDict = new _cff_parser.CFFPrivateDict();
                  privateDict.setByName("Subrs", null);
                  var fields = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
                  for (i = 0, ii = fields.length; i < ii; i++) {
                    var field = fields[i];
                    if (!(field in properties.privateData)) {
                      continue;
                    }
                    var value = properties.privateData[field];
                    if (Array.isArray(value)) {
                      for (var j = value.length - 1; j > 0; j--) {
                        value[j] -= value[j - 1];
                      }
                    }
                    privateDict.setByName(field, value);
                  }
                  cff.topDict.privateDict = privateDict;
                  var subrIndex = new _cff_parser.CFFIndex();
                  for (i = 0, ii = subrs.length; i < ii; i++) {
                    subrIndex.add(subrs[i]);
                  }
                  privateDict.subrsIndex = subrIndex;
                  var compiler = new _cff_parser.CFFCompiler(cff);
                  return compiler.compile();
                }
              };
              return Type1Font2;
            }();
            var CFFFont = function CFFFontClosure() {
              function CFFFont2(file, properties) {
                this.properties = properties;
                var parser = new _cff_parser.CFFParser(file, properties, SEAC_ANALYSIS_ENABLED);
                this.cff = parser.parse();
                var compiler = new _cff_parser.CFFCompiler(this.cff);
                this.seacs = this.cff.seacs;
                try {
                  this.data = compiler.compile();
                } catch (e) {
                  (0, _util.warn)("Failed to compile font " + properties.loadedName);
                  this.data = file;
                }
              }
              CFFFont2.prototype = {
                get numGlyphs() {
                  return this.cff.charStrings.count;
                },
                getCharset: function CFFFont_getCharset() {
                  return this.cff.charset.charset;
                },
                getGlyphMapping: function CFFFont_getGlyphMapping() {
                  var cff = this.cff;
                  var properties = this.properties;
                  var charsets = cff.charset.charset;
                  var charCodeToGlyphId;
                  var glyphId;
                  if (properties.composite) {
                    charCodeToGlyphId = /* @__PURE__ */ Object.create(null);
                    if (cff.isCIDFont) {
                      for (glyphId = 0; glyphId < charsets.length; glyphId++) {
                        var cid = charsets[glyphId];
                        var charCode = properties.cMap.charCodeOf(cid);
                        charCodeToGlyphId[charCode] = glyphId;
                      }
                    } else {
                      for (glyphId = 0; glyphId < cff.charStrings.count; glyphId++) {
                        charCodeToGlyphId[glyphId] = glyphId;
                      }
                    }
                    return charCodeToGlyphId;
                  }
                  var encoding = cff.encoding ? cff.encoding.encoding : null;
                  charCodeToGlyphId = type1FontGlyphMapping(properties, encoding, charsets);
                  return charCodeToGlyphId;
                }
              };
              return CFFFont2;
            }();
            (function checkSeacSupport() {
              if (typeof navigator !== "undefined" && /Windows/.test(navigator.userAgent)) {
                exports3.SEAC_ANALYSIS_ENABLED = SEAC_ANALYSIS_ENABLED = true;
              }
            })();
            (function checkChromeWindows() {
              if (typeof navigator !== "undefined" && /Windows.*Chrome/.test(navigator.userAgent)) {
                SKIP_PRIVATE_USE_RANGE_F000_TO_F01F = true;
              }
            })();
            exports3.SEAC_ANALYSIS_ENABLED = SEAC_ANALYSIS_ENABLED;
            exports3.PRIVATE_USE_OFFSET_START = PRIVATE_USE_OFFSET_START;
            exports3.PRIVATE_USE_OFFSET_END = PRIVATE_USE_OFFSET_END;
            exports3.ErrorFont = ErrorFont;
            exports3.Font = Font;
            exports3.FontFlags = FontFlags;
            exports3.ToUnicodeMap = ToUnicodeMap;
            exports3.IdentityToUnicodeMap = IdentityToUnicodeMap;
            exports3.ProblematicCharRanges = ProblematicCharRanges;
            exports3.getFontType = getFontType;
          },
          /* 138 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.CFFCompiler = exports3.CFFPrivateDict = exports3.CFFTopDict = exports3.CFFCharset = exports3.CFFIndex = exports3.CFFStrings = exports3.CFFHeader = exports3.CFF = exports3.CFFParser = exports3.CFFStandardStrings = void 0;
            var _util = __w_pdfjs_require__(2);
            var _charsets = __w_pdfjs_require__(139);
            var _encodings = __w_pdfjs_require__(140);
            var MAX_SUBR_NESTING = 10;
            var CFFStandardStrings = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
            var CFFParser = function CFFParserClosure() {
              var CharstringValidationData = [null, {
                id: "hstem",
                min: 2,
                stackClearing: true,
                stem: true
              }, null, {
                id: "vstem",
                min: 2,
                stackClearing: true,
                stem: true
              }, {
                id: "vmoveto",
                min: 1,
                stackClearing: true
              }, {
                id: "rlineto",
                min: 2,
                resetStack: true
              }, {
                id: "hlineto",
                min: 1,
                resetStack: true
              }, {
                id: "vlineto",
                min: 1,
                resetStack: true
              }, {
                id: "rrcurveto",
                min: 6,
                resetStack: true
              }, null, {
                id: "callsubr",
                min: 1,
                undefStack: true
              }, {
                id: "return",
                min: 0,
                undefStack: true
              }, null, null, {
                id: "endchar",
                min: 0,
                stackClearing: true
              }, null, null, null, {
                id: "hstemhm",
                min: 2,
                stackClearing: true,
                stem: true
              }, {
                id: "hintmask",
                min: 0,
                stackClearing: true
              }, {
                id: "cntrmask",
                min: 0,
                stackClearing: true
              }, {
                id: "rmoveto",
                min: 2,
                stackClearing: true
              }, {
                id: "hmoveto",
                min: 1,
                stackClearing: true
              }, {
                id: "vstemhm",
                min: 2,
                stackClearing: true,
                stem: true
              }, {
                id: "rcurveline",
                min: 8,
                resetStack: true
              }, {
                id: "rlinecurve",
                min: 8,
                resetStack: true
              }, {
                id: "vvcurveto",
                min: 4,
                resetStack: true
              }, {
                id: "hhcurveto",
                min: 4,
                resetStack: true
              }, null, {
                id: "callgsubr",
                min: 1,
                undefStack: true
              }, {
                id: "vhcurveto",
                min: 4,
                resetStack: true
              }, {
                id: "hvcurveto",
                min: 4,
                resetStack: true
              }];
              var CharstringValidationData12 = [null, null, null, {
                id: "and",
                min: 2,
                stackDelta: -1
              }, {
                id: "or",
                min: 2,
                stackDelta: -1
              }, {
                id: "not",
                min: 1,
                stackDelta: 0
              }, null, null, null, {
                id: "abs",
                min: 1,
                stackDelta: 0
              }, {
                id: "add",
                min: 2,
                stackDelta: -1,
                stackFn: function stack_div(stack, index) {
                  stack[index - 2] = stack[index - 2] + stack[index - 1];
                }
              }, {
                id: "sub",
                min: 2,
                stackDelta: -1,
                stackFn: function stack_div(stack, index) {
                  stack[index - 2] = stack[index - 2] - stack[index - 1];
                }
              }, {
                id: "div",
                min: 2,
                stackDelta: -1,
                stackFn: function stack_div(stack, index) {
                  stack[index - 2] = stack[index - 2] / stack[index - 1];
                }
              }, null, {
                id: "neg",
                min: 1,
                stackDelta: 0,
                stackFn: function stack_div(stack, index) {
                  stack[index - 1] = -stack[index - 1];
                }
              }, {
                id: "eq",
                min: 2,
                stackDelta: -1
              }, null, null, {
                id: "drop",
                min: 1,
                stackDelta: -1
              }, null, {
                id: "put",
                min: 2,
                stackDelta: -2
              }, {
                id: "get",
                min: 1,
                stackDelta: 0
              }, {
                id: "ifelse",
                min: 4,
                stackDelta: -3
              }, {
                id: "random",
                min: 0,
                stackDelta: 1
              }, {
                id: "mul",
                min: 2,
                stackDelta: -1,
                stackFn: function stack_div(stack, index) {
                  stack[index - 2] = stack[index - 2] * stack[index - 1];
                }
              }, null, {
                id: "sqrt",
                min: 1,
                stackDelta: 0
              }, {
                id: "dup",
                min: 1,
                stackDelta: 1
              }, {
                id: "exch",
                min: 2,
                stackDelta: 0
              }, {
                id: "index",
                min: 2,
                stackDelta: 0
              }, {
                id: "roll",
                min: 3,
                stackDelta: -2
              }, null, null, null, {
                id: "hflex",
                min: 7,
                resetStack: true
              }, {
                id: "flex",
                min: 13,
                resetStack: true
              }, {
                id: "hflex1",
                min: 9,
                resetStack: true
              }, {
                id: "flex1",
                min: 11,
                resetStack: true
              }];
              function CFFParser2(file, properties, seacAnalysisEnabled) {
                this.bytes = file.getBytes();
                this.properties = properties;
                this.seacAnalysisEnabled = !!seacAnalysisEnabled;
              }
              CFFParser2.prototype = {
                parse: function CFFParser_parse() {
                  var properties = this.properties;
                  var cff = new CFF();
                  this.cff = cff;
                  var header = this.parseHeader();
                  var nameIndex = this.parseIndex(header.endPos);
                  var topDictIndex = this.parseIndex(nameIndex.endPos);
                  var stringIndex = this.parseIndex(topDictIndex.endPos);
                  var globalSubrIndex = this.parseIndex(stringIndex.endPos);
                  var topDictParsed = this.parseDict(topDictIndex.obj.get(0));
                  var topDict = this.createDict(CFFTopDict, topDictParsed, cff.strings);
                  cff.header = header.obj;
                  cff.names = this.parseNameIndex(nameIndex.obj);
                  cff.strings = this.parseStringIndex(stringIndex.obj);
                  cff.topDict = topDict;
                  cff.globalSubrIndex = globalSubrIndex.obj;
                  this.parsePrivateDict(cff.topDict);
                  cff.isCIDFont = topDict.hasName("ROS");
                  var charStringOffset = topDict.getByName("CharStrings");
                  var charStringIndex = this.parseIndex(charStringOffset).obj;
                  var fontMatrix = topDict.getByName("FontMatrix");
                  if (fontMatrix) {
                    properties.fontMatrix = fontMatrix;
                  }
                  var fontBBox = topDict.getByName("FontBBox");
                  if (fontBBox) {
                    properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
                    properties.descent = Math.min(fontBBox[1], fontBBox[3]);
                    properties.ascentScaled = true;
                  }
                  var charset, encoding;
                  if (cff.isCIDFont) {
                    var fdArrayIndex = this.parseIndex(topDict.getByName("FDArray")).obj;
                    for (var i = 0, ii = fdArrayIndex.count; i < ii; ++i) {
                      var dictRaw = fdArrayIndex.get(i);
                      var fontDict = this.createDict(CFFTopDict, this.parseDict(dictRaw), cff.strings);
                      this.parsePrivateDict(fontDict);
                      cff.fdArray.push(fontDict);
                    }
                    encoding = null;
                    charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, true);
                    cff.fdSelect = this.parseFDSelect(topDict.getByName("FDSelect"), charStringIndex.count);
                  } else {
                    charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, false);
                    encoding = this.parseEncoding(topDict.getByName("Encoding"), properties, cff.strings, charset.charset);
                  }
                  cff.charset = charset;
                  cff.encoding = encoding;
                  var charStringsAndSeacs = this.parseCharStrings({
                    charStrings: charStringIndex,
                    localSubrIndex: topDict.privateDict.subrsIndex,
                    globalSubrIndex: globalSubrIndex.obj,
                    fdSelect: cff.fdSelect,
                    fdArray: cff.fdArray,
                    privateDict: topDict.privateDict
                  });
                  cff.charStrings = charStringsAndSeacs.charStrings;
                  cff.seacs = charStringsAndSeacs.seacs;
                  cff.widths = charStringsAndSeacs.widths;
                  return cff;
                },
                parseHeader: function CFFParser_parseHeader() {
                  var bytes = this.bytes;
                  var bytesLength = bytes.length;
                  var offset = 0;
                  while (offset < bytesLength && bytes[offset] !== 1) {
                    ++offset;
                  }
                  if (offset >= bytesLength) {
                    throw new _util.FormatError("Invalid CFF header");
                  }
                  if (offset !== 0) {
                    (0, _util.info)("cff data is shifted");
                    bytes = bytes.subarray(offset);
                    this.bytes = bytes;
                  }
                  var major = bytes[0];
                  var minor = bytes[1];
                  var hdrSize = bytes[2];
                  var offSize = bytes[3];
                  var header = new CFFHeader(major, minor, hdrSize, offSize);
                  return {
                    obj: header,
                    endPos: hdrSize
                  };
                },
                parseDict: function CFFParser_parseDict(dict) {
                  var pos = 0;
                  function parseOperand() {
                    var value = dict[pos++];
                    if (value === 30) {
                      return parseFloatOperand();
                    } else if (value === 28) {
                      value = dict[pos++];
                      value = (value << 24 | dict[pos++] << 16) >> 16;
                      return value;
                    } else if (value === 29) {
                      value = dict[pos++];
                      value = value << 8 | dict[pos++];
                      value = value << 8 | dict[pos++];
                      value = value << 8 | dict[pos++];
                      return value;
                    } else if (value >= 32 && value <= 246) {
                      return value - 139;
                    } else if (value >= 247 && value <= 250) {
                      return (value - 247) * 256 + dict[pos++] + 108;
                    } else if (value >= 251 && value <= 254) {
                      return -((value - 251) * 256) - dict[pos++] - 108;
                    }
                    (0, _util.warn)('CFFParser_parseDict: "' + value + '" is a reserved command.');
                    return NaN;
                  }
                  function parseFloatOperand() {
                    var str = "";
                    var eof = 15;
                    var lookup = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
                    var length = dict.length;
                    while (pos < length) {
                      var b2 = dict[pos++];
                      var b1 = b2 >> 4;
                      var b22 = b2 & 15;
                      if (b1 === eof) {
                        break;
                      }
                      str += lookup[b1];
                      if (b22 === eof) {
                        break;
                      }
                      str += lookup[b22];
                    }
                    return parseFloat(str);
                  }
                  var operands = [];
                  var entries = [];
                  pos = 0;
                  var end = dict.length;
                  while (pos < end) {
                    var b = dict[pos];
                    if (b <= 21) {
                      if (b === 12) {
                        b = b << 8 | dict[++pos];
                      }
                      entries.push([b, operands]);
                      operands = [];
                      ++pos;
                    } else {
                      operands.push(parseOperand());
                    }
                  }
                  return entries;
                },
                parseIndex: function CFFParser_parseIndex(pos) {
                  var cffIndex = new CFFIndex();
                  var bytes = this.bytes;
                  var count = bytes[pos++] << 8 | bytes[pos++];
                  var offsets = [];
                  var end = pos;
                  var i, ii;
                  if (count !== 0) {
                    var offsetSize = bytes[pos++];
                    var startPos = pos + (count + 1) * offsetSize - 1;
                    for (i = 0, ii = count + 1; i < ii; ++i) {
                      var offset = 0;
                      for (var j = 0; j < offsetSize; ++j) {
                        offset <<= 8;
                        offset += bytes[pos++];
                      }
                      offsets.push(startPos + offset);
                    }
                    end = offsets[count];
                  }
                  for (i = 0, ii = offsets.length - 1; i < ii; ++i) {
                    var offsetStart = offsets[i];
                    var offsetEnd = offsets[i + 1];
                    cffIndex.add(bytes.subarray(offsetStart, offsetEnd));
                  }
                  return {
                    obj: cffIndex,
                    endPos: end
                  };
                },
                parseNameIndex: function CFFParser_parseNameIndex(index) {
                  var names = [];
                  for (var i = 0, ii = index.count; i < ii; ++i) {
                    var name = index.get(i);
                    names.push((0, _util.bytesToString)(name));
                  }
                  return names;
                },
                parseStringIndex: function CFFParser_parseStringIndex(index) {
                  var strings = new CFFStrings();
                  for (var i = 0, ii = index.count; i < ii; ++i) {
                    var data = index.get(i);
                    strings.add((0, _util.bytesToString)(data));
                  }
                  return strings;
                },
                createDict: function CFFParser_createDict(Type, dict, strings) {
                  var cffDict = new Type(strings);
                  for (var i = 0, ii = dict.length; i < ii; ++i) {
                    var pair = dict[i];
                    var key = pair[0];
                    var value = pair[1];
                    cffDict.setByKey(key, value);
                  }
                  return cffDict;
                },
                parseCharString: function CFFParser_parseCharString(state, data, localSubrIndex, globalSubrIndex) {
                  if (!data || state.callDepth > MAX_SUBR_NESTING) {
                    return false;
                  }
                  var stackSize = state.stackSize;
                  var stack = state.stack;
                  var length = data.length;
                  for (var j = 0; j < length; ) {
                    var value = data[j++];
                    var validationCommand = null;
                    if (value === 12) {
                      var q = data[j++];
                      if (q === 0) {
                        data[j - 2] = 139;
                        data[j - 1] = 22;
                        stackSize = 0;
                      } else {
                        validationCommand = CharstringValidationData12[q];
                      }
                    } else if (value === 28) {
                      stack[stackSize] = (data[j] << 24 | data[j + 1] << 16) >> 16;
                      j += 2;
                      stackSize++;
                    } else if (value === 14) {
                      if (stackSize >= 4) {
                        stackSize -= 4;
                        if (this.seacAnalysisEnabled) {
                          state.seac = stack.slice(stackSize, stackSize + 4);
                          return false;
                        }
                      }
                      validationCommand = CharstringValidationData[value];
                    } else if (value >= 32 && value <= 246) {
                      stack[stackSize] = value - 139;
                      stackSize++;
                    } else if (value >= 247 && value <= 254) {
                      stack[stackSize] = value < 251 ? (value - 247 << 8) + data[j] + 108 : -(value - 251 << 8) - data[j] - 108;
                      j++;
                      stackSize++;
                    } else if (value === 255) {
                      stack[stackSize] = (data[j] << 24 | data[j + 1] << 16 | data[j + 2] << 8 | data[j + 3]) / 65536;
                      j += 4;
                      stackSize++;
                    } else if (value === 19 || value === 20) {
                      state.hints += stackSize >> 1;
                      j += state.hints + 7 >> 3;
                      stackSize %= 2;
                      validationCommand = CharstringValidationData[value];
                    } else if (value === 10 || value === 29) {
                      var subrsIndex;
                      if (value === 10) {
                        subrsIndex = localSubrIndex;
                      } else {
                        subrsIndex = globalSubrIndex;
                      }
                      if (!subrsIndex) {
                        validationCommand = CharstringValidationData[value];
                        (0, _util.warn)("Missing subrsIndex for " + validationCommand.id);
                        return false;
                      }
                      var bias = 32768;
                      if (subrsIndex.count < 1240) {
                        bias = 107;
                      } else if (subrsIndex.count < 33900) {
                        bias = 1131;
                      }
                      var subrNumber = stack[--stackSize] + bias;
                      if (subrNumber < 0 || subrNumber >= subrsIndex.count || isNaN(subrNumber)) {
                        validationCommand = CharstringValidationData[value];
                        (0, _util.warn)("Out of bounds subrIndex for " + validationCommand.id);
                        return false;
                      }
                      state.stackSize = stackSize;
                      state.callDepth++;
                      var valid = this.parseCharString(state, subrsIndex.get(subrNumber), localSubrIndex, globalSubrIndex);
                      if (!valid) {
                        return false;
                      }
                      state.callDepth--;
                      stackSize = state.stackSize;
                      continue;
                    } else if (value === 11) {
                      state.stackSize = stackSize;
                      return true;
                    } else {
                      validationCommand = CharstringValidationData[value];
                    }
                    if (validationCommand) {
                      if (validationCommand.stem) {
                        state.hints += stackSize >> 1;
                      }
                      if ("min" in validationCommand) {
                        if (!state.undefStack && stackSize < validationCommand.min) {
                          (0, _util.warn)("Not enough parameters for " + validationCommand.id + "; actual: " + stackSize + ", expected: " + validationCommand.min);
                          return false;
                        }
                      }
                      if (state.firstStackClearing && validationCommand.stackClearing) {
                        state.firstStackClearing = false;
                        stackSize -= validationCommand.min;
                        if (stackSize >= 2 && validationCommand.stem) {
                          stackSize %= 2;
                        } else if (stackSize > 1) {
                          (0, _util.warn)("Found too many parameters for stack-clearing command");
                        }
                        if (stackSize > 0 && stack[stackSize - 1] >= 0) {
                          state.width = stack[stackSize - 1];
                        }
                      }
                      if ("stackDelta" in validationCommand) {
                        if ("stackFn" in validationCommand) {
                          validationCommand.stackFn(stack, stackSize);
                        }
                        stackSize += validationCommand.stackDelta;
                      } else if (validationCommand.stackClearing) {
                        stackSize = 0;
                      } else if (validationCommand.resetStack) {
                        stackSize = 0;
                        state.undefStack = false;
                      } else if (validationCommand.undefStack) {
                        stackSize = 0;
                        state.undefStack = true;
                        state.firstStackClearing = false;
                      }
                    }
                  }
                  state.stackSize = stackSize;
                  return true;
                },
                parseCharStrings: function parseCharStrings(_ref) {
                  var charStrings = _ref.charStrings, localSubrIndex = _ref.localSubrIndex, globalSubrIndex = _ref.globalSubrIndex, fdSelect = _ref.fdSelect, fdArray = _ref.fdArray, privateDict = _ref.privateDict;
                  var seacs = [];
                  var widths = [];
                  var count = charStrings.count;
                  for (var i = 0; i < count; i++) {
                    var charstring = charStrings.get(i);
                    var state = {
                      callDepth: 0,
                      stackSize: 0,
                      stack: [],
                      undefStack: true,
                      hints: 0,
                      firstStackClearing: true,
                      seac: null,
                      width: null
                    };
                    var valid = true;
                    var localSubrToUse = null;
                    var privateDictToUse = privateDict;
                    if (fdSelect && fdArray.length) {
                      var fdIndex = fdSelect.getFDIndex(i);
                      if (fdIndex === -1) {
                        (0, _util.warn)("Glyph index is not in fd select.");
                        valid = false;
                      }
                      if (fdIndex >= fdArray.length) {
                        (0, _util.warn)("Invalid fd index for glyph index.");
                        valid = false;
                      }
                      if (valid) {
                        privateDictToUse = fdArray[fdIndex].privateDict;
                        localSubrToUse = privateDictToUse.subrsIndex;
                      }
                    } else if (localSubrIndex) {
                      localSubrToUse = localSubrIndex;
                    }
                    if (valid) {
                      valid = this.parseCharString(state, charstring, localSubrToUse, globalSubrIndex);
                    }
                    if (state.width !== null) {
                      var nominalWidth = privateDictToUse.getByName("nominalWidthX");
                      widths[i] = nominalWidth + state.width;
                    } else {
                      var defaultWidth = privateDictToUse.getByName("defaultWidthX");
                      widths[i] = defaultWidth;
                    }
                    if (state.seac !== null) {
                      seacs[i] = state.seac;
                    }
                    if (!valid) {
                      charStrings.set(i, new Uint8Array([14]));
                    }
                  }
                  return {
                    charStrings,
                    seacs,
                    widths
                  };
                },
                emptyPrivateDictionary: function CFFParser_emptyPrivateDictionary(parentDict) {
                  var privateDict = this.createDict(CFFPrivateDict, [], parentDict.strings);
                  parentDict.setByKey(18, [0, 0]);
                  parentDict.privateDict = privateDict;
                },
                parsePrivateDict: function CFFParser_parsePrivateDict(parentDict) {
                  if (!parentDict.hasName("Private")) {
                    this.emptyPrivateDictionary(parentDict);
                    return;
                  }
                  var privateOffset = parentDict.getByName("Private");
                  if (!Array.isArray(privateOffset) || privateOffset.length !== 2) {
                    parentDict.removeByName("Private");
                    return;
                  }
                  var size = privateOffset[0];
                  var offset = privateOffset[1];
                  if (size === 0 || offset >= this.bytes.length) {
                    this.emptyPrivateDictionary(parentDict);
                    return;
                  }
                  var privateDictEnd = offset + size;
                  var dictData = this.bytes.subarray(offset, privateDictEnd);
                  var dict = this.parseDict(dictData);
                  var privateDict = this.createDict(CFFPrivateDict, dict, parentDict.strings);
                  parentDict.privateDict = privateDict;
                  if (!privateDict.getByName("Subrs")) {
                    return;
                  }
                  var subrsOffset = privateDict.getByName("Subrs");
                  var relativeOffset = offset + subrsOffset;
                  if (subrsOffset === 0 || relativeOffset >= this.bytes.length) {
                    this.emptyPrivateDictionary(parentDict);
                    return;
                  }
                  var subrsIndex = this.parseIndex(relativeOffset);
                  privateDict.subrsIndex = subrsIndex.obj;
                },
                parseCharsets: function CFFParser_parseCharsets(pos, length, strings, cid) {
                  if (pos === 0) {
                    return new CFFCharset(true, CFFCharsetPredefinedTypes.ISO_ADOBE, _charsets.ISOAdobeCharset);
                  } else if (pos === 1) {
                    return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT, _charsets.ExpertCharset);
                  } else if (pos === 2) {
                    return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT_SUBSET, _charsets.ExpertSubsetCharset);
                  }
                  var bytes = this.bytes;
                  var start = pos;
                  var format = bytes[pos++];
                  var charset = [".notdef"];
                  var id, count, i;
                  length -= 1;
                  switch (format) {
                    case 0:
                      for (i = 0; i < length; i++) {
                        id = bytes[pos++] << 8 | bytes[pos++];
                        charset.push(cid ? id : strings.get(id));
                      }
                      break;
                    case 1:
                      while (charset.length <= length) {
                        id = bytes[pos++] << 8 | bytes[pos++];
                        count = bytes[pos++];
                        for (i = 0; i <= count; i++) {
                          charset.push(cid ? id++ : strings.get(id++));
                        }
                      }
                      break;
                    case 2:
                      while (charset.length <= length) {
                        id = bytes[pos++] << 8 | bytes[pos++];
                        count = bytes[pos++] << 8 | bytes[pos++];
                        for (i = 0; i <= count; i++) {
                          charset.push(cid ? id++ : strings.get(id++));
                        }
                      }
                      break;
                    default:
                      throw new _util.FormatError("Unknown charset format");
                  }
                  var end = pos;
                  var raw = bytes.subarray(start, end);
                  return new CFFCharset(false, format, charset, raw);
                },
                parseEncoding: function CFFParser_parseEncoding(pos, properties, strings, charset) {
                  var encoding = /* @__PURE__ */ Object.create(null);
                  var bytes = this.bytes;
                  var predefined = false;
                  var format, i, ii;
                  var raw = null;
                  function readSupplement() {
                    var supplementsCount = bytes[pos++];
                    for (i = 0; i < supplementsCount; i++) {
                      var code = bytes[pos++];
                      var sid = (bytes[pos++] << 8) + (bytes[pos++] & 255);
                      encoding[code] = charset.indexOf(strings.get(sid));
                    }
                  }
                  if (pos === 0 || pos === 1) {
                    predefined = true;
                    format = pos;
                    var baseEncoding = pos ? _encodings.ExpertEncoding : _encodings.StandardEncoding;
                    for (i = 0, ii = charset.length; i < ii; i++) {
                      var index = baseEncoding.indexOf(charset[i]);
                      if (index !== -1) {
                        encoding[index] = i;
                      }
                    }
                  } else {
                    var dataStart = pos;
                    format = bytes[pos++];
                    switch (format & 127) {
                      case 0:
                        var glyphsCount = bytes[pos++];
                        for (i = 1; i <= glyphsCount; i++) {
                          encoding[bytes[pos++]] = i;
                        }
                        break;
                      case 1:
                        var rangesCount = bytes[pos++];
                        var gid = 1;
                        for (i = 0; i < rangesCount; i++) {
                          var start = bytes[pos++];
                          var left = bytes[pos++];
                          for (var j = start; j <= start + left; j++) {
                            encoding[j] = gid++;
                          }
                        }
                        break;
                      default:
                        throw new _util.FormatError("Unknown encoding format: " + format + " in CFF");
                    }
                    var dataEnd = pos;
                    if (format & 128) {
                      bytes[dataStart] &= 127;
                      readSupplement();
                    }
                    raw = bytes.subarray(dataStart, dataEnd);
                  }
                  format = format & 127;
                  return new CFFEncoding(predefined, format, encoding, raw);
                },
                parseFDSelect: function CFFParser_parseFDSelect(pos, length) {
                  var start = pos;
                  var bytes = this.bytes;
                  var format = bytes[pos++];
                  var fdSelect = [], rawBytes;
                  var i, invalidFirstGID = false;
                  switch (format) {
                    case 0:
                      for (i = 0; i < length; ++i) {
                        var id = bytes[pos++];
                        fdSelect.push(id);
                      }
                      rawBytes = bytes.subarray(start, pos);
                      break;
                    case 3:
                      var rangesCount = bytes[pos++] << 8 | bytes[pos++];
                      for (i = 0; i < rangesCount; ++i) {
                        var first = bytes[pos++] << 8 | bytes[pos++];
                        if (i === 0 && first !== 0) {
                          (0, _util.warn)("parseFDSelect: The first range must have a first GID of 0 -- trying to recover.");
                          invalidFirstGID = true;
                          first = 0;
                        }
                        var fdIndex = bytes[pos++];
                        var next = bytes[pos] << 8 | bytes[pos + 1];
                        for (var j = first; j < next; ++j) {
                          fdSelect.push(fdIndex);
                        }
                      }
                      pos += 2;
                      rawBytes = bytes.subarray(start, pos);
                      if (invalidFirstGID) {
                        rawBytes[3] = rawBytes[4] = 0;
                      }
                      break;
                    default:
                      throw new _util.FormatError('parseFDSelect: Unknown format "' + format + '".');
                  }
                  if (fdSelect.length !== length) {
                    throw new _util.FormatError("parseFDSelect: Invalid font data.");
                  }
                  return new CFFFDSelect(fdSelect, rawBytes);
                }
              };
              return CFFParser2;
            }();
            var CFF = /* @__PURE__ */ function CFFClosure() {
              function CFF2() {
                this.header = null;
                this.names = [];
                this.topDict = null;
                this.strings = new CFFStrings();
                this.globalSubrIndex = null;
                this.encoding = null;
                this.charset = null;
                this.charStrings = null;
                this.fdArray = [];
                this.fdSelect = null;
                this.isCIDFont = false;
              }
              return CFF2;
            }();
            var CFFHeader = /* @__PURE__ */ function CFFHeaderClosure() {
              function CFFHeader2(major, minor, hdrSize, offSize) {
                this.major = major;
                this.minor = minor;
                this.hdrSize = hdrSize;
                this.offSize = offSize;
              }
              return CFFHeader2;
            }();
            var CFFStrings = function CFFStringsClosure() {
              function CFFStrings2() {
                this.strings = [];
              }
              CFFStrings2.prototype = {
                get: function CFFStrings_get(index) {
                  if (index >= 0 && index <= 390) {
                    return CFFStandardStrings[index];
                  }
                  if (index - 391 <= this.strings.length) {
                    return this.strings[index - 391];
                  }
                  return CFFStandardStrings[0];
                },
                add: function CFFStrings_add(value) {
                  this.strings.push(value);
                },
                get count() {
                  return this.strings.length;
                }
              };
              return CFFStrings2;
            }();
            var CFFIndex = function CFFIndexClosure() {
              function CFFIndex2() {
                this.objects = [];
                this.length = 0;
              }
              CFFIndex2.prototype = {
                add: function CFFIndex_add(data) {
                  this.length += data.length;
                  this.objects.push(data);
                },
                set: function CFFIndex_set(index, data) {
                  this.length += data.length - this.objects[index].length;
                  this.objects[index] = data;
                },
                get: function CFFIndex_get(index) {
                  return this.objects[index];
                },
                get count() {
                  return this.objects.length;
                }
              };
              return CFFIndex2;
            }();
            var CFFDict = function CFFDictClosure() {
              function CFFDict2(tables, strings) {
                this.keyToNameMap = tables.keyToNameMap;
                this.nameToKeyMap = tables.nameToKeyMap;
                this.defaults = tables.defaults;
                this.types = tables.types;
                this.opcodes = tables.opcodes;
                this.order = tables.order;
                this.strings = strings;
                this.values = /* @__PURE__ */ Object.create(null);
              }
              CFFDict2.prototype = {
                setByKey: function CFFDict_setByKey(key, value) {
                  if (!(key in this.keyToNameMap)) {
                    return false;
                  }
                  var valueLength = value.length;
                  if (valueLength === 0) {
                    return true;
                  }
                  for (var i = 0; i < valueLength; i++) {
                    if (isNaN(value[i])) {
                      (0, _util.warn)('Invalid CFFDict value: "' + value + '" for key "' + key + '".');
                      return true;
                    }
                  }
                  var type = this.types[key];
                  if (type === "num" || type === "sid" || type === "offset") {
                    value = value[0];
                  }
                  this.values[key] = value;
                  return true;
                },
                setByName: function CFFDict_setByName(name, value) {
                  if (!(name in this.nameToKeyMap)) {
                    throw new _util.FormatError('Invalid dictionary name "' + name + '"');
                  }
                  this.values[this.nameToKeyMap[name]] = value;
                },
                hasName: function CFFDict_hasName(name) {
                  return this.nameToKeyMap[name] in this.values;
                },
                getByName: function CFFDict_getByName(name) {
                  if (!(name in this.nameToKeyMap)) {
                    throw new _util.FormatError("Invalid dictionary name " + name + '"');
                  }
                  var key = this.nameToKeyMap[name];
                  if (!(key in this.values)) {
                    return this.defaults[key];
                  }
                  return this.values[key];
                },
                removeByName: function CFFDict_removeByName(name) {
                  delete this.values[this.nameToKeyMap[name]];
                }
              };
              CFFDict2.createTables = function CFFDict_createTables(layout) {
                var tables = {
                  keyToNameMap: {},
                  nameToKeyMap: {},
                  defaults: {},
                  types: {},
                  opcodes: {},
                  order: []
                };
                for (var i = 0, ii = layout.length; i < ii; ++i) {
                  var entry = layout[i];
                  var key = Array.isArray(entry[0]) ? (entry[0][0] << 8) + entry[0][1] : entry[0];
                  tables.keyToNameMap[key] = entry[1];
                  tables.nameToKeyMap[entry[1]] = key;
                  tables.types[key] = entry[2];
                  tables.defaults[key] = entry[3];
                  tables.opcodes[key] = Array.isArray(entry[0]) ? entry[0] : [entry[0]];
                  tables.order.push(key);
                }
                return tables;
              };
              return CFFDict2;
            }();
            var CFFTopDict = function CFFTopDictClosure() {
              var layout = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
              var tables = null;
              function CFFTopDict2(strings) {
                if (tables === null) {
                  tables = CFFDict.createTables(layout);
                }
                CFFDict.call(this, tables, strings);
                this.privateDict = null;
              }
              CFFTopDict2.prototype = Object.create(CFFDict.prototype);
              return CFFTopDict2;
            }();
            var CFFPrivateDict = function CFFPrivateDictClosure() {
              var layout = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
              var tables = null;
              function CFFPrivateDict2(strings) {
                if (tables === null) {
                  tables = CFFDict.createTables(layout);
                }
                CFFDict.call(this, tables, strings);
                this.subrsIndex = null;
              }
              CFFPrivateDict2.prototype = Object.create(CFFDict.prototype);
              return CFFPrivateDict2;
            }();
            var CFFCharsetPredefinedTypes = {
              ISO_ADOBE: 0,
              EXPERT: 1,
              EXPERT_SUBSET: 2
            };
            var CFFCharset = /* @__PURE__ */ function CFFCharsetClosure() {
              function CFFCharset2(predefined, format, charset, raw) {
                this.predefined = predefined;
                this.format = format;
                this.charset = charset;
                this.raw = raw;
              }
              return CFFCharset2;
            }();
            var CFFEncoding = /* @__PURE__ */ function CFFEncodingClosure() {
              function CFFEncoding2(predefined, format, encoding, raw) {
                this.predefined = predefined;
                this.format = format;
                this.encoding = encoding;
                this.raw = raw;
              }
              return CFFEncoding2;
            }();
            var CFFFDSelect = function CFFFDSelectClosure() {
              function CFFFDSelect2(fdSelect, raw) {
                this.fdSelect = fdSelect;
                this.raw = raw;
              }
              CFFFDSelect2.prototype = {
                getFDIndex: function CFFFDSelect_get(glyphIndex) {
                  if (glyphIndex < 0 || glyphIndex >= this.fdSelect.length) {
                    return -1;
                  }
                  return this.fdSelect[glyphIndex];
                }
              };
              return CFFFDSelect2;
            }();
            var CFFOffsetTracker = function CFFOffsetTrackerClosure() {
              function CFFOffsetTracker2() {
                this.offsets = /* @__PURE__ */ Object.create(null);
              }
              CFFOffsetTracker2.prototype = {
                isTracking: function CFFOffsetTracker_isTracking(key) {
                  return key in this.offsets;
                },
                track: function CFFOffsetTracker_track(key, location) {
                  if (key in this.offsets) {
                    throw new _util.FormatError("Already tracking location of " + key);
                  }
                  this.offsets[key] = location;
                },
                offset: function CFFOffsetTracker_offset(value) {
                  for (var key in this.offsets) {
                    this.offsets[key] += value;
                  }
                },
                setEntryLocation: function CFFOffsetTracker_setEntryLocation(key, values, output) {
                  if (!(key in this.offsets)) {
                    throw new _util.FormatError("Not tracking location of " + key);
                  }
                  var data = output.data;
                  var dataOffset = this.offsets[key];
                  var size = 5;
                  for (var i = 0, ii = values.length; i < ii; ++i) {
                    var offset0 = i * size + dataOffset;
                    var offset1 = offset0 + 1;
                    var offset2 = offset0 + 2;
                    var offset3 = offset0 + 3;
                    var offset4 = offset0 + 4;
                    if (data[offset0] !== 29 || data[offset1] !== 0 || data[offset2] !== 0 || data[offset3] !== 0 || data[offset4] !== 0) {
                      throw new _util.FormatError("writing to an offset that is not empty");
                    }
                    var value = values[i];
                    data[offset0] = 29;
                    data[offset1] = value >> 24 & 255;
                    data[offset2] = value >> 16 & 255;
                    data[offset3] = value >> 8 & 255;
                    data[offset4] = value & 255;
                  }
                }
              };
              return CFFOffsetTracker2;
            }();
            var CFFCompiler = function CFFCompilerClosure() {
              function CFFCompiler2(cff) {
                this.cff = cff;
              }
              CFFCompiler2.prototype = {
                compile: function CFFCompiler_compile() {
                  var cff = this.cff;
                  var output = {
                    data: [],
                    length: 0,
                    add: function CFFCompiler_add(data) {
                      this.data = this.data.concat(data);
                      this.length = this.data.length;
                    }
                  };
                  var header = this.compileHeader(cff.header);
                  output.add(header);
                  var nameIndex = this.compileNameIndex(cff.names);
                  output.add(nameIndex);
                  if (cff.isCIDFont) {
                    if (cff.topDict.hasName("FontMatrix")) {
                      var base = cff.topDict.getByName("FontMatrix");
                      cff.topDict.removeByName("FontMatrix");
                      for (var i = 0, ii = cff.fdArray.length; i < ii; i++) {
                        var subDict = cff.fdArray[i];
                        var matrix = base.slice(0);
                        if (subDict.hasName("FontMatrix")) {
                          matrix = _util.Util.transform(matrix, subDict.getByName("FontMatrix"));
                        }
                        subDict.setByName("FontMatrix", matrix);
                      }
                    }
                  }
                  var compiled = this.compileTopDicts([cff.topDict], output.length, cff.isCIDFont);
                  output.add(compiled.output);
                  var topDictTracker = compiled.trackers[0];
                  var stringIndex = this.compileStringIndex(cff.strings.strings);
                  output.add(stringIndex);
                  var globalSubrIndex = this.compileIndex(cff.globalSubrIndex);
                  output.add(globalSubrIndex);
                  if (cff.encoding && cff.topDict.hasName("Encoding")) {
                    if (cff.encoding.predefined) {
                      topDictTracker.setEntryLocation("Encoding", [cff.encoding.format], output);
                    } else {
                      var encoding = this.compileEncoding(cff.encoding);
                      topDictTracker.setEntryLocation("Encoding", [output.length], output);
                      output.add(encoding);
                    }
                  }
                  if (cff.charset && cff.topDict.hasName("charset")) {
                    if (cff.charset.predefined) {
                      topDictTracker.setEntryLocation("charset", [cff.charset.format], output);
                    } else {
                      var charset = this.compileCharset(cff.charset);
                      topDictTracker.setEntryLocation("charset", [output.length], output);
                      output.add(charset);
                    }
                  }
                  var charStrings = this.compileCharStrings(cff.charStrings);
                  topDictTracker.setEntryLocation("CharStrings", [output.length], output);
                  output.add(charStrings);
                  if (cff.isCIDFont) {
                    topDictTracker.setEntryLocation("FDSelect", [output.length], output);
                    var fdSelect = this.compileFDSelect(cff.fdSelect.raw);
                    output.add(fdSelect);
                    compiled = this.compileTopDicts(cff.fdArray, output.length, true);
                    topDictTracker.setEntryLocation("FDArray", [output.length], output);
                    output.add(compiled.output);
                    var fontDictTrackers = compiled.trackers;
                    this.compilePrivateDicts(cff.fdArray, fontDictTrackers, output);
                  }
                  this.compilePrivateDicts([cff.topDict], [topDictTracker], output);
                  output.add([0]);
                  return output.data;
                },
                encodeNumber: function CFFCompiler_encodeNumber(value) {
                  if (parseFloat(value) === parseInt(value, 10) && !isNaN(value)) {
                    return this.encodeInteger(value);
                  }
                  return this.encodeFloat(value);
                },
                encodeFloat: function CFFCompiler_encodeFloat(num) {
                  var value = num.toString();
                  var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
                  if (m) {
                    var epsilon = parseFloat("1e" + ((m[2] ? +m[2] : 0) + m[1].length));
                    value = (Math.round(num * epsilon) / epsilon).toString();
                  }
                  var nibbles = "";
                  var i, ii;
                  for (i = 0, ii = value.length; i < ii; ++i) {
                    var a = value[i];
                    if (a === "e") {
                      nibbles += value[++i] === "-" ? "c" : "b";
                    } else if (a === ".") {
                      nibbles += "a";
                    } else if (a === "-") {
                      nibbles += "e";
                    } else {
                      nibbles += a;
                    }
                  }
                  nibbles += nibbles.length & 1 ? "f" : "ff";
                  var out = [30];
                  for (i = 0, ii = nibbles.length; i < ii; i += 2) {
                    out.push(parseInt(nibbles.substr(i, 2), 16));
                  }
                  return out;
                },
                encodeInteger: function CFFCompiler_encodeInteger(value) {
                  var code;
                  if (value >= -107 && value <= 107) {
                    code = [value + 139];
                  } else if (value >= 108 && value <= 1131) {
                    value = value - 108;
                    code = [(value >> 8) + 247, value & 255];
                  } else if (value >= -1131 && value <= -108) {
                    value = -value - 108;
                    code = [(value >> 8) + 251, value & 255];
                  } else if (value >= -32768 && value <= 32767) {
                    code = [28, value >> 8 & 255, value & 255];
                  } else {
                    code = [29, value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255];
                  }
                  return code;
                },
                compileHeader: function CFFCompiler_compileHeader(header) {
                  return [header.major, header.minor, header.hdrSize, header.offSize];
                },
                compileNameIndex: function CFFCompiler_compileNameIndex(names) {
                  var nameIndex = new CFFIndex();
                  for (var i = 0, ii = names.length; i < ii; ++i) {
                    var name = names[i];
                    var length = Math.min(name.length, 127);
                    var sanitizedName = new Array(length);
                    for (var j = 0; j < length; j++) {
                      var char = name[j];
                      if (char < "!" || char > "~" || char === "[" || char === "]" || char === "(" || char === ")" || char === "{" || char === "}" || char === "<" || char === ">" || char === "/" || char === "%") {
                        char = "_";
                      }
                      sanitizedName[j] = char;
                    }
                    sanitizedName = sanitizedName.join("");
                    if (sanitizedName === "") {
                      sanitizedName = "Bad_Font_Name";
                    }
                    nameIndex.add((0, _util.stringToBytes)(sanitizedName));
                  }
                  return this.compileIndex(nameIndex);
                },
                compileTopDicts: function CFFCompiler_compileTopDicts(dicts, length, removeCidKeys) {
                  var fontDictTrackers = [];
                  var fdArrayIndex = new CFFIndex();
                  for (var i = 0, ii = dicts.length; i < ii; ++i) {
                    var fontDict = dicts[i];
                    if (removeCidKeys) {
                      fontDict.removeByName("CIDFontVersion");
                      fontDict.removeByName("CIDFontRevision");
                      fontDict.removeByName("CIDFontType");
                      fontDict.removeByName("CIDCount");
                      fontDict.removeByName("UIDBase");
                    }
                    var fontDictTracker = new CFFOffsetTracker();
                    var fontDictData = this.compileDict(fontDict, fontDictTracker);
                    fontDictTrackers.push(fontDictTracker);
                    fdArrayIndex.add(fontDictData);
                    fontDictTracker.offset(length);
                  }
                  fdArrayIndex = this.compileIndex(fdArrayIndex, fontDictTrackers);
                  return {
                    trackers: fontDictTrackers,
                    output: fdArrayIndex
                  };
                },
                compilePrivateDicts: function CFFCompiler_compilePrivateDicts(dicts, trackers, output) {
                  for (var i = 0, ii = dicts.length; i < ii; ++i) {
                    var fontDict = dicts[i];
                    var privateDict = fontDict.privateDict;
                    if (!privateDict || !fontDict.hasName("Private")) {
                      throw new _util.FormatError("There must be a private dictionary.");
                    }
                    var privateDictTracker = new CFFOffsetTracker();
                    var privateDictData = this.compileDict(privateDict, privateDictTracker);
                    var outputLength = output.length;
                    privateDictTracker.offset(outputLength);
                    if (!privateDictData.length) {
                      outputLength = 0;
                    }
                    trackers[i].setEntryLocation("Private", [privateDictData.length, outputLength], output);
                    output.add(privateDictData);
                    if (privateDict.subrsIndex && privateDict.hasName("Subrs")) {
                      var subrs = this.compileIndex(privateDict.subrsIndex);
                      privateDictTracker.setEntryLocation("Subrs", [privateDictData.length], output);
                      output.add(subrs);
                    }
                  }
                },
                compileDict: function CFFCompiler_compileDict(dict, offsetTracker) {
                  var out = [];
                  var order = dict.order;
                  for (var i = 0; i < order.length; ++i) {
                    var key = order[i];
                    if (!(key in dict.values)) {
                      continue;
                    }
                    var values = dict.values[key];
                    var types = dict.types[key];
                    if (!Array.isArray(types)) {
                      types = [types];
                    }
                    if (!Array.isArray(values)) {
                      values = [values];
                    }
                    if (values.length === 0) {
                      continue;
                    }
                    for (var j = 0, jj = types.length; j < jj; ++j) {
                      var type = types[j];
                      var value = values[j];
                      switch (type) {
                        case "num":
                        case "sid":
                          out = out.concat(this.encodeNumber(value));
                          break;
                        case "offset":
                          var name = dict.keyToNameMap[key];
                          if (!offsetTracker.isTracking(name)) {
                            offsetTracker.track(name, out.length);
                          }
                          out = out.concat([29, 0, 0, 0, 0]);
                          break;
                        case "array":
                        case "delta":
                          out = out.concat(this.encodeNumber(value));
                          for (var k = 1, kk = values.length; k < kk; ++k) {
                            out = out.concat(this.encodeNumber(values[k]));
                          }
                          break;
                        default:
                          throw new _util.FormatError("Unknown data type of " + type);
                      }
                    }
                    out = out.concat(dict.opcodes[key]);
                  }
                  return out;
                },
                compileStringIndex: function CFFCompiler_compileStringIndex(strings) {
                  var stringIndex = new CFFIndex();
                  for (var i = 0, ii = strings.length; i < ii; ++i) {
                    stringIndex.add((0, _util.stringToBytes)(strings[i]));
                  }
                  return this.compileIndex(stringIndex);
                },
                compileGlobalSubrIndex: function CFFCompiler_compileGlobalSubrIndex() {
                  var globalSubrIndex = this.cff.globalSubrIndex;
                  this.out.writeByteArray(this.compileIndex(globalSubrIndex));
                },
                compileCharStrings: function CFFCompiler_compileCharStrings(charStrings) {
                  return this.compileIndex(charStrings);
                },
                compileCharset: function CFFCompiler_compileCharset(charset) {
                  return this.compileTypedArray(charset.raw);
                },
                compileEncoding: function CFFCompiler_compileEncoding(encoding) {
                  return this.compileTypedArray(encoding.raw);
                },
                compileFDSelect: function CFFCompiler_compileFDSelect(fdSelect) {
                  return this.compileTypedArray(fdSelect);
                },
                compileTypedArray: function CFFCompiler_compileTypedArray(data) {
                  var out = [];
                  for (var i = 0, ii = data.length; i < ii; ++i) {
                    out[i] = data[i];
                  }
                  return out;
                },
                compileIndex: function CFFCompiler_compileIndex(index, trackers) {
                  trackers = trackers || [];
                  var objects = index.objects;
                  var count = objects.length;
                  if (count === 0) {
                    return [0, 0, 0];
                  }
                  var data = [count >> 8 & 255, count & 255];
                  var lastOffset = 1, i;
                  for (i = 0; i < count; ++i) {
                    lastOffset += objects[i].length;
                  }
                  var offsetSize;
                  if (lastOffset < 256) {
                    offsetSize = 1;
                  } else if (lastOffset < 65536) {
                    offsetSize = 2;
                  } else if (lastOffset < 16777216) {
                    offsetSize = 3;
                  } else {
                    offsetSize = 4;
                  }
                  data.push(offsetSize);
                  var relativeOffset = 1;
                  for (i = 0; i < count + 1; i++) {
                    if (offsetSize === 1) {
                      data.push(relativeOffset & 255);
                    } else if (offsetSize === 2) {
                      data.push(relativeOffset >> 8 & 255, relativeOffset & 255);
                    } else if (offsetSize === 3) {
                      data.push(relativeOffset >> 16 & 255, relativeOffset >> 8 & 255, relativeOffset & 255);
                    } else {
                      data.push(relativeOffset >>> 24 & 255, relativeOffset >> 16 & 255, relativeOffset >> 8 & 255, relativeOffset & 255);
                    }
                    if (objects[i]) {
                      relativeOffset += objects[i].length;
                    }
                  }
                  for (i = 0; i < count; i++) {
                    if (trackers[i]) {
                      trackers[i].offset(data.length);
                    }
                    for (var j = 0, jj = objects[i].length; j < jj; j++) {
                      data.push(objects[i][j]);
                    }
                  }
                  return data;
                }
              };
              return CFFCompiler2;
            }();
            exports3.CFFStandardStrings = CFFStandardStrings;
            exports3.CFFParser = CFFParser;
            exports3.CFF = CFF;
            exports3.CFFHeader = CFFHeader;
            exports3.CFFStrings = CFFStrings;
            exports3.CFFIndex = CFFIndex;
            exports3.CFFCharset = CFFCharset;
            exports3.CFFTopDict = CFFTopDict;
            exports3.CFFPrivateDict = CFFPrivateDict;
            exports3.CFFCompiler = CFFCompiler;
          },
          /* 139 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            var ISOAdobeCharset = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
            var ExpertCharset = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
            var ExpertSubsetCharset = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
            exports3.ISOAdobeCharset = ISOAdobeCharset;
            exports3.ExpertCharset = ExpertCharset;
            exports3.ExpertSubsetCharset = ExpertSubsetCharset;
          },
          /* 140 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            var ExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
            var MacExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];
            var MacRomanEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
            var StandardEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
            var WinAnsiEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
            var SymbolSetEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
            var ZapfDingbatsEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
            function getEncoding(encodingName) {
              switch (encodingName) {
                case "WinAnsiEncoding":
                  return WinAnsiEncoding;
                case "StandardEncoding":
                  return StandardEncoding;
                case "MacRomanEncoding":
                  return MacRomanEncoding;
                case "SymbolSetEncoding":
                  return SymbolSetEncoding;
                case "ZapfDingbatsEncoding":
                  return ZapfDingbatsEncoding;
                case "ExpertEncoding":
                  return ExpertEncoding;
                case "MacExpertEncoding":
                  return MacExpertEncoding;
                default:
                  return null;
              }
            }
            exports3.WinAnsiEncoding = WinAnsiEncoding;
            exports3.StandardEncoding = StandardEncoding;
            exports3.MacRomanEncoding = MacRomanEncoding;
            exports3.SymbolSetEncoding = SymbolSetEncoding;
            exports3.ZapfDingbatsEncoding = ZapfDingbatsEncoding;
            exports3.ExpertEncoding = ExpertEncoding;
            exports3.getEncoding = getEncoding;
          },
          /* 141 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            var getLookupTableFactory = __w_pdfjs_require__(2).getLookupTableFactory;
            var getGlyphsUnicode = getLookupTableFactory(function(t) {
              t["A"] = 65;
              t["AE"] = 198;
              t["AEacute"] = 508;
              t["AEmacron"] = 482;
              t["AEsmall"] = 63462;
              t["Aacute"] = 193;
              t["Aacutesmall"] = 63457;
              t["Abreve"] = 258;
              t["Abreveacute"] = 7854;
              t["Abrevecyrillic"] = 1232;
              t["Abrevedotbelow"] = 7862;
              t["Abrevegrave"] = 7856;
              t["Abrevehookabove"] = 7858;
              t["Abrevetilde"] = 7860;
              t["Acaron"] = 461;
              t["Acircle"] = 9398;
              t["Acircumflex"] = 194;
              t["Acircumflexacute"] = 7844;
              t["Acircumflexdotbelow"] = 7852;
              t["Acircumflexgrave"] = 7846;
              t["Acircumflexhookabove"] = 7848;
              t["Acircumflexsmall"] = 63458;
              t["Acircumflextilde"] = 7850;
              t["Acute"] = 63177;
              t["Acutesmall"] = 63412;
              t["Acyrillic"] = 1040;
              t["Adblgrave"] = 512;
              t["Adieresis"] = 196;
              t["Adieresiscyrillic"] = 1234;
              t["Adieresismacron"] = 478;
              t["Adieresissmall"] = 63460;
              t["Adotbelow"] = 7840;
              t["Adotmacron"] = 480;
              t["Agrave"] = 192;
              t["Agravesmall"] = 63456;
              t["Ahookabove"] = 7842;
              t["Aiecyrillic"] = 1236;
              t["Ainvertedbreve"] = 514;
              t["Alpha"] = 913;
              t["Alphatonos"] = 902;
              t["Amacron"] = 256;
              t["Amonospace"] = 65313;
              t["Aogonek"] = 260;
              t["Aring"] = 197;
              t["Aringacute"] = 506;
              t["Aringbelow"] = 7680;
              t["Aringsmall"] = 63461;
              t["Asmall"] = 63329;
              t["Atilde"] = 195;
              t["Atildesmall"] = 63459;
              t["Aybarmenian"] = 1329;
              t["B"] = 66;
              t["Bcircle"] = 9399;
              t["Bdotaccent"] = 7682;
              t["Bdotbelow"] = 7684;
              t["Becyrillic"] = 1041;
              t["Benarmenian"] = 1330;
              t["Beta"] = 914;
              t["Bhook"] = 385;
              t["Blinebelow"] = 7686;
              t["Bmonospace"] = 65314;
              t["Brevesmall"] = 63220;
              t["Bsmall"] = 63330;
              t["Btopbar"] = 386;
              t["C"] = 67;
              t["Caarmenian"] = 1342;
              t["Cacute"] = 262;
              t["Caron"] = 63178;
              t["Caronsmall"] = 63221;
              t["Ccaron"] = 268;
              t["Ccedilla"] = 199;
              t["Ccedillaacute"] = 7688;
              t["Ccedillasmall"] = 63463;
              t["Ccircle"] = 9400;
              t["Ccircumflex"] = 264;
              t["Cdot"] = 266;
              t["Cdotaccent"] = 266;
              t["Cedillasmall"] = 63416;
              t["Chaarmenian"] = 1353;
              t["Cheabkhasiancyrillic"] = 1212;
              t["Checyrillic"] = 1063;
              t["Chedescenderabkhasiancyrillic"] = 1214;
              t["Chedescendercyrillic"] = 1206;
              t["Chedieresiscyrillic"] = 1268;
              t["Cheharmenian"] = 1347;
              t["Chekhakassiancyrillic"] = 1227;
              t["Cheverticalstrokecyrillic"] = 1208;
              t["Chi"] = 935;
              t["Chook"] = 391;
              t["Circumflexsmall"] = 63222;
              t["Cmonospace"] = 65315;
              t["Coarmenian"] = 1361;
              t["Csmall"] = 63331;
              t["D"] = 68;
              t["DZ"] = 497;
              t["DZcaron"] = 452;
              t["Daarmenian"] = 1332;
              t["Dafrican"] = 393;
              t["Dcaron"] = 270;
              t["Dcedilla"] = 7696;
              t["Dcircle"] = 9401;
              t["Dcircumflexbelow"] = 7698;
              t["Dcroat"] = 272;
              t["Ddotaccent"] = 7690;
              t["Ddotbelow"] = 7692;
              t["Decyrillic"] = 1044;
              t["Deicoptic"] = 1006;
              t["Delta"] = 8710;
              t["Deltagreek"] = 916;
              t["Dhook"] = 394;
              t["Dieresis"] = 63179;
              t["DieresisAcute"] = 63180;
              t["DieresisGrave"] = 63181;
              t["Dieresissmall"] = 63400;
              t["Digammagreek"] = 988;
              t["Djecyrillic"] = 1026;
              t["Dlinebelow"] = 7694;
              t["Dmonospace"] = 65316;
              t["Dotaccentsmall"] = 63223;
              t["Dslash"] = 272;
              t["Dsmall"] = 63332;
              t["Dtopbar"] = 395;
              t["Dz"] = 498;
              t["Dzcaron"] = 453;
              t["Dzeabkhasiancyrillic"] = 1248;
              t["Dzecyrillic"] = 1029;
              t["Dzhecyrillic"] = 1039;
              t["E"] = 69;
              t["Eacute"] = 201;
              t["Eacutesmall"] = 63465;
              t["Ebreve"] = 276;
              t["Ecaron"] = 282;
              t["Ecedillabreve"] = 7708;
              t["Echarmenian"] = 1333;
              t["Ecircle"] = 9402;
              t["Ecircumflex"] = 202;
              t["Ecircumflexacute"] = 7870;
              t["Ecircumflexbelow"] = 7704;
              t["Ecircumflexdotbelow"] = 7878;
              t["Ecircumflexgrave"] = 7872;
              t["Ecircumflexhookabove"] = 7874;
              t["Ecircumflexsmall"] = 63466;
              t["Ecircumflextilde"] = 7876;
              t["Ecyrillic"] = 1028;
              t["Edblgrave"] = 516;
              t["Edieresis"] = 203;
              t["Edieresissmall"] = 63467;
              t["Edot"] = 278;
              t["Edotaccent"] = 278;
              t["Edotbelow"] = 7864;
              t["Efcyrillic"] = 1060;
              t["Egrave"] = 200;
              t["Egravesmall"] = 63464;
              t["Eharmenian"] = 1335;
              t["Ehookabove"] = 7866;
              t["Eightroman"] = 8551;
              t["Einvertedbreve"] = 518;
              t["Eiotifiedcyrillic"] = 1124;
              t["Elcyrillic"] = 1051;
              t["Elevenroman"] = 8554;
              t["Emacron"] = 274;
              t["Emacronacute"] = 7702;
              t["Emacrongrave"] = 7700;
              t["Emcyrillic"] = 1052;
              t["Emonospace"] = 65317;
              t["Encyrillic"] = 1053;
              t["Endescendercyrillic"] = 1186;
              t["Eng"] = 330;
              t["Enghecyrillic"] = 1188;
              t["Enhookcyrillic"] = 1223;
              t["Eogonek"] = 280;
              t["Eopen"] = 400;
              t["Epsilon"] = 917;
              t["Epsilontonos"] = 904;
              t["Ercyrillic"] = 1056;
              t["Ereversed"] = 398;
              t["Ereversedcyrillic"] = 1069;
              t["Escyrillic"] = 1057;
              t["Esdescendercyrillic"] = 1194;
              t["Esh"] = 425;
              t["Esmall"] = 63333;
              t["Eta"] = 919;
              t["Etarmenian"] = 1336;
              t["Etatonos"] = 905;
              t["Eth"] = 208;
              t["Ethsmall"] = 63472;
              t["Etilde"] = 7868;
              t["Etildebelow"] = 7706;
              t["Euro"] = 8364;
              t["Ezh"] = 439;
              t["Ezhcaron"] = 494;
              t["Ezhreversed"] = 440;
              t["F"] = 70;
              t["Fcircle"] = 9403;
              t["Fdotaccent"] = 7710;
              t["Feharmenian"] = 1366;
              t["Feicoptic"] = 996;
              t["Fhook"] = 401;
              t["Fitacyrillic"] = 1138;
              t["Fiveroman"] = 8548;
              t["Fmonospace"] = 65318;
              t["Fourroman"] = 8547;
              t["Fsmall"] = 63334;
              t["G"] = 71;
              t["GBsquare"] = 13191;
              t["Gacute"] = 500;
              t["Gamma"] = 915;
              t["Gammaafrican"] = 404;
              t["Gangiacoptic"] = 1002;
              t["Gbreve"] = 286;
              t["Gcaron"] = 486;
              t["Gcedilla"] = 290;
              t["Gcircle"] = 9404;
              t["Gcircumflex"] = 284;
              t["Gcommaaccent"] = 290;
              t["Gdot"] = 288;
              t["Gdotaccent"] = 288;
              t["Gecyrillic"] = 1043;
              t["Ghadarmenian"] = 1346;
              t["Ghemiddlehookcyrillic"] = 1172;
              t["Ghestrokecyrillic"] = 1170;
              t["Gheupturncyrillic"] = 1168;
              t["Ghook"] = 403;
              t["Gimarmenian"] = 1331;
              t["Gjecyrillic"] = 1027;
              t["Gmacron"] = 7712;
              t["Gmonospace"] = 65319;
              t["Grave"] = 63182;
              t["Gravesmall"] = 63328;
              t["Gsmall"] = 63335;
              t["Gsmallhook"] = 667;
              t["Gstroke"] = 484;
              t["H"] = 72;
              t["H18533"] = 9679;
              t["H18543"] = 9642;
              t["H18551"] = 9643;
              t["H22073"] = 9633;
              t["HPsquare"] = 13259;
              t["Haabkhasiancyrillic"] = 1192;
              t["Hadescendercyrillic"] = 1202;
              t["Hardsigncyrillic"] = 1066;
              t["Hbar"] = 294;
              t["Hbrevebelow"] = 7722;
              t["Hcedilla"] = 7720;
              t["Hcircle"] = 9405;
              t["Hcircumflex"] = 292;
              t["Hdieresis"] = 7718;
              t["Hdotaccent"] = 7714;
              t["Hdotbelow"] = 7716;
              t["Hmonospace"] = 65320;
              t["Hoarmenian"] = 1344;
              t["Horicoptic"] = 1e3;
              t["Hsmall"] = 63336;
              t["Hungarumlaut"] = 63183;
              t["Hungarumlautsmall"] = 63224;
              t["Hzsquare"] = 13200;
              t["I"] = 73;
              t["IAcyrillic"] = 1071;
              t["IJ"] = 306;
              t["IUcyrillic"] = 1070;
              t["Iacute"] = 205;
              t["Iacutesmall"] = 63469;
              t["Ibreve"] = 300;
              t["Icaron"] = 463;
              t["Icircle"] = 9406;
              t["Icircumflex"] = 206;
              t["Icircumflexsmall"] = 63470;
              t["Icyrillic"] = 1030;
              t["Idblgrave"] = 520;
              t["Idieresis"] = 207;
              t["Idieresisacute"] = 7726;
              t["Idieresiscyrillic"] = 1252;
              t["Idieresissmall"] = 63471;
              t["Idot"] = 304;
              t["Idotaccent"] = 304;
              t["Idotbelow"] = 7882;
              t["Iebrevecyrillic"] = 1238;
              t["Iecyrillic"] = 1045;
              t["Ifraktur"] = 8465;
              t["Igrave"] = 204;
              t["Igravesmall"] = 63468;
              t["Ihookabove"] = 7880;
              t["Iicyrillic"] = 1048;
              t["Iinvertedbreve"] = 522;
              t["Iishortcyrillic"] = 1049;
              t["Imacron"] = 298;
              t["Imacroncyrillic"] = 1250;
              t["Imonospace"] = 65321;
              t["Iniarmenian"] = 1339;
              t["Iocyrillic"] = 1025;
              t["Iogonek"] = 302;
              t["Iota"] = 921;
              t["Iotaafrican"] = 406;
              t["Iotadieresis"] = 938;
              t["Iotatonos"] = 906;
              t["Ismall"] = 63337;
              t["Istroke"] = 407;
              t["Itilde"] = 296;
              t["Itildebelow"] = 7724;
              t["Izhitsacyrillic"] = 1140;
              t["Izhitsadblgravecyrillic"] = 1142;
              t["J"] = 74;
              t["Jaarmenian"] = 1345;
              t["Jcircle"] = 9407;
              t["Jcircumflex"] = 308;
              t["Jecyrillic"] = 1032;
              t["Jheharmenian"] = 1355;
              t["Jmonospace"] = 65322;
              t["Jsmall"] = 63338;
              t["K"] = 75;
              t["KBsquare"] = 13189;
              t["KKsquare"] = 13261;
              t["Kabashkircyrillic"] = 1184;
              t["Kacute"] = 7728;
              t["Kacyrillic"] = 1050;
              t["Kadescendercyrillic"] = 1178;
              t["Kahookcyrillic"] = 1219;
              t["Kappa"] = 922;
              t["Kastrokecyrillic"] = 1182;
              t["Kaverticalstrokecyrillic"] = 1180;
              t["Kcaron"] = 488;
              t["Kcedilla"] = 310;
              t["Kcircle"] = 9408;
              t["Kcommaaccent"] = 310;
              t["Kdotbelow"] = 7730;
              t["Keharmenian"] = 1364;
              t["Kenarmenian"] = 1343;
              t["Khacyrillic"] = 1061;
              t["Kheicoptic"] = 998;
              t["Khook"] = 408;
              t["Kjecyrillic"] = 1036;
              t["Klinebelow"] = 7732;
              t["Kmonospace"] = 65323;
              t["Koppacyrillic"] = 1152;
              t["Koppagreek"] = 990;
              t["Ksicyrillic"] = 1134;
              t["Ksmall"] = 63339;
              t["L"] = 76;
              t["LJ"] = 455;
              t["LL"] = 63167;
              t["Lacute"] = 313;
              t["Lambda"] = 923;
              t["Lcaron"] = 317;
              t["Lcedilla"] = 315;
              t["Lcircle"] = 9409;
              t["Lcircumflexbelow"] = 7740;
              t["Lcommaaccent"] = 315;
              t["Ldot"] = 319;
              t["Ldotaccent"] = 319;
              t["Ldotbelow"] = 7734;
              t["Ldotbelowmacron"] = 7736;
              t["Liwnarmenian"] = 1340;
              t["Lj"] = 456;
              t["Ljecyrillic"] = 1033;
              t["Llinebelow"] = 7738;
              t["Lmonospace"] = 65324;
              t["Lslash"] = 321;
              t["Lslashsmall"] = 63225;
              t["Lsmall"] = 63340;
              t["M"] = 77;
              t["MBsquare"] = 13190;
              t["Macron"] = 63184;
              t["Macronsmall"] = 63407;
              t["Macute"] = 7742;
              t["Mcircle"] = 9410;
              t["Mdotaccent"] = 7744;
              t["Mdotbelow"] = 7746;
              t["Menarmenian"] = 1348;
              t["Mmonospace"] = 65325;
              t["Msmall"] = 63341;
              t["Mturned"] = 412;
              t["Mu"] = 924;
              t["N"] = 78;
              t["NJ"] = 458;
              t["Nacute"] = 323;
              t["Ncaron"] = 327;
              t["Ncedilla"] = 325;
              t["Ncircle"] = 9411;
              t["Ncircumflexbelow"] = 7754;
              t["Ncommaaccent"] = 325;
              t["Ndotaccent"] = 7748;
              t["Ndotbelow"] = 7750;
              t["Nhookleft"] = 413;
              t["Nineroman"] = 8552;
              t["Nj"] = 459;
              t["Njecyrillic"] = 1034;
              t["Nlinebelow"] = 7752;
              t["Nmonospace"] = 65326;
              t["Nowarmenian"] = 1350;
              t["Nsmall"] = 63342;
              t["Ntilde"] = 209;
              t["Ntildesmall"] = 63473;
              t["Nu"] = 925;
              t["O"] = 79;
              t["OE"] = 338;
              t["OEsmall"] = 63226;
              t["Oacute"] = 211;
              t["Oacutesmall"] = 63475;
              t["Obarredcyrillic"] = 1256;
              t["Obarreddieresiscyrillic"] = 1258;
              t["Obreve"] = 334;
              t["Ocaron"] = 465;
              t["Ocenteredtilde"] = 415;
              t["Ocircle"] = 9412;
              t["Ocircumflex"] = 212;
              t["Ocircumflexacute"] = 7888;
              t["Ocircumflexdotbelow"] = 7896;
              t["Ocircumflexgrave"] = 7890;
              t["Ocircumflexhookabove"] = 7892;
              t["Ocircumflexsmall"] = 63476;
              t["Ocircumflextilde"] = 7894;
              t["Ocyrillic"] = 1054;
              t["Odblacute"] = 336;
              t["Odblgrave"] = 524;
              t["Odieresis"] = 214;
              t["Odieresiscyrillic"] = 1254;
              t["Odieresissmall"] = 63478;
              t["Odotbelow"] = 7884;
              t["Ogoneksmall"] = 63227;
              t["Ograve"] = 210;
              t["Ogravesmall"] = 63474;
              t["Oharmenian"] = 1365;
              t["Ohm"] = 8486;
              t["Ohookabove"] = 7886;
              t["Ohorn"] = 416;
              t["Ohornacute"] = 7898;
              t["Ohorndotbelow"] = 7906;
              t["Ohorngrave"] = 7900;
              t["Ohornhookabove"] = 7902;
              t["Ohorntilde"] = 7904;
              t["Ohungarumlaut"] = 336;
              t["Oi"] = 418;
              t["Oinvertedbreve"] = 526;
              t["Omacron"] = 332;
              t["Omacronacute"] = 7762;
              t["Omacrongrave"] = 7760;
              t["Omega"] = 8486;
              t["Omegacyrillic"] = 1120;
              t["Omegagreek"] = 937;
              t["Omegaroundcyrillic"] = 1146;
              t["Omegatitlocyrillic"] = 1148;
              t["Omegatonos"] = 911;
              t["Omicron"] = 927;
              t["Omicrontonos"] = 908;
              t["Omonospace"] = 65327;
              t["Oneroman"] = 8544;
              t["Oogonek"] = 490;
              t["Oogonekmacron"] = 492;
              t["Oopen"] = 390;
              t["Oslash"] = 216;
              t["Oslashacute"] = 510;
              t["Oslashsmall"] = 63480;
              t["Osmall"] = 63343;
              t["Ostrokeacute"] = 510;
              t["Otcyrillic"] = 1150;
              t["Otilde"] = 213;
              t["Otildeacute"] = 7756;
              t["Otildedieresis"] = 7758;
              t["Otildesmall"] = 63477;
              t["P"] = 80;
              t["Pacute"] = 7764;
              t["Pcircle"] = 9413;
              t["Pdotaccent"] = 7766;
              t["Pecyrillic"] = 1055;
              t["Peharmenian"] = 1354;
              t["Pemiddlehookcyrillic"] = 1190;
              t["Phi"] = 934;
              t["Phook"] = 420;
              t["Pi"] = 928;
              t["Piwrarmenian"] = 1363;
              t["Pmonospace"] = 65328;
              t["Psi"] = 936;
              t["Psicyrillic"] = 1136;
              t["Psmall"] = 63344;
              t["Q"] = 81;
              t["Qcircle"] = 9414;
              t["Qmonospace"] = 65329;
              t["Qsmall"] = 63345;
              t["R"] = 82;
              t["Raarmenian"] = 1356;
              t["Racute"] = 340;
              t["Rcaron"] = 344;
              t["Rcedilla"] = 342;
              t["Rcircle"] = 9415;
              t["Rcommaaccent"] = 342;
              t["Rdblgrave"] = 528;
              t["Rdotaccent"] = 7768;
              t["Rdotbelow"] = 7770;
              t["Rdotbelowmacron"] = 7772;
              t["Reharmenian"] = 1360;
              t["Rfraktur"] = 8476;
              t["Rho"] = 929;
              t["Ringsmall"] = 63228;
              t["Rinvertedbreve"] = 530;
              t["Rlinebelow"] = 7774;
              t["Rmonospace"] = 65330;
              t["Rsmall"] = 63346;
              t["Rsmallinverted"] = 641;
              t["Rsmallinvertedsuperior"] = 694;
              t["S"] = 83;
              t["SF010000"] = 9484;
              t["SF020000"] = 9492;
              t["SF030000"] = 9488;
              t["SF040000"] = 9496;
              t["SF050000"] = 9532;
              t["SF060000"] = 9516;
              t["SF070000"] = 9524;
              t["SF080000"] = 9500;
              t["SF090000"] = 9508;
              t["SF100000"] = 9472;
              t["SF110000"] = 9474;
              t["SF190000"] = 9569;
              t["SF200000"] = 9570;
              t["SF210000"] = 9558;
              t["SF220000"] = 9557;
              t["SF230000"] = 9571;
              t["SF240000"] = 9553;
              t["SF250000"] = 9559;
              t["SF260000"] = 9565;
              t["SF270000"] = 9564;
              t["SF280000"] = 9563;
              t["SF360000"] = 9566;
              t["SF370000"] = 9567;
              t["SF380000"] = 9562;
              t["SF390000"] = 9556;
              t["SF400000"] = 9577;
              t["SF410000"] = 9574;
              t["SF420000"] = 9568;
              t["SF430000"] = 9552;
              t["SF440000"] = 9580;
              t["SF450000"] = 9575;
              t["SF460000"] = 9576;
              t["SF470000"] = 9572;
              t["SF480000"] = 9573;
              t["SF490000"] = 9561;
              t["SF500000"] = 9560;
              t["SF510000"] = 9554;
              t["SF520000"] = 9555;
              t["SF530000"] = 9579;
              t["SF540000"] = 9578;
              t["Sacute"] = 346;
              t["Sacutedotaccent"] = 7780;
              t["Sampigreek"] = 992;
              t["Scaron"] = 352;
              t["Scarondotaccent"] = 7782;
              t["Scaronsmall"] = 63229;
              t["Scedilla"] = 350;
              t["Schwa"] = 399;
              t["Schwacyrillic"] = 1240;
              t["Schwadieresiscyrillic"] = 1242;
              t["Scircle"] = 9416;
              t["Scircumflex"] = 348;
              t["Scommaaccent"] = 536;
              t["Sdotaccent"] = 7776;
              t["Sdotbelow"] = 7778;
              t["Sdotbelowdotaccent"] = 7784;
              t["Seharmenian"] = 1357;
              t["Sevenroman"] = 8550;
              t["Shaarmenian"] = 1351;
              t["Shacyrillic"] = 1064;
              t["Shchacyrillic"] = 1065;
              t["Sheicoptic"] = 994;
              t["Shhacyrillic"] = 1210;
              t["Shimacoptic"] = 1004;
              t["Sigma"] = 931;
              t["Sixroman"] = 8549;
              t["Smonospace"] = 65331;
              t["Softsigncyrillic"] = 1068;
              t["Ssmall"] = 63347;
              t["Stigmagreek"] = 986;
              t["T"] = 84;
              t["Tau"] = 932;
              t["Tbar"] = 358;
              t["Tcaron"] = 356;
              t["Tcedilla"] = 354;
              t["Tcircle"] = 9417;
              t["Tcircumflexbelow"] = 7792;
              t["Tcommaaccent"] = 354;
              t["Tdotaccent"] = 7786;
              t["Tdotbelow"] = 7788;
              t["Tecyrillic"] = 1058;
              t["Tedescendercyrillic"] = 1196;
              t["Tenroman"] = 8553;
              t["Tetsecyrillic"] = 1204;
              t["Theta"] = 920;
              t["Thook"] = 428;
              t["Thorn"] = 222;
              t["Thornsmall"] = 63486;
              t["Threeroman"] = 8546;
              t["Tildesmall"] = 63230;
              t["Tiwnarmenian"] = 1359;
              t["Tlinebelow"] = 7790;
              t["Tmonospace"] = 65332;
              t["Toarmenian"] = 1337;
              t["Tonefive"] = 444;
              t["Tonesix"] = 388;
              t["Tonetwo"] = 423;
              t["Tretroflexhook"] = 430;
              t["Tsecyrillic"] = 1062;
              t["Tshecyrillic"] = 1035;
              t["Tsmall"] = 63348;
              t["Twelveroman"] = 8555;
              t["Tworoman"] = 8545;
              t["U"] = 85;
              t["Uacute"] = 218;
              t["Uacutesmall"] = 63482;
              t["Ubreve"] = 364;
              t["Ucaron"] = 467;
              t["Ucircle"] = 9418;
              t["Ucircumflex"] = 219;
              t["Ucircumflexbelow"] = 7798;
              t["Ucircumflexsmall"] = 63483;
              t["Ucyrillic"] = 1059;
              t["Udblacute"] = 368;
              t["Udblgrave"] = 532;
              t["Udieresis"] = 220;
              t["Udieresisacute"] = 471;
              t["Udieresisbelow"] = 7794;
              t["Udieresiscaron"] = 473;
              t["Udieresiscyrillic"] = 1264;
              t["Udieresisgrave"] = 475;
              t["Udieresismacron"] = 469;
              t["Udieresissmall"] = 63484;
              t["Udotbelow"] = 7908;
              t["Ugrave"] = 217;
              t["Ugravesmall"] = 63481;
              t["Uhookabove"] = 7910;
              t["Uhorn"] = 431;
              t["Uhornacute"] = 7912;
              t["Uhorndotbelow"] = 7920;
              t["Uhorngrave"] = 7914;
              t["Uhornhookabove"] = 7916;
              t["Uhorntilde"] = 7918;
              t["Uhungarumlaut"] = 368;
              t["Uhungarumlautcyrillic"] = 1266;
              t["Uinvertedbreve"] = 534;
              t["Ukcyrillic"] = 1144;
              t["Umacron"] = 362;
              t["Umacroncyrillic"] = 1262;
              t["Umacrondieresis"] = 7802;
              t["Umonospace"] = 65333;
              t["Uogonek"] = 370;
              t["Upsilon"] = 933;
              t["Upsilon1"] = 978;
              t["Upsilonacutehooksymbolgreek"] = 979;
              t["Upsilonafrican"] = 433;
              t["Upsilondieresis"] = 939;
              t["Upsilondieresishooksymbolgreek"] = 980;
              t["Upsilonhooksymbol"] = 978;
              t["Upsilontonos"] = 910;
              t["Uring"] = 366;
              t["Ushortcyrillic"] = 1038;
              t["Usmall"] = 63349;
              t["Ustraightcyrillic"] = 1198;
              t["Ustraightstrokecyrillic"] = 1200;
              t["Utilde"] = 360;
              t["Utildeacute"] = 7800;
              t["Utildebelow"] = 7796;
              t["V"] = 86;
              t["Vcircle"] = 9419;
              t["Vdotbelow"] = 7806;
              t["Vecyrillic"] = 1042;
              t["Vewarmenian"] = 1358;
              t["Vhook"] = 434;
              t["Vmonospace"] = 65334;
              t["Voarmenian"] = 1352;
              t["Vsmall"] = 63350;
              t["Vtilde"] = 7804;
              t["W"] = 87;
              t["Wacute"] = 7810;
              t["Wcircle"] = 9420;
              t["Wcircumflex"] = 372;
              t["Wdieresis"] = 7812;
              t["Wdotaccent"] = 7814;
              t["Wdotbelow"] = 7816;
              t["Wgrave"] = 7808;
              t["Wmonospace"] = 65335;
              t["Wsmall"] = 63351;
              t["X"] = 88;
              t["Xcircle"] = 9421;
              t["Xdieresis"] = 7820;
              t["Xdotaccent"] = 7818;
              t["Xeharmenian"] = 1341;
              t["Xi"] = 926;
              t["Xmonospace"] = 65336;
              t["Xsmall"] = 63352;
              t["Y"] = 89;
              t["Yacute"] = 221;
              t["Yacutesmall"] = 63485;
              t["Yatcyrillic"] = 1122;
              t["Ycircle"] = 9422;
              t["Ycircumflex"] = 374;
              t["Ydieresis"] = 376;
              t["Ydieresissmall"] = 63487;
              t["Ydotaccent"] = 7822;
              t["Ydotbelow"] = 7924;
              t["Yericyrillic"] = 1067;
              t["Yerudieresiscyrillic"] = 1272;
              t["Ygrave"] = 7922;
              t["Yhook"] = 435;
              t["Yhookabove"] = 7926;
              t["Yiarmenian"] = 1349;
              t["Yicyrillic"] = 1031;
              t["Yiwnarmenian"] = 1362;
              t["Ymonospace"] = 65337;
              t["Ysmall"] = 63353;
              t["Ytilde"] = 7928;
              t["Yusbigcyrillic"] = 1130;
              t["Yusbigiotifiedcyrillic"] = 1132;
              t["Yuslittlecyrillic"] = 1126;
              t["Yuslittleiotifiedcyrillic"] = 1128;
              t["Z"] = 90;
              t["Zaarmenian"] = 1334;
              t["Zacute"] = 377;
              t["Zcaron"] = 381;
              t["Zcaronsmall"] = 63231;
              t["Zcircle"] = 9423;
              t["Zcircumflex"] = 7824;
              t["Zdot"] = 379;
              t["Zdotaccent"] = 379;
              t["Zdotbelow"] = 7826;
              t["Zecyrillic"] = 1047;
              t["Zedescendercyrillic"] = 1176;
              t["Zedieresiscyrillic"] = 1246;
              t["Zeta"] = 918;
              t["Zhearmenian"] = 1338;
              t["Zhebrevecyrillic"] = 1217;
              t["Zhecyrillic"] = 1046;
              t["Zhedescendercyrillic"] = 1174;
              t["Zhedieresiscyrillic"] = 1244;
              t["Zlinebelow"] = 7828;
              t["Zmonospace"] = 65338;
              t["Zsmall"] = 63354;
              t["Zstroke"] = 437;
              t["a"] = 97;
              t["aabengali"] = 2438;
              t["aacute"] = 225;
              t["aadeva"] = 2310;
              t["aagujarati"] = 2694;
              t["aagurmukhi"] = 2566;
              t["aamatragurmukhi"] = 2622;
              t["aarusquare"] = 13059;
              t["aavowelsignbengali"] = 2494;
              t["aavowelsigndeva"] = 2366;
              t["aavowelsigngujarati"] = 2750;
              t["abbreviationmarkarmenian"] = 1375;
              t["abbreviationsigndeva"] = 2416;
              t["abengali"] = 2437;
              t["abopomofo"] = 12570;
              t["abreve"] = 259;
              t["abreveacute"] = 7855;
              t["abrevecyrillic"] = 1233;
              t["abrevedotbelow"] = 7863;
              t["abrevegrave"] = 7857;
              t["abrevehookabove"] = 7859;
              t["abrevetilde"] = 7861;
              t["acaron"] = 462;
              t["acircle"] = 9424;
              t["acircumflex"] = 226;
              t["acircumflexacute"] = 7845;
              t["acircumflexdotbelow"] = 7853;
              t["acircumflexgrave"] = 7847;
              t["acircumflexhookabove"] = 7849;
              t["acircumflextilde"] = 7851;
              t["acute"] = 180;
              t["acutebelowcmb"] = 791;
              t["acutecmb"] = 769;
              t["acutecomb"] = 769;
              t["acutedeva"] = 2388;
              t["acutelowmod"] = 719;
              t["acutetonecmb"] = 833;
              t["acyrillic"] = 1072;
              t["adblgrave"] = 513;
              t["addakgurmukhi"] = 2673;
              t["adeva"] = 2309;
              t["adieresis"] = 228;
              t["adieresiscyrillic"] = 1235;
              t["adieresismacron"] = 479;
              t["adotbelow"] = 7841;
              t["adotmacron"] = 481;
              t["ae"] = 230;
              t["aeacute"] = 509;
              t["aekorean"] = 12624;
              t["aemacron"] = 483;
              t["afii00208"] = 8213;
              t["afii08941"] = 8356;
              t["afii10017"] = 1040;
              t["afii10018"] = 1041;
              t["afii10019"] = 1042;
              t["afii10020"] = 1043;
              t["afii10021"] = 1044;
              t["afii10022"] = 1045;
              t["afii10023"] = 1025;
              t["afii10024"] = 1046;
              t["afii10025"] = 1047;
              t["afii10026"] = 1048;
              t["afii10027"] = 1049;
              t["afii10028"] = 1050;
              t["afii10029"] = 1051;
              t["afii10030"] = 1052;
              t["afii10031"] = 1053;
              t["afii10032"] = 1054;
              t["afii10033"] = 1055;
              t["afii10034"] = 1056;
              t["afii10035"] = 1057;
              t["afii10036"] = 1058;
              t["afii10037"] = 1059;
              t["afii10038"] = 1060;
              t["afii10039"] = 1061;
              t["afii10040"] = 1062;
              t["afii10041"] = 1063;
              t["afii10042"] = 1064;
              t["afii10043"] = 1065;
              t["afii10044"] = 1066;
              t["afii10045"] = 1067;
              t["afii10046"] = 1068;
              t["afii10047"] = 1069;
              t["afii10048"] = 1070;
              t["afii10049"] = 1071;
              t["afii10050"] = 1168;
              t["afii10051"] = 1026;
              t["afii10052"] = 1027;
              t["afii10053"] = 1028;
              t["afii10054"] = 1029;
              t["afii10055"] = 1030;
              t["afii10056"] = 1031;
              t["afii10057"] = 1032;
              t["afii10058"] = 1033;
              t["afii10059"] = 1034;
              t["afii10060"] = 1035;
              t["afii10061"] = 1036;
              t["afii10062"] = 1038;
              t["afii10063"] = 63172;
              t["afii10064"] = 63173;
              t["afii10065"] = 1072;
              t["afii10066"] = 1073;
              t["afii10067"] = 1074;
              t["afii10068"] = 1075;
              t["afii10069"] = 1076;
              t["afii10070"] = 1077;
              t["afii10071"] = 1105;
              t["afii10072"] = 1078;
              t["afii10073"] = 1079;
              t["afii10074"] = 1080;
              t["afii10075"] = 1081;
              t["afii10076"] = 1082;
              t["afii10077"] = 1083;
              t["afii10078"] = 1084;
              t["afii10079"] = 1085;
              t["afii10080"] = 1086;
              t["afii10081"] = 1087;
              t["afii10082"] = 1088;
              t["afii10083"] = 1089;
              t["afii10084"] = 1090;
              t["afii10085"] = 1091;
              t["afii10086"] = 1092;
              t["afii10087"] = 1093;
              t["afii10088"] = 1094;
              t["afii10089"] = 1095;
              t["afii10090"] = 1096;
              t["afii10091"] = 1097;
              t["afii10092"] = 1098;
              t["afii10093"] = 1099;
              t["afii10094"] = 1100;
              t["afii10095"] = 1101;
              t["afii10096"] = 1102;
              t["afii10097"] = 1103;
              t["afii10098"] = 1169;
              t["afii10099"] = 1106;
              t["afii10100"] = 1107;
              t["afii10101"] = 1108;
              t["afii10102"] = 1109;
              t["afii10103"] = 1110;
              t["afii10104"] = 1111;
              t["afii10105"] = 1112;
              t["afii10106"] = 1113;
              t["afii10107"] = 1114;
              t["afii10108"] = 1115;
              t["afii10109"] = 1116;
              t["afii10110"] = 1118;
              t["afii10145"] = 1039;
              t["afii10146"] = 1122;
              t["afii10147"] = 1138;
              t["afii10148"] = 1140;
              t["afii10192"] = 63174;
              t["afii10193"] = 1119;
              t["afii10194"] = 1123;
              t["afii10195"] = 1139;
              t["afii10196"] = 1141;
              t["afii10831"] = 63175;
              t["afii10832"] = 63176;
              t["afii10846"] = 1241;
              t["afii299"] = 8206;
              t["afii300"] = 8207;
              t["afii301"] = 8205;
              t["afii57381"] = 1642;
              t["afii57388"] = 1548;
              t["afii57392"] = 1632;
              t["afii57393"] = 1633;
              t["afii57394"] = 1634;
              t["afii57395"] = 1635;
              t["afii57396"] = 1636;
              t["afii57397"] = 1637;
              t["afii57398"] = 1638;
              t["afii57399"] = 1639;
              t["afii57400"] = 1640;
              t["afii57401"] = 1641;
              t["afii57403"] = 1563;
              t["afii57407"] = 1567;
              t["afii57409"] = 1569;
              t["afii57410"] = 1570;
              t["afii57411"] = 1571;
              t["afii57412"] = 1572;
              t["afii57413"] = 1573;
              t["afii57414"] = 1574;
              t["afii57415"] = 1575;
              t["afii57416"] = 1576;
              t["afii57417"] = 1577;
              t["afii57418"] = 1578;
              t["afii57419"] = 1579;
              t["afii57420"] = 1580;
              t["afii57421"] = 1581;
              t["afii57422"] = 1582;
              t["afii57423"] = 1583;
              t["afii57424"] = 1584;
              t["afii57425"] = 1585;
              t["afii57426"] = 1586;
              t["afii57427"] = 1587;
              t["afii57428"] = 1588;
              t["afii57429"] = 1589;
              t["afii57430"] = 1590;
              t["afii57431"] = 1591;
              t["afii57432"] = 1592;
              t["afii57433"] = 1593;
              t["afii57434"] = 1594;
              t["afii57440"] = 1600;
              t["afii57441"] = 1601;
              t["afii57442"] = 1602;
              t["afii57443"] = 1603;
              t["afii57444"] = 1604;
              t["afii57445"] = 1605;
              t["afii57446"] = 1606;
              t["afii57448"] = 1608;
              t["afii57449"] = 1609;
              t["afii57450"] = 1610;
              t["afii57451"] = 1611;
              t["afii57452"] = 1612;
              t["afii57453"] = 1613;
              t["afii57454"] = 1614;
              t["afii57455"] = 1615;
              t["afii57456"] = 1616;
              t["afii57457"] = 1617;
              t["afii57458"] = 1618;
              t["afii57470"] = 1607;
              t["afii57505"] = 1700;
              t["afii57506"] = 1662;
              t["afii57507"] = 1670;
              t["afii57508"] = 1688;
              t["afii57509"] = 1711;
              t["afii57511"] = 1657;
              t["afii57512"] = 1672;
              t["afii57513"] = 1681;
              t["afii57514"] = 1722;
              t["afii57519"] = 1746;
              t["afii57534"] = 1749;
              t["afii57636"] = 8362;
              t["afii57645"] = 1470;
              t["afii57658"] = 1475;
              t["afii57664"] = 1488;
              t["afii57665"] = 1489;
              t["afii57666"] = 1490;
              t["afii57667"] = 1491;
              t["afii57668"] = 1492;
              t["afii57669"] = 1493;
              t["afii57670"] = 1494;
              t["afii57671"] = 1495;
              t["afii57672"] = 1496;
              t["afii57673"] = 1497;
              t["afii57674"] = 1498;
              t["afii57675"] = 1499;
              t["afii57676"] = 1500;
              t["afii57677"] = 1501;
              t["afii57678"] = 1502;
              t["afii57679"] = 1503;
              t["afii57680"] = 1504;
              t["afii57681"] = 1505;
              t["afii57682"] = 1506;
              t["afii57683"] = 1507;
              t["afii57684"] = 1508;
              t["afii57685"] = 1509;
              t["afii57686"] = 1510;
              t["afii57687"] = 1511;
              t["afii57688"] = 1512;
              t["afii57689"] = 1513;
              t["afii57690"] = 1514;
              t["afii57694"] = 64298;
              t["afii57695"] = 64299;
              t["afii57700"] = 64331;
              t["afii57705"] = 64287;
              t["afii57716"] = 1520;
              t["afii57717"] = 1521;
              t["afii57718"] = 1522;
              t["afii57723"] = 64309;
              t["afii57793"] = 1460;
              t["afii57794"] = 1461;
              t["afii57795"] = 1462;
              t["afii57796"] = 1467;
              t["afii57797"] = 1464;
              t["afii57798"] = 1463;
              t["afii57799"] = 1456;
              t["afii57800"] = 1458;
              t["afii57801"] = 1457;
              t["afii57802"] = 1459;
              t["afii57803"] = 1474;
              t["afii57804"] = 1473;
              t["afii57806"] = 1465;
              t["afii57807"] = 1468;
              t["afii57839"] = 1469;
              t["afii57841"] = 1471;
              t["afii57842"] = 1472;
              t["afii57929"] = 700;
              t["afii61248"] = 8453;
              t["afii61289"] = 8467;
              t["afii61352"] = 8470;
              t["afii61573"] = 8236;
              t["afii61574"] = 8237;
              t["afii61575"] = 8238;
              t["afii61664"] = 8204;
              t["afii63167"] = 1645;
              t["afii64937"] = 701;
              t["agrave"] = 224;
              t["agujarati"] = 2693;
              t["agurmukhi"] = 2565;
              t["ahiragana"] = 12354;
              t["ahookabove"] = 7843;
              t["aibengali"] = 2448;
              t["aibopomofo"] = 12574;
              t["aideva"] = 2320;
              t["aiecyrillic"] = 1237;
              t["aigujarati"] = 2704;
              t["aigurmukhi"] = 2576;
              t["aimatragurmukhi"] = 2632;
              t["ainarabic"] = 1593;
              t["ainfinalarabic"] = 65226;
              t["aininitialarabic"] = 65227;
              t["ainmedialarabic"] = 65228;
              t["ainvertedbreve"] = 515;
              t["aivowelsignbengali"] = 2504;
              t["aivowelsigndeva"] = 2376;
              t["aivowelsigngujarati"] = 2760;
              t["akatakana"] = 12450;
              t["akatakanahalfwidth"] = 65393;
              t["akorean"] = 12623;
              t["alef"] = 1488;
              t["alefarabic"] = 1575;
              t["alefdageshhebrew"] = 64304;
              t["aleffinalarabic"] = 65166;
              t["alefhamzaabovearabic"] = 1571;
              t["alefhamzaabovefinalarabic"] = 65156;
              t["alefhamzabelowarabic"] = 1573;
              t["alefhamzabelowfinalarabic"] = 65160;
              t["alefhebrew"] = 1488;
              t["aleflamedhebrew"] = 64335;
              t["alefmaddaabovearabic"] = 1570;
              t["alefmaddaabovefinalarabic"] = 65154;
              t["alefmaksuraarabic"] = 1609;
              t["alefmaksurafinalarabic"] = 65264;
              t["alefmaksurainitialarabic"] = 65267;
              t["alefmaksuramedialarabic"] = 65268;
              t["alefpatahhebrew"] = 64302;
              t["alefqamatshebrew"] = 64303;
              t["aleph"] = 8501;
              t["allequal"] = 8780;
              t["alpha"] = 945;
              t["alphatonos"] = 940;
              t["amacron"] = 257;
              t["amonospace"] = 65345;
              t["ampersand"] = 38;
              t["ampersandmonospace"] = 65286;
              t["ampersandsmall"] = 63270;
              t["amsquare"] = 13250;
              t["anbopomofo"] = 12578;
              t["angbopomofo"] = 12580;
              t["angbracketleft"] = 12296;
              t["angbracketright"] = 12297;
              t["angkhankhuthai"] = 3674;
              t["angle"] = 8736;
              t["anglebracketleft"] = 12296;
              t["anglebracketleftvertical"] = 65087;
              t["anglebracketright"] = 12297;
              t["anglebracketrightvertical"] = 65088;
              t["angleleft"] = 9001;
              t["angleright"] = 9002;
              t["angstrom"] = 8491;
              t["anoteleia"] = 903;
              t["anudattadeva"] = 2386;
              t["anusvarabengali"] = 2434;
              t["anusvaradeva"] = 2306;
              t["anusvaragujarati"] = 2690;
              t["aogonek"] = 261;
              t["apaatosquare"] = 13056;
              t["aparen"] = 9372;
              t["apostrophearmenian"] = 1370;
              t["apostrophemod"] = 700;
              t["apple"] = 63743;
              t["approaches"] = 8784;
              t["approxequal"] = 8776;
              t["approxequalorimage"] = 8786;
              t["approximatelyequal"] = 8773;
              t["araeaekorean"] = 12686;
              t["araeakorean"] = 12685;
              t["arc"] = 8978;
              t["arighthalfring"] = 7834;
              t["aring"] = 229;
              t["aringacute"] = 507;
              t["aringbelow"] = 7681;
              t["arrowboth"] = 8596;
              t["arrowdashdown"] = 8675;
              t["arrowdashleft"] = 8672;
              t["arrowdashright"] = 8674;
              t["arrowdashup"] = 8673;
              t["arrowdblboth"] = 8660;
              t["arrowdbldown"] = 8659;
              t["arrowdblleft"] = 8656;
              t["arrowdblright"] = 8658;
              t["arrowdblup"] = 8657;
              t["arrowdown"] = 8595;
              t["arrowdownleft"] = 8601;
              t["arrowdownright"] = 8600;
              t["arrowdownwhite"] = 8681;
              t["arrowheaddownmod"] = 709;
              t["arrowheadleftmod"] = 706;
              t["arrowheadrightmod"] = 707;
              t["arrowheadupmod"] = 708;
              t["arrowhorizex"] = 63719;
              t["arrowleft"] = 8592;
              t["arrowleftdbl"] = 8656;
              t["arrowleftdblstroke"] = 8653;
              t["arrowleftoverright"] = 8646;
              t["arrowleftwhite"] = 8678;
              t["arrowright"] = 8594;
              t["arrowrightdblstroke"] = 8655;
              t["arrowrightheavy"] = 10142;
              t["arrowrightoverleft"] = 8644;
              t["arrowrightwhite"] = 8680;
              t["arrowtableft"] = 8676;
              t["arrowtabright"] = 8677;
              t["arrowup"] = 8593;
              t["arrowupdn"] = 8597;
              t["arrowupdnbse"] = 8616;
              t["arrowupdownbase"] = 8616;
              t["arrowupleft"] = 8598;
              t["arrowupleftofdown"] = 8645;
              t["arrowupright"] = 8599;
              t["arrowupwhite"] = 8679;
              t["arrowvertex"] = 63718;
              t["asciicircum"] = 94;
              t["asciicircummonospace"] = 65342;
              t["asciitilde"] = 126;
              t["asciitildemonospace"] = 65374;
              t["ascript"] = 593;
              t["ascriptturned"] = 594;
              t["asmallhiragana"] = 12353;
              t["asmallkatakana"] = 12449;
              t["asmallkatakanahalfwidth"] = 65383;
              t["asterisk"] = 42;
              t["asteriskaltonearabic"] = 1645;
              t["asteriskarabic"] = 1645;
              t["asteriskmath"] = 8727;
              t["asteriskmonospace"] = 65290;
              t["asterisksmall"] = 65121;
              t["asterism"] = 8258;
              t["asuperior"] = 63209;
              t["asymptoticallyequal"] = 8771;
              t["at"] = 64;
              t["atilde"] = 227;
              t["atmonospace"] = 65312;
              t["atsmall"] = 65131;
              t["aturned"] = 592;
              t["aubengali"] = 2452;
              t["aubopomofo"] = 12576;
              t["audeva"] = 2324;
              t["augujarati"] = 2708;
              t["augurmukhi"] = 2580;
              t["aulengthmarkbengali"] = 2519;
              t["aumatragurmukhi"] = 2636;
              t["auvowelsignbengali"] = 2508;
              t["auvowelsigndeva"] = 2380;
              t["auvowelsigngujarati"] = 2764;
              t["avagrahadeva"] = 2365;
              t["aybarmenian"] = 1377;
              t["ayin"] = 1506;
              t["ayinaltonehebrew"] = 64288;
              t["ayinhebrew"] = 1506;
              t["b"] = 98;
              t["babengali"] = 2476;
              t["backslash"] = 92;
              t["backslashmonospace"] = 65340;
              t["badeva"] = 2348;
              t["bagujarati"] = 2732;
              t["bagurmukhi"] = 2604;
              t["bahiragana"] = 12400;
              t["bahtthai"] = 3647;
              t["bakatakana"] = 12496;
              t["bar"] = 124;
              t["barmonospace"] = 65372;
              t["bbopomofo"] = 12549;
              t["bcircle"] = 9425;
              t["bdotaccent"] = 7683;
              t["bdotbelow"] = 7685;
              t["beamedsixteenthnotes"] = 9836;
              t["because"] = 8757;
              t["becyrillic"] = 1073;
              t["beharabic"] = 1576;
              t["behfinalarabic"] = 65168;
              t["behinitialarabic"] = 65169;
              t["behiragana"] = 12409;
              t["behmedialarabic"] = 65170;
              t["behmeeminitialarabic"] = 64671;
              t["behmeemisolatedarabic"] = 64520;
              t["behnoonfinalarabic"] = 64621;
              t["bekatakana"] = 12505;
              t["benarmenian"] = 1378;
              t["bet"] = 1489;
              t["beta"] = 946;
              t["betasymbolgreek"] = 976;
              t["betdagesh"] = 64305;
              t["betdageshhebrew"] = 64305;
              t["bethebrew"] = 1489;
              t["betrafehebrew"] = 64332;
              t["bhabengali"] = 2477;
              t["bhadeva"] = 2349;
              t["bhagujarati"] = 2733;
              t["bhagurmukhi"] = 2605;
              t["bhook"] = 595;
              t["bihiragana"] = 12403;
              t["bikatakana"] = 12499;
              t["bilabialclick"] = 664;
              t["bindigurmukhi"] = 2562;
              t["birusquare"] = 13105;
              t["blackcircle"] = 9679;
              t["blackdiamond"] = 9670;
              t["blackdownpointingtriangle"] = 9660;
              t["blackleftpointingpointer"] = 9668;
              t["blackleftpointingtriangle"] = 9664;
              t["blacklenticularbracketleft"] = 12304;
              t["blacklenticularbracketleftvertical"] = 65083;
              t["blacklenticularbracketright"] = 12305;
              t["blacklenticularbracketrightvertical"] = 65084;
              t["blacklowerlefttriangle"] = 9699;
              t["blacklowerrighttriangle"] = 9698;
              t["blackrectangle"] = 9644;
              t["blackrightpointingpointer"] = 9658;
              t["blackrightpointingtriangle"] = 9654;
              t["blacksmallsquare"] = 9642;
              t["blacksmilingface"] = 9787;
              t["blacksquare"] = 9632;
              t["blackstar"] = 9733;
              t["blackupperlefttriangle"] = 9700;
              t["blackupperrighttriangle"] = 9701;
              t["blackuppointingsmalltriangle"] = 9652;
              t["blackuppointingtriangle"] = 9650;
              t["blank"] = 9251;
              t["blinebelow"] = 7687;
              t["block"] = 9608;
              t["bmonospace"] = 65346;
              t["bobaimaithai"] = 3610;
              t["bohiragana"] = 12412;
              t["bokatakana"] = 12508;
              t["bparen"] = 9373;
              t["bqsquare"] = 13251;
              t["braceex"] = 63732;
              t["braceleft"] = 123;
              t["braceleftbt"] = 63731;
              t["braceleftmid"] = 63730;
              t["braceleftmonospace"] = 65371;
              t["braceleftsmall"] = 65115;
              t["bracelefttp"] = 63729;
              t["braceleftvertical"] = 65079;
              t["braceright"] = 125;
              t["bracerightbt"] = 63742;
              t["bracerightmid"] = 63741;
              t["bracerightmonospace"] = 65373;
              t["bracerightsmall"] = 65116;
              t["bracerighttp"] = 63740;
              t["bracerightvertical"] = 65080;
              t["bracketleft"] = 91;
              t["bracketleftbt"] = 63728;
              t["bracketleftex"] = 63727;
              t["bracketleftmonospace"] = 65339;
              t["bracketlefttp"] = 63726;
              t["bracketright"] = 93;
              t["bracketrightbt"] = 63739;
              t["bracketrightex"] = 63738;
              t["bracketrightmonospace"] = 65341;
              t["bracketrighttp"] = 63737;
              t["breve"] = 728;
              t["brevebelowcmb"] = 814;
              t["brevecmb"] = 774;
              t["breveinvertedbelowcmb"] = 815;
              t["breveinvertedcmb"] = 785;
              t["breveinverteddoublecmb"] = 865;
              t["bridgebelowcmb"] = 810;
              t["bridgeinvertedbelowcmb"] = 826;
              t["brokenbar"] = 166;
              t["bstroke"] = 384;
              t["bsuperior"] = 63210;
              t["btopbar"] = 387;
              t["buhiragana"] = 12406;
              t["bukatakana"] = 12502;
              t["bullet"] = 8226;
              t["bulletinverse"] = 9688;
              t["bulletoperator"] = 8729;
              t["bullseye"] = 9678;
              t["c"] = 99;
              t["caarmenian"] = 1390;
              t["cabengali"] = 2458;
              t["cacute"] = 263;
              t["cadeva"] = 2330;
              t["cagujarati"] = 2714;
              t["cagurmukhi"] = 2586;
              t["calsquare"] = 13192;
              t["candrabindubengali"] = 2433;
              t["candrabinducmb"] = 784;
              t["candrabindudeva"] = 2305;
              t["candrabindugujarati"] = 2689;
              t["capslock"] = 8682;
              t["careof"] = 8453;
              t["caron"] = 711;
              t["caronbelowcmb"] = 812;
              t["caroncmb"] = 780;
              t["carriagereturn"] = 8629;
              t["cbopomofo"] = 12568;
              t["ccaron"] = 269;
              t["ccedilla"] = 231;
              t["ccedillaacute"] = 7689;
              t["ccircle"] = 9426;
              t["ccircumflex"] = 265;
              t["ccurl"] = 597;
              t["cdot"] = 267;
              t["cdotaccent"] = 267;
              t["cdsquare"] = 13253;
              t["cedilla"] = 184;
              t["cedillacmb"] = 807;
              t["cent"] = 162;
              t["centigrade"] = 8451;
              t["centinferior"] = 63199;
              t["centmonospace"] = 65504;
              t["centoldstyle"] = 63394;
              t["centsuperior"] = 63200;
              t["chaarmenian"] = 1401;
              t["chabengali"] = 2459;
              t["chadeva"] = 2331;
              t["chagujarati"] = 2715;
              t["chagurmukhi"] = 2587;
              t["chbopomofo"] = 12564;
              t["cheabkhasiancyrillic"] = 1213;
              t["checkmark"] = 10003;
              t["checyrillic"] = 1095;
              t["chedescenderabkhasiancyrillic"] = 1215;
              t["chedescendercyrillic"] = 1207;
              t["chedieresiscyrillic"] = 1269;
              t["cheharmenian"] = 1395;
              t["chekhakassiancyrillic"] = 1228;
              t["cheverticalstrokecyrillic"] = 1209;
              t["chi"] = 967;
              t["chieuchacirclekorean"] = 12919;
              t["chieuchaparenkorean"] = 12823;
              t["chieuchcirclekorean"] = 12905;
              t["chieuchkorean"] = 12618;
              t["chieuchparenkorean"] = 12809;
              t["chochangthai"] = 3594;
              t["chochanthai"] = 3592;
              t["chochingthai"] = 3593;
              t["chochoethai"] = 3596;
              t["chook"] = 392;
              t["cieucacirclekorean"] = 12918;
              t["cieucaparenkorean"] = 12822;
              t["cieuccirclekorean"] = 12904;
              t["cieuckorean"] = 12616;
              t["cieucparenkorean"] = 12808;
              t["cieucuparenkorean"] = 12828;
              t["circle"] = 9675;
              t["circlecopyrt"] = 169;
              t["circlemultiply"] = 8855;
              t["circleot"] = 8857;
              t["circleplus"] = 8853;
              t["circlepostalmark"] = 12342;
              t["circlewithlefthalfblack"] = 9680;
              t["circlewithrighthalfblack"] = 9681;
              t["circumflex"] = 710;
              t["circumflexbelowcmb"] = 813;
              t["circumflexcmb"] = 770;
              t["clear"] = 8999;
              t["clickalveolar"] = 450;
              t["clickdental"] = 448;
              t["clicklateral"] = 449;
              t["clickretroflex"] = 451;
              t["club"] = 9827;
              t["clubsuitblack"] = 9827;
              t["clubsuitwhite"] = 9831;
              t["cmcubedsquare"] = 13220;
              t["cmonospace"] = 65347;
              t["cmsquaredsquare"] = 13216;
              t["coarmenian"] = 1409;
              t["colon"] = 58;
              t["colonmonetary"] = 8353;
              t["colonmonospace"] = 65306;
              t["colonsign"] = 8353;
              t["colonsmall"] = 65109;
              t["colontriangularhalfmod"] = 721;
              t["colontriangularmod"] = 720;
              t["comma"] = 44;
              t["commaabovecmb"] = 787;
              t["commaaboverightcmb"] = 789;
              t["commaaccent"] = 63171;
              t["commaarabic"] = 1548;
              t["commaarmenian"] = 1373;
              t["commainferior"] = 63201;
              t["commamonospace"] = 65292;
              t["commareversedabovecmb"] = 788;
              t["commareversedmod"] = 701;
              t["commasmall"] = 65104;
              t["commasuperior"] = 63202;
              t["commaturnedabovecmb"] = 786;
              t["commaturnedmod"] = 699;
              t["compass"] = 9788;
              t["congruent"] = 8773;
              t["contourintegral"] = 8750;
              t["control"] = 8963;
              t["controlACK"] = 6;
              t["controlBEL"] = 7;
              t["controlBS"] = 8;
              t["controlCAN"] = 24;
              t["controlCR"] = 13;
              t["controlDC1"] = 17;
              t["controlDC2"] = 18;
              t["controlDC3"] = 19;
              t["controlDC4"] = 20;
              t["controlDEL"] = 127;
              t["controlDLE"] = 16;
              t["controlEM"] = 25;
              t["controlENQ"] = 5;
              t["controlEOT"] = 4;
              t["controlESC"] = 27;
              t["controlETB"] = 23;
              t["controlETX"] = 3;
              t["controlFF"] = 12;
              t["controlFS"] = 28;
              t["controlGS"] = 29;
              t["controlHT"] = 9;
              t["controlLF"] = 10;
              t["controlNAK"] = 21;
              t["controlNULL"] = 0;
              t["controlRS"] = 30;
              t["controlSI"] = 15;
              t["controlSO"] = 14;
              t["controlSOT"] = 2;
              t["controlSTX"] = 1;
              t["controlSUB"] = 26;
              t["controlSYN"] = 22;
              t["controlUS"] = 31;
              t["controlVT"] = 11;
              t["copyright"] = 169;
              t["copyrightsans"] = 63721;
              t["copyrightserif"] = 63193;
              t["cornerbracketleft"] = 12300;
              t["cornerbracketlefthalfwidth"] = 65378;
              t["cornerbracketleftvertical"] = 65089;
              t["cornerbracketright"] = 12301;
              t["cornerbracketrighthalfwidth"] = 65379;
              t["cornerbracketrightvertical"] = 65090;
              t["corporationsquare"] = 13183;
              t["cosquare"] = 13255;
              t["coverkgsquare"] = 13254;
              t["cparen"] = 9374;
              t["cruzeiro"] = 8354;
              t["cstretched"] = 663;
              t["curlyand"] = 8911;
              t["curlyor"] = 8910;
              t["currency"] = 164;
              t["cyrBreve"] = 63185;
              t["cyrFlex"] = 63186;
              t["cyrbreve"] = 63188;
              t["cyrflex"] = 63189;
              t["d"] = 100;
              t["daarmenian"] = 1380;
              t["dabengali"] = 2470;
              t["dadarabic"] = 1590;
              t["dadeva"] = 2342;
              t["dadfinalarabic"] = 65214;
              t["dadinitialarabic"] = 65215;
              t["dadmedialarabic"] = 65216;
              t["dagesh"] = 1468;
              t["dageshhebrew"] = 1468;
              t["dagger"] = 8224;
              t["daggerdbl"] = 8225;
              t["dagujarati"] = 2726;
              t["dagurmukhi"] = 2598;
              t["dahiragana"] = 12384;
              t["dakatakana"] = 12480;
              t["dalarabic"] = 1583;
              t["dalet"] = 1491;
              t["daletdagesh"] = 64307;
              t["daletdageshhebrew"] = 64307;
              t["dalethebrew"] = 1491;
              t["dalfinalarabic"] = 65194;
              t["dammaarabic"] = 1615;
              t["dammalowarabic"] = 1615;
              t["dammatanaltonearabic"] = 1612;
              t["dammatanarabic"] = 1612;
              t["danda"] = 2404;
              t["dargahebrew"] = 1447;
              t["dargalefthebrew"] = 1447;
              t["dasiapneumatacyrilliccmb"] = 1157;
              t["dblGrave"] = 63187;
              t["dblanglebracketleft"] = 12298;
              t["dblanglebracketleftvertical"] = 65085;
              t["dblanglebracketright"] = 12299;
              t["dblanglebracketrightvertical"] = 65086;
              t["dblarchinvertedbelowcmb"] = 811;
              t["dblarrowleft"] = 8660;
              t["dblarrowright"] = 8658;
              t["dbldanda"] = 2405;
              t["dblgrave"] = 63190;
              t["dblgravecmb"] = 783;
              t["dblintegral"] = 8748;
              t["dbllowline"] = 8215;
              t["dbllowlinecmb"] = 819;
              t["dbloverlinecmb"] = 831;
              t["dblprimemod"] = 698;
              t["dblverticalbar"] = 8214;
              t["dblverticallineabovecmb"] = 782;
              t["dbopomofo"] = 12553;
              t["dbsquare"] = 13256;
              t["dcaron"] = 271;
              t["dcedilla"] = 7697;
              t["dcircle"] = 9427;
              t["dcircumflexbelow"] = 7699;
              t["dcroat"] = 273;
              t["ddabengali"] = 2465;
              t["ddadeva"] = 2337;
              t["ddagujarati"] = 2721;
              t["ddagurmukhi"] = 2593;
              t["ddalarabic"] = 1672;
              t["ddalfinalarabic"] = 64393;
              t["dddhadeva"] = 2396;
              t["ddhabengali"] = 2466;
              t["ddhadeva"] = 2338;
              t["ddhagujarati"] = 2722;
              t["ddhagurmukhi"] = 2594;
              t["ddotaccent"] = 7691;
              t["ddotbelow"] = 7693;
              t["decimalseparatorarabic"] = 1643;
              t["decimalseparatorpersian"] = 1643;
              t["decyrillic"] = 1076;
              t["degree"] = 176;
              t["dehihebrew"] = 1453;
              t["dehiragana"] = 12391;
              t["deicoptic"] = 1007;
              t["dekatakana"] = 12487;
              t["deleteleft"] = 9003;
              t["deleteright"] = 8998;
              t["delta"] = 948;
              t["deltaturned"] = 397;
              t["denominatorminusonenumeratorbengali"] = 2552;
              t["dezh"] = 676;
              t["dhabengali"] = 2471;
              t["dhadeva"] = 2343;
              t["dhagujarati"] = 2727;
              t["dhagurmukhi"] = 2599;
              t["dhook"] = 599;
              t["dialytikatonos"] = 901;
              t["dialytikatonoscmb"] = 836;
              t["diamond"] = 9830;
              t["diamondsuitwhite"] = 9826;
              t["dieresis"] = 168;
              t["dieresisacute"] = 63191;
              t["dieresisbelowcmb"] = 804;
              t["dieresiscmb"] = 776;
              t["dieresisgrave"] = 63192;
              t["dieresistonos"] = 901;
              t["dihiragana"] = 12386;
              t["dikatakana"] = 12482;
              t["dittomark"] = 12291;
              t["divide"] = 247;
              t["divides"] = 8739;
              t["divisionslash"] = 8725;
              t["djecyrillic"] = 1106;
              t["dkshade"] = 9619;
              t["dlinebelow"] = 7695;
              t["dlsquare"] = 13207;
              t["dmacron"] = 273;
              t["dmonospace"] = 65348;
              t["dnblock"] = 9604;
              t["dochadathai"] = 3598;
              t["dodekthai"] = 3604;
              t["dohiragana"] = 12393;
              t["dokatakana"] = 12489;
              t["dollar"] = 36;
              t["dollarinferior"] = 63203;
              t["dollarmonospace"] = 65284;
              t["dollaroldstyle"] = 63268;
              t["dollarsmall"] = 65129;
              t["dollarsuperior"] = 63204;
              t["dong"] = 8363;
              t["dorusquare"] = 13094;
              t["dotaccent"] = 729;
              t["dotaccentcmb"] = 775;
              t["dotbelowcmb"] = 803;
              t["dotbelowcomb"] = 803;
              t["dotkatakana"] = 12539;
              t["dotlessi"] = 305;
              t["dotlessj"] = 63166;
              t["dotlessjstrokehook"] = 644;
              t["dotmath"] = 8901;
              t["dottedcircle"] = 9676;
              t["doubleyodpatah"] = 64287;
              t["doubleyodpatahhebrew"] = 64287;
              t["downtackbelowcmb"] = 798;
              t["downtackmod"] = 725;
              t["dparen"] = 9375;
              t["dsuperior"] = 63211;
              t["dtail"] = 598;
              t["dtopbar"] = 396;
              t["duhiragana"] = 12389;
              t["dukatakana"] = 12485;
              t["dz"] = 499;
              t["dzaltone"] = 675;
              t["dzcaron"] = 454;
              t["dzcurl"] = 677;
              t["dzeabkhasiancyrillic"] = 1249;
              t["dzecyrillic"] = 1109;
              t["dzhecyrillic"] = 1119;
              t["e"] = 101;
              t["eacute"] = 233;
              t["earth"] = 9793;
              t["ebengali"] = 2447;
              t["ebopomofo"] = 12572;
              t["ebreve"] = 277;
              t["ecandradeva"] = 2317;
              t["ecandragujarati"] = 2701;
              t["ecandravowelsigndeva"] = 2373;
              t["ecandravowelsigngujarati"] = 2757;
              t["ecaron"] = 283;
              t["ecedillabreve"] = 7709;
              t["echarmenian"] = 1381;
              t["echyiwnarmenian"] = 1415;
              t["ecircle"] = 9428;
              t["ecircumflex"] = 234;
              t["ecircumflexacute"] = 7871;
              t["ecircumflexbelow"] = 7705;
              t["ecircumflexdotbelow"] = 7879;
              t["ecircumflexgrave"] = 7873;
              t["ecircumflexhookabove"] = 7875;
              t["ecircumflextilde"] = 7877;
              t["ecyrillic"] = 1108;
              t["edblgrave"] = 517;
              t["edeva"] = 2319;
              t["edieresis"] = 235;
              t["edot"] = 279;
              t["edotaccent"] = 279;
              t["edotbelow"] = 7865;
              t["eegurmukhi"] = 2575;
              t["eematragurmukhi"] = 2631;
              t["efcyrillic"] = 1092;
              t["egrave"] = 232;
              t["egujarati"] = 2703;
              t["eharmenian"] = 1383;
              t["ehbopomofo"] = 12573;
              t["ehiragana"] = 12360;
              t["ehookabove"] = 7867;
              t["eibopomofo"] = 12575;
              t["eight"] = 56;
              t["eightarabic"] = 1640;
              t["eightbengali"] = 2542;
              t["eightcircle"] = 9319;
              t["eightcircleinversesansserif"] = 10129;
              t["eightdeva"] = 2414;
              t["eighteencircle"] = 9329;
              t["eighteenparen"] = 9349;
              t["eighteenperiod"] = 9369;
              t["eightgujarati"] = 2798;
              t["eightgurmukhi"] = 2670;
              t["eighthackarabic"] = 1640;
              t["eighthangzhou"] = 12328;
              t["eighthnotebeamed"] = 9835;
              t["eightideographicparen"] = 12839;
              t["eightinferior"] = 8328;
              t["eightmonospace"] = 65304;
              t["eightoldstyle"] = 63288;
              t["eightparen"] = 9339;
              t["eightperiod"] = 9359;
              t["eightpersian"] = 1784;
              t["eightroman"] = 8567;
              t["eightsuperior"] = 8312;
              t["eightthai"] = 3672;
              t["einvertedbreve"] = 519;
              t["eiotifiedcyrillic"] = 1125;
              t["ekatakana"] = 12456;
              t["ekatakanahalfwidth"] = 65396;
              t["ekonkargurmukhi"] = 2676;
              t["ekorean"] = 12628;
              t["elcyrillic"] = 1083;
              t["element"] = 8712;
              t["elevencircle"] = 9322;
              t["elevenparen"] = 9342;
              t["elevenperiod"] = 9362;
              t["elevenroman"] = 8570;
              t["ellipsis"] = 8230;
              t["ellipsisvertical"] = 8942;
              t["emacron"] = 275;
              t["emacronacute"] = 7703;
              t["emacrongrave"] = 7701;
              t["emcyrillic"] = 1084;
              t["emdash"] = 8212;
              t["emdashvertical"] = 65073;
              t["emonospace"] = 65349;
              t["emphasismarkarmenian"] = 1371;
              t["emptyset"] = 8709;
              t["enbopomofo"] = 12579;
              t["encyrillic"] = 1085;
              t["endash"] = 8211;
              t["endashvertical"] = 65074;
              t["endescendercyrillic"] = 1187;
              t["eng"] = 331;
              t["engbopomofo"] = 12581;
              t["enghecyrillic"] = 1189;
              t["enhookcyrillic"] = 1224;
              t["enspace"] = 8194;
              t["eogonek"] = 281;
              t["eokorean"] = 12627;
              t["eopen"] = 603;
              t["eopenclosed"] = 666;
              t["eopenreversed"] = 604;
              t["eopenreversedclosed"] = 606;
              t["eopenreversedhook"] = 605;
              t["eparen"] = 9376;
              t["epsilon"] = 949;
              t["epsilontonos"] = 941;
              t["equal"] = 61;
              t["equalmonospace"] = 65309;
              t["equalsmall"] = 65126;
              t["equalsuperior"] = 8316;
              t["equivalence"] = 8801;
              t["erbopomofo"] = 12582;
              t["ercyrillic"] = 1088;
              t["ereversed"] = 600;
              t["ereversedcyrillic"] = 1101;
              t["escyrillic"] = 1089;
              t["esdescendercyrillic"] = 1195;
              t["esh"] = 643;
              t["eshcurl"] = 646;
              t["eshortdeva"] = 2318;
              t["eshortvowelsigndeva"] = 2374;
              t["eshreversedloop"] = 426;
              t["eshsquatreversed"] = 645;
              t["esmallhiragana"] = 12359;
              t["esmallkatakana"] = 12455;
              t["esmallkatakanahalfwidth"] = 65386;
              t["estimated"] = 8494;
              t["esuperior"] = 63212;
              t["eta"] = 951;
              t["etarmenian"] = 1384;
              t["etatonos"] = 942;
              t["eth"] = 240;
              t["etilde"] = 7869;
              t["etildebelow"] = 7707;
              t["etnahtafoukhhebrew"] = 1425;
              t["etnahtafoukhlefthebrew"] = 1425;
              t["etnahtahebrew"] = 1425;
              t["etnahtalefthebrew"] = 1425;
              t["eturned"] = 477;
              t["eukorean"] = 12641;
              t["euro"] = 8364;
              t["evowelsignbengali"] = 2503;
              t["evowelsigndeva"] = 2375;
              t["evowelsigngujarati"] = 2759;
              t["exclam"] = 33;
              t["exclamarmenian"] = 1372;
              t["exclamdbl"] = 8252;
              t["exclamdown"] = 161;
              t["exclamdownsmall"] = 63393;
              t["exclammonospace"] = 65281;
              t["exclamsmall"] = 63265;
              t["existential"] = 8707;
              t["ezh"] = 658;
              t["ezhcaron"] = 495;
              t["ezhcurl"] = 659;
              t["ezhreversed"] = 441;
              t["ezhtail"] = 442;
              t["f"] = 102;
              t["fadeva"] = 2398;
              t["fagurmukhi"] = 2654;
              t["fahrenheit"] = 8457;
              t["fathaarabic"] = 1614;
              t["fathalowarabic"] = 1614;
              t["fathatanarabic"] = 1611;
              t["fbopomofo"] = 12552;
              t["fcircle"] = 9429;
              t["fdotaccent"] = 7711;
              t["feharabic"] = 1601;
              t["feharmenian"] = 1414;
              t["fehfinalarabic"] = 65234;
              t["fehinitialarabic"] = 65235;
              t["fehmedialarabic"] = 65236;
              t["feicoptic"] = 997;
              t["female"] = 9792;
              t["ff"] = 64256;
              t["ffi"] = 64259;
              t["ffl"] = 64260;
              t["fi"] = 64257;
              t["fifteencircle"] = 9326;
              t["fifteenparen"] = 9346;
              t["fifteenperiod"] = 9366;
              t["figuredash"] = 8210;
              t["filledbox"] = 9632;
              t["filledrect"] = 9644;
              t["finalkaf"] = 1498;
              t["finalkafdagesh"] = 64314;
              t["finalkafdageshhebrew"] = 64314;
              t["finalkafhebrew"] = 1498;
              t["finalmem"] = 1501;
              t["finalmemhebrew"] = 1501;
              t["finalnun"] = 1503;
              t["finalnunhebrew"] = 1503;
              t["finalpe"] = 1507;
              t["finalpehebrew"] = 1507;
              t["finaltsadi"] = 1509;
              t["finaltsadihebrew"] = 1509;
              t["firsttonechinese"] = 713;
              t["fisheye"] = 9673;
              t["fitacyrillic"] = 1139;
              t["five"] = 53;
              t["fivearabic"] = 1637;
              t["fivebengali"] = 2539;
              t["fivecircle"] = 9316;
              t["fivecircleinversesansserif"] = 10126;
              t["fivedeva"] = 2411;
              t["fiveeighths"] = 8541;
              t["fivegujarati"] = 2795;
              t["fivegurmukhi"] = 2667;
              t["fivehackarabic"] = 1637;
              t["fivehangzhou"] = 12325;
              t["fiveideographicparen"] = 12836;
              t["fiveinferior"] = 8325;
              t["fivemonospace"] = 65301;
              t["fiveoldstyle"] = 63285;
              t["fiveparen"] = 9336;
              t["fiveperiod"] = 9356;
              t["fivepersian"] = 1781;
              t["fiveroman"] = 8564;
              t["fivesuperior"] = 8309;
              t["fivethai"] = 3669;
              t["fl"] = 64258;
              t["florin"] = 402;
              t["fmonospace"] = 65350;
              t["fmsquare"] = 13209;
              t["fofanthai"] = 3615;
              t["fofathai"] = 3613;
              t["fongmanthai"] = 3663;
              t["forall"] = 8704;
              t["four"] = 52;
              t["fourarabic"] = 1636;
              t["fourbengali"] = 2538;
              t["fourcircle"] = 9315;
              t["fourcircleinversesansserif"] = 10125;
              t["fourdeva"] = 2410;
              t["fourgujarati"] = 2794;
              t["fourgurmukhi"] = 2666;
              t["fourhackarabic"] = 1636;
              t["fourhangzhou"] = 12324;
              t["fourideographicparen"] = 12835;
              t["fourinferior"] = 8324;
              t["fourmonospace"] = 65300;
              t["fournumeratorbengali"] = 2551;
              t["fouroldstyle"] = 63284;
              t["fourparen"] = 9335;
              t["fourperiod"] = 9355;
              t["fourpersian"] = 1780;
              t["fourroman"] = 8563;
              t["foursuperior"] = 8308;
              t["fourteencircle"] = 9325;
              t["fourteenparen"] = 9345;
              t["fourteenperiod"] = 9365;
              t["fourthai"] = 3668;
              t["fourthtonechinese"] = 715;
              t["fparen"] = 9377;
              t["fraction"] = 8260;
              t["franc"] = 8355;
              t["g"] = 103;
              t["gabengali"] = 2455;
              t["gacute"] = 501;
              t["gadeva"] = 2327;
              t["gafarabic"] = 1711;
              t["gaffinalarabic"] = 64403;
              t["gafinitialarabic"] = 64404;
              t["gafmedialarabic"] = 64405;
              t["gagujarati"] = 2711;
              t["gagurmukhi"] = 2583;
              t["gahiragana"] = 12364;
              t["gakatakana"] = 12460;
              t["gamma"] = 947;
              t["gammalatinsmall"] = 611;
              t["gammasuperior"] = 736;
              t["gangiacoptic"] = 1003;
              t["gbopomofo"] = 12557;
              t["gbreve"] = 287;
              t["gcaron"] = 487;
              t["gcedilla"] = 291;
              t["gcircle"] = 9430;
              t["gcircumflex"] = 285;
              t["gcommaaccent"] = 291;
              t["gdot"] = 289;
              t["gdotaccent"] = 289;
              t["gecyrillic"] = 1075;
              t["gehiragana"] = 12370;
              t["gekatakana"] = 12466;
              t["geometricallyequal"] = 8785;
              t["gereshaccenthebrew"] = 1436;
              t["gereshhebrew"] = 1523;
              t["gereshmuqdamhebrew"] = 1437;
              t["germandbls"] = 223;
              t["gershayimaccenthebrew"] = 1438;
              t["gershayimhebrew"] = 1524;
              t["getamark"] = 12307;
              t["ghabengali"] = 2456;
              t["ghadarmenian"] = 1394;
              t["ghadeva"] = 2328;
              t["ghagujarati"] = 2712;
              t["ghagurmukhi"] = 2584;
              t["ghainarabic"] = 1594;
              t["ghainfinalarabic"] = 65230;
              t["ghaininitialarabic"] = 65231;
              t["ghainmedialarabic"] = 65232;
              t["ghemiddlehookcyrillic"] = 1173;
              t["ghestrokecyrillic"] = 1171;
              t["gheupturncyrillic"] = 1169;
              t["ghhadeva"] = 2394;
              t["ghhagurmukhi"] = 2650;
              t["ghook"] = 608;
              t["ghzsquare"] = 13203;
              t["gihiragana"] = 12366;
              t["gikatakana"] = 12462;
              t["gimarmenian"] = 1379;
              t["gimel"] = 1490;
              t["gimeldagesh"] = 64306;
              t["gimeldageshhebrew"] = 64306;
              t["gimelhebrew"] = 1490;
              t["gjecyrillic"] = 1107;
              t["glottalinvertedstroke"] = 446;
              t["glottalstop"] = 660;
              t["glottalstopinverted"] = 662;
              t["glottalstopmod"] = 704;
              t["glottalstopreversed"] = 661;
              t["glottalstopreversedmod"] = 705;
              t["glottalstopreversedsuperior"] = 740;
              t["glottalstopstroke"] = 673;
              t["glottalstopstrokereversed"] = 674;
              t["gmacron"] = 7713;
              t["gmonospace"] = 65351;
              t["gohiragana"] = 12372;
              t["gokatakana"] = 12468;
              t["gparen"] = 9378;
              t["gpasquare"] = 13228;
              t["gradient"] = 8711;
              t["grave"] = 96;
              t["gravebelowcmb"] = 790;
              t["gravecmb"] = 768;
              t["gravecomb"] = 768;
              t["gravedeva"] = 2387;
              t["gravelowmod"] = 718;
              t["gravemonospace"] = 65344;
              t["gravetonecmb"] = 832;
              t["greater"] = 62;
              t["greaterequal"] = 8805;
              t["greaterequalorless"] = 8923;
              t["greatermonospace"] = 65310;
              t["greaterorequivalent"] = 8819;
              t["greaterorless"] = 8823;
              t["greateroverequal"] = 8807;
              t["greatersmall"] = 65125;
              t["gscript"] = 609;
              t["gstroke"] = 485;
              t["guhiragana"] = 12368;
              t["guillemotleft"] = 171;
              t["guillemotright"] = 187;
              t["guilsinglleft"] = 8249;
              t["guilsinglright"] = 8250;
              t["gukatakana"] = 12464;
              t["guramusquare"] = 13080;
              t["gysquare"] = 13257;
              t["h"] = 104;
              t["haabkhasiancyrillic"] = 1193;
              t["haaltonearabic"] = 1729;
              t["habengali"] = 2489;
              t["hadescendercyrillic"] = 1203;
              t["hadeva"] = 2361;
              t["hagujarati"] = 2745;
              t["hagurmukhi"] = 2617;
              t["haharabic"] = 1581;
              t["hahfinalarabic"] = 65186;
              t["hahinitialarabic"] = 65187;
              t["hahiragana"] = 12399;
              t["hahmedialarabic"] = 65188;
              t["haitusquare"] = 13098;
              t["hakatakana"] = 12495;
              t["hakatakanahalfwidth"] = 65418;
              t["halantgurmukhi"] = 2637;
              t["hamzaarabic"] = 1569;
              t["hamzalowarabic"] = 1569;
              t["hangulfiller"] = 12644;
              t["hardsigncyrillic"] = 1098;
              t["harpoonleftbarbup"] = 8636;
              t["harpoonrightbarbup"] = 8640;
              t["hasquare"] = 13258;
              t["hatafpatah"] = 1458;
              t["hatafpatah16"] = 1458;
              t["hatafpatah23"] = 1458;
              t["hatafpatah2f"] = 1458;
              t["hatafpatahhebrew"] = 1458;
              t["hatafpatahnarrowhebrew"] = 1458;
              t["hatafpatahquarterhebrew"] = 1458;
              t["hatafpatahwidehebrew"] = 1458;
              t["hatafqamats"] = 1459;
              t["hatafqamats1b"] = 1459;
              t["hatafqamats28"] = 1459;
              t["hatafqamats34"] = 1459;
              t["hatafqamatshebrew"] = 1459;
              t["hatafqamatsnarrowhebrew"] = 1459;
              t["hatafqamatsquarterhebrew"] = 1459;
              t["hatafqamatswidehebrew"] = 1459;
              t["hatafsegol"] = 1457;
              t["hatafsegol17"] = 1457;
              t["hatafsegol24"] = 1457;
              t["hatafsegol30"] = 1457;
              t["hatafsegolhebrew"] = 1457;
              t["hatafsegolnarrowhebrew"] = 1457;
              t["hatafsegolquarterhebrew"] = 1457;
              t["hatafsegolwidehebrew"] = 1457;
              t["hbar"] = 295;
              t["hbopomofo"] = 12559;
              t["hbrevebelow"] = 7723;
              t["hcedilla"] = 7721;
              t["hcircle"] = 9431;
              t["hcircumflex"] = 293;
              t["hdieresis"] = 7719;
              t["hdotaccent"] = 7715;
              t["hdotbelow"] = 7717;
              t["he"] = 1492;
              t["heart"] = 9829;
              t["heartsuitblack"] = 9829;
              t["heartsuitwhite"] = 9825;
              t["hedagesh"] = 64308;
              t["hedageshhebrew"] = 64308;
              t["hehaltonearabic"] = 1729;
              t["heharabic"] = 1607;
              t["hehebrew"] = 1492;
              t["hehfinalaltonearabic"] = 64423;
              t["hehfinalalttwoarabic"] = 65258;
              t["hehfinalarabic"] = 65258;
              t["hehhamzaabovefinalarabic"] = 64421;
              t["hehhamzaaboveisolatedarabic"] = 64420;
              t["hehinitialaltonearabic"] = 64424;
              t["hehinitialarabic"] = 65259;
              t["hehiragana"] = 12408;
              t["hehmedialaltonearabic"] = 64425;
              t["hehmedialarabic"] = 65260;
              t["heiseierasquare"] = 13179;
              t["hekatakana"] = 12504;
              t["hekatakanahalfwidth"] = 65421;
              t["hekutaarusquare"] = 13110;
              t["henghook"] = 615;
              t["herutusquare"] = 13113;
              t["het"] = 1495;
              t["hethebrew"] = 1495;
              t["hhook"] = 614;
              t["hhooksuperior"] = 689;
              t["hieuhacirclekorean"] = 12923;
              t["hieuhaparenkorean"] = 12827;
              t["hieuhcirclekorean"] = 12909;
              t["hieuhkorean"] = 12622;
              t["hieuhparenkorean"] = 12813;
              t["hihiragana"] = 12402;
              t["hikatakana"] = 12498;
              t["hikatakanahalfwidth"] = 65419;
              t["hiriq"] = 1460;
              t["hiriq14"] = 1460;
              t["hiriq21"] = 1460;
              t["hiriq2d"] = 1460;
              t["hiriqhebrew"] = 1460;
              t["hiriqnarrowhebrew"] = 1460;
              t["hiriqquarterhebrew"] = 1460;
              t["hiriqwidehebrew"] = 1460;
              t["hlinebelow"] = 7830;
              t["hmonospace"] = 65352;
              t["hoarmenian"] = 1392;
              t["hohipthai"] = 3627;
              t["hohiragana"] = 12411;
              t["hokatakana"] = 12507;
              t["hokatakanahalfwidth"] = 65422;
              t["holam"] = 1465;
              t["holam19"] = 1465;
              t["holam26"] = 1465;
              t["holam32"] = 1465;
              t["holamhebrew"] = 1465;
              t["holamnarrowhebrew"] = 1465;
              t["holamquarterhebrew"] = 1465;
              t["holamwidehebrew"] = 1465;
              t["honokhukthai"] = 3630;
              t["hookabovecomb"] = 777;
              t["hookcmb"] = 777;
              t["hookpalatalizedbelowcmb"] = 801;
              t["hookretroflexbelowcmb"] = 802;
              t["hoonsquare"] = 13122;
              t["horicoptic"] = 1001;
              t["horizontalbar"] = 8213;
              t["horncmb"] = 795;
              t["hotsprings"] = 9832;
              t["house"] = 8962;
              t["hparen"] = 9379;
              t["hsuperior"] = 688;
              t["hturned"] = 613;
              t["huhiragana"] = 12405;
              t["huiitosquare"] = 13107;
              t["hukatakana"] = 12501;
              t["hukatakanahalfwidth"] = 65420;
              t["hungarumlaut"] = 733;
              t["hungarumlautcmb"] = 779;
              t["hv"] = 405;
              t["hyphen"] = 45;
              t["hypheninferior"] = 63205;
              t["hyphenmonospace"] = 65293;
              t["hyphensmall"] = 65123;
              t["hyphensuperior"] = 63206;
              t["hyphentwo"] = 8208;
              t["i"] = 105;
              t["iacute"] = 237;
              t["iacyrillic"] = 1103;
              t["ibengali"] = 2439;
              t["ibopomofo"] = 12583;
              t["ibreve"] = 301;
              t["icaron"] = 464;
              t["icircle"] = 9432;
              t["icircumflex"] = 238;
              t["icyrillic"] = 1110;
              t["idblgrave"] = 521;
              t["ideographearthcircle"] = 12943;
              t["ideographfirecircle"] = 12939;
              t["ideographicallianceparen"] = 12863;
              t["ideographiccallparen"] = 12858;
              t["ideographiccentrecircle"] = 12965;
              t["ideographicclose"] = 12294;
              t["ideographiccomma"] = 12289;
              t["ideographiccommaleft"] = 65380;
              t["ideographiccongratulationparen"] = 12855;
              t["ideographiccorrectcircle"] = 12963;
              t["ideographicearthparen"] = 12847;
              t["ideographicenterpriseparen"] = 12861;
              t["ideographicexcellentcircle"] = 12957;
              t["ideographicfestivalparen"] = 12864;
              t["ideographicfinancialcircle"] = 12950;
              t["ideographicfinancialparen"] = 12854;
              t["ideographicfireparen"] = 12843;
              t["ideographichaveparen"] = 12850;
              t["ideographichighcircle"] = 12964;
              t["ideographiciterationmark"] = 12293;
              t["ideographiclaborcircle"] = 12952;
              t["ideographiclaborparen"] = 12856;
              t["ideographicleftcircle"] = 12967;
              t["ideographiclowcircle"] = 12966;
              t["ideographicmedicinecircle"] = 12969;
              t["ideographicmetalparen"] = 12846;
              t["ideographicmoonparen"] = 12842;
              t["ideographicnameparen"] = 12852;
              t["ideographicperiod"] = 12290;
              t["ideographicprintcircle"] = 12958;
              t["ideographicreachparen"] = 12867;
              t["ideographicrepresentparen"] = 12857;
              t["ideographicresourceparen"] = 12862;
              t["ideographicrightcircle"] = 12968;
              t["ideographicsecretcircle"] = 12953;
              t["ideographicselfparen"] = 12866;
              t["ideographicsocietyparen"] = 12851;
              t["ideographicspace"] = 12288;
              t["ideographicspecialparen"] = 12853;
              t["ideographicstockparen"] = 12849;
              t["ideographicstudyparen"] = 12859;
              t["ideographicsunparen"] = 12848;
              t["ideographicsuperviseparen"] = 12860;
              t["ideographicwaterparen"] = 12844;
              t["ideographicwoodparen"] = 12845;
              t["ideographiczero"] = 12295;
              t["ideographmetalcircle"] = 12942;
              t["ideographmooncircle"] = 12938;
              t["ideographnamecircle"] = 12948;
              t["ideographsuncircle"] = 12944;
              t["ideographwatercircle"] = 12940;
              t["ideographwoodcircle"] = 12941;
              t["ideva"] = 2311;
              t["idieresis"] = 239;
              t["idieresisacute"] = 7727;
              t["idieresiscyrillic"] = 1253;
              t["idotbelow"] = 7883;
              t["iebrevecyrillic"] = 1239;
              t["iecyrillic"] = 1077;
              t["ieungacirclekorean"] = 12917;
              t["ieungaparenkorean"] = 12821;
              t["ieungcirclekorean"] = 12903;
              t["ieungkorean"] = 12615;
              t["ieungparenkorean"] = 12807;
              t["igrave"] = 236;
              t["igujarati"] = 2695;
              t["igurmukhi"] = 2567;
              t["ihiragana"] = 12356;
              t["ihookabove"] = 7881;
              t["iibengali"] = 2440;
              t["iicyrillic"] = 1080;
              t["iideva"] = 2312;
              t["iigujarati"] = 2696;
              t["iigurmukhi"] = 2568;
              t["iimatragurmukhi"] = 2624;
              t["iinvertedbreve"] = 523;
              t["iishortcyrillic"] = 1081;
              t["iivowelsignbengali"] = 2496;
              t["iivowelsigndeva"] = 2368;
              t["iivowelsigngujarati"] = 2752;
              t["ij"] = 307;
              t["ikatakana"] = 12452;
              t["ikatakanahalfwidth"] = 65394;
              t["ikorean"] = 12643;
              t["ilde"] = 732;
              t["iluyhebrew"] = 1452;
              t["imacron"] = 299;
              t["imacroncyrillic"] = 1251;
              t["imageorapproximatelyequal"] = 8787;
              t["imatragurmukhi"] = 2623;
              t["imonospace"] = 65353;
              t["increment"] = 8710;
              t["infinity"] = 8734;
              t["iniarmenian"] = 1387;
              t["integral"] = 8747;
              t["integralbottom"] = 8993;
              t["integralbt"] = 8993;
              t["integralex"] = 63733;
              t["integraltop"] = 8992;
              t["integraltp"] = 8992;
              t["intersection"] = 8745;
              t["intisquare"] = 13061;
              t["invbullet"] = 9688;
              t["invcircle"] = 9689;
              t["invsmileface"] = 9787;
              t["iocyrillic"] = 1105;
              t["iogonek"] = 303;
              t["iota"] = 953;
              t["iotadieresis"] = 970;
              t["iotadieresistonos"] = 912;
              t["iotalatin"] = 617;
              t["iotatonos"] = 943;
              t["iparen"] = 9380;
              t["irigurmukhi"] = 2674;
              t["ismallhiragana"] = 12355;
              t["ismallkatakana"] = 12451;
              t["ismallkatakanahalfwidth"] = 65384;
              t["issharbengali"] = 2554;
              t["istroke"] = 616;
              t["isuperior"] = 63213;
              t["iterationhiragana"] = 12445;
              t["iterationkatakana"] = 12541;
              t["itilde"] = 297;
              t["itildebelow"] = 7725;
              t["iubopomofo"] = 12585;
              t["iucyrillic"] = 1102;
              t["ivowelsignbengali"] = 2495;
              t["ivowelsigndeva"] = 2367;
              t["ivowelsigngujarati"] = 2751;
              t["izhitsacyrillic"] = 1141;
              t["izhitsadblgravecyrillic"] = 1143;
              t["j"] = 106;
              t["jaarmenian"] = 1393;
              t["jabengali"] = 2460;
              t["jadeva"] = 2332;
              t["jagujarati"] = 2716;
              t["jagurmukhi"] = 2588;
              t["jbopomofo"] = 12560;
              t["jcaron"] = 496;
              t["jcircle"] = 9433;
              t["jcircumflex"] = 309;
              t["jcrossedtail"] = 669;
              t["jdotlessstroke"] = 607;
              t["jecyrillic"] = 1112;
              t["jeemarabic"] = 1580;
              t["jeemfinalarabic"] = 65182;
              t["jeeminitialarabic"] = 65183;
              t["jeemmedialarabic"] = 65184;
              t["jeharabic"] = 1688;
              t["jehfinalarabic"] = 64395;
              t["jhabengali"] = 2461;
              t["jhadeva"] = 2333;
              t["jhagujarati"] = 2717;
              t["jhagurmukhi"] = 2589;
              t["jheharmenian"] = 1403;
              t["jis"] = 12292;
              t["jmonospace"] = 65354;
              t["jparen"] = 9381;
              t["jsuperior"] = 690;
              t["k"] = 107;
              t["kabashkircyrillic"] = 1185;
              t["kabengali"] = 2453;
              t["kacute"] = 7729;
              t["kacyrillic"] = 1082;
              t["kadescendercyrillic"] = 1179;
              t["kadeva"] = 2325;
              t["kaf"] = 1499;
              t["kafarabic"] = 1603;
              t["kafdagesh"] = 64315;
              t["kafdageshhebrew"] = 64315;
              t["kaffinalarabic"] = 65242;
              t["kafhebrew"] = 1499;
              t["kafinitialarabic"] = 65243;
              t["kafmedialarabic"] = 65244;
              t["kafrafehebrew"] = 64333;
              t["kagujarati"] = 2709;
              t["kagurmukhi"] = 2581;
              t["kahiragana"] = 12363;
              t["kahookcyrillic"] = 1220;
              t["kakatakana"] = 12459;
              t["kakatakanahalfwidth"] = 65398;
              t["kappa"] = 954;
              t["kappasymbolgreek"] = 1008;
              t["kapyeounmieumkorean"] = 12657;
              t["kapyeounphieuphkorean"] = 12676;
              t["kapyeounpieupkorean"] = 12664;
              t["kapyeounssangpieupkorean"] = 12665;
              t["karoriisquare"] = 13069;
              t["kashidaautoarabic"] = 1600;
              t["kashidaautonosidebearingarabic"] = 1600;
              t["kasmallkatakana"] = 12533;
              t["kasquare"] = 13188;
              t["kasraarabic"] = 1616;
              t["kasratanarabic"] = 1613;
              t["kastrokecyrillic"] = 1183;
              t["katahiraprolongmarkhalfwidth"] = 65392;
              t["kaverticalstrokecyrillic"] = 1181;
              t["kbopomofo"] = 12558;
              t["kcalsquare"] = 13193;
              t["kcaron"] = 489;
              t["kcedilla"] = 311;
              t["kcircle"] = 9434;
              t["kcommaaccent"] = 311;
              t["kdotbelow"] = 7731;
              t["keharmenian"] = 1412;
              t["kehiragana"] = 12369;
              t["kekatakana"] = 12465;
              t["kekatakanahalfwidth"] = 65401;
              t["kenarmenian"] = 1391;
              t["kesmallkatakana"] = 12534;
              t["kgreenlandic"] = 312;
              t["khabengali"] = 2454;
              t["khacyrillic"] = 1093;
              t["khadeva"] = 2326;
              t["khagujarati"] = 2710;
              t["khagurmukhi"] = 2582;
              t["khaharabic"] = 1582;
              t["khahfinalarabic"] = 65190;
              t["khahinitialarabic"] = 65191;
              t["khahmedialarabic"] = 65192;
              t["kheicoptic"] = 999;
              t["khhadeva"] = 2393;
              t["khhagurmukhi"] = 2649;
              t["khieukhacirclekorean"] = 12920;
              t["khieukhaparenkorean"] = 12824;
              t["khieukhcirclekorean"] = 12906;
              t["khieukhkorean"] = 12619;
              t["khieukhparenkorean"] = 12810;
              t["khokhaithai"] = 3586;
              t["khokhonthai"] = 3589;
              t["khokhuatthai"] = 3587;
              t["khokhwaithai"] = 3588;
              t["khomutthai"] = 3675;
              t["khook"] = 409;
              t["khorakhangthai"] = 3590;
              t["khzsquare"] = 13201;
              t["kihiragana"] = 12365;
              t["kikatakana"] = 12461;
              t["kikatakanahalfwidth"] = 65399;
              t["kiroguramusquare"] = 13077;
              t["kiromeetorusquare"] = 13078;
              t["kirosquare"] = 13076;
              t["kiyeokacirclekorean"] = 12910;
              t["kiyeokaparenkorean"] = 12814;
              t["kiyeokcirclekorean"] = 12896;
              t["kiyeokkorean"] = 12593;
              t["kiyeokparenkorean"] = 12800;
              t["kiyeoksioskorean"] = 12595;
              t["kjecyrillic"] = 1116;
              t["klinebelow"] = 7733;
              t["klsquare"] = 13208;
              t["kmcubedsquare"] = 13222;
              t["kmonospace"] = 65355;
              t["kmsquaredsquare"] = 13218;
              t["kohiragana"] = 12371;
              t["kohmsquare"] = 13248;
              t["kokaithai"] = 3585;
              t["kokatakana"] = 12467;
              t["kokatakanahalfwidth"] = 65402;
              t["kooposquare"] = 13086;
              t["koppacyrillic"] = 1153;
              t["koreanstandardsymbol"] = 12927;
              t["koroniscmb"] = 835;
              t["kparen"] = 9382;
              t["kpasquare"] = 13226;
              t["ksicyrillic"] = 1135;
              t["ktsquare"] = 13263;
              t["kturned"] = 670;
              t["kuhiragana"] = 12367;
              t["kukatakana"] = 12463;
              t["kukatakanahalfwidth"] = 65400;
              t["kvsquare"] = 13240;
              t["kwsquare"] = 13246;
              t["l"] = 108;
              t["labengali"] = 2482;
              t["lacute"] = 314;
              t["ladeva"] = 2354;
              t["lagujarati"] = 2738;
              t["lagurmukhi"] = 2610;
              t["lakkhangyaothai"] = 3653;
              t["lamaleffinalarabic"] = 65276;
              t["lamalefhamzaabovefinalarabic"] = 65272;
              t["lamalefhamzaaboveisolatedarabic"] = 65271;
              t["lamalefhamzabelowfinalarabic"] = 65274;
              t["lamalefhamzabelowisolatedarabic"] = 65273;
              t["lamalefisolatedarabic"] = 65275;
              t["lamalefmaddaabovefinalarabic"] = 65270;
              t["lamalefmaddaaboveisolatedarabic"] = 65269;
              t["lamarabic"] = 1604;
              t["lambda"] = 955;
              t["lambdastroke"] = 411;
              t["lamed"] = 1500;
              t["lameddagesh"] = 64316;
              t["lameddageshhebrew"] = 64316;
              t["lamedhebrew"] = 1500;
              t["lamfinalarabic"] = 65246;
              t["lamhahinitialarabic"] = 64714;
              t["laminitialarabic"] = 65247;
              t["lamjeeminitialarabic"] = 64713;
              t["lamkhahinitialarabic"] = 64715;
              t["lamlamhehisolatedarabic"] = 65010;
              t["lammedialarabic"] = 65248;
              t["lammeemhahinitialarabic"] = 64904;
              t["lammeeminitialarabic"] = 64716;
              t["largecircle"] = 9711;
              t["lbar"] = 410;
              t["lbelt"] = 620;
              t["lbopomofo"] = 12556;
              t["lcaron"] = 318;
              t["lcedilla"] = 316;
              t["lcircle"] = 9435;
              t["lcircumflexbelow"] = 7741;
              t["lcommaaccent"] = 316;
              t["ldot"] = 320;
              t["ldotaccent"] = 320;
              t["ldotbelow"] = 7735;
              t["ldotbelowmacron"] = 7737;
              t["leftangleabovecmb"] = 794;
              t["lefttackbelowcmb"] = 792;
              t["less"] = 60;
              t["lessequal"] = 8804;
              t["lessequalorgreater"] = 8922;
              t["lessmonospace"] = 65308;
              t["lessorequivalent"] = 8818;
              t["lessorgreater"] = 8822;
              t["lessoverequal"] = 8806;
              t["lesssmall"] = 65124;
              t["lezh"] = 622;
              t["lfblock"] = 9612;
              t["lhookretroflex"] = 621;
              t["lira"] = 8356;
              t["liwnarmenian"] = 1388;
              t["lj"] = 457;
              t["ljecyrillic"] = 1113;
              t["ll"] = 63168;
              t["lladeva"] = 2355;
              t["llagujarati"] = 2739;
              t["llinebelow"] = 7739;
              t["llladeva"] = 2356;
              t["llvocalicbengali"] = 2529;
              t["llvocalicdeva"] = 2401;
              t["llvocalicvowelsignbengali"] = 2531;
              t["llvocalicvowelsigndeva"] = 2403;
              t["lmiddletilde"] = 619;
              t["lmonospace"] = 65356;
              t["lmsquare"] = 13264;
              t["lochulathai"] = 3628;
              t["logicaland"] = 8743;
              t["logicalnot"] = 172;
              t["logicalnotreversed"] = 8976;
              t["logicalor"] = 8744;
              t["lolingthai"] = 3621;
              t["longs"] = 383;
              t["lowlinecenterline"] = 65102;
              t["lowlinecmb"] = 818;
              t["lowlinedashed"] = 65101;
              t["lozenge"] = 9674;
              t["lparen"] = 9383;
              t["lslash"] = 322;
              t["lsquare"] = 8467;
              t["lsuperior"] = 63214;
              t["ltshade"] = 9617;
              t["luthai"] = 3622;
              t["lvocalicbengali"] = 2444;
              t["lvocalicdeva"] = 2316;
              t["lvocalicvowelsignbengali"] = 2530;
              t["lvocalicvowelsigndeva"] = 2402;
              t["lxsquare"] = 13267;
              t["m"] = 109;
              t["mabengali"] = 2478;
              t["macron"] = 175;
              t["macronbelowcmb"] = 817;
              t["macroncmb"] = 772;
              t["macronlowmod"] = 717;
              t["macronmonospace"] = 65507;
              t["macute"] = 7743;
              t["madeva"] = 2350;
              t["magujarati"] = 2734;
              t["magurmukhi"] = 2606;
              t["mahapakhhebrew"] = 1444;
              t["mahapakhlefthebrew"] = 1444;
              t["mahiragana"] = 12414;
              t["maichattawalowleftthai"] = 63637;
              t["maichattawalowrightthai"] = 63636;
              t["maichattawathai"] = 3659;
              t["maichattawaupperleftthai"] = 63635;
              t["maieklowleftthai"] = 63628;
              t["maieklowrightthai"] = 63627;
              t["maiekthai"] = 3656;
              t["maiekupperleftthai"] = 63626;
              t["maihanakatleftthai"] = 63620;
              t["maihanakatthai"] = 3633;
              t["maitaikhuleftthai"] = 63625;
              t["maitaikhuthai"] = 3655;
              t["maitholowleftthai"] = 63631;
              t["maitholowrightthai"] = 63630;
              t["maithothai"] = 3657;
              t["maithoupperleftthai"] = 63629;
              t["maitrilowleftthai"] = 63634;
              t["maitrilowrightthai"] = 63633;
              t["maitrithai"] = 3658;
              t["maitriupperleftthai"] = 63632;
              t["maiyamokthai"] = 3654;
              t["makatakana"] = 12510;
              t["makatakanahalfwidth"] = 65423;
              t["male"] = 9794;
              t["mansyonsquare"] = 13127;
              t["maqafhebrew"] = 1470;
              t["mars"] = 9794;
              t["masoracirclehebrew"] = 1455;
              t["masquare"] = 13187;
              t["mbopomofo"] = 12551;
              t["mbsquare"] = 13268;
              t["mcircle"] = 9436;
              t["mcubedsquare"] = 13221;
              t["mdotaccent"] = 7745;
              t["mdotbelow"] = 7747;
              t["meemarabic"] = 1605;
              t["meemfinalarabic"] = 65250;
              t["meeminitialarabic"] = 65251;
              t["meemmedialarabic"] = 65252;
              t["meemmeeminitialarabic"] = 64721;
              t["meemmeemisolatedarabic"] = 64584;
              t["meetorusquare"] = 13133;
              t["mehiragana"] = 12417;
              t["meizierasquare"] = 13182;
              t["mekatakana"] = 12513;
              t["mekatakanahalfwidth"] = 65426;
              t["mem"] = 1502;
              t["memdagesh"] = 64318;
              t["memdageshhebrew"] = 64318;
              t["memhebrew"] = 1502;
              t["menarmenian"] = 1396;
              t["merkhahebrew"] = 1445;
              t["merkhakefulahebrew"] = 1446;
              t["merkhakefulalefthebrew"] = 1446;
              t["merkhalefthebrew"] = 1445;
              t["mhook"] = 625;
              t["mhzsquare"] = 13202;
              t["middledotkatakanahalfwidth"] = 65381;
              t["middot"] = 183;
              t["mieumacirclekorean"] = 12914;
              t["mieumaparenkorean"] = 12818;
              t["mieumcirclekorean"] = 12900;
              t["mieumkorean"] = 12609;
              t["mieumpansioskorean"] = 12656;
              t["mieumparenkorean"] = 12804;
              t["mieumpieupkorean"] = 12654;
              t["mieumsioskorean"] = 12655;
              t["mihiragana"] = 12415;
              t["mikatakana"] = 12511;
              t["mikatakanahalfwidth"] = 65424;
              t["minus"] = 8722;
              t["minusbelowcmb"] = 800;
              t["minuscircle"] = 8854;
              t["minusmod"] = 727;
              t["minusplus"] = 8723;
              t["minute"] = 8242;
              t["miribaarusquare"] = 13130;
              t["mirisquare"] = 13129;
              t["mlonglegturned"] = 624;
              t["mlsquare"] = 13206;
              t["mmcubedsquare"] = 13219;
              t["mmonospace"] = 65357;
              t["mmsquaredsquare"] = 13215;
              t["mohiragana"] = 12418;
              t["mohmsquare"] = 13249;
              t["mokatakana"] = 12514;
              t["mokatakanahalfwidth"] = 65427;
              t["molsquare"] = 13270;
              t["momathai"] = 3617;
              t["moverssquare"] = 13223;
              t["moverssquaredsquare"] = 13224;
              t["mparen"] = 9384;
              t["mpasquare"] = 13227;
              t["mssquare"] = 13235;
              t["msuperior"] = 63215;
              t["mturned"] = 623;
              t["mu"] = 181;
              t["mu1"] = 181;
              t["muasquare"] = 13186;
              t["muchgreater"] = 8811;
              t["muchless"] = 8810;
              t["mufsquare"] = 13196;
              t["mugreek"] = 956;
              t["mugsquare"] = 13197;
              t["muhiragana"] = 12416;
              t["mukatakana"] = 12512;
              t["mukatakanahalfwidth"] = 65425;
              t["mulsquare"] = 13205;
              t["multiply"] = 215;
              t["mumsquare"] = 13211;
              t["munahhebrew"] = 1443;
              t["munahlefthebrew"] = 1443;
              t["musicalnote"] = 9834;
              t["musicalnotedbl"] = 9835;
              t["musicflatsign"] = 9837;
              t["musicsharpsign"] = 9839;
              t["mussquare"] = 13234;
              t["muvsquare"] = 13238;
              t["muwsquare"] = 13244;
              t["mvmegasquare"] = 13241;
              t["mvsquare"] = 13239;
              t["mwmegasquare"] = 13247;
              t["mwsquare"] = 13245;
              t["n"] = 110;
              t["nabengali"] = 2472;
              t["nabla"] = 8711;
              t["nacute"] = 324;
              t["nadeva"] = 2344;
              t["nagujarati"] = 2728;
              t["nagurmukhi"] = 2600;
              t["nahiragana"] = 12394;
              t["nakatakana"] = 12490;
              t["nakatakanahalfwidth"] = 65413;
              t["napostrophe"] = 329;
              t["nasquare"] = 13185;
              t["nbopomofo"] = 12555;
              t["nbspace"] = 160;
              t["ncaron"] = 328;
              t["ncedilla"] = 326;
              t["ncircle"] = 9437;
              t["ncircumflexbelow"] = 7755;
              t["ncommaaccent"] = 326;
              t["ndotaccent"] = 7749;
              t["ndotbelow"] = 7751;
              t["nehiragana"] = 12397;
              t["nekatakana"] = 12493;
              t["nekatakanahalfwidth"] = 65416;
              t["newsheqelsign"] = 8362;
              t["nfsquare"] = 13195;
              t["ngabengali"] = 2457;
              t["ngadeva"] = 2329;
              t["ngagujarati"] = 2713;
              t["ngagurmukhi"] = 2585;
              t["ngonguthai"] = 3591;
              t["nhiragana"] = 12435;
              t["nhookleft"] = 626;
              t["nhookretroflex"] = 627;
              t["nieunacirclekorean"] = 12911;
              t["nieunaparenkorean"] = 12815;
              t["nieuncieuckorean"] = 12597;
              t["nieuncirclekorean"] = 12897;
              t["nieunhieuhkorean"] = 12598;
              t["nieunkorean"] = 12596;
              t["nieunpansioskorean"] = 12648;
              t["nieunparenkorean"] = 12801;
              t["nieunsioskorean"] = 12647;
              t["nieuntikeutkorean"] = 12646;
              t["nihiragana"] = 12395;
              t["nikatakana"] = 12491;
              t["nikatakanahalfwidth"] = 65414;
              t["nikhahitleftthai"] = 63641;
              t["nikhahitthai"] = 3661;
              t["nine"] = 57;
              t["ninearabic"] = 1641;
              t["ninebengali"] = 2543;
              t["ninecircle"] = 9320;
              t["ninecircleinversesansserif"] = 10130;
              t["ninedeva"] = 2415;
              t["ninegujarati"] = 2799;
              t["ninegurmukhi"] = 2671;
              t["ninehackarabic"] = 1641;
              t["ninehangzhou"] = 12329;
              t["nineideographicparen"] = 12840;
              t["nineinferior"] = 8329;
              t["ninemonospace"] = 65305;
              t["nineoldstyle"] = 63289;
              t["nineparen"] = 9340;
              t["nineperiod"] = 9360;
              t["ninepersian"] = 1785;
              t["nineroman"] = 8568;
              t["ninesuperior"] = 8313;
              t["nineteencircle"] = 9330;
              t["nineteenparen"] = 9350;
              t["nineteenperiod"] = 9370;
              t["ninethai"] = 3673;
              t["nj"] = 460;
              t["njecyrillic"] = 1114;
              t["nkatakana"] = 12531;
              t["nkatakanahalfwidth"] = 65437;
              t["nlegrightlong"] = 414;
              t["nlinebelow"] = 7753;
              t["nmonospace"] = 65358;
              t["nmsquare"] = 13210;
              t["nnabengali"] = 2467;
              t["nnadeva"] = 2339;
              t["nnagujarati"] = 2723;
              t["nnagurmukhi"] = 2595;
              t["nnnadeva"] = 2345;
              t["nohiragana"] = 12398;
              t["nokatakana"] = 12494;
              t["nokatakanahalfwidth"] = 65417;
              t["nonbreakingspace"] = 160;
              t["nonenthai"] = 3603;
              t["nonuthai"] = 3609;
              t["noonarabic"] = 1606;
              t["noonfinalarabic"] = 65254;
              t["noonghunnaarabic"] = 1722;
              t["noonghunnafinalarabic"] = 64415;
              t["nooninitialarabic"] = 65255;
              t["noonjeeminitialarabic"] = 64722;
              t["noonjeemisolatedarabic"] = 64587;
              t["noonmedialarabic"] = 65256;
              t["noonmeeminitialarabic"] = 64725;
              t["noonmeemisolatedarabic"] = 64590;
              t["noonnoonfinalarabic"] = 64653;
              t["notcontains"] = 8716;
              t["notelement"] = 8713;
              t["notelementof"] = 8713;
              t["notequal"] = 8800;
              t["notgreater"] = 8815;
              t["notgreaternorequal"] = 8817;
              t["notgreaternorless"] = 8825;
              t["notidentical"] = 8802;
              t["notless"] = 8814;
              t["notlessnorequal"] = 8816;
              t["notparallel"] = 8742;
              t["notprecedes"] = 8832;
              t["notsubset"] = 8836;
              t["notsucceeds"] = 8833;
              t["notsuperset"] = 8837;
              t["nowarmenian"] = 1398;
              t["nparen"] = 9385;
              t["nssquare"] = 13233;
              t["nsuperior"] = 8319;
              t["ntilde"] = 241;
              t["nu"] = 957;
              t["nuhiragana"] = 12396;
              t["nukatakana"] = 12492;
              t["nukatakanahalfwidth"] = 65415;
              t["nuktabengali"] = 2492;
              t["nuktadeva"] = 2364;
              t["nuktagujarati"] = 2748;
              t["nuktagurmukhi"] = 2620;
              t["numbersign"] = 35;
              t["numbersignmonospace"] = 65283;
              t["numbersignsmall"] = 65119;
              t["numeralsigngreek"] = 884;
              t["numeralsignlowergreek"] = 885;
              t["numero"] = 8470;
              t["nun"] = 1504;
              t["nundagesh"] = 64320;
              t["nundageshhebrew"] = 64320;
              t["nunhebrew"] = 1504;
              t["nvsquare"] = 13237;
              t["nwsquare"] = 13243;
              t["nyabengali"] = 2462;
              t["nyadeva"] = 2334;
              t["nyagujarati"] = 2718;
              t["nyagurmukhi"] = 2590;
              t["o"] = 111;
              t["oacute"] = 243;
              t["oangthai"] = 3629;
              t["obarred"] = 629;
              t["obarredcyrillic"] = 1257;
              t["obarreddieresiscyrillic"] = 1259;
              t["obengali"] = 2451;
              t["obopomofo"] = 12571;
              t["obreve"] = 335;
              t["ocandradeva"] = 2321;
              t["ocandragujarati"] = 2705;
              t["ocandravowelsigndeva"] = 2377;
              t["ocandravowelsigngujarati"] = 2761;
              t["ocaron"] = 466;
              t["ocircle"] = 9438;
              t["ocircumflex"] = 244;
              t["ocircumflexacute"] = 7889;
              t["ocircumflexdotbelow"] = 7897;
              t["ocircumflexgrave"] = 7891;
              t["ocircumflexhookabove"] = 7893;
              t["ocircumflextilde"] = 7895;
              t["ocyrillic"] = 1086;
              t["odblacute"] = 337;
              t["odblgrave"] = 525;
              t["odeva"] = 2323;
              t["odieresis"] = 246;
              t["odieresiscyrillic"] = 1255;
              t["odotbelow"] = 7885;
              t["oe"] = 339;
              t["oekorean"] = 12634;
              t["ogonek"] = 731;
              t["ogonekcmb"] = 808;
              t["ograve"] = 242;
              t["ogujarati"] = 2707;
              t["oharmenian"] = 1413;
              t["ohiragana"] = 12362;
              t["ohookabove"] = 7887;
              t["ohorn"] = 417;
              t["ohornacute"] = 7899;
              t["ohorndotbelow"] = 7907;
              t["ohorngrave"] = 7901;
              t["ohornhookabove"] = 7903;
              t["ohorntilde"] = 7905;
              t["ohungarumlaut"] = 337;
              t["oi"] = 419;
              t["oinvertedbreve"] = 527;
              t["okatakana"] = 12458;
              t["okatakanahalfwidth"] = 65397;
              t["okorean"] = 12631;
              t["olehebrew"] = 1451;
              t["omacron"] = 333;
              t["omacronacute"] = 7763;
              t["omacrongrave"] = 7761;
              t["omdeva"] = 2384;
              t["omega"] = 969;
              t["omega1"] = 982;
              t["omegacyrillic"] = 1121;
              t["omegalatinclosed"] = 631;
              t["omegaroundcyrillic"] = 1147;
              t["omegatitlocyrillic"] = 1149;
              t["omegatonos"] = 974;
              t["omgujarati"] = 2768;
              t["omicron"] = 959;
              t["omicrontonos"] = 972;
              t["omonospace"] = 65359;
              t["one"] = 49;
              t["onearabic"] = 1633;
              t["onebengali"] = 2535;
              t["onecircle"] = 9312;
              t["onecircleinversesansserif"] = 10122;
              t["onedeva"] = 2407;
              t["onedotenleader"] = 8228;
              t["oneeighth"] = 8539;
              t["onefitted"] = 63196;
              t["onegujarati"] = 2791;
              t["onegurmukhi"] = 2663;
              t["onehackarabic"] = 1633;
              t["onehalf"] = 189;
              t["onehangzhou"] = 12321;
              t["oneideographicparen"] = 12832;
              t["oneinferior"] = 8321;
              t["onemonospace"] = 65297;
              t["onenumeratorbengali"] = 2548;
              t["oneoldstyle"] = 63281;
              t["oneparen"] = 9332;
              t["oneperiod"] = 9352;
              t["onepersian"] = 1777;
              t["onequarter"] = 188;
              t["oneroman"] = 8560;
              t["onesuperior"] = 185;
              t["onethai"] = 3665;
              t["onethird"] = 8531;
              t["oogonek"] = 491;
              t["oogonekmacron"] = 493;
              t["oogurmukhi"] = 2579;
              t["oomatragurmukhi"] = 2635;
              t["oopen"] = 596;
              t["oparen"] = 9386;
              t["openbullet"] = 9702;
              t["option"] = 8997;
              t["ordfeminine"] = 170;
              t["ordmasculine"] = 186;
              t["orthogonal"] = 8735;
              t["oshortdeva"] = 2322;
              t["oshortvowelsigndeva"] = 2378;
              t["oslash"] = 248;
              t["oslashacute"] = 511;
              t["osmallhiragana"] = 12361;
              t["osmallkatakana"] = 12457;
              t["osmallkatakanahalfwidth"] = 65387;
              t["ostrokeacute"] = 511;
              t["osuperior"] = 63216;
              t["otcyrillic"] = 1151;
              t["otilde"] = 245;
              t["otildeacute"] = 7757;
              t["otildedieresis"] = 7759;
              t["oubopomofo"] = 12577;
              t["overline"] = 8254;
              t["overlinecenterline"] = 65098;
              t["overlinecmb"] = 773;
              t["overlinedashed"] = 65097;
              t["overlinedblwavy"] = 65100;
              t["overlinewavy"] = 65099;
              t["overscore"] = 175;
              t["ovowelsignbengali"] = 2507;
              t["ovowelsigndeva"] = 2379;
              t["ovowelsigngujarati"] = 2763;
              t["p"] = 112;
              t["paampssquare"] = 13184;
              t["paasentosquare"] = 13099;
              t["pabengali"] = 2474;
              t["pacute"] = 7765;
              t["padeva"] = 2346;
              t["pagedown"] = 8671;
              t["pageup"] = 8670;
              t["pagujarati"] = 2730;
              t["pagurmukhi"] = 2602;
              t["pahiragana"] = 12401;
              t["paiyannoithai"] = 3631;
              t["pakatakana"] = 12497;
              t["palatalizationcyrilliccmb"] = 1156;
              t["palochkacyrillic"] = 1216;
              t["pansioskorean"] = 12671;
              t["paragraph"] = 182;
              t["parallel"] = 8741;
              t["parenleft"] = 40;
              t["parenleftaltonearabic"] = 64830;
              t["parenleftbt"] = 63725;
              t["parenleftex"] = 63724;
              t["parenleftinferior"] = 8333;
              t["parenleftmonospace"] = 65288;
              t["parenleftsmall"] = 65113;
              t["parenleftsuperior"] = 8317;
              t["parenlefttp"] = 63723;
              t["parenleftvertical"] = 65077;
              t["parenright"] = 41;
              t["parenrightaltonearabic"] = 64831;
              t["parenrightbt"] = 63736;
              t["parenrightex"] = 63735;
              t["parenrightinferior"] = 8334;
              t["parenrightmonospace"] = 65289;
              t["parenrightsmall"] = 65114;
              t["parenrightsuperior"] = 8318;
              t["parenrighttp"] = 63734;
              t["parenrightvertical"] = 65078;
              t["partialdiff"] = 8706;
              t["paseqhebrew"] = 1472;
              t["pashtahebrew"] = 1433;
              t["pasquare"] = 13225;
              t["patah"] = 1463;
              t["patah11"] = 1463;
              t["patah1d"] = 1463;
              t["patah2a"] = 1463;
              t["patahhebrew"] = 1463;
              t["patahnarrowhebrew"] = 1463;
              t["patahquarterhebrew"] = 1463;
              t["patahwidehebrew"] = 1463;
              t["pazerhebrew"] = 1441;
              t["pbopomofo"] = 12550;
              t["pcircle"] = 9439;
              t["pdotaccent"] = 7767;
              t["pe"] = 1508;
              t["pecyrillic"] = 1087;
              t["pedagesh"] = 64324;
              t["pedageshhebrew"] = 64324;
              t["peezisquare"] = 13115;
              t["pefinaldageshhebrew"] = 64323;
              t["peharabic"] = 1662;
              t["peharmenian"] = 1402;
              t["pehebrew"] = 1508;
              t["pehfinalarabic"] = 64343;
              t["pehinitialarabic"] = 64344;
              t["pehiragana"] = 12410;
              t["pehmedialarabic"] = 64345;
              t["pekatakana"] = 12506;
              t["pemiddlehookcyrillic"] = 1191;
              t["perafehebrew"] = 64334;
              t["percent"] = 37;
              t["percentarabic"] = 1642;
              t["percentmonospace"] = 65285;
              t["percentsmall"] = 65130;
              t["period"] = 46;
              t["periodarmenian"] = 1417;
              t["periodcentered"] = 183;
              t["periodhalfwidth"] = 65377;
              t["periodinferior"] = 63207;
              t["periodmonospace"] = 65294;
              t["periodsmall"] = 65106;
              t["periodsuperior"] = 63208;
              t["perispomenigreekcmb"] = 834;
              t["perpendicular"] = 8869;
              t["perthousand"] = 8240;
              t["peseta"] = 8359;
              t["pfsquare"] = 13194;
              t["phabengali"] = 2475;
              t["phadeva"] = 2347;
              t["phagujarati"] = 2731;
              t["phagurmukhi"] = 2603;
              t["phi"] = 966;
              t["phi1"] = 981;
              t["phieuphacirclekorean"] = 12922;
              t["phieuphaparenkorean"] = 12826;
              t["phieuphcirclekorean"] = 12908;
              t["phieuphkorean"] = 12621;
              t["phieuphparenkorean"] = 12812;
              t["philatin"] = 632;
              t["phinthuthai"] = 3642;
              t["phisymbolgreek"] = 981;
              t["phook"] = 421;
              t["phophanthai"] = 3614;
              t["phophungthai"] = 3612;
              t["phosamphaothai"] = 3616;
              t["pi"] = 960;
              t["pieupacirclekorean"] = 12915;
              t["pieupaparenkorean"] = 12819;
              t["pieupcieuckorean"] = 12662;
              t["pieupcirclekorean"] = 12901;
              t["pieupkiyeokkorean"] = 12658;
              t["pieupkorean"] = 12610;
              t["pieupparenkorean"] = 12805;
              t["pieupsioskiyeokkorean"] = 12660;
              t["pieupsioskorean"] = 12612;
              t["pieupsiostikeutkorean"] = 12661;
              t["pieupthieuthkorean"] = 12663;
              t["pieuptikeutkorean"] = 12659;
              t["pihiragana"] = 12404;
              t["pikatakana"] = 12500;
              t["pisymbolgreek"] = 982;
              t["piwrarmenian"] = 1411;
              t["plus"] = 43;
              t["plusbelowcmb"] = 799;
              t["pluscircle"] = 8853;
              t["plusminus"] = 177;
              t["plusmod"] = 726;
              t["plusmonospace"] = 65291;
              t["plussmall"] = 65122;
              t["plussuperior"] = 8314;
              t["pmonospace"] = 65360;
              t["pmsquare"] = 13272;
              t["pohiragana"] = 12413;
              t["pointingindexdownwhite"] = 9759;
              t["pointingindexleftwhite"] = 9756;
              t["pointingindexrightwhite"] = 9758;
              t["pointingindexupwhite"] = 9757;
              t["pokatakana"] = 12509;
              t["poplathai"] = 3611;
              t["postalmark"] = 12306;
              t["postalmarkface"] = 12320;
              t["pparen"] = 9387;
              t["precedes"] = 8826;
              t["prescription"] = 8478;
              t["primemod"] = 697;
              t["primereversed"] = 8245;
              t["product"] = 8719;
              t["projective"] = 8965;
              t["prolongedkana"] = 12540;
              t["propellor"] = 8984;
              t["propersubset"] = 8834;
              t["propersuperset"] = 8835;
              t["proportion"] = 8759;
              t["proportional"] = 8733;
              t["psi"] = 968;
              t["psicyrillic"] = 1137;
              t["psilipneumatacyrilliccmb"] = 1158;
              t["pssquare"] = 13232;
              t["puhiragana"] = 12407;
              t["pukatakana"] = 12503;
              t["pvsquare"] = 13236;
              t["pwsquare"] = 13242;
              t["q"] = 113;
              t["qadeva"] = 2392;
              t["qadmahebrew"] = 1448;
              t["qafarabic"] = 1602;
              t["qaffinalarabic"] = 65238;
              t["qafinitialarabic"] = 65239;
              t["qafmedialarabic"] = 65240;
              t["qamats"] = 1464;
              t["qamats10"] = 1464;
              t["qamats1a"] = 1464;
              t["qamats1c"] = 1464;
              t["qamats27"] = 1464;
              t["qamats29"] = 1464;
              t["qamats33"] = 1464;
              t["qamatsde"] = 1464;
              t["qamatshebrew"] = 1464;
              t["qamatsnarrowhebrew"] = 1464;
              t["qamatsqatanhebrew"] = 1464;
              t["qamatsqatannarrowhebrew"] = 1464;
              t["qamatsqatanquarterhebrew"] = 1464;
              t["qamatsqatanwidehebrew"] = 1464;
              t["qamatsquarterhebrew"] = 1464;
              t["qamatswidehebrew"] = 1464;
              t["qarneyparahebrew"] = 1439;
              t["qbopomofo"] = 12561;
              t["qcircle"] = 9440;
              t["qhook"] = 672;
              t["qmonospace"] = 65361;
              t["qof"] = 1511;
              t["qofdagesh"] = 64327;
              t["qofdageshhebrew"] = 64327;
              t["qofhebrew"] = 1511;
              t["qparen"] = 9388;
              t["quarternote"] = 9833;
              t["qubuts"] = 1467;
              t["qubuts18"] = 1467;
              t["qubuts25"] = 1467;
              t["qubuts31"] = 1467;
              t["qubutshebrew"] = 1467;
              t["qubutsnarrowhebrew"] = 1467;
              t["qubutsquarterhebrew"] = 1467;
              t["qubutswidehebrew"] = 1467;
              t["question"] = 63;
              t["questionarabic"] = 1567;
              t["questionarmenian"] = 1374;
              t["questiondown"] = 191;
              t["questiondownsmall"] = 63423;
              t["questiongreek"] = 894;
              t["questionmonospace"] = 65311;
              t["questionsmall"] = 63295;
              t["quotedbl"] = 34;
              t["quotedblbase"] = 8222;
              t["quotedblleft"] = 8220;
              t["quotedblmonospace"] = 65282;
              t["quotedblprime"] = 12318;
              t["quotedblprimereversed"] = 12317;
              t["quotedblright"] = 8221;
              t["quoteleft"] = 8216;
              t["quoteleftreversed"] = 8219;
              t["quotereversed"] = 8219;
              t["quoteright"] = 8217;
              t["quoterightn"] = 329;
              t["quotesinglbase"] = 8218;
              t["quotesingle"] = 39;
              t["quotesinglemonospace"] = 65287;
              t["r"] = 114;
              t["raarmenian"] = 1404;
              t["rabengali"] = 2480;
              t["racute"] = 341;
              t["radeva"] = 2352;
              t["radical"] = 8730;
              t["radicalex"] = 63717;
              t["radoverssquare"] = 13230;
              t["radoverssquaredsquare"] = 13231;
              t["radsquare"] = 13229;
              t["rafe"] = 1471;
              t["rafehebrew"] = 1471;
              t["ragujarati"] = 2736;
              t["ragurmukhi"] = 2608;
              t["rahiragana"] = 12425;
              t["rakatakana"] = 12521;
              t["rakatakanahalfwidth"] = 65431;
              t["ralowerdiagonalbengali"] = 2545;
              t["ramiddlediagonalbengali"] = 2544;
              t["ramshorn"] = 612;
              t["ratio"] = 8758;
              t["rbopomofo"] = 12566;
              t["rcaron"] = 345;
              t["rcedilla"] = 343;
              t["rcircle"] = 9441;
              t["rcommaaccent"] = 343;
              t["rdblgrave"] = 529;
              t["rdotaccent"] = 7769;
              t["rdotbelow"] = 7771;
              t["rdotbelowmacron"] = 7773;
              t["referencemark"] = 8251;
              t["reflexsubset"] = 8838;
              t["reflexsuperset"] = 8839;
              t["registered"] = 174;
              t["registersans"] = 63720;
              t["registerserif"] = 63194;
              t["reharabic"] = 1585;
              t["reharmenian"] = 1408;
              t["rehfinalarabic"] = 65198;
              t["rehiragana"] = 12428;
              t["rekatakana"] = 12524;
              t["rekatakanahalfwidth"] = 65434;
              t["resh"] = 1512;
              t["reshdageshhebrew"] = 64328;
              t["reshhebrew"] = 1512;
              t["reversedtilde"] = 8765;
              t["reviahebrew"] = 1431;
              t["reviamugrashhebrew"] = 1431;
              t["revlogicalnot"] = 8976;
              t["rfishhook"] = 638;
              t["rfishhookreversed"] = 639;
              t["rhabengali"] = 2525;
              t["rhadeva"] = 2397;
              t["rho"] = 961;
              t["rhook"] = 637;
              t["rhookturned"] = 635;
              t["rhookturnedsuperior"] = 693;
              t["rhosymbolgreek"] = 1009;
              t["rhotichookmod"] = 734;
              t["rieulacirclekorean"] = 12913;
              t["rieulaparenkorean"] = 12817;
              t["rieulcirclekorean"] = 12899;
              t["rieulhieuhkorean"] = 12608;
              t["rieulkiyeokkorean"] = 12602;
              t["rieulkiyeoksioskorean"] = 12649;
              t["rieulkorean"] = 12601;
              t["rieulmieumkorean"] = 12603;
              t["rieulpansioskorean"] = 12652;
              t["rieulparenkorean"] = 12803;
              t["rieulphieuphkorean"] = 12607;
              t["rieulpieupkorean"] = 12604;
              t["rieulpieupsioskorean"] = 12651;
              t["rieulsioskorean"] = 12605;
              t["rieulthieuthkorean"] = 12606;
              t["rieultikeutkorean"] = 12650;
              t["rieulyeorinhieuhkorean"] = 12653;
              t["rightangle"] = 8735;
              t["righttackbelowcmb"] = 793;
              t["righttriangle"] = 8895;
              t["rihiragana"] = 12426;
              t["rikatakana"] = 12522;
              t["rikatakanahalfwidth"] = 65432;
              t["ring"] = 730;
              t["ringbelowcmb"] = 805;
              t["ringcmb"] = 778;
              t["ringhalfleft"] = 703;
              t["ringhalfleftarmenian"] = 1369;
              t["ringhalfleftbelowcmb"] = 796;
              t["ringhalfleftcentered"] = 723;
              t["ringhalfright"] = 702;
              t["ringhalfrightbelowcmb"] = 825;
              t["ringhalfrightcentered"] = 722;
              t["rinvertedbreve"] = 531;
              t["rittorusquare"] = 13137;
              t["rlinebelow"] = 7775;
              t["rlongleg"] = 636;
              t["rlonglegturned"] = 634;
              t["rmonospace"] = 65362;
              t["rohiragana"] = 12429;
              t["rokatakana"] = 12525;
              t["rokatakanahalfwidth"] = 65435;
              t["roruathai"] = 3619;
              t["rparen"] = 9389;
              t["rrabengali"] = 2524;
              t["rradeva"] = 2353;
              t["rragurmukhi"] = 2652;
              t["rreharabic"] = 1681;
              t["rrehfinalarabic"] = 64397;
              t["rrvocalicbengali"] = 2528;
              t["rrvocalicdeva"] = 2400;
              t["rrvocalicgujarati"] = 2784;
              t["rrvocalicvowelsignbengali"] = 2500;
              t["rrvocalicvowelsigndeva"] = 2372;
              t["rrvocalicvowelsigngujarati"] = 2756;
              t["rsuperior"] = 63217;
              t["rtblock"] = 9616;
              t["rturned"] = 633;
              t["rturnedsuperior"] = 692;
              t["ruhiragana"] = 12427;
              t["rukatakana"] = 12523;
              t["rukatakanahalfwidth"] = 65433;
              t["rupeemarkbengali"] = 2546;
              t["rupeesignbengali"] = 2547;
              t["rupiah"] = 63197;
              t["ruthai"] = 3620;
              t["rvocalicbengali"] = 2443;
              t["rvocalicdeva"] = 2315;
              t["rvocalicgujarati"] = 2699;
              t["rvocalicvowelsignbengali"] = 2499;
              t["rvocalicvowelsigndeva"] = 2371;
              t["rvocalicvowelsigngujarati"] = 2755;
              t["s"] = 115;
              t["sabengali"] = 2488;
              t["sacute"] = 347;
              t["sacutedotaccent"] = 7781;
              t["sadarabic"] = 1589;
              t["sadeva"] = 2360;
              t["sadfinalarabic"] = 65210;
              t["sadinitialarabic"] = 65211;
              t["sadmedialarabic"] = 65212;
              t["sagujarati"] = 2744;
              t["sagurmukhi"] = 2616;
              t["sahiragana"] = 12373;
              t["sakatakana"] = 12469;
              t["sakatakanahalfwidth"] = 65403;
              t["sallallahoualayhewasallamarabic"] = 65018;
              t["samekh"] = 1505;
              t["samekhdagesh"] = 64321;
              t["samekhdageshhebrew"] = 64321;
              t["samekhhebrew"] = 1505;
              t["saraaathai"] = 3634;
              t["saraaethai"] = 3649;
              t["saraaimaimalaithai"] = 3652;
              t["saraaimaimuanthai"] = 3651;
              t["saraamthai"] = 3635;
              t["saraathai"] = 3632;
              t["saraethai"] = 3648;
              t["saraiileftthai"] = 63622;
              t["saraiithai"] = 3637;
              t["saraileftthai"] = 63621;
              t["saraithai"] = 3636;
              t["saraothai"] = 3650;
              t["saraueeleftthai"] = 63624;
              t["saraueethai"] = 3639;
              t["saraueleftthai"] = 63623;
              t["sarauethai"] = 3638;
              t["sarauthai"] = 3640;
              t["sarauuthai"] = 3641;
              t["sbopomofo"] = 12569;
              t["scaron"] = 353;
              t["scarondotaccent"] = 7783;
              t["scedilla"] = 351;
              t["schwa"] = 601;
              t["schwacyrillic"] = 1241;
              t["schwadieresiscyrillic"] = 1243;
              t["schwahook"] = 602;
              t["scircle"] = 9442;
              t["scircumflex"] = 349;
              t["scommaaccent"] = 537;
              t["sdotaccent"] = 7777;
              t["sdotbelow"] = 7779;
              t["sdotbelowdotaccent"] = 7785;
              t["seagullbelowcmb"] = 828;
              t["second"] = 8243;
              t["secondtonechinese"] = 714;
              t["section"] = 167;
              t["seenarabic"] = 1587;
              t["seenfinalarabic"] = 65202;
              t["seeninitialarabic"] = 65203;
              t["seenmedialarabic"] = 65204;
              t["segol"] = 1462;
              t["segol13"] = 1462;
              t["segol1f"] = 1462;
              t["segol2c"] = 1462;
              t["segolhebrew"] = 1462;
              t["segolnarrowhebrew"] = 1462;
              t["segolquarterhebrew"] = 1462;
              t["segoltahebrew"] = 1426;
              t["segolwidehebrew"] = 1462;
              t["seharmenian"] = 1405;
              t["sehiragana"] = 12379;
              t["sekatakana"] = 12475;
              t["sekatakanahalfwidth"] = 65406;
              t["semicolon"] = 59;
              t["semicolonarabic"] = 1563;
              t["semicolonmonospace"] = 65307;
              t["semicolonsmall"] = 65108;
              t["semivoicedmarkkana"] = 12444;
              t["semivoicedmarkkanahalfwidth"] = 65439;
              t["sentisquare"] = 13090;
              t["sentosquare"] = 13091;
              t["seven"] = 55;
              t["sevenarabic"] = 1639;
              t["sevenbengali"] = 2541;
              t["sevencircle"] = 9318;
              t["sevencircleinversesansserif"] = 10128;
              t["sevendeva"] = 2413;
              t["seveneighths"] = 8542;
              t["sevengujarati"] = 2797;
              t["sevengurmukhi"] = 2669;
              t["sevenhackarabic"] = 1639;
              t["sevenhangzhou"] = 12327;
              t["sevenideographicparen"] = 12838;
              t["seveninferior"] = 8327;
              t["sevenmonospace"] = 65303;
              t["sevenoldstyle"] = 63287;
              t["sevenparen"] = 9338;
              t["sevenperiod"] = 9358;
              t["sevenpersian"] = 1783;
              t["sevenroman"] = 8566;
              t["sevensuperior"] = 8311;
              t["seventeencircle"] = 9328;
              t["seventeenparen"] = 9348;
              t["seventeenperiod"] = 9368;
              t["seventhai"] = 3671;
              t["sfthyphen"] = 173;
              t["shaarmenian"] = 1399;
              t["shabengali"] = 2486;
              t["shacyrillic"] = 1096;
              t["shaddaarabic"] = 1617;
              t["shaddadammaarabic"] = 64609;
              t["shaddadammatanarabic"] = 64606;
              t["shaddafathaarabic"] = 64608;
              t["shaddakasraarabic"] = 64610;
              t["shaddakasratanarabic"] = 64607;
              t["shade"] = 9618;
              t["shadedark"] = 9619;
              t["shadelight"] = 9617;
              t["shademedium"] = 9618;
              t["shadeva"] = 2358;
              t["shagujarati"] = 2742;
              t["shagurmukhi"] = 2614;
              t["shalshelethebrew"] = 1427;
              t["shbopomofo"] = 12565;
              t["shchacyrillic"] = 1097;
              t["sheenarabic"] = 1588;
              t["sheenfinalarabic"] = 65206;
              t["sheeninitialarabic"] = 65207;
              t["sheenmedialarabic"] = 65208;
              t["sheicoptic"] = 995;
              t["sheqel"] = 8362;
              t["sheqelhebrew"] = 8362;
              t["sheva"] = 1456;
              t["sheva115"] = 1456;
              t["sheva15"] = 1456;
              t["sheva22"] = 1456;
              t["sheva2e"] = 1456;
              t["shevahebrew"] = 1456;
              t["shevanarrowhebrew"] = 1456;
              t["shevaquarterhebrew"] = 1456;
              t["shevawidehebrew"] = 1456;
              t["shhacyrillic"] = 1211;
              t["shimacoptic"] = 1005;
              t["shin"] = 1513;
              t["shindagesh"] = 64329;
              t["shindageshhebrew"] = 64329;
              t["shindageshshindot"] = 64300;
              t["shindageshshindothebrew"] = 64300;
              t["shindageshsindot"] = 64301;
              t["shindageshsindothebrew"] = 64301;
              t["shindothebrew"] = 1473;
              t["shinhebrew"] = 1513;
              t["shinshindot"] = 64298;
              t["shinshindothebrew"] = 64298;
              t["shinsindot"] = 64299;
              t["shinsindothebrew"] = 64299;
              t["shook"] = 642;
              t["sigma"] = 963;
              t["sigma1"] = 962;
              t["sigmafinal"] = 962;
              t["sigmalunatesymbolgreek"] = 1010;
              t["sihiragana"] = 12375;
              t["sikatakana"] = 12471;
              t["sikatakanahalfwidth"] = 65404;
              t["siluqhebrew"] = 1469;
              t["siluqlefthebrew"] = 1469;
              t["similar"] = 8764;
              t["sindothebrew"] = 1474;
              t["siosacirclekorean"] = 12916;
              t["siosaparenkorean"] = 12820;
              t["sioscieuckorean"] = 12670;
              t["sioscirclekorean"] = 12902;
              t["sioskiyeokkorean"] = 12666;
              t["sioskorean"] = 12613;
              t["siosnieunkorean"] = 12667;
              t["siosparenkorean"] = 12806;
              t["siospieupkorean"] = 12669;
              t["siostikeutkorean"] = 12668;
              t["six"] = 54;
              t["sixarabic"] = 1638;
              t["sixbengali"] = 2540;
              t["sixcircle"] = 9317;
              t["sixcircleinversesansserif"] = 10127;
              t["sixdeva"] = 2412;
              t["sixgujarati"] = 2796;
              t["sixgurmukhi"] = 2668;
              t["sixhackarabic"] = 1638;
              t["sixhangzhou"] = 12326;
              t["sixideographicparen"] = 12837;
              t["sixinferior"] = 8326;
              t["sixmonospace"] = 65302;
              t["sixoldstyle"] = 63286;
              t["sixparen"] = 9337;
              t["sixperiod"] = 9357;
              t["sixpersian"] = 1782;
              t["sixroman"] = 8565;
              t["sixsuperior"] = 8310;
              t["sixteencircle"] = 9327;
              t["sixteencurrencydenominatorbengali"] = 2553;
              t["sixteenparen"] = 9347;
              t["sixteenperiod"] = 9367;
              t["sixthai"] = 3670;
              t["slash"] = 47;
              t["slashmonospace"] = 65295;
              t["slong"] = 383;
              t["slongdotaccent"] = 7835;
              t["smileface"] = 9786;
              t["smonospace"] = 65363;
              t["sofpasuqhebrew"] = 1475;
              t["softhyphen"] = 173;
              t["softsigncyrillic"] = 1100;
              t["sohiragana"] = 12381;
              t["sokatakana"] = 12477;
              t["sokatakanahalfwidth"] = 65407;
              t["soliduslongoverlaycmb"] = 824;
              t["solidusshortoverlaycmb"] = 823;
              t["sorusithai"] = 3625;
              t["sosalathai"] = 3624;
              t["sosothai"] = 3595;
              t["sosuathai"] = 3626;
              t["space"] = 32;
              t["spacehackarabic"] = 32;
              t["spade"] = 9824;
              t["spadesuitblack"] = 9824;
              t["spadesuitwhite"] = 9828;
              t["sparen"] = 9390;
              t["squarebelowcmb"] = 827;
              t["squarecc"] = 13252;
              t["squarecm"] = 13213;
              t["squarediagonalcrosshatchfill"] = 9641;
              t["squarehorizontalfill"] = 9636;
              t["squarekg"] = 13199;
              t["squarekm"] = 13214;
              t["squarekmcapital"] = 13262;
              t["squareln"] = 13265;
              t["squarelog"] = 13266;
              t["squaremg"] = 13198;
              t["squaremil"] = 13269;
              t["squaremm"] = 13212;
              t["squaremsquared"] = 13217;
              t["squareorthogonalcrosshatchfill"] = 9638;
              t["squareupperlefttolowerrightfill"] = 9639;
              t["squareupperrighttolowerleftfill"] = 9640;
              t["squareverticalfill"] = 9637;
              t["squarewhitewithsmallblack"] = 9635;
              t["srsquare"] = 13275;
              t["ssabengali"] = 2487;
              t["ssadeva"] = 2359;
              t["ssagujarati"] = 2743;
              t["ssangcieuckorean"] = 12617;
              t["ssanghieuhkorean"] = 12677;
              t["ssangieungkorean"] = 12672;
              t["ssangkiyeokkorean"] = 12594;
              t["ssangnieunkorean"] = 12645;
              t["ssangpieupkorean"] = 12611;
              t["ssangsioskorean"] = 12614;
              t["ssangtikeutkorean"] = 12600;
              t["ssuperior"] = 63218;
              t["sterling"] = 163;
              t["sterlingmonospace"] = 65505;
              t["strokelongoverlaycmb"] = 822;
              t["strokeshortoverlaycmb"] = 821;
              t["subset"] = 8834;
              t["subsetnotequal"] = 8842;
              t["subsetorequal"] = 8838;
              t["succeeds"] = 8827;
              t["suchthat"] = 8715;
              t["suhiragana"] = 12377;
              t["sukatakana"] = 12473;
              t["sukatakanahalfwidth"] = 65405;
              t["sukunarabic"] = 1618;
              t["summation"] = 8721;
              t["sun"] = 9788;
              t["superset"] = 8835;
              t["supersetnotequal"] = 8843;
              t["supersetorequal"] = 8839;
              t["svsquare"] = 13276;
              t["syouwaerasquare"] = 13180;
              t["t"] = 116;
              t["tabengali"] = 2468;
              t["tackdown"] = 8868;
              t["tackleft"] = 8867;
              t["tadeva"] = 2340;
              t["tagujarati"] = 2724;
              t["tagurmukhi"] = 2596;
              t["taharabic"] = 1591;
              t["tahfinalarabic"] = 65218;
              t["tahinitialarabic"] = 65219;
              t["tahiragana"] = 12383;
              t["tahmedialarabic"] = 65220;
              t["taisyouerasquare"] = 13181;
              t["takatakana"] = 12479;
              t["takatakanahalfwidth"] = 65408;
              t["tatweelarabic"] = 1600;
              t["tau"] = 964;
              t["tav"] = 1514;
              t["tavdages"] = 64330;
              t["tavdagesh"] = 64330;
              t["tavdageshhebrew"] = 64330;
              t["tavhebrew"] = 1514;
              t["tbar"] = 359;
              t["tbopomofo"] = 12554;
              t["tcaron"] = 357;
              t["tccurl"] = 680;
              t["tcedilla"] = 355;
              t["tcheharabic"] = 1670;
              t["tchehfinalarabic"] = 64379;
              t["tchehinitialarabic"] = 64380;
              t["tchehmedialarabic"] = 64381;
              t["tcircle"] = 9443;
              t["tcircumflexbelow"] = 7793;
              t["tcommaaccent"] = 355;
              t["tdieresis"] = 7831;
              t["tdotaccent"] = 7787;
              t["tdotbelow"] = 7789;
              t["tecyrillic"] = 1090;
              t["tedescendercyrillic"] = 1197;
              t["teharabic"] = 1578;
              t["tehfinalarabic"] = 65174;
              t["tehhahinitialarabic"] = 64674;
              t["tehhahisolatedarabic"] = 64524;
              t["tehinitialarabic"] = 65175;
              t["tehiragana"] = 12390;
              t["tehjeeminitialarabic"] = 64673;
              t["tehjeemisolatedarabic"] = 64523;
              t["tehmarbutaarabic"] = 1577;
              t["tehmarbutafinalarabic"] = 65172;
              t["tehmedialarabic"] = 65176;
              t["tehmeeminitialarabic"] = 64676;
              t["tehmeemisolatedarabic"] = 64526;
              t["tehnoonfinalarabic"] = 64627;
              t["tekatakana"] = 12486;
              t["tekatakanahalfwidth"] = 65411;
              t["telephone"] = 8481;
              t["telephoneblack"] = 9742;
              t["telishagedolahebrew"] = 1440;
              t["telishaqetanahebrew"] = 1449;
              t["tencircle"] = 9321;
              t["tenideographicparen"] = 12841;
              t["tenparen"] = 9341;
              t["tenperiod"] = 9361;
              t["tenroman"] = 8569;
              t["tesh"] = 679;
              t["tet"] = 1496;
              t["tetdagesh"] = 64312;
              t["tetdageshhebrew"] = 64312;
              t["tethebrew"] = 1496;
              t["tetsecyrillic"] = 1205;
              t["tevirhebrew"] = 1435;
              t["tevirlefthebrew"] = 1435;
              t["thabengali"] = 2469;
              t["thadeva"] = 2341;
              t["thagujarati"] = 2725;
              t["thagurmukhi"] = 2597;
              t["thalarabic"] = 1584;
              t["thalfinalarabic"] = 65196;
              t["thanthakhatlowleftthai"] = 63640;
              t["thanthakhatlowrightthai"] = 63639;
              t["thanthakhatthai"] = 3660;
              t["thanthakhatupperleftthai"] = 63638;
              t["theharabic"] = 1579;
              t["thehfinalarabic"] = 65178;
              t["thehinitialarabic"] = 65179;
              t["thehmedialarabic"] = 65180;
              t["thereexists"] = 8707;
              t["therefore"] = 8756;
              t["theta"] = 952;
              t["theta1"] = 977;
              t["thetasymbolgreek"] = 977;
              t["thieuthacirclekorean"] = 12921;
              t["thieuthaparenkorean"] = 12825;
              t["thieuthcirclekorean"] = 12907;
              t["thieuthkorean"] = 12620;
              t["thieuthparenkorean"] = 12811;
              t["thirteencircle"] = 9324;
              t["thirteenparen"] = 9344;
              t["thirteenperiod"] = 9364;
              t["thonangmonthothai"] = 3601;
              t["thook"] = 429;
              t["thophuthaothai"] = 3602;
              t["thorn"] = 254;
              t["thothahanthai"] = 3607;
              t["thothanthai"] = 3600;
              t["thothongthai"] = 3608;
              t["thothungthai"] = 3606;
              t["thousandcyrillic"] = 1154;
              t["thousandsseparatorarabic"] = 1644;
              t["thousandsseparatorpersian"] = 1644;
              t["three"] = 51;
              t["threearabic"] = 1635;
              t["threebengali"] = 2537;
              t["threecircle"] = 9314;
              t["threecircleinversesansserif"] = 10124;
              t["threedeva"] = 2409;
              t["threeeighths"] = 8540;
              t["threegujarati"] = 2793;
              t["threegurmukhi"] = 2665;
              t["threehackarabic"] = 1635;
              t["threehangzhou"] = 12323;
              t["threeideographicparen"] = 12834;
              t["threeinferior"] = 8323;
              t["threemonospace"] = 65299;
              t["threenumeratorbengali"] = 2550;
              t["threeoldstyle"] = 63283;
              t["threeparen"] = 9334;
              t["threeperiod"] = 9354;
              t["threepersian"] = 1779;
              t["threequarters"] = 190;
              t["threequartersemdash"] = 63198;
              t["threeroman"] = 8562;
              t["threesuperior"] = 179;
              t["threethai"] = 3667;
              t["thzsquare"] = 13204;
              t["tihiragana"] = 12385;
              t["tikatakana"] = 12481;
              t["tikatakanahalfwidth"] = 65409;
              t["tikeutacirclekorean"] = 12912;
              t["tikeutaparenkorean"] = 12816;
              t["tikeutcirclekorean"] = 12898;
              t["tikeutkorean"] = 12599;
              t["tikeutparenkorean"] = 12802;
              t["tilde"] = 732;
              t["tildebelowcmb"] = 816;
              t["tildecmb"] = 771;
              t["tildecomb"] = 771;
              t["tildedoublecmb"] = 864;
              t["tildeoperator"] = 8764;
              t["tildeoverlaycmb"] = 820;
              t["tildeverticalcmb"] = 830;
              t["timescircle"] = 8855;
              t["tipehahebrew"] = 1430;
              t["tipehalefthebrew"] = 1430;
              t["tippigurmukhi"] = 2672;
              t["titlocyrilliccmb"] = 1155;
              t["tiwnarmenian"] = 1407;
              t["tlinebelow"] = 7791;
              t["tmonospace"] = 65364;
              t["toarmenian"] = 1385;
              t["tohiragana"] = 12392;
              t["tokatakana"] = 12488;
              t["tokatakanahalfwidth"] = 65412;
              t["tonebarextrahighmod"] = 741;
              t["tonebarextralowmod"] = 745;
              t["tonebarhighmod"] = 742;
              t["tonebarlowmod"] = 744;
              t["tonebarmidmod"] = 743;
              t["tonefive"] = 445;
              t["tonesix"] = 389;
              t["tonetwo"] = 424;
              t["tonos"] = 900;
              t["tonsquare"] = 13095;
              t["topatakthai"] = 3599;
              t["tortoiseshellbracketleft"] = 12308;
              t["tortoiseshellbracketleftsmall"] = 65117;
              t["tortoiseshellbracketleftvertical"] = 65081;
              t["tortoiseshellbracketright"] = 12309;
              t["tortoiseshellbracketrightsmall"] = 65118;
              t["tortoiseshellbracketrightvertical"] = 65082;
              t["totaothai"] = 3605;
              t["tpalatalhook"] = 427;
              t["tparen"] = 9391;
              t["trademark"] = 8482;
              t["trademarksans"] = 63722;
              t["trademarkserif"] = 63195;
              t["tretroflexhook"] = 648;
              t["triagdn"] = 9660;
              t["triaglf"] = 9668;
              t["triagrt"] = 9658;
              t["triagup"] = 9650;
              t["ts"] = 678;
              t["tsadi"] = 1510;
              t["tsadidagesh"] = 64326;
              t["tsadidageshhebrew"] = 64326;
              t["tsadihebrew"] = 1510;
              t["tsecyrillic"] = 1094;
              t["tsere"] = 1461;
              t["tsere12"] = 1461;
              t["tsere1e"] = 1461;
              t["tsere2b"] = 1461;
              t["tserehebrew"] = 1461;
              t["tserenarrowhebrew"] = 1461;
              t["tserequarterhebrew"] = 1461;
              t["tserewidehebrew"] = 1461;
              t["tshecyrillic"] = 1115;
              t["tsuperior"] = 63219;
              t["ttabengali"] = 2463;
              t["ttadeva"] = 2335;
              t["ttagujarati"] = 2719;
              t["ttagurmukhi"] = 2591;
              t["tteharabic"] = 1657;
              t["ttehfinalarabic"] = 64359;
              t["ttehinitialarabic"] = 64360;
              t["ttehmedialarabic"] = 64361;
              t["tthabengali"] = 2464;
              t["tthadeva"] = 2336;
              t["tthagujarati"] = 2720;
              t["tthagurmukhi"] = 2592;
              t["tturned"] = 647;
              t["tuhiragana"] = 12388;
              t["tukatakana"] = 12484;
              t["tukatakanahalfwidth"] = 65410;
              t["tusmallhiragana"] = 12387;
              t["tusmallkatakana"] = 12483;
              t["tusmallkatakanahalfwidth"] = 65391;
              t["twelvecircle"] = 9323;
              t["twelveparen"] = 9343;
              t["twelveperiod"] = 9363;
              t["twelveroman"] = 8571;
              t["twentycircle"] = 9331;
              t["twentyhangzhou"] = 21316;
              t["twentyparen"] = 9351;
              t["twentyperiod"] = 9371;
              t["two"] = 50;
              t["twoarabic"] = 1634;
              t["twobengali"] = 2536;
              t["twocircle"] = 9313;
              t["twocircleinversesansserif"] = 10123;
              t["twodeva"] = 2408;
              t["twodotenleader"] = 8229;
              t["twodotleader"] = 8229;
              t["twodotleadervertical"] = 65072;
              t["twogujarati"] = 2792;
              t["twogurmukhi"] = 2664;
              t["twohackarabic"] = 1634;
              t["twohangzhou"] = 12322;
              t["twoideographicparen"] = 12833;
              t["twoinferior"] = 8322;
              t["twomonospace"] = 65298;
              t["twonumeratorbengali"] = 2549;
              t["twooldstyle"] = 63282;
              t["twoparen"] = 9333;
              t["twoperiod"] = 9353;
              t["twopersian"] = 1778;
              t["tworoman"] = 8561;
              t["twostroke"] = 443;
              t["twosuperior"] = 178;
              t["twothai"] = 3666;
              t["twothirds"] = 8532;
              t["u"] = 117;
              t["uacute"] = 250;
              t["ubar"] = 649;
              t["ubengali"] = 2441;
              t["ubopomofo"] = 12584;
              t["ubreve"] = 365;
              t["ucaron"] = 468;
              t["ucircle"] = 9444;
              t["ucircumflex"] = 251;
              t["ucircumflexbelow"] = 7799;
              t["ucyrillic"] = 1091;
              t["udattadeva"] = 2385;
              t["udblacute"] = 369;
              t["udblgrave"] = 533;
              t["udeva"] = 2313;
              t["udieresis"] = 252;
              t["udieresisacute"] = 472;
              t["udieresisbelow"] = 7795;
              t["udieresiscaron"] = 474;
              t["udieresiscyrillic"] = 1265;
              t["udieresisgrave"] = 476;
              t["udieresismacron"] = 470;
              t["udotbelow"] = 7909;
              t["ugrave"] = 249;
              t["ugujarati"] = 2697;
              t["ugurmukhi"] = 2569;
              t["uhiragana"] = 12358;
              t["uhookabove"] = 7911;
              t["uhorn"] = 432;
              t["uhornacute"] = 7913;
              t["uhorndotbelow"] = 7921;
              t["uhorngrave"] = 7915;
              t["uhornhookabove"] = 7917;
              t["uhorntilde"] = 7919;
              t["uhungarumlaut"] = 369;
              t["uhungarumlautcyrillic"] = 1267;
              t["uinvertedbreve"] = 535;
              t["ukatakana"] = 12454;
              t["ukatakanahalfwidth"] = 65395;
              t["ukcyrillic"] = 1145;
              t["ukorean"] = 12636;
              t["umacron"] = 363;
              t["umacroncyrillic"] = 1263;
              t["umacrondieresis"] = 7803;
              t["umatragurmukhi"] = 2625;
              t["umonospace"] = 65365;
              t["underscore"] = 95;
              t["underscoredbl"] = 8215;
              t["underscoremonospace"] = 65343;
              t["underscorevertical"] = 65075;
              t["underscorewavy"] = 65103;
              t["union"] = 8746;
              t["universal"] = 8704;
              t["uogonek"] = 371;
              t["uparen"] = 9392;
              t["upblock"] = 9600;
              t["upperdothebrew"] = 1476;
              t["upsilon"] = 965;
              t["upsilondieresis"] = 971;
              t["upsilondieresistonos"] = 944;
              t["upsilonlatin"] = 650;
              t["upsilontonos"] = 973;
              t["uptackbelowcmb"] = 797;
              t["uptackmod"] = 724;
              t["uragurmukhi"] = 2675;
              t["uring"] = 367;
              t["ushortcyrillic"] = 1118;
              t["usmallhiragana"] = 12357;
              t["usmallkatakana"] = 12453;
              t["usmallkatakanahalfwidth"] = 65385;
              t["ustraightcyrillic"] = 1199;
              t["ustraightstrokecyrillic"] = 1201;
              t["utilde"] = 361;
              t["utildeacute"] = 7801;
              t["utildebelow"] = 7797;
              t["uubengali"] = 2442;
              t["uudeva"] = 2314;
              t["uugujarati"] = 2698;
              t["uugurmukhi"] = 2570;
              t["uumatragurmukhi"] = 2626;
              t["uuvowelsignbengali"] = 2498;
              t["uuvowelsigndeva"] = 2370;
              t["uuvowelsigngujarati"] = 2754;
              t["uvowelsignbengali"] = 2497;
              t["uvowelsigndeva"] = 2369;
              t["uvowelsigngujarati"] = 2753;
              t["v"] = 118;
              t["vadeva"] = 2357;
              t["vagujarati"] = 2741;
              t["vagurmukhi"] = 2613;
              t["vakatakana"] = 12535;
              t["vav"] = 1493;
              t["vavdagesh"] = 64309;
              t["vavdagesh65"] = 64309;
              t["vavdageshhebrew"] = 64309;
              t["vavhebrew"] = 1493;
              t["vavholam"] = 64331;
              t["vavholamhebrew"] = 64331;
              t["vavvavhebrew"] = 1520;
              t["vavyodhebrew"] = 1521;
              t["vcircle"] = 9445;
              t["vdotbelow"] = 7807;
              t["vecyrillic"] = 1074;
              t["veharabic"] = 1700;
              t["vehfinalarabic"] = 64363;
              t["vehinitialarabic"] = 64364;
              t["vehmedialarabic"] = 64365;
              t["vekatakana"] = 12537;
              t["venus"] = 9792;
              t["verticalbar"] = 124;
              t["verticallineabovecmb"] = 781;
              t["verticallinebelowcmb"] = 809;
              t["verticallinelowmod"] = 716;
              t["verticallinemod"] = 712;
              t["vewarmenian"] = 1406;
              t["vhook"] = 651;
              t["vikatakana"] = 12536;
              t["viramabengali"] = 2509;
              t["viramadeva"] = 2381;
              t["viramagujarati"] = 2765;
              t["visargabengali"] = 2435;
              t["visargadeva"] = 2307;
              t["visargagujarati"] = 2691;
              t["vmonospace"] = 65366;
              t["voarmenian"] = 1400;
              t["voicediterationhiragana"] = 12446;
              t["voicediterationkatakana"] = 12542;
              t["voicedmarkkana"] = 12443;
              t["voicedmarkkanahalfwidth"] = 65438;
              t["vokatakana"] = 12538;
              t["vparen"] = 9393;
              t["vtilde"] = 7805;
              t["vturned"] = 652;
              t["vuhiragana"] = 12436;
              t["vukatakana"] = 12532;
              t["w"] = 119;
              t["wacute"] = 7811;
              t["waekorean"] = 12633;
              t["wahiragana"] = 12431;
              t["wakatakana"] = 12527;
              t["wakatakanahalfwidth"] = 65436;
              t["wakorean"] = 12632;
              t["wasmallhiragana"] = 12430;
              t["wasmallkatakana"] = 12526;
              t["wattosquare"] = 13143;
              t["wavedash"] = 12316;
              t["wavyunderscorevertical"] = 65076;
              t["wawarabic"] = 1608;
              t["wawfinalarabic"] = 65262;
              t["wawhamzaabovearabic"] = 1572;
              t["wawhamzaabovefinalarabic"] = 65158;
              t["wbsquare"] = 13277;
              t["wcircle"] = 9446;
              t["wcircumflex"] = 373;
              t["wdieresis"] = 7813;
              t["wdotaccent"] = 7815;
              t["wdotbelow"] = 7817;
              t["wehiragana"] = 12433;
              t["weierstrass"] = 8472;
              t["wekatakana"] = 12529;
              t["wekorean"] = 12638;
              t["weokorean"] = 12637;
              t["wgrave"] = 7809;
              t["whitebullet"] = 9702;
              t["whitecircle"] = 9675;
              t["whitecircleinverse"] = 9689;
              t["whitecornerbracketleft"] = 12302;
              t["whitecornerbracketleftvertical"] = 65091;
              t["whitecornerbracketright"] = 12303;
              t["whitecornerbracketrightvertical"] = 65092;
              t["whitediamond"] = 9671;
              t["whitediamondcontainingblacksmalldiamond"] = 9672;
              t["whitedownpointingsmalltriangle"] = 9663;
              t["whitedownpointingtriangle"] = 9661;
              t["whiteleftpointingsmalltriangle"] = 9667;
              t["whiteleftpointingtriangle"] = 9665;
              t["whitelenticularbracketleft"] = 12310;
              t["whitelenticularbracketright"] = 12311;
              t["whiterightpointingsmalltriangle"] = 9657;
              t["whiterightpointingtriangle"] = 9655;
              t["whitesmallsquare"] = 9643;
              t["whitesmilingface"] = 9786;
              t["whitesquare"] = 9633;
              t["whitestar"] = 9734;
              t["whitetelephone"] = 9743;
              t["whitetortoiseshellbracketleft"] = 12312;
              t["whitetortoiseshellbracketright"] = 12313;
              t["whiteuppointingsmalltriangle"] = 9653;
              t["whiteuppointingtriangle"] = 9651;
              t["wihiragana"] = 12432;
              t["wikatakana"] = 12528;
              t["wikorean"] = 12639;
              t["wmonospace"] = 65367;
              t["wohiragana"] = 12434;
              t["wokatakana"] = 12530;
              t["wokatakanahalfwidth"] = 65382;
              t["won"] = 8361;
              t["wonmonospace"] = 65510;
              t["wowaenthai"] = 3623;
              t["wparen"] = 9394;
              t["wring"] = 7832;
              t["wsuperior"] = 695;
              t["wturned"] = 653;
              t["wynn"] = 447;
              t["x"] = 120;
              t["xabovecmb"] = 829;
              t["xbopomofo"] = 12562;
              t["xcircle"] = 9447;
              t["xdieresis"] = 7821;
              t["xdotaccent"] = 7819;
              t["xeharmenian"] = 1389;
              t["xi"] = 958;
              t["xmonospace"] = 65368;
              t["xparen"] = 9395;
              t["xsuperior"] = 739;
              t["y"] = 121;
              t["yaadosquare"] = 13134;
              t["yabengali"] = 2479;
              t["yacute"] = 253;
              t["yadeva"] = 2351;
              t["yaekorean"] = 12626;
              t["yagujarati"] = 2735;
              t["yagurmukhi"] = 2607;
              t["yahiragana"] = 12420;
              t["yakatakana"] = 12516;
              t["yakatakanahalfwidth"] = 65428;
              t["yakorean"] = 12625;
              t["yamakkanthai"] = 3662;
              t["yasmallhiragana"] = 12419;
              t["yasmallkatakana"] = 12515;
              t["yasmallkatakanahalfwidth"] = 65388;
              t["yatcyrillic"] = 1123;
              t["ycircle"] = 9448;
              t["ycircumflex"] = 375;
              t["ydieresis"] = 255;
              t["ydotaccent"] = 7823;
              t["ydotbelow"] = 7925;
              t["yeharabic"] = 1610;
              t["yehbarreearabic"] = 1746;
              t["yehbarreefinalarabic"] = 64431;
              t["yehfinalarabic"] = 65266;
              t["yehhamzaabovearabic"] = 1574;
              t["yehhamzaabovefinalarabic"] = 65162;
              t["yehhamzaaboveinitialarabic"] = 65163;
              t["yehhamzaabovemedialarabic"] = 65164;
              t["yehinitialarabic"] = 65267;
              t["yehmedialarabic"] = 65268;
              t["yehmeeminitialarabic"] = 64733;
              t["yehmeemisolatedarabic"] = 64600;
              t["yehnoonfinalarabic"] = 64660;
              t["yehthreedotsbelowarabic"] = 1745;
              t["yekorean"] = 12630;
              t["yen"] = 165;
              t["yenmonospace"] = 65509;
              t["yeokorean"] = 12629;
              t["yeorinhieuhkorean"] = 12678;
              t["yerahbenyomohebrew"] = 1450;
              t["yerahbenyomolefthebrew"] = 1450;
              t["yericyrillic"] = 1099;
              t["yerudieresiscyrillic"] = 1273;
              t["yesieungkorean"] = 12673;
              t["yesieungpansioskorean"] = 12675;
              t["yesieungsioskorean"] = 12674;
              t["yetivhebrew"] = 1434;
              t["ygrave"] = 7923;
              t["yhook"] = 436;
              t["yhookabove"] = 7927;
              t["yiarmenian"] = 1397;
              t["yicyrillic"] = 1111;
              t["yikorean"] = 12642;
              t["yinyang"] = 9775;
              t["yiwnarmenian"] = 1410;
              t["ymonospace"] = 65369;
              t["yod"] = 1497;
              t["yoddagesh"] = 64313;
              t["yoddageshhebrew"] = 64313;
              t["yodhebrew"] = 1497;
              t["yodyodhebrew"] = 1522;
              t["yodyodpatahhebrew"] = 64287;
              t["yohiragana"] = 12424;
              t["yoikorean"] = 12681;
              t["yokatakana"] = 12520;
              t["yokatakanahalfwidth"] = 65430;
              t["yokorean"] = 12635;
              t["yosmallhiragana"] = 12423;
              t["yosmallkatakana"] = 12519;
              t["yosmallkatakanahalfwidth"] = 65390;
              t["yotgreek"] = 1011;
              t["yoyaekorean"] = 12680;
              t["yoyakorean"] = 12679;
              t["yoyakthai"] = 3618;
              t["yoyingthai"] = 3597;
              t["yparen"] = 9396;
              t["ypogegrammeni"] = 890;
              t["ypogegrammenigreekcmb"] = 837;
              t["yr"] = 422;
              t["yring"] = 7833;
              t["ysuperior"] = 696;
              t["ytilde"] = 7929;
              t["yturned"] = 654;
              t["yuhiragana"] = 12422;
              t["yuikorean"] = 12684;
              t["yukatakana"] = 12518;
              t["yukatakanahalfwidth"] = 65429;
              t["yukorean"] = 12640;
              t["yusbigcyrillic"] = 1131;
              t["yusbigiotifiedcyrillic"] = 1133;
              t["yuslittlecyrillic"] = 1127;
              t["yuslittleiotifiedcyrillic"] = 1129;
              t["yusmallhiragana"] = 12421;
              t["yusmallkatakana"] = 12517;
              t["yusmallkatakanahalfwidth"] = 65389;
              t["yuyekorean"] = 12683;
              t["yuyeokorean"] = 12682;
              t["yyabengali"] = 2527;
              t["yyadeva"] = 2399;
              t["z"] = 122;
              t["zaarmenian"] = 1382;
              t["zacute"] = 378;
              t["zadeva"] = 2395;
              t["zagurmukhi"] = 2651;
              t["zaharabic"] = 1592;
              t["zahfinalarabic"] = 65222;
              t["zahinitialarabic"] = 65223;
              t["zahiragana"] = 12374;
              t["zahmedialarabic"] = 65224;
              t["zainarabic"] = 1586;
              t["zainfinalarabic"] = 65200;
              t["zakatakana"] = 12470;
              t["zaqefgadolhebrew"] = 1429;
              t["zaqefqatanhebrew"] = 1428;
              t["zarqahebrew"] = 1432;
              t["zayin"] = 1494;
              t["zayindagesh"] = 64310;
              t["zayindageshhebrew"] = 64310;
              t["zayinhebrew"] = 1494;
              t["zbopomofo"] = 12567;
              t["zcaron"] = 382;
              t["zcircle"] = 9449;
              t["zcircumflex"] = 7825;
              t["zcurl"] = 657;
              t["zdot"] = 380;
              t["zdotaccent"] = 380;
              t["zdotbelow"] = 7827;
              t["zecyrillic"] = 1079;
              t["zedescendercyrillic"] = 1177;
              t["zedieresiscyrillic"] = 1247;
              t["zehiragana"] = 12380;
              t["zekatakana"] = 12476;
              t["zero"] = 48;
              t["zeroarabic"] = 1632;
              t["zerobengali"] = 2534;
              t["zerodeva"] = 2406;
              t["zerogujarati"] = 2790;
              t["zerogurmukhi"] = 2662;
              t["zerohackarabic"] = 1632;
              t["zeroinferior"] = 8320;
              t["zeromonospace"] = 65296;
              t["zerooldstyle"] = 63280;
              t["zeropersian"] = 1776;
              t["zerosuperior"] = 8304;
              t["zerothai"] = 3664;
              t["zerowidthjoiner"] = 65279;
              t["zerowidthnonjoiner"] = 8204;
              t["zerowidthspace"] = 8203;
              t["zeta"] = 950;
              t["zhbopomofo"] = 12563;
              t["zhearmenian"] = 1386;
              t["zhebrevecyrillic"] = 1218;
              t["zhecyrillic"] = 1078;
              t["zhedescendercyrillic"] = 1175;
              t["zhedieresiscyrillic"] = 1245;
              t["zihiragana"] = 12376;
              t["zikatakana"] = 12472;
              t["zinorhebrew"] = 1454;
              t["zlinebelow"] = 7829;
              t["zmonospace"] = 65370;
              t["zohiragana"] = 12382;
              t["zokatakana"] = 12478;
              t["zparen"] = 9397;
              t["zretroflexhook"] = 656;
              t["zstroke"] = 438;
              t["zuhiragana"] = 12378;
              t["zukatakana"] = 12474;
              t[".notdef"] = 0;
              t["angbracketleftbig"] = 9001;
              t["angbracketleftBig"] = 9001;
              t["angbracketleftbigg"] = 9001;
              t["angbracketleftBigg"] = 9001;
              t["angbracketrightBig"] = 9002;
              t["angbracketrightbig"] = 9002;
              t["angbracketrightBigg"] = 9002;
              t["angbracketrightbigg"] = 9002;
              t["arrowhookleft"] = 8618;
              t["arrowhookright"] = 8617;
              t["arrowlefttophalf"] = 8636;
              t["arrowleftbothalf"] = 8637;
              t["arrownortheast"] = 8599;
              t["arrownorthwest"] = 8598;
              t["arrowrighttophalf"] = 8640;
              t["arrowrightbothalf"] = 8641;
              t["arrowsoutheast"] = 8600;
              t["arrowsouthwest"] = 8601;
              t["backslashbig"] = 8726;
              t["backslashBig"] = 8726;
              t["backslashBigg"] = 8726;
              t["backslashbigg"] = 8726;
              t["bardbl"] = 8214;
              t["bracehtipdownleft"] = 65079;
              t["bracehtipdownright"] = 65079;
              t["bracehtipupleft"] = 65080;
              t["bracehtipupright"] = 65080;
              t["braceleftBig"] = 123;
              t["braceleftbig"] = 123;
              t["braceleftbigg"] = 123;
              t["braceleftBigg"] = 123;
              t["bracerightBig"] = 125;
              t["bracerightbig"] = 125;
              t["bracerightbigg"] = 125;
              t["bracerightBigg"] = 125;
              t["bracketleftbig"] = 91;
              t["bracketleftBig"] = 91;
              t["bracketleftbigg"] = 91;
              t["bracketleftBigg"] = 91;
              t["bracketrightBig"] = 93;
              t["bracketrightbig"] = 93;
              t["bracketrightbigg"] = 93;
              t["bracketrightBigg"] = 93;
              t["ceilingleftbig"] = 8968;
              t["ceilingleftBig"] = 8968;
              t["ceilingleftBigg"] = 8968;
              t["ceilingleftbigg"] = 8968;
              t["ceilingrightbig"] = 8969;
              t["ceilingrightBig"] = 8969;
              t["ceilingrightbigg"] = 8969;
              t["ceilingrightBigg"] = 8969;
              t["circledotdisplay"] = 8857;
              t["circledottext"] = 8857;
              t["circlemultiplydisplay"] = 8855;
              t["circlemultiplytext"] = 8855;
              t["circleplusdisplay"] = 8853;
              t["circleplustext"] = 8853;
              t["contintegraldisplay"] = 8750;
              t["contintegraltext"] = 8750;
              t["coproductdisplay"] = 8720;
              t["coproducttext"] = 8720;
              t["floorleftBig"] = 8970;
              t["floorleftbig"] = 8970;
              t["floorleftbigg"] = 8970;
              t["floorleftBigg"] = 8970;
              t["floorrightbig"] = 8971;
              t["floorrightBig"] = 8971;
              t["floorrightBigg"] = 8971;
              t["floorrightbigg"] = 8971;
              t["hatwide"] = 770;
              t["hatwider"] = 770;
              t["hatwidest"] = 770;
              t["intercal"] = 7488;
              t["integraldisplay"] = 8747;
              t["integraltext"] = 8747;
              t["intersectiondisplay"] = 8898;
              t["intersectiontext"] = 8898;
              t["logicalanddisplay"] = 8743;
              t["logicalandtext"] = 8743;
              t["logicalordisplay"] = 8744;
              t["logicalortext"] = 8744;
              t["parenleftBig"] = 40;
              t["parenleftbig"] = 40;
              t["parenleftBigg"] = 40;
              t["parenleftbigg"] = 40;
              t["parenrightBig"] = 41;
              t["parenrightbig"] = 41;
              t["parenrightBigg"] = 41;
              t["parenrightbigg"] = 41;
              t["prime"] = 8242;
              t["productdisplay"] = 8719;
              t["producttext"] = 8719;
              t["radicalbig"] = 8730;
              t["radicalBig"] = 8730;
              t["radicalBigg"] = 8730;
              t["radicalbigg"] = 8730;
              t["radicalbt"] = 8730;
              t["radicaltp"] = 8730;
              t["radicalvertex"] = 8730;
              t["slashbig"] = 47;
              t["slashBig"] = 47;
              t["slashBigg"] = 47;
              t["slashbigg"] = 47;
              t["summationdisplay"] = 8721;
              t["summationtext"] = 8721;
              t["tildewide"] = 732;
              t["tildewider"] = 732;
              t["tildewidest"] = 732;
              t["uniondisplay"] = 8899;
              t["unionmultidisplay"] = 8846;
              t["unionmultitext"] = 8846;
              t["unionsqdisplay"] = 8852;
              t["unionsqtext"] = 8852;
              t["uniontext"] = 8899;
              t["vextenddouble"] = 8741;
              t["vextendsingle"] = 8739;
            });
            var getDingbatsGlyphsUnicode = getLookupTableFactory(function(t) {
              t["space"] = 32;
              t["a1"] = 9985;
              t["a2"] = 9986;
              t["a202"] = 9987;
              t["a3"] = 9988;
              t["a4"] = 9742;
              t["a5"] = 9990;
              t["a119"] = 9991;
              t["a118"] = 9992;
              t["a117"] = 9993;
              t["a11"] = 9755;
              t["a12"] = 9758;
              t["a13"] = 9996;
              t["a14"] = 9997;
              t["a15"] = 9998;
              t["a16"] = 9999;
              t["a105"] = 1e4;
              t["a17"] = 10001;
              t["a18"] = 10002;
              t["a19"] = 10003;
              t["a20"] = 10004;
              t["a21"] = 10005;
              t["a22"] = 10006;
              t["a23"] = 10007;
              t["a24"] = 10008;
              t["a25"] = 10009;
              t["a26"] = 10010;
              t["a27"] = 10011;
              t["a28"] = 10012;
              t["a6"] = 10013;
              t["a7"] = 10014;
              t["a8"] = 10015;
              t["a9"] = 10016;
              t["a10"] = 10017;
              t["a29"] = 10018;
              t["a30"] = 10019;
              t["a31"] = 10020;
              t["a32"] = 10021;
              t["a33"] = 10022;
              t["a34"] = 10023;
              t["a35"] = 9733;
              t["a36"] = 10025;
              t["a37"] = 10026;
              t["a38"] = 10027;
              t["a39"] = 10028;
              t["a40"] = 10029;
              t["a41"] = 10030;
              t["a42"] = 10031;
              t["a43"] = 10032;
              t["a44"] = 10033;
              t["a45"] = 10034;
              t["a46"] = 10035;
              t["a47"] = 10036;
              t["a48"] = 10037;
              t["a49"] = 10038;
              t["a50"] = 10039;
              t["a51"] = 10040;
              t["a52"] = 10041;
              t["a53"] = 10042;
              t["a54"] = 10043;
              t["a55"] = 10044;
              t["a56"] = 10045;
              t["a57"] = 10046;
              t["a58"] = 10047;
              t["a59"] = 10048;
              t["a60"] = 10049;
              t["a61"] = 10050;
              t["a62"] = 10051;
              t["a63"] = 10052;
              t["a64"] = 10053;
              t["a65"] = 10054;
              t["a66"] = 10055;
              t["a67"] = 10056;
              t["a68"] = 10057;
              t["a69"] = 10058;
              t["a70"] = 10059;
              t["a71"] = 9679;
              t["a72"] = 10061;
              t["a73"] = 9632;
              t["a74"] = 10063;
              t["a203"] = 10064;
              t["a75"] = 10065;
              t["a204"] = 10066;
              t["a76"] = 9650;
              t["a77"] = 9660;
              t["a78"] = 9670;
              t["a79"] = 10070;
              t["a81"] = 9687;
              t["a82"] = 10072;
              t["a83"] = 10073;
              t["a84"] = 10074;
              t["a97"] = 10075;
              t["a98"] = 10076;
              t["a99"] = 10077;
              t["a100"] = 10078;
              t["a101"] = 10081;
              t["a102"] = 10082;
              t["a103"] = 10083;
              t["a104"] = 10084;
              t["a106"] = 10085;
              t["a107"] = 10086;
              t["a108"] = 10087;
              t["a112"] = 9827;
              t["a111"] = 9830;
              t["a110"] = 9829;
              t["a109"] = 9824;
              t["a120"] = 9312;
              t["a121"] = 9313;
              t["a122"] = 9314;
              t["a123"] = 9315;
              t["a124"] = 9316;
              t["a125"] = 9317;
              t["a126"] = 9318;
              t["a127"] = 9319;
              t["a128"] = 9320;
              t["a129"] = 9321;
              t["a130"] = 10102;
              t["a131"] = 10103;
              t["a132"] = 10104;
              t["a133"] = 10105;
              t["a134"] = 10106;
              t["a135"] = 10107;
              t["a136"] = 10108;
              t["a137"] = 10109;
              t["a138"] = 10110;
              t["a139"] = 10111;
              t["a140"] = 10112;
              t["a141"] = 10113;
              t["a142"] = 10114;
              t["a143"] = 10115;
              t["a144"] = 10116;
              t["a145"] = 10117;
              t["a146"] = 10118;
              t["a147"] = 10119;
              t["a148"] = 10120;
              t["a149"] = 10121;
              t["a150"] = 10122;
              t["a151"] = 10123;
              t["a152"] = 10124;
              t["a153"] = 10125;
              t["a154"] = 10126;
              t["a155"] = 10127;
              t["a156"] = 10128;
              t["a157"] = 10129;
              t["a158"] = 10130;
              t["a159"] = 10131;
              t["a160"] = 10132;
              t["a161"] = 8594;
              t["a163"] = 8596;
              t["a164"] = 8597;
              t["a196"] = 10136;
              t["a165"] = 10137;
              t["a192"] = 10138;
              t["a166"] = 10139;
              t["a167"] = 10140;
              t["a168"] = 10141;
              t["a169"] = 10142;
              t["a170"] = 10143;
              t["a171"] = 10144;
              t["a172"] = 10145;
              t["a173"] = 10146;
              t["a162"] = 10147;
              t["a174"] = 10148;
              t["a175"] = 10149;
              t["a176"] = 10150;
              t["a177"] = 10151;
              t["a178"] = 10152;
              t["a179"] = 10153;
              t["a193"] = 10154;
              t["a180"] = 10155;
              t["a199"] = 10156;
              t["a181"] = 10157;
              t["a200"] = 10158;
              t["a182"] = 10159;
              t["a201"] = 10161;
              t["a183"] = 10162;
              t["a184"] = 10163;
              t["a197"] = 10164;
              t["a185"] = 10165;
              t["a194"] = 10166;
              t["a198"] = 10167;
              t["a186"] = 10168;
              t["a195"] = 10169;
              t["a187"] = 10170;
              t["a188"] = 10171;
              t["a189"] = 10172;
              t["a190"] = 10173;
              t["a191"] = 10174;
              t["a89"] = 10088;
              t["a90"] = 10089;
              t["a93"] = 10090;
              t["a94"] = 10091;
              t["a91"] = 10092;
              t["a92"] = 10093;
              t["a205"] = 10094;
              t["a85"] = 10095;
              t["a206"] = 10096;
              t["a86"] = 10097;
              t["a87"] = 10098;
              t["a88"] = 10099;
              t["a95"] = 10100;
              t["a96"] = 10101;
              t[".notdef"] = 0;
            });
            exports3.getGlyphsUnicode = getGlyphsUnicode;
            exports3.getDingbatsGlyphsUnicode = getDingbatsGlyphsUnicode;
          },
          /* 142 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.getSupplementalGlyphMapForCalibri = exports3.getSupplementalGlyphMapForArialBlack = exports3.getGlyphMapForStandardFonts = exports3.getSymbolsFonts = exports3.getSerifFonts = exports3.getNonStdFontMap = exports3.getStdFontMap = void 0;
            var _util = __w_pdfjs_require__(2);
            var getStdFontMap = (0, _util.getLookupTableFactory)(function(t) {
              t["ArialNarrow"] = "Helvetica";
              t["ArialNarrow-Bold"] = "Helvetica-Bold";
              t["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique";
              t["ArialNarrow-Italic"] = "Helvetica-Oblique";
              t["ArialBlack"] = "Helvetica";
              t["ArialBlack-Bold"] = "Helvetica-Bold";
              t["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique";
              t["ArialBlack-Italic"] = "Helvetica-Oblique";
              t["Arial-Black"] = "Helvetica";
              t["Arial-Black-Bold"] = "Helvetica-Bold";
              t["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique";
              t["Arial-Black-Italic"] = "Helvetica-Oblique";
              t["Arial"] = "Helvetica";
              t["Arial-Bold"] = "Helvetica-Bold";
              t["Arial-BoldItalic"] = "Helvetica-BoldOblique";
              t["Arial-Italic"] = "Helvetica-Oblique";
              t["Arial-BoldItalicMT"] = "Helvetica-BoldOblique";
              t["Arial-BoldMT"] = "Helvetica-Bold";
              t["Arial-ItalicMT"] = "Helvetica-Oblique";
              t["ArialMT"] = "Helvetica";
              t["Courier-Bold"] = "Courier-Bold";
              t["Courier-BoldItalic"] = "Courier-BoldOblique";
              t["Courier-Italic"] = "Courier-Oblique";
              t["CourierNew"] = "Courier";
              t["CourierNew-Bold"] = "Courier-Bold";
              t["CourierNew-BoldItalic"] = "Courier-BoldOblique";
              t["CourierNew-Italic"] = "Courier-Oblique";
              t["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique";
              t["CourierNewPS-BoldMT"] = "Courier-Bold";
              t["CourierNewPS-ItalicMT"] = "Courier-Oblique";
              t["CourierNewPSMT"] = "Courier";
              t["Helvetica"] = "Helvetica";
              t["Helvetica-Bold"] = "Helvetica-Bold";
              t["Helvetica-BoldItalic"] = "Helvetica-BoldOblique";
              t["Helvetica-BoldOblique"] = "Helvetica-BoldOblique";
              t["Helvetica-Italic"] = "Helvetica-Oblique";
              t["Helvetica-Oblique"] = "Helvetica-Oblique";
              t["SegoeUISymbol"] = "Helvetica";
              t["Symbol-Bold"] = "Symbol";
              t["Symbol-BoldItalic"] = "Symbol";
              t["Symbol-Italic"] = "Symbol";
              t["TimesNewRoman"] = "Times-Roman";
              t["TimesNewRoman-Bold"] = "Times-Bold";
              t["TimesNewRoman-BoldItalic"] = "Times-BoldItalic";
              t["TimesNewRoman-Italic"] = "Times-Italic";
              t["TimesNewRomanPS"] = "Times-Roman";
              t["TimesNewRomanPS-Bold"] = "Times-Bold";
              t["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic";
              t["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic";
              t["TimesNewRomanPS-BoldMT"] = "Times-Bold";
              t["TimesNewRomanPS-Italic"] = "Times-Italic";
              t["TimesNewRomanPS-ItalicMT"] = "Times-Italic";
              t["TimesNewRomanPSMT"] = "Times-Roman";
              t["TimesNewRomanPSMT-Bold"] = "Times-Bold";
              t["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic";
              t["TimesNewRomanPSMT-Italic"] = "Times-Italic";
            });
            var getNonStdFontMap = (0, _util.getLookupTableFactory)(function(t) {
              t["Calibri"] = "Helvetica";
              t["Calibri-Bold"] = "Helvetica-Bold";
              t["Calibri-BoldItalic"] = "Helvetica-BoldOblique";
              t["Calibri-Italic"] = "Helvetica-Oblique";
              t["CenturyGothic"] = "Helvetica";
              t["CenturyGothic-Bold"] = "Helvetica-Bold";
              t["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique";
              t["CenturyGothic-Italic"] = "Helvetica-Oblique";
              t["ComicSansMS"] = "Comic Sans MS";
              t["ComicSansMS-Bold"] = "Comic Sans MS-Bold";
              t["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic";
              t["ComicSansMS-Italic"] = "Comic Sans MS-Italic";
              t["LucidaConsole"] = "Courier";
              t["LucidaConsole-Bold"] = "Courier-Bold";
              t["LucidaConsole-BoldItalic"] = "Courier-BoldOblique";
              t["LucidaConsole-Italic"] = "Courier-Oblique";
              t["LucidaSans-Demi"] = "Helvetica-Bold";
              t["MS-Gothic"] = "MS Gothic";
              t["MS-Gothic-Bold"] = "MS Gothic-Bold";
              t["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic";
              t["MS-Gothic-Italic"] = "MS Gothic-Italic";
              t["MS-Mincho"] = "MS Mincho";
              t["MS-Mincho-Bold"] = "MS Mincho-Bold";
              t["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic";
              t["MS-Mincho-Italic"] = "MS Mincho-Italic";
              t["MS-PGothic"] = "MS PGothic";
              t["MS-PGothic-Bold"] = "MS PGothic-Bold";
              t["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic";
              t["MS-PGothic-Italic"] = "MS PGothic-Italic";
              t["MS-PMincho"] = "MS PMincho";
              t["MS-PMincho-Bold"] = "MS PMincho-Bold";
              t["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic";
              t["MS-PMincho-Italic"] = "MS PMincho-Italic";
              t["NuptialScript"] = "Times-Italic";
              t["Wingdings"] = "ZapfDingbats";
            });
            var getSerifFonts = (0, _util.getLookupTableFactory)(function(t) {
              t["Adobe Jenson"] = true;
              t["Adobe Text"] = true;
              t["Albertus"] = true;
              t["Aldus"] = true;
              t["Alexandria"] = true;
              t["Algerian"] = true;
              t["American Typewriter"] = true;
              t["Antiqua"] = true;
              t["Apex"] = true;
              t["Arno"] = true;
              t["Aster"] = true;
              t["Aurora"] = true;
              t["Baskerville"] = true;
              t["Bell"] = true;
              t["Bembo"] = true;
              t["Bembo Schoolbook"] = true;
              t["Benguiat"] = true;
              t["Berkeley Old Style"] = true;
              t["Bernhard Modern"] = true;
              t["Berthold City"] = true;
              t["Bodoni"] = true;
              t["Bauer Bodoni"] = true;
              t["Book Antiqua"] = true;
              t["Bookman"] = true;
              t["Bordeaux Roman"] = true;
              t["Californian FB"] = true;
              t["Calisto"] = true;
              t["Calvert"] = true;
              t["Capitals"] = true;
              t["Cambria"] = true;
              t["Cartier"] = true;
              t["Caslon"] = true;
              t["Catull"] = true;
              t["Centaur"] = true;
              t["Century Old Style"] = true;
              t["Century Schoolbook"] = true;
              t["Chaparral"] = true;
              t["Charis SIL"] = true;
              t["Cheltenham"] = true;
              t["Cholla Slab"] = true;
              t["Clarendon"] = true;
              t["Clearface"] = true;
              t["Cochin"] = true;
              t["Colonna"] = true;
              t["Computer Modern"] = true;
              t["Concrete Roman"] = true;
              t["Constantia"] = true;
              t["Cooper Black"] = true;
              t["Corona"] = true;
              t["Ecotype"] = true;
              t["Egyptienne"] = true;
              t["Elephant"] = true;
              t["Excelsior"] = true;
              t["Fairfield"] = true;
              t["FF Scala"] = true;
              t["Folkard"] = true;
              t["Footlight"] = true;
              t["FreeSerif"] = true;
              t["Friz Quadrata"] = true;
              t["Garamond"] = true;
              t["Gentium"] = true;
              t["Georgia"] = true;
              t["Gloucester"] = true;
              t["Goudy Old Style"] = true;
              t["Goudy Schoolbook"] = true;
              t["Goudy Pro Font"] = true;
              t["Granjon"] = true;
              t["Guardian Egyptian"] = true;
              t["Heather"] = true;
              t["Hercules"] = true;
              t["High Tower Text"] = true;
              t["Hiroshige"] = true;
              t["Hoefler Text"] = true;
              t["Humana Serif"] = true;
              t["Imprint"] = true;
              t["Ionic No. 5"] = true;
              t["Janson"] = true;
              t["Joanna"] = true;
              t["Korinna"] = true;
              t["Lexicon"] = true;
              t["Liberation Serif"] = true;
              t["Linux Libertine"] = true;
              t["Literaturnaya"] = true;
              t["Lucida"] = true;
              t["Lucida Bright"] = true;
              t["Melior"] = true;
              t["Memphis"] = true;
              t["Miller"] = true;
              t["Minion"] = true;
              t["Modern"] = true;
              t["Mona Lisa"] = true;
              t["Mrs Eaves"] = true;
              t["MS Serif"] = true;
              t["Museo Slab"] = true;
              t["New York"] = true;
              t["Nimbus Roman"] = true;
              t["NPS Rawlinson Roadway"] = true;
              t["NuptialScript"] = true;
              t["Palatino"] = true;
              t["Perpetua"] = true;
              t["Plantin"] = true;
              t["Plantin Schoolbook"] = true;
              t["Playbill"] = true;
              t["Poor Richard"] = true;
              t["Rawlinson Roadway"] = true;
              t["Renault"] = true;
              t["Requiem"] = true;
              t["Rockwell"] = true;
              t["Roman"] = true;
              t["Rotis Serif"] = true;
              t["Sabon"] = true;
              t["Scala"] = true;
              t["Seagull"] = true;
              t["Sistina"] = true;
              t["Souvenir"] = true;
              t["STIX"] = true;
              t["Stone Informal"] = true;
              t["Stone Serif"] = true;
              t["Sylfaen"] = true;
              t["Times"] = true;
              t["Trajan"] = true;
              t["Trinité"] = true;
              t["Trump Mediaeval"] = true;
              t["Utopia"] = true;
              t["Vale Type"] = true;
              t["Bitstream Vera"] = true;
              t["Vera Serif"] = true;
              t["Versailles"] = true;
              t["Wanted"] = true;
              t["Weiss"] = true;
              t["Wide Latin"] = true;
              t["Windsor"] = true;
              t["XITS"] = true;
            });
            var getSymbolsFonts = (0, _util.getLookupTableFactory)(function(t) {
              t["Dingbats"] = true;
              t["Symbol"] = true;
              t["ZapfDingbats"] = true;
            });
            var getGlyphMapForStandardFonts = (0, _util.getLookupTableFactory)(function(t) {
              t[2] = 10;
              t[3] = 32;
              t[4] = 33;
              t[5] = 34;
              t[6] = 35;
              t[7] = 36;
              t[8] = 37;
              t[9] = 38;
              t[10] = 39;
              t[11] = 40;
              t[12] = 41;
              t[13] = 42;
              t[14] = 43;
              t[15] = 44;
              t[16] = 45;
              t[17] = 46;
              t[18] = 47;
              t[19] = 48;
              t[20] = 49;
              t[21] = 50;
              t[22] = 51;
              t[23] = 52;
              t[24] = 53;
              t[25] = 54;
              t[26] = 55;
              t[27] = 56;
              t[28] = 57;
              t[29] = 58;
              t[30] = 894;
              t[31] = 60;
              t[32] = 61;
              t[33] = 62;
              t[34] = 63;
              t[35] = 64;
              t[36] = 65;
              t[37] = 66;
              t[38] = 67;
              t[39] = 68;
              t[40] = 69;
              t[41] = 70;
              t[42] = 71;
              t[43] = 72;
              t[44] = 73;
              t[45] = 74;
              t[46] = 75;
              t[47] = 76;
              t[48] = 77;
              t[49] = 78;
              t[50] = 79;
              t[51] = 80;
              t[52] = 81;
              t[53] = 82;
              t[54] = 83;
              t[55] = 84;
              t[56] = 85;
              t[57] = 86;
              t[58] = 87;
              t[59] = 88;
              t[60] = 89;
              t[61] = 90;
              t[62] = 91;
              t[63] = 92;
              t[64] = 93;
              t[65] = 94;
              t[66] = 95;
              t[67] = 96;
              t[68] = 97;
              t[69] = 98;
              t[70] = 99;
              t[71] = 100;
              t[72] = 101;
              t[73] = 102;
              t[74] = 103;
              t[75] = 104;
              t[76] = 105;
              t[77] = 106;
              t[78] = 107;
              t[79] = 108;
              t[80] = 109;
              t[81] = 110;
              t[82] = 111;
              t[83] = 112;
              t[84] = 113;
              t[85] = 114;
              t[86] = 115;
              t[87] = 116;
              t[88] = 117;
              t[89] = 118;
              t[90] = 119;
              t[91] = 120;
              t[92] = 121;
              t[93] = 122;
              t[94] = 123;
              t[95] = 124;
              t[96] = 125;
              t[97] = 126;
              t[98] = 196;
              t[99] = 197;
              t[100] = 199;
              t[101] = 201;
              t[102] = 209;
              t[103] = 214;
              t[104] = 220;
              t[105] = 225;
              t[106] = 224;
              t[107] = 226;
              t[108] = 228;
              t[109] = 227;
              t[110] = 229;
              t[111] = 231;
              t[112] = 233;
              t[113] = 232;
              t[114] = 234;
              t[115] = 235;
              t[116] = 237;
              t[117] = 236;
              t[118] = 238;
              t[119] = 239;
              t[120] = 241;
              t[121] = 243;
              t[122] = 242;
              t[123] = 244;
              t[124] = 246;
              t[125] = 245;
              t[126] = 250;
              t[127] = 249;
              t[128] = 251;
              t[129] = 252;
              t[130] = 8224;
              t[131] = 176;
              t[132] = 162;
              t[133] = 163;
              t[134] = 167;
              t[135] = 8226;
              t[136] = 182;
              t[137] = 223;
              t[138] = 174;
              t[139] = 169;
              t[140] = 8482;
              t[141] = 180;
              t[142] = 168;
              t[143] = 8800;
              t[144] = 198;
              t[145] = 216;
              t[146] = 8734;
              t[147] = 177;
              t[148] = 8804;
              t[149] = 8805;
              t[150] = 165;
              t[151] = 181;
              t[152] = 8706;
              t[153] = 8721;
              t[154] = 8719;
              t[156] = 8747;
              t[157] = 170;
              t[158] = 186;
              t[159] = 8486;
              t[160] = 230;
              t[161] = 248;
              t[162] = 191;
              t[163] = 161;
              t[164] = 172;
              t[165] = 8730;
              t[166] = 402;
              t[167] = 8776;
              t[168] = 8710;
              t[169] = 171;
              t[170] = 187;
              t[171] = 8230;
              t[210] = 218;
              t[223] = 711;
              t[224] = 321;
              t[225] = 322;
              t[227] = 353;
              t[229] = 382;
              t[234] = 253;
              t[252] = 263;
              t[253] = 268;
              t[254] = 269;
              t[258] = 258;
              t[260] = 260;
              t[261] = 261;
              t[265] = 280;
              t[266] = 281;
              t[268] = 283;
              t[269] = 313;
              t[275] = 323;
              t[276] = 324;
              t[278] = 328;
              t[284] = 345;
              t[285] = 346;
              t[286] = 347;
              t[292] = 367;
              t[295] = 377;
              t[296] = 378;
              t[298] = 380;
              t[305] = 963;
              t[306] = 964;
              t[307] = 966;
              t[308] = 8215;
              t[309] = 8252;
              t[310] = 8319;
              t[311] = 8359;
              t[312] = 8592;
              t[313] = 8593;
              t[337] = 9552;
              t[493] = 1039;
              t[494] = 1040;
              t[705] = 1524;
              t[706] = 8362;
              t[710] = 64288;
              t[711] = 64298;
              t[759] = 1617;
              t[761] = 1776;
              t[763] = 1778;
              t[775] = 1652;
              t[777] = 1764;
              t[778] = 1780;
              t[779] = 1781;
              t[780] = 1782;
              t[782] = 771;
              t[783] = 64726;
              t[786] = 8363;
              t[788] = 8532;
              t[790] = 768;
              t[791] = 769;
              t[792] = 768;
              t[795] = 803;
              t[797] = 64336;
              t[798] = 64337;
              t[799] = 64342;
              t[800] = 64343;
              t[801] = 64344;
              t[802] = 64345;
              t[803] = 64362;
              t[804] = 64363;
              t[805] = 64364;
              t[2424] = 7821;
              t[2425] = 7822;
              t[2426] = 7823;
              t[2427] = 7824;
              t[2428] = 7825;
              t[2429] = 7826;
              t[2430] = 7827;
              t[2433] = 7682;
              t[2678] = 8045;
              t[2679] = 8046;
              t[2830] = 1552;
              t[2838] = 686;
              t[2840] = 751;
              t[2842] = 753;
              t[2843] = 754;
              t[2844] = 755;
              t[2846] = 757;
              t[2856] = 767;
              t[2857] = 848;
              t[2858] = 849;
              t[2862] = 853;
              t[2863] = 854;
              t[2864] = 855;
              t[2865] = 861;
              t[2866] = 862;
              t[2906] = 7460;
              t[2908] = 7462;
              t[2909] = 7463;
              t[2910] = 7464;
              t[2912] = 7466;
              t[2913] = 7467;
              t[2914] = 7468;
              t[2916] = 7470;
              t[2917] = 7471;
              t[2918] = 7472;
              t[2920] = 7474;
              t[2921] = 7475;
              t[2922] = 7476;
              t[2924] = 7478;
              t[2925] = 7479;
              t[2926] = 7480;
              t[2928] = 7482;
              t[2929] = 7483;
              t[2930] = 7484;
              t[2932] = 7486;
              t[2933] = 7487;
              t[2934] = 7488;
              t[2936] = 7490;
              t[2937] = 7491;
              t[2938] = 7492;
              t[2940] = 7494;
              t[2941] = 7495;
              t[2942] = 7496;
              t[2944] = 7498;
              t[2946] = 7500;
              t[2948] = 7502;
              t[2950] = 7504;
              t[2951] = 7505;
              t[2952] = 7506;
              t[2954] = 7508;
              t[2955] = 7509;
              t[2956] = 7510;
              t[2958] = 7512;
              t[2959] = 7513;
              t[2960] = 7514;
              t[2962] = 7516;
              t[2963] = 7517;
              t[2964] = 7518;
              t[2966] = 7520;
              t[2967] = 7521;
              t[2968] = 7522;
              t[2970] = 7524;
              t[2971] = 7525;
              t[2972] = 7526;
              t[2974] = 7528;
              t[2975] = 7529;
              t[2976] = 7530;
              t[2978] = 1537;
              t[2979] = 1538;
              t[2980] = 1539;
              t[2982] = 1549;
              t[2983] = 1551;
              t[2984] = 1552;
              t[2986] = 1554;
              t[2987] = 1555;
              t[2988] = 1556;
              t[2990] = 1623;
              t[2991] = 1624;
              t[2995] = 1775;
              t[2999] = 1791;
              t[3002] = 64290;
              t[3003] = 64291;
              t[3004] = 64292;
              t[3006] = 64294;
              t[3007] = 64295;
              t[3008] = 64296;
              t[3011] = 1900;
              t[3014] = 8223;
              t[3015] = 8244;
              t[3017] = 7532;
              t[3018] = 7533;
              t[3019] = 7534;
              t[3075] = 7590;
              t[3076] = 7591;
              t[3079] = 7594;
              t[3080] = 7595;
              t[3083] = 7598;
              t[3084] = 7599;
              t[3087] = 7602;
              t[3088] = 7603;
              t[3091] = 7606;
              t[3092] = 7607;
              t[3095] = 7610;
              t[3096] = 7611;
              t[3099] = 7614;
              t[3100] = 7615;
              t[3103] = 7618;
              t[3104] = 7619;
              t[3107] = 8337;
              t[3108] = 8338;
              t[3116] = 1884;
              t[3119] = 1885;
              t[3120] = 1885;
              t[3123] = 1886;
              t[3124] = 1886;
              t[3127] = 1887;
              t[3128] = 1887;
              t[3131] = 1888;
              t[3132] = 1888;
              t[3135] = 1889;
              t[3136] = 1889;
              t[3139] = 1890;
              t[3140] = 1890;
              t[3143] = 1891;
              t[3144] = 1891;
              t[3147] = 1892;
              t[3148] = 1892;
              t[3153] = 580;
              t[3154] = 581;
              t[3157] = 584;
              t[3158] = 585;
              t[3161] = 588;
              t[3162] = 589;
              t[3165] = 891;
              t[3166] = 892;
              t[3169] = 1274;
              t[3170] = 1275;
              t[3173] = 1278;
              t[3174] = 1279;
              t[3181] = 7622;
              t[3182] = 7623;
              t[3282] = 11799;
              t[3316] = 578;
              t[3379] = 42785;
              t[3393] = 1159;
              t[3416] = 8377;
            });
            var getSupplementalGlyphMapForArialBlack = (0, _util.getLookupTableFactory)(function(t) {
              t[227] = 322;
              t[264] = 261;
              t[291] = 346;
            });
            var getSupplementalGlyphMapForCalibri = (0, _util.getLookupTableFactory)(function(t) {
              t[1] = 32;
              t[4] = 65;
              t[17] = 66;
              t[18] = 67;
              t[24] = 68;
              t[28] = 69;
              t[38] = 70;
              t[39] = 71;
              t[44] = 72;
              t[47] = 73;
              t[58] = 74;
              t[60] = 75;
              t[62] = 76;
              t[68] = 77;
              t[69] = 78;
              t[75] = 79;
              t[87] = 80;
              t[89] = 81;
              t[90] = 82;
              t[94] = 83;
              t[100] = 84;
              t[104] = 85;
              t[115] = 86;
              t[116] = 87;
              t[121] = 88;
              t[122] = 89;
              t[127] = 90;
              t[258] = 97;
              t[268] = 261;
              t[271] = 98;
              t[272] = 99;
              t[273] = 263;
              t[282] = 100;
              t[286] = 101;
              t[295] = 281;
              t[296] = 102;
              t[336] = 103;
              t[346] = 104;
              t[349] = 105;
              t[361] = 106;
              t[364] = 107;
              t[367] = 108;
              t[371] = 322;
              t[373] = 109;
              t[374] = 110;
              t[381] = 111;
              t[383] = 243;
              t[393] = 112;
              t[395] = 113;
              t[396] = 114;
              t[400] = 115;
              t[401] = 347;
              t[410] = 116;
              t[437] = 117;
              t[448] = 118;
              t[449] = 119;
              t[454] = 120;
              t[455] = 121;
              t[460] = 122;
              t[463] = 380;
              t[853] = 44;
              t[855] = 58;
              t[856] = 46;
              t[876] = 47;
              t[878] = 45;
              t[882] = 45;
              t[894] = 40;
              t[895] = 41;
              t[896] = 91;
              t[897] = 93;
              t[923] = 64;
              t[1004] = 48;
              t[1005] = 49;
              t[1006] = 50;
              t[1007] = 51;
              t[1008] = 52;
              t[1009] = 53;
              t[1010] = 54;
              t[1011] = 55;
              t[1012] = 56;
              t[1013] = 57;
              t[1081] = 37;
              t[1085] = 43;
              t[1086] = 45;
            });
            exports3.getStdFontMap = getStdFontMap;
            exports3.getNonStdFontMap = getNonStdFontMap;
            exports3.getSerifFonts = getSerifFonts;
            exports3.getSymbolsFonts = getSymbolsFonts;
            exports3.getGlyphMapForStandardFonts = getGlyphMapForStandardFonts;
            exports3.getSupplementalGlyphMapForArialBlack = getSupplementalGlyphMapForArialBlack;
            exports3.getSupplementalGlyphMapForCalibri = getSupplementalGlyphMapForCalibri;
          },
          /* 143 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            var getLookupTableFactory = __w_pdfjs_require__(2).getLookupTableFactory;
            var getSpecialPUASymbols = getLookupTableFactory(function(t) {
              t[63721] = 169;
              t[63193] = 169;
              t[63720] = 174;
              t[63194] = 174;
              t[63722] = 8482;
              t[63195] = 8482;
              t[63729] = 9127;
              t[63730] = 9128;
              t[63731] = 9129;
              t[63740] = 9131;
              t[63741] = 9132;
              t[63742] = 9133;
              t[63726] = 9121;
              t[63727] = 9122;
              t[63728] = 9123;
              t[63737] = 9124;
              t[63738] = 9125;
              t[63739] = 9126;
              t[63723] = 9115;
              t[63724] = 9116;
              t[63725] = 9117;
              t[63734] = 9118;
              t[63735] = 9119;
              t[63736] = 9120;
            });
            function mapSpecialUnicodeValues(code) {
              if (code >= 65520 && code <= 65535) {
                return 0;
              } else if (code >= 62976 && code <= 63743) {
                return getSpecialPUASymbols()[code] || code;
              } else if (code === 173) {
                return 45;
              }
              return code;
            }
            function getUnicodeForGlyph(name, glyphsUnicodeMap) {
              var unicode = glyphsUnicodeMap[name];
              if (unicode !== void 0) {
                return unicode;
              }
              if (!name) {
                return -1;
              }
              if (name[0] === "u") {
                var nameLen = name.length, hexStr;
                if (nameLen === 7 && name[1] === "n" && name[2] === "i") {
                  hexStr = name.substr(3);
                } else if (nameLen >= 5 && nameLen <= 7) {
                  hexStr = name.substr(1);
                } else {
                  return -1;
                }
                if (hexStr === hexStr.toUpperCase()) {
                  unicode = parseInt(hexStr, 16);
                  if (unicode >= 0) {
                    return unicode;
                  }
                }
              }
              return -1;
            }
            var UnicodeRanges = [
              {
                "begin": 0,
                "end": 127
              },
              {
                "begin": 128,
                "end": 255
              },
              {
                "begin": 256,
                "end": 383
              },
              {
                "begin": 384,
                "end": 591
              },
              {
                "begin": 592,
                "end": 687
              },
              {
                "begin": 688,
                "end": 767
              },
              {
                "begin": 768,
                "end": 879
              },
              {
                "begin": 880,
                "end": 1023
              },
              {
                "begin": 11392,
                "end": 11519
              },
              {
                "begin": 1024,
                "end": 1279
              },
              {
                "begin": 1328,
                "end": 1423
              },
              {
                "begin": 1424,
                "end": 1535
              },
              {
                "begin": 42240,
                "end": 42559
              },
              {
                "begin": 1536,
                "end": 1791
              },
              {
                "begin": 1984,
                "end": 2047
              },
              {
                "begin": 2304,
                "end": 2431
              },
              {
                "begin": 2432,
                "end": 2559
              },
              {
                "begin": 2560,
                "end": 2687
              },
              {
                "begin": 2688,
                "end": 2815
              },
              {
                "begin": 2816,
                "end": 2943
              },
              {
                "begin": 2944,
                "end": 3071
              },
              {
                "begin": 3072,
                "end": 3199
              },
              {
                "begin": 3200,
                "end": 3327
              },
              {
                "begin": 3328,
                "end": 3455
              },
              {
                "begin": 3584,
                "end": 3711
              },
              {
                "begin": 3712,
                "end": 3839
              },
              {
                "begin": 4256,
                "end": 4351
              },
              {
                "begin": 6912,
                "end": 7039
              },
              {
                "begin": 4352,
                "end": 4607
              },
              {
                "begin": 7680,
                "end": 7935
              },
              {
                "begin": 7936,
                "end": 8191
              },
              {
                "begin": 8192,
                "end": 8303
              },
              {
                "begin": 8304,
                "end": 8351
              },
              {
                "begin": 8352,
                "end": 8399
              },
              {
                "begin": 8400,
                "end": 8447
              },
              {
                "begin": 8448,
                "end": 8527
              },
              {
                "begin": 8528,
                "end": 8591
              },
              {
                "begin": 8592,
                "end": 8703
              },
              {
                "begin": 8704,
                "end": 8959
              },
              {
                "begin": 8960,
                "end": 9215
              },
              {
                "begin": 9216,
                "end": 9279
              },
              {
                "begin": 9280,
                "end": 9311
              },
              {
                "begin": 9312,
                "end": 9471
              },
              {
                "begin": 9472,
                "end": 9599
              },
              {
                "begin": 9600,
                "end": 9631
              },
              {
                "begin": 9632,
                "end": 9727
              },
              {
                "begin": 9728,
                "end": 9983
              },
              {
                "begin": 9984,
                "end": 10175
              },
              {
                "begin": 12288,
                "end": 12351
              },
              {
                "begin": 12352,
                "end": 12447
              },
              {
                "begin": 12448,
                "end": 12543
              },
              {
                "begin": 12544,
                "end": 12591
              },
              {
                "begin": 12592,
                "end": 12687
              },
              {
                "begin": 43072,
                "end": 43135
              },
              {
                "begin": 12800,
                "end": 13055
              },
              {
                "begin": 13056,
                "end": 13311
              },
              {
                "begin": 44032,
                "end": 55215
              },
              {
                "begin": 55296,
                "end": 57343
              },
              {
                "begin": 67840,
                "end": 67871
              },
              {
                "begin": 19968,
                "end": 40959
              },
              {
                "begin": 57344,
                "end": 63743
              },
              {
                "begin": 12736,
                "end": 12783
              },
              {
                "begin": 64256,
                "end": 64335
              },
              {
                "begin": 64336,
                "end": 65023
              },
              {
                "begin": 65056,
                "end": 65071
              },
              {
                "begin": 65040,
                "end": 65055
              },
              {
                "begin": 65104,
                "end": 65135
              },
              {
                "begin": 65136,
                "end": 65279
              },
              {
                "begin": 65280,
                "end": 65519
              },
              {
                "begin": 65520,
                "end": 65535
              },
              {
                "begin": 3840,
                "end": 4095
              },
              {
                "begin": 1792,
                "end": 1871
              },
              {
                "begin": 1920,
                "end": 1983
              },
              {
                "begin": 3456,
                "end": 3583
              },
              {
                "begin": 4096,
                "end": 4255
              },
              {
                "begin": 4608,
                "end": 4991
              },
              {
                "begin": 5024,
                "end": 5119
              },
              {
                "begin": 5120,
                "end": 5759
              },
              {
                "begin": 5760,
                "end": 5791
              },
              {
                "begin": 5792,
                "end": 5887
              },
              {
                "begin": 6016,
                "end": 6143
              },
              {
                "begin": 6144,
                "end": 6319
              },
              {
                "begin": 10240,
                "end": 10495
              },
              {
                "begin": 40960,
                "end": 42127
              },
              {
                "begin": 5888,
                "end": 5919
              },
              {
                "begin": 66304,
                "end": 66351
              },
              {
                "begin": 66352,
                "end": 66383
              },
              {
                "begin": 66560,
                "end": 66639
              },
              {
                "begin": 118784,
                "end": 119039
              },
              {
                "begin": 119808,
                "end": 120831
              },
              {
                "begin": 1044480,
                "end": 1048573
              },
              {
                "begin": 65024,
                "end": 65039
              },
              {
                "begin": 917504,
                "end": 917631
              },
              {
                "begin": 6400,
                "end": 6479
              },
              {
                "begin": 6480,
                "end": 6527
              },
              {
                "begin": 6528,
                "end": 6623
              },
              {
                "begin": 6656,
                "end": 6687
              },
              {
                "begin": 11264,
                "end": 11359
              },
              {
                "begin": 11568,
                "end": 11647
              },
              {
                "begin": 19904,
                "end": 19967
              },
              {
                "begin": 43008,
                "end": 43055
              },
              {
                "begin": 65536,
                "end": 65663
              },
              {
                "begin": 65856,
                "end": 65935
              },
              {
                "begin": 66432,
                "end": 66463
              },
              {
                "begin": 66464,
                "end": 66527
              },
              {
                "begin": 66640,
                "end": 66687
              },
              {
                "begin": 66688,
                "end": 66735
              },
              {
                "begin": 67584,
                "end": 67647
              },
              {
                "begin": 68096,
                "end": 68191
              },
              {
                "begin": 119552,
                "end": 119647
              },
              {
                "begin": 73728,
                "end": 74751
              },
              {
                "begin": 119648,
                "end": 119679
              },
              {
                "begin": 7040,
                "end": 7103
              },
              {
                "begin": 7168,
                "end": 7247
              },
              {
                "begin": 7248,
                "end": 7295
              },
              {
                "begin": 43136,
                "end": 43231
              },
              {
                "begin": 43264,
                "end": 43311
              },
              {
                "begin": 43312,
                "end": 43359
              },
              {
                "begin": 43520,
                "end": 43615
              },
              {
                "begin": 65936,
                "end": 65999
              },
              {
                "begin": 66e3,
                "end": 66047
              },
              {
                "begin": 66208,
                "end": 66271
              },
              {
                "begin": 127024,
                "end": 127135
              }
            ];
            function getUnicodeRangeFor(value) {
              for (var i = 0, ii = UnicodeRanges.length; i < ii; i++) {
                var range = UnicodeRanges[i];
                if (value >= range.begin && value < range.end) {
                  return i;
                }
              }
              return -1;
            }
            function isRTLRangeFor(value) {
              var range = UnicodeRanges[13];
              if (value >= range.begin && value < range.end) {
                return true;
              }
              range = UnicodeRanges[11];
              if (value >= range.begin && value < range.end) {
                return true;
              }
              return false;
            }
            var getNormalizedUnicodes = getLookupTableFactory(function(t) {
              t["¨"] = " ̈";
              t["¯"] = " ̄";
              t["´"] = " ́";
              t["µ"] = "μ";
              t["¸"] = " ̧";
              t["Ĳ"] = "IJ";
              t["ĳ"] = "ij";
              t["Ŀ"] = "L·";
              t["ŀ"] = "l·";
              t["ŉ"] = "ʼn";
              t["ſ"] = "s";
              t["Ǆ"] = "DŽ";
              t["ǅ"] = "Dž";
              t["ǆ"] = "dž";
              t["Ǉ"] = "LJ";
              t["ǈ"] = "Lj";
              t["ǉ"] = "lj";
              t["Ǌ"] = "NJ";
              t["ǋ"] = "Nj";
              t["ǌ"] = "nj";
              t["Ǳ"] = "DZ";
              t["ǲ"] = "Dz";
              t["ǳ"] = "dz";
              t["˘"] = " ̆";
              t["˙"] = " ̇";
              t["˚"] = " ̊";
              t["˛"] = " ̨";
              t["˜"] = " ̃";
              t["˝"] = " ̋";
              t["ͺ"] = " ͅ";
              t["΄"] = " ́";
              t["ϐ"] = "β";
              t["ϑ"] = "θ";
              t["ϒ"] = "Υ";
              t["ϕ"] = "φ";
              t["ϖ"] = "π";
              t["ϰ"] = "κ";
              t["ϱ"] = "ρ";
              t["ϲ"] = "ς";
              t["ϴ"] = "Θ";
              t["ϵ"] = "ε";
              t["Ϲ"] = "Σ";
              t["և"] = "եւ";
              t["ٵ"] = "اٴ";
              t["ٶ"] = "وٴ";
              t["ٷ"] = "ۇٴ";
              t["ٸ"] = "يٴ";
              t["ำ"] = "ํา";
              t["ຳ"] = "ໍາ";
              t["ໜ"] = "ຫນ";
              t["ໝ"] = "ຫມ";
              t["ཷ"] = "ྲཱྀ";
              t["ཹ"] = "ླཱྀ";
              t["ẚ"] = "aʾ";
              t["᾽"] = " ̓";
              t["᾿"] = " ̓";
              t["῀"] = " ͂";
              t["῾"] = " ̔";
              t[" "] = " ";
              t[" "] = " ";
              t[" "] = " ";
              t[" "] = " ";
              t[" "] = " ";
              t[" "] = " ";
              t[" "] = " ";
              t[" "] = " ";
              t["‗"] = " ̳";
              t["․"] = ".";
              t["‥"] = "..";
              t["…"] = "...";
              t["″"] = "′′";
              t["‴"] = "′′′";
              t["‶"] = "‵‵";
              t["‷"] = "‵‵‵";
              t["‼"] = "!!";
              t["‾"] = " ̅";
              t["⁇"] = "??";
              t["⁈"] = "?!";
              t["⁉"] = "!?";
              t["⁗"] = "′′′′";
              t[" "] = " ";
              t["₨"] = "Rs";
              t["℀"] = "a/c";
              t["℁"] = "a/s";
              t["℃"] = "°C";
              t["℅"] = "c/o";
              t["℆"] = "c/u";
              t["ℇ"] = "Ɛ";
              t["℉"] = "°F";
              t["№"] = "No";
              t["℡"] = "TEL";
              t["ℵ"] = "א";
              t["ℶ"] = "ב";
              t["ℷ"] = "ג";
              t["ℸ"] = "ד";
              t["℻"] = "FAX";
              t["Ⅰ"] = "I";
              t["Ⅱ"] = "II";
              t["Ⅲ"] = "III";
              t["Ⅳ"] = "IV";
              t["Ⅴ"] = "V";
              t["Ⅵ"] = "VI";
              t["Ⅶ"] = "VII";
              t["Ⅷ"] = "VIII";
              t["Ⅸ"] = "IX";
              t["Ⅹ"] = "X";
              t["Ⅺ"] = "XI";
              t["Ⅻ"] = "XII";
              t["Ⅼ"] = "L";
              t["Ⅽ"] = "C";
              t["Ⅾ"] = "D";
              t["Ⅿ"] = "M";
              t["ⅰ"] = "i";
              t["ⅱ"] = "ii";
              t["ⅲ"] = "iii";
              t["ⅳ"] = "iv";
              t["ⅴ"] = "v";
              t["ⅵ"] = "vi";
              t["ⅶ"] = "vii";
              t["ⅷ"] = "viii";
              t["ⅸ"] = "ix";
              t["ⅹ"] = "x";
              t["ⅺ"] = "xi";
              t["ⅻ"] = "xii";
              t["ⅼ"] = "l";
              t["ⅽ"] = "c";
              t["ⅾ"] = "d";
              t["ⅿ"] = "m";
              t["∬"] = "∫∫";
              t["∭"] = "∫∫∫";
              t["∯"] = "∮∮";
              t["∰"] = "∮∮∮";
              t["⑴"] = "(1)";
              t["⑵"] = "(2)";
              t["⑶"] = "(3)";
              t["⑷"] = "(4)";
              t["⑸"] = "(5)";
              t["⑹"] = "(6)";
              t["⑺"] = "(7)";
              t["⑻"] = "(8)";
              t["⑼"] = "(9)";
              t["⑽"] = "(10)";
              t["⑾"] = "(11)";
              t["⑿"] = "(12)";
              t["⒀"] = "(13)";
              t["⒁"] = "(14)";
              t["⒂"] = "(15)";
              t["⒃"] = "(16)";
              t["⒄"] = "(17)";
              t["⒅"] = "(18)";
              t["⒆"] = "(19)";
              t["⒇"] = "(20)";
              t["⒈"] = "1.";
              t["⒉"] = "2.";
              t["⒊"] = "3.";
              t["⒋"] = "4.";
              t["⒌"] = "5.";
              t["⒍"] = "6.";
              t["⒎"] = "7.";
              t["⒏"] = "8.";
              t["⒐"] = "9.";
              t["⒑"] = "10.";
              t["⒒"] = "11.";
              t["⒓"] = "12.";
              t["⒔"] = "13.";
              t["⒕"] = "14.";
              t["⒖"] = "15.";
              t["⒗"] = "16.";
              t["⒘"] = "17.";
              t["⒙"] = "18.";
              t["⒚"] = "19.";
              t["⒛"] = "20.";
              t["⒜"] = "(a)";
              t["⒝"] = "(b)";
              t["⒞"] = "(c)";
              t["⒟"] = "(d)";
              t["⒠"] = "(e)";
              t["⒡"] = "(f)";
              t["⒢"] = "(g)";
              t["⒣"] = "(h)";
              t["⒤"] = "(i)";
              t["⒥"] = "(j)";
              t["⒦"] = "(k)";
              t["⒧"] = "(l)";
              t["⒨"] = "(m)";
              t["⒩"] = "(n)";
              t["⒪"] = "(o)";
              t["⒫"] = "(p)";
              t["⒬"] = "(q)";
              t["⒭"] = "(r)";
              t["⒮"] = "(s)";
              t["⒯"] = "(t)";
              t["⒰"] = "(u)";
              t["⒱"] = "(v)";
              t["⒲"] = "(w)";
              t["⒳"] = "(x)";
              t["⒴"] = "(y)";
              t["⒵"] = "(z)";
              t["⨌"] = "∫∫∫∫";
              t["⩴"] = "::=";
              t["⩵"] = "==";
              t["⩶"] = "===";
              t["⺟"] = "母";
              t["⻳"] = "龟";
              t["⼀"] = "一";
              t["⼁"] = "丨";
              t["⼂"] = "丶";
              t["⼃"] = "丿";
              t["⼄"] = "乙";
              t["⼅"] = "亅";
              t["⼆"] = "二";
              t["⼇"] = "亠";
              t["⼈"] = "人";
              t["⼉"] = "儿";
              t["⼊"] = "入";
              t["⼋"] = "八";
              t["⼌"] = "冂";
              t["⼍"] = "冖";
              t["⼎"] = "冫";
              t["⼏"] = "几";
              t["⼐"] = "凵";
              t["⼑"] = "刀";
              t["⼒"] = "力";
              t["⼓"] = "勹";
              t["⼔"] = "匕";
              t["⼕"] = "匚";
              t["⼖"] = "匸";
              t["⼗"] = "十";
              t["⼘"] = "卜";
              t["⼙"] = "卩";
              t["⼚"] = "厂";
              t["⼛"] = "厶";
              t["⼜"] = "又";
              t["⼝"] = "口";
              t["⼞"] = "囗";
              t["⼟"] = "土";
              t["⼠"] = "士";
              t["⼡"] = "夂";
              t["⼢"] = "夊";
              t["⼣"] = "夕";
              t["⼤"] = "大";
              t["⼥"] = "女";
              t["⼦"] = "子";
              t["⼧"] = "宀";
              t["⼨"] = "寸";
              t["⼩"] = "小";
              t["⼪"] = "尢";
              t["⼫"] = "尸";
              t["⼬"] = "屮";
              t["⼭"] = "山";
              t["⼮"] = "巛";
              t["⼯"] = "工";
              t["⼰"] = "己";
              t["⼱"] = "巾";
              t["⼲"] = "干";
              t["⼳"] = "幺";
              t["⼴"] = "广";
              t["⼵"] = "廴";
              t["⼶"] = "廾";
              t["⼷"] = "弋";
              t["⼸"] = "弓";
              t["⼹"] = "彐";
              t["⼺"] = "彡";
              t["⼻"] = "彳";
              t["⼼"] = "心";
              t["⼽"] = "戈";
              t["⼾"] = "戶";
              t["⼿"] = "手";
              t["⽀"] = "支";
              t["⽁"] = "攴";
              t["⽂"] = "文";
              t["⽃"] = "斗";
              t["⽄"] = "斤";
              t["⽅"] = "方";
              t["⽆"] = "无";
              t["⽇"] = "日";
              t["⽈"] = "曰";
              t["⽉"] = "月";
              t["⽊"] = "木";
              t["⽋"] = "欠";
              t["⽌"] = "止";
              t["⽍"] = "歹";
              t["⽎"] = "殳";
              t["⽏"] = "毋";
              t["⽐"] = "比";
              t["⽑"] = "毛";
              t["⽒"] = "氏";
              t["⽓"] = "气";
              t["⽔"] = "水";
              t["⽕"] = "火";
              t["⽖"] = "爪";
              t["⽗"] = "父";
              t["⽘"] = "爻";
              t["⽙"] = "爿";
              t["⽚"] = "片";
              t["⽛"] = "牙";
              t["⽜"] = "牛";
              t["⽝"] = "犬";
              t["⽞"] = "玄";
              t["⽟"] = "玉";
              t["⽠"] = "瓜";
              t["⽡"] = "瓦";
              t["⽢"] = "甘";
              t["⽣"] = "生";
              t["⽤"] = "用";
              t["⽥"] = "田";
              t["⽦"] = "疋";
              t["⽧"] = "疒";
              t["⽨"] = "癶";
              t["⽩"] = "白";
              t["⽪"] = "皮";
              t["⽫"] = "皿";
              t["⽬"] = "目";
              t["⽭"] = "矛";
              t["⽮"] = "矢";
              t["⽯"] = "石";
              t["⽰"] = "示";
              t["⽱"] = "禸";
              t["⽲"] = "禾";
              t["⽳"] = "穴";
              t["⽴"] = "立";
              t["⽵"] = "竹";
              t["⽶"] = "米";
              t["⽷"] = "糸";
              t["⽸"] = "缶";
              t["⽹"] = "网";
              t["⽺"] = "羊";
              t["⽻"] = "羽";
              t["⽼"] = "老";
              t["⽽"] = "而";
              t["⽾"] = "耒";
              t["⽿"] = "耳";
              t["⾀"] = "聿";
              t["⾁"] = "肉";
              t["⾂"] = "臣";
              t["⾃"] = "自";
              t["⾄"] = "至";
              t["⾅"] = "臼";
              t["⾆"] = "舌";
              t["⾇"] = "舛";
              t["⾈"] = "舟";
              t["⾉"] = "艮";
              t["⾊"] = "色";
              t["⾋"] = "艸";
              t["⾌"] = "虍";
              t["⾍"] = "虫";
              t["⾎"] = "血";
              t["⾏"] = "行";
              t["⾐"] = "衣";
              t["⾑"] = "襾";
              t["⾒"] = "見";
              t["⾓"] = "角";
              t["⾔"] = "言";
              t["⾕"] = "谷";
              t["⾖"] = "豆";
              t["⾗"] = "豕";
              t["⾘"] = "豸";
              t["⾙"] = "貝";
              t["⾚"] = "赤";
              t["⾛"] = "走";
              t["⾜"] = "足";
              t["⾝"] = "身";
              t["⾞"] = "車";
              t["⾟"] = "辛";
              t["⾠"] = "辰";
              t["⾡"] = "辵";
              t["⾢"] = "邑";
              t["⾣"] = "酉";
              t["⾤"] = "釆";
              t["⾥"] = "里";
              t["⾦"] = "金";
              t["⾧"] = "長";
              t["⾨"] = "門";
              t["⾩"] = "阜";
              t["⾪"] = "隶";
              t["⾫"] = "隹";
              t["⾬"] = "雨";
              t["⾭"] = "靑";
              t["⾮"] = "非";
              t["⾯"] = "面";
              t["⾰"] = "革";
              t["⾱"] = "韋";
              t["⾲"] = "韭";
              t["⾳"] = "音";
              t["⾴"] = "頁";
              t["⾵"] = "風";
              t["⾶"] = "飛";
              t["⾷"] = "食";
              t["⾸"] = "首";
              t["⾹"] = "香";
              t["⾺"] = "馬";
              t["⾻"] = "骨";
              t["⾼"] = "高";
              t["⾽"] = "髟";
              t["⾾"] = "鬥";
              t["⾿"] = "鬯";
              t["⿀"] = "鬲";
              t["⿁"] = "鬼";
              t["⿂"] = "魚";
              t["⿃"] = "鳥";
              t["⿄"] = "鹵";
              t["⿅"] = "鹿";
              t["⿆"] = "麥";
              t["⿇"] = "麻";
              t["⿈"] = "黃";
              t["⿉"] = "黍";
              t["⿊"] = "黑";
              t["⿋"] = "黹";
              t["⿌"] = "黽";
              t["⿍"] = "鼎";
              t["⿎"] = "鼓";
              t["⿏"] = "鼠";
              t["⿐"] = "鼻";
              t["⿑"] = "齊";
              t["⿒"] = "齒";
              t["⿓"] = "龍";
              t["⿔"] = "龜";
              t["⿕"] = "龠";
              t["〶"] = "〒";
              t["〸"] = "十";
              t["〹"] = "卄";
              t["〺"] = "卅";
              t["゛"] = " ゙";
              t["゜"] = " ゚";
              t["ㄱ"] = "ᄀ";
              t["ㄲ"] = "ᄁ";
              t["ㄳ"] = "ᆪ";
              t["ㄴ"] = "ᄂ";
              t["ㄵ"] = "ᆬ";
              t["ㄶ"] = "ᆭ";
              t["ㄷ"] = "ᄃ";
              t["ㄸ"] = "ᄄ";
              t["ㄹ"] = "ᄅ";
              t["ㄺ"] = "ᆰ";
              t["ㄻ"] = "ᆱ";
              t["ㄼ"] = "ᆲ";
              t["ㄽ"] = "ᆳ";
              t["ㄾ"] = "ᆴ";
              t["ㄿ"] = "ᆵ";
              t["ㅀ"] = "ᄚ";
              t["ㅁ"] = "ᄆ";
              t["ㅂ"] = "ᄇ";
              t["ㅃ"] = "ᄈ";
              t["ㅄ"] = "ᄡ";
              t["ㅅ"] = "ᄉ";
              t["ㅆ"] = "ᄊ";
              t["ㅇ"] = "ᄋ";
              t["ㅈ"] = "ᄌ";
              t["ㅉ"] = "ᄍ";
              t["ㅊ"] = "ᄎ";
              t["ㅋ"] = "ᄏ";
              t["ㅌ"] = "ᄐ";
              t["ㅍ"] = "ᄑ";
              t["ㅎ"] = "ᄒ";
              t["ㅏ"] = "ᅡ";
              t["ㅐ"] = "ᅢ";
              t["ㅑ"] = "ᅣ";
              t["ㅒ"] = "ᅤ";
              t["ㅓ"] = "ᅥ";
              t["ㅔ"] = "ᅦ";
              t["ㅕ"] = "ᅧ";
              t["ㅖ"] = "ᅨ";
              t["ㅗ"] = "ᅩ";
              t["ㅘ"] = "ᅪ";
              t["ㅙ"] = "ᅫ";
              t["ㅚ"] = "ᅬ";
              t["ㅛ"] = "ᅭ";
              t["ㅜ"] = "ᅮ";
              t["ㅝ"] = "ᅯ";
              t["ㅞ"] = "ᅰ";
              t["ㅟ"] = "ᅱ";
              t["ㅠ"] = "ᅲ";
              t["ㅡ"] = "ᅳ";
              t["ㅢ"] = "ᅴ";
              t["ㅣ"] = "ᅵ";
              t["ㅤ"] = "ᅠ";
              t["ㅥ"] = "ᄔ";
              t["ㅦ"] = "ᄕ";
              t["ㅧ"] = "ᇇ";
              t["ㅨ"] = "ᇈ";
              t["ㅩ"] = "ᇌ";
              t["ㅪ"] = "ᇎ";
              t["ㅫ"] = "ᇓ";
              t["ㅬ"] = "ᇗ";
              t["ㅭ"] = "ᇙ";
              t["ㅮ"] = "ᄜ";
              t["ㅯ"] = "ᇝ";
              t["ㅰ"] = "ᇟ";
              t["ㅱ"] = "ᄝ";
              t["ㅲ"] = "ᄞ";
              t["ㅳ"] = "ᄠ";
              t["ㅴ"] = "ᄢ";
              t["ㅵ"] = "ᄣ";
              t["ㅶ"] = "ᄧ";
              t["ㅷ"] = "ᄩ";
              t["ㅸ"] = "ᄫ";
              t["ㅹ"] = "ᄬ";
              t["ㅺ"] = "ᄭ";
              t["ㅻ"] = "ᄮ";
              t["ㅼ"] = "ᄯ";
              t["ㅽ"] = "ᄲ";
              t["ㅾ"] = "ᄶ";
              t["ㅿ"] = "ᅀ";
              t["ㆀ"] = "ᅇ";
              t["ㆁ"] = "ᅌ";
              t["ㆂ"] = "ᇱ";
              t["ㆃ"] = "ᇲ";
              t["ㆄ"] = "ᅗ";
              t["ㆅ"] = "ᅘ";
              t["ㆆ"] = "ᅙ";
              t["ㆇ"] = "ᆄ";
              t["ㆈ"] = "ᆅ";
              t["ㆉ"] = "ᆈ";
              t["ㆊ"] = "ᆑ";
              t["ㆋ"] = "ᆒ";
              t["ㆌ"] = "ᆔ";
              t["ㆍ"] = "ᆞ";
              t["ㆎ"] = "ᆡ";
              t["㈀"] = "(ᄀ)";
              t["㈁"] = "(ᄂ)";
              t["㈂"] = "(ᄃ)";
              t["㈃"] = "(ᄅ)";
              t["㈄"] = "(ᄆ)";
              t["㈅"] = "(ᄇ)";
              t["㈆"] = "(ᄉ)";
              t["㈇"] = "(ᄋ)";
              t["㈈"] = "(ᄌ)";
              t["㈉"] = "(ᄎ)";
              t["㈊"] = "(ᄏ)";
              t["㈋"] = "(ᄐ)";
              t["㈌"] = "(ᄑ)";
              t["㈍"] = "(ᄒ)";
              t["㈎"] = "(가)";
              t["㈏"] = "(나)";
              t["㈐"] = "(다)";
              t["㈑"] = "(라)";
              t["㈒"] = "(마)";
              t["㈓"] = "(바)";
              t["㈔"] = "(사)";
              t["㈕"] = "(아)";
              t["㈖"] = "(자)";
              t["㈗"] = "(차)";
              t["㈘"] = "(카)";
              t["㈙"] = "(타)";
              t["㈚"] = "(파)";
              t["㈛"] = "(하)";
              t["㈜"] = "(주)";
              t["㈝"] = "(오전)";
              t["㈞"] = "(오후)";
              t["㈠"] = "(一)";
              t["㈡"] = "(二)";
              t["㈢"] = "(三)";
              t["㈣"] = "(四)";
              t["㈤"] = "(五)";
              t["㈥"] = "(六)";
              t["㈦"] = "(七)";
              t["㈧"] = "(八)";
              t["㈨"] = "(九)";
              t["㈩"] = "(十)";
              t["㈪"] = "(月)";
              t["㈫"] = "(火)";
              t["㈬"] = "(水)";
              t["㈭"] = "(木)";
              t["㈮"] = "(金)";
              t["㈯"] = "(土)";
              t["㈰"] = "(日)";
              t["㈱"] = "(株)";
              t["㈲"] = "(有)";
              t["㈳"] = "(社)";
              t["㈴"] = "(名)";
              t["㈵"] = "(特)";
              t["㈶"] = "(財)";
              t["㈷"] = "(祝)";
              t["㈸"] = "(労)";
              t["㈹"] = "(代)";
              t["㈺"] = "(呼)";
              t["㈻"] = "(学)";
              t["㈼"] = "(監)";
              t["㈽"] = "(企)";
              t["㈾"] = "(資)";
              t["㈿"] = "(協)";
              t["㉀"] = "(祭)";
              t["㉁"] = "(休)";
              t["㉂"] = "(自)";
              t["㉃"] = "(至)";
              t["㋀"] = "1月";
              t["㋁"] = "2月";
              t["㋂"] = "3月";
              t["㋃"] = "4月";
              t["㋄"] = "5月";
              t["㋅"] = "6月";
              t["㋆"] = "7月";
              t["㋇"] = "8月";
              t["㋈"] = "9月";
              t["㋉"] = "10月";
              t["㋊"] = "11月";
              t["㋋"] = "12月";
              t["㍘"] = "0点";
              t["㍙"] = "1点";
              t["㍚"] = "2点";
              t["㍛"] = "3点";
              t["㍜"] = "4点";
              t["㍝"] = "5点";
              t["㍞"] = "6点";
              t["㍟"] = "7点";
              t["㍠"] = "8点";
              t["㍡"] = "9点";
              t["㍢"] = "10点";
              t["㍣"] = "11点";
              t["㍤"] = "12点";
              t["㍥"] = "13点";
              t["㍦"] = "14点";
              t["㍧"] = "15点";
              t["㍨"] = "16点";
              t["㍩"] = "17点";
              t["㍪"] = "18点";
              t["㍫"] = "19点";
              t["㍬"] = "20点";
              t["㍭"] = "21点";
              t["㍮"] = "22点";
              t["㍯"] = "23点";
              t["㍰"] = "24点";
              t["㏠"] = "1日";
              t["㏡"] = "2日";
              t["㏢"] = "3日";
              t["㏣"] = "4日";
              t["㏤"] = "5日";
              t["㏥"] = "6日";
              t["㏦"] = "7日";
              t["㏧"] = "8日";
              t["㏨"] = "9日";
              t["㏩"] = "10日";
              t["㏪"] = "11日";
              t["㏫"] = "12日";
              t["㏬"] = "13日";
              t["㏭"] = "14日";
              t["㏮"] = "15日";
              t["㏯"] = "16日";
              t["㏰"] = "17日";
              t["㏱"] = "18日";
              t["㏲"] = "19日";
              t["㏳"] = "20日";
              t["㏴"] = "21日";
              t["㏵"] = "22日";
              t["㏶"] = "23日";
              t["㏷"] = "24日";
              t["㏸"] = "25日";
              t["㏹"] = "26日";
              t["㏺"] = "27日";
              t["㏻"] = "28日";
              t["㏼"] = "29日";
              t["㏽"] = "30日";
              t["㏾"] = "31日";
              t["ﬀ"] = "ff";
              t["ﬁ"] = "fi";
              t["ﬂ"] = "fl";
              t["ﬃ"] = "ffi";
              t["ﬄ"] = "ffl";
              t["ﬅ"] = "ſt";
              t["ﬆ"] = "st";
              t["ﬓ"] = "մն";
              t["ﬔ"] = "մե";
              t["ﬕ"] = "մի";
              t["ﬖ"] = "վն";
              t["ﬗ"] = "մխ";
              t["ﭏ"] = "אל";
              t["ﭐ"] = "ٱ";
              t["ﭑ"] = "ٱ";
              t["ﭒ"] = "ٻ";
              t["ﭓ"] = "ٻ";
              t["ﭔ"] = "ٻ";
              t["ﭕ"] = "ٻ";
              t["ﭖ"] = "پ";
              t["ﭗ"] = "پ";
              t["ﭘ"] = "پ";
              t["ﭙ"] = "پ";
              t["ﭚ"] = "ڀ";
              t["ﭛ"] = "ڀ";
              t["ﭜ"] = "ڀ";
              t["ﭝ"] = "ڀ";
              t["ﭞ"] = "ٺ";
              t["ﭟ"] = "ٺ";
              t["ﭠ"] = "ٺ";
              t["ﭡ"] = "ٺ";
              t["ﭢ"] = "ٿ";
              t["ﭣ"] = "ٿ";
              t["ﭤ"] = "ٿ";
              t["ﭥ"] = "ٿ";
              t["ﭦ"] = "ٹ";
              t["ﭧ"] = "ٹ";
              t["ﭨ"] = "ٹ";
              t["ﭩ"] = "ٹ";
              t["ﭪ"] = "ڤ";
              t["ﭫ"] = "ڤ";
              t["ﭬ"] = "ڤ";
              t["ﭭ"] = "ڤ";
              t["ﭮ"] = "ڦ";
              t["ﭯ"] = "ڦ";
              t["ﭰ"] = "ڦ";
              t["ﭱ"] = "ڦ";
              t["ﭲ"] = "ڄ";
              t["ﭳ"] = "ڄ";
              t["ﭴ"] = "ڄ";
              t["ﭵ"] = "ڄ";
              t["ﭶ"] = "ڃ";
              t["ﭷ"] = "ڃ";
              t["ﭸ"] = "ڃ";
              t["ﭹ"] = "ڃ";
              t["ﭺ"] = "چ";
              t["ﭻ"] = "چ";
              t["ﭼ"] = "چ";
              t["ﭽ"] = "چ";
              t["ﭾ"] = "ڇ";
              t["ﭿ"] = "ڇ";
              t["ﮀ"] = "ڇ";
              t["ﮁ"] = "ڇ";
              t["ﮂ"] = "ڍ";
              t["ﮃ"] = "ڍ";
              t["ﮄ"] = "ڌ";
              t["ﮅ"] = "ڌ";
              t["ﮆ"] = "ڎ";
              t["ﮇ"] = "ڎ";
              t["ﮈ"] = "ڈ";
              t["ﮉ"] = "ڈ";
              t["ﮊ"] = "ژ";
              t["ﮋ"] = "ژ";
              t["ﮌ"] = "ڑ";
              t["ﮍ"] = "ڑ";
              t["ﮎ"] = "ک";
              t["ﮏ"] = "ک";
              t["ﮐ"] = "ک";
              t["ﮑ"] = "ک";
              t["ﮒ"] = "گ";
              t["ﮓ"] = "گ";
              t["ﮔ"] = "گ";
              t["ﮕ"] = "گ";
              t["ﮖ"] = "ڳ";
              t["ﮗ"] = "ڳ";
              t["ﮘ"] = "ڳ";
              t["ﮙ"] = "ڳ";
              t["ﮚ"] = "ڱ";
              t["ﮛ"] = "ڱ";
              t["ﮜ"] = "ڱ";
              t["ﮝ"] = "ڱ";
              t["ﮞ"] = "ں";
              t["ﮟ"] = "ں";
              t["ﮠ"] = "ڻ";
              t["ﮡ"] = "ڻ";
              t["ﮢ"] = "ڻ";
              t["ﮣ"] = "ڻ";
              t["ﮤ"] = "ۀ";
              t["ﮥ"] = "ۀ";
              t["ﮦ"] = "ہ";
              t["ﮧ"] = "ہ";
              t["ﮨ"] = "ہ";
              t["ﮩ"] = "ہ";
              t["ﮪ"] = "ھ";
              t["ﮫ"] = "ھ";
              t["ﮬ"] = "ھ";
              t["ﮭ"] = "ھ";
              t["ﮮ"] = "ے";
              t["ﮯ"] = "ے";
              t["ﮰ"] = "ۓ";
              t["ﮱ"] = "ۓ";
              t["ﯓ"] = "ڭ";
              t["ﯔ"] = "ڭ";
              t["ﯕ"] = "ڭ";
              t["ﯖ"] = "ڭ";
              t["ﯗ"] = "ۇ";
              t["ﯘ"] = "ۇ";
              t["ﯙ"] = "ۆ";
              t["ﯚ"] = "ۆ";
              t["ﯛ"] = "ۈ";
              t["ﯜ"] = "ۈ";
              t["ﯝ"] = "ٷ";
              t["ﯞ"] = "ۋ";
              t["ﯟ"] = "ۋ";
              t["ﯠ"] = "ۅ";
              t["ﯡ"] = "ۅ";
              t["ﯢ"] = "ۉ";
              t["ﯣ"] = "ۉ";
              t["ﯤ"] = "ې";
              t["ﯥ"] = "ې";
              t["ﯦ"] = "ې";
              t["ﯧ"] = "ې";
              t["ﯨ"] = "ى";
              t["ﯩ"] = "ى";
              t["ﯪ"] = "ئا";
              t["ﯫ"] = "ئا";
              t["ﯬ"] = "ئە";
              t["ﯭ"] = "ئە";
              t["ﯮ"] = "ئو";
              t["ﯯ"] = "ئو";
              t["ﯰ"] = "ئۇ";
              t["ﯱ"] = "ئۇ";
              t["ﯲ"] = "ئۆ";
              t["ﯳ"] = "ئۆ";
              t["ﯴ"] = "ئۈ";
              t["ﯵ"] = "ئۈ";
              t["ﯶ"] = "ئې";
              t["ﯷ"] = "ئې";
              t["ﯸ"] = "ئې";
              t["ﯹ"] = "ئى";
              t["ﯺ"] = "ئى";
              t["ﯻ"] = "ئى";
              t["ﯼ"] = "ی";
              t["ﯽ"] = "ی";
              t["ﯾ"] = "ی";
              t["ﯿ"] = "ی";
              t["ﰀ"] = "ئج";
              t["ﰁ"] = "ئح";
              t["ﰂ"] = "ئم";
              t["ﰃ"] = "ئى";
              t["ﰄ"] = "ئي";
              t["ﰅ"] = "بج";
              t["ﰆ"] = "بح";
              t["ﰇ"] = "بخ";
              t["ﰈ"] = "بم";
              t["ﰉ"] = "بى";
              t["ﰊ"] = "بي";
              t["ﰋ"] = "تج";
              t["ﰌ"] = "تح";
              t["ﰍ"] = "تخ";
              t["ﰎ"] = "تم";
              t["ﰏ"] = "تى";
              t["ﰐ"] = "تي";
              t["ﰑ"] = "ثج";
              t["ﰒ"] = "ثم";
              t["ﰓ"] = "ثى";
              t["ﰔ"] = "ثي";
              t["ﰕ"] = "جح";
              t["ﰖ"] = "جم";
              t["ﰗ"] = "حج";
              t["ﰘ"] = "حم";
              t["ﰙ"] = "خج";
              t["ﰚ"] = "خح";
              t["ﰛ"] = "خم";
              t["ﰜ"] = "سج";
              t["ﰝ"] = "سح";
              t["ﰞ"] = "سخ";
              t["ﰟ"] = "سم";
              t["ﰠ"] = "صح";
              t["ﰡ"] = "صم";
              t["ﰢ"] = "ضج";
              t["ﰣ"] = "ضح";
              t["ﰤ"] = "ضخ";
              t["ﰥ"] = "ضم";
              t["ﰦ"] = "طح";
              t["ﰧ"] = "طم";
              t["ﰨ"] = "ظم";
              t["ﰩ"] = "عج";
              t["ﰪ"] = "عم";
              t["ﰫ"] = "غج";
              t["ﰬ"] = "غم";
              t["ﰭ"] = "فج";
              t["ﰮ"] = "فح";
              t["ﰯ"] = "فخ";
              t["ﰰ"] = "فم";
              t["ﰱ"] = "فى";
              t["ﰲ"] = "في";
              t["ﰳ"] = "قح";
              t["ﰴ"] = "قم";
              t["ﰵ"] = "قى";
              t["ﰶ"] = "قي";
              t["ﰷ"] = "كا";
              t["ﰸ"] = "كج";
              t["ﰹ"] = "كح";
              t["ﰺ"] = "كخ";
              t["ﰻ"] = "كل";
              t["ﰼ"] = "كم";
              t["ﰽ"] = "كى";
              t["ﰾ"] = "كي";
              t["ﰿ"] = "لج";
              t["ﱀ"] = "لح";
              t["ﱁ"] = "لخ";
              t["ﱂ"] = "لم";
              t["ﱃ"] = "لى";
              t["ﱄ"] = "لي";
              t["ﱅ"] = "مج";
              t["ﱆ"] = "مح";
              t["ﱇ"] = "مخ";
              t["ﱈ"] = "مم";
              t["ﱉ"] = "مى";
              t["ﱊ"] = "مي";
              t["ﱋ"] = "نج";
              t["ﱌ"] = "نح";
              t["ﱍ"] = "نخ";
              t["ﱎ"] = "نم";
              t["ﱏ"] = "نى";
              t["ﱐ"] = "ني";
              t["ﱑ"] = "هج";
              t["ﱒ"] = "هم";
              t["ﱓ"] = "هى";
              t["ﱔ"] = "هي";
              t["ﱕ"] = "يج";
              t["ﱖ"] = "يح";
              t["ﱗ"] = "يخ";
              t["ﱘ"] = "يم";
              t["ﱙ"] = "يى";
              t["ﱚ"] = "يي";
              t["ﱛ"] = "ذٰ";
              t["ﱜ"] = "رٰ";
              t["ﱝ"] = "ىٰ";
              t["ﱞ"] = " ٌّ";
              t["ﱟ"] = " ٍّ";
              t["ﱠ"] = " َّ";
              t["ﱡ"] = " ُّ";
              t["ﱢ"] = " ِّ";
              t["ﱣ"] = " ّٰ";
              t["ﱤ"] = "ئر";
              t["ﱥ"] = "ئز";
              t["ﱦ"] = "ئم";
              t["ﱧ"] = "ئن";
              t["ﱨ"] = "ئى";
              t["ﱩ"] = "ئي";
              t["ﱪ"] = "بر";
              t["ﱫ"] = "بز";
              t["ﱬ"] = "بم";
              t["ﱭ"] = "بن";
              t["ﱮ"] = "بى";
              t["ﱯ"] = "بي";
              t["ﱰ"] = "تر";
              t["ﱱ"] = "تز";
              t["ﱲ"] = "تم";
              t["ﱳ"] = "تن";
              t["ﱴ"] = "تى";
              t["ﱵ"] = "تي";
              t["ﱶ"] = "ثر";
              t["ﱷ"] = "ثز";
              t["ﱸ"] = "ثم";
              t["ﱹ"] = "ثن";
              t["ﱺ"] = "ثى";
              t["ﱻ"] = "ثي";
              t["ﱼ"] = "فى";
              t["ﱽ"] = "في";
              t["ﱾ"] = "قى";
              t["ﱿ"] = "قي";
              t["ﲀ"] = "كا";
              t["ﲁ"] = "كل";
              t["ﲂ"] = "كم";
              t["ﲃ"] = "كى";
              t["ﲄ"] = "كي";
              t["ﲅ"] = "لم";
              t["ﲆ"] = "لى";
              t["ﲇ"] = "لي";
              t["ﲈ"] = "ما";
              t["ﲉ"] = "مم";
              t["ﲊ"] = "نر";
              t["ﲋ"] = "نز";
              t["ﲌ"] = "نم";
              t["ﲍ"] = "نن";
              t["ﲎ"] = "نى";
              t["ﲏ"] = "ني";
              t["ﲐ"] = "ىٰ";
              t["ﲑ"] = "ير";
              t["ﲒ"] = "يز";
              t["ﲓ"] = "يم";
              t["ﲔ"] = "ين";
              t["ﲕ"] = "يى";
              t["ﲖ"] = "يي";
              t["ﲗ"] = "ئج";
              t["ﲘ"] = "ئح";
              t["ﲙ"] = "ئخ";
              t["ﲚ"] = "ئم";
              t["ﲛ"] = "ئه";
              t["ﲜ"] = "بج";
              t["ﲝ"] = "بح";
              t["ﲞ"] = "بخ";
              t["ﲟ"] = "بم";
              t["ﲠ"] = "به";
              t["ﲡ"] = "تج";
              t["ﲢ"] = "تح";
              t["ﲣ"] = "تخ";
              t["ﲤ"] = "تم";
              t["ﲥ"] = "ته";
              t["ﲦ"] = "ثم";
              t["ﲧ"] = "جح";
              t["ﲨ"] = "جم";
              t["ﲩ"] = "حج";
              t["ﲪ"] = "حم";
              t["ﲫ"] = "خج";
              t["ﲬ"] = "خم";
              t["ﲭ"] = "سج";
              t["ﲮ"] = "سح";
              t["ﲯ"] = "سخ";
              t["ﲰ"] = "سم";
              t["ﲱ"] = "صح";
              t["ﲲ"] = "صخ";
              t["ﲳ"] = "صم";
              t["ﲴ"] = "ضج";
              t["ﲵ"] = "ضح";
              t["ﲶ"] = "ضخ";
              t["ﲷ"] = "ضم";
              t["ﲸ"] = "طح";
              t["ﲹ"] = "ظم";
              t["ﲺ"] = "عج";
              t["ﲻ"] = "عم";
              t["ﲼ"] = "غج";
              t["ﲽ"] = "غم";
              t["ﲾ"] = "فج";
              t["ﲿ"] = "فح";
              t["ﳀ"] = "فخ";
              t["ﳁ"] = "فم";
              t["ﳂ"] = "قح";
              t["ﳃ"] = "قم";
              t["ﳄ"] = "كج";
              t["ﳅ"] = "كح";
              t["ﳆ"] = "كخ";
              t["ﳇ"] = "كل";
              t["ﳈ"] = "كم";
              t["ﳉ"] = "لج";
              t["ﳊ"] = "لح";
              t["ﳋ"] = "لخ";
              t["ﳌ"] = "لم";
              t["ﳍ"] = "له";
              t["ﳎ"] = "مج";
              t["ﳏ"] = "مح";
              t["ﳐ"] = "مخ";
              t["ﳑ"] = "مم";
              t["ﳒ"] = "نج";
              t["ﳓ"] = "نح";
              t["ﳔ"] = "نخ";
              t["ﳕ"] = "نم";
              t["ﳖ"] = "نه";
              t["ﳗ"] = "هج";
              t["ﳘ"] = "هم";
              t["ﳙ"] = "هٰ";
              t["ﳚ"] = "يج";
              t["ﳛ"] = "يح";
              t["ﳜ"] = "يخ";
              t["ﳝ"] = "يم";
              t["ﳞ"] = "يه";
              t["ﳟ"] = "ئم";
              t["ﳠ"] = "ئه";
              t["ﳡ"] = "بم";
              t["ﳢ"] = "به";
              t["ﳣ"] = "تم";
              t["ﳤ"] = "ته";
              t["ﳥ"] = "ثم";
              t["ﳦ"] = "ثه";
              t["ﳧ"] = "سم";
              t["ﳨ"] = "سه";
              t["ﳩ"] = "شم";
              t["ﳪ"] = "شه";
              t["ﳫ"] = "كل";
              t["ﳬ"] = "كم";
              t["ﳭ"] = "لم";
              t["ﳮ"] = "نم";
              t["ﳯ"] = "نه";
              t["ﳰ"] = "يم";
              t["ﳱ"] = "يه";
              t["ﳲ"] = "ـَّ";
              t["ﳳ"] = "ـُّ";
              t["ﳴ"] = "ـِّ";
              t["ﳵ"] = "طى";
              t["ﳶ"] = "طي";
              t["ﳷ"] = "عى";
              t["ﳸ"] = "عي";
              t["ﳹ"] = "غى";
              t["ﳺ"] = "غي";
              t["ﳻ"] = "سى";
              t["ﳼ"] = "سي";
              t["ﳽ"] = "شى";
              t["ﳾ"] = "شي";
              t["ﳿ"] = "حى";
              t["ﴀ"] = "حي";
              t["ﴁ"] = "جى";
              t["ﴂ"] = "جي";
              t["ﴃ"] = "خى";
              t["ﴄ"] = "خي";
              t["ﴅ"] = "صى";
              t["ﴆ"] = "صي";
              t["ﴇ"] = "ضى";
              t["ﴈ"] = "ضي";
              t["ﴉ"] = "شج";
              t["ﴊ"] = "شح";
              t["ﴋ"] = "شخ";
              t["ﴌ"] = "شم";
              t["ﴍ"] = "شر";
              t["ﴎ"] = "سر";
              t["ﴏ"] = "صر";
              t["ﴐ"] = "ضر";
              t["ﴑ"] = "طى";
              t["ﴒ"] = "طي";
              t["ﴓ"] = "عى";
              t["ﴔ"] = "عي";
              t["ﴕ"] = "غى";
              t["ﴖ"] = "غي";
              t["ﴗ"] = "سى";
              t["ﴘ"] = "سي";
              t["ﴙ"] = "شى";
              t["ﴚ"] = "شي";
              t["ﴛ"] = "حى";
              t["ﴜ"] = "حي";
              t["ﴝ"] = "جى";
              t["ﴞ"] = "جي";
              t["ﴟ"] = "خى";
              t["ﴠ"] = "خي";
              t["ﴡ"] = "صى";
              t["ﴢ"] = "صي";
              t["ﴣ"] = "ضى";
              t["ﴤ"] = "ضي";
              t["ﴥ"] = "شج";
              t["ﴦ"] = "شح";
              t["ﴧ"] = "شخ";
              t["ﴨ"] = "شم";
              t["ﴩ"] = "شر";
              t["ﴪ"] = "سر";
              t["ﴫ"] = "صر";
              t["ﴬ"] = "ضر";
              t["ﴭ"] = "شج";
              t["ﴮ"] = "شح";
              t["ﴯ"] = "شخ";
              t["ﴰ"] = "شم";
              t["ﴱ"] = "سه";
              t["ﴲ"] = "شه";
              t["ﴳ"] = "طم";
              t["ﴴ"] = "سج";
              t["ﴵ"] = "سح";
              t["ﴶ"] = "سخ";
              t["ﴷ"] = "شج";
              t["ﴸ"] = "شح";
              t["ﴹ"] = "شخ";
              t["ﴺ"] = "طم";
              t["ﴻ"] = "ظم";
              t["ﴼ"] = "اً";
              t["ﴽ"] = "اً";
              t["ﵐ"] = "تجم";
              t["ﵑ"] = "تحج";
              t["ﵒ"] = "تحج";
              t["ﵓ"] = "تحم";
              t["ﵔ"] = "تخم";
              t["ﵕ"] = "تمج";
              t["ﵖ"] = "تمح";
              t["ﵗ"] = "تمخ";
              t["ﵘ"] = "جمح";
              t["ﵙ"] = "جمح";
              t["ﵚ"] = "حمي";
              t["ﵛ"] = "حمى";
              t["ﵜ"] = "سحج";
              t["ﵝ"] = "سجح";
              t["ﵞ"] = "سجى";
              t["ﵟ"] = "سمح";
              t["ﵠ"] = "سمح";
              t["ﵡ"] = "سمج";
              t["ﵢ"] = "سمم";
              t["ﵣ"] = "سمم";
              t["ﵤ"] = "صحح";
              t["ﵥ"] = "صحح";
              t["ﵦ"] = "صمم";
              t["ﵧ"] = "شحم";
              t["ﵨ"] = "شحم";
              t["ﵩ"] = "شجي";
              t["ﵪ"] = "شمخ";
              t["ﵫ"] = "شمخ";
              t["ﵬ"] = "شمم";
              t["ﵭ"] = "شمم";
              t["ﵮ"] = "ضحى";
              t["ﵯ"] = "ضخم";
              t["ﵰ"] = "ضخم";
              t["ﵱ"] = "طمح";
              t["ﵲ"] = "طمح";
              t["ﵳ"] = "طمم";
              t["ﵴ"] = "طمي";
              t["ﵵ"] = "عجم";
              t["ﵶ"] = "عمم";
              t["ﵷ"] = "عمم";
              t["ﵸ"] = "عمى";
              t["ﵹ"] = "غمم";
              t["ﵺ"] = "غمي";
              t["ﵻ"] = "غمى";
              t["ﵼ"] = "فخم";
              t["ﵽ"] = "فخم";
              t["ﵾ"] = "قمح";
              t["ﵿ"] = "قمم";
              t["ﶀ"] = "لحم";
              t["ﶁ"] = "لحي";
              t["ﶂ"] = "لحى";
              t["ﶃ"] = "لجج";
              t["ﶄ"] = "لجج";
              t["ﶅ"] = "لخم";
              t["ﶆ"] = "لخم";
              t["ﶇ"] = "لمح";
              t["ﶈ"] = "لمح";
              t["ﶉ"] = "محج";
              t["ﶊ"] = "محم";
              t["ﶋ"] = "محي";
              t["ﶌ"] = "مجح";
              t["ﶍ"] = "مجم";
              t["ﶎ"] = "مخج";
              t["ﶏ"] = "مخم";
              t["ﶒ"] = "مجخ";
              t["ﶓ"] = "همج";
              t["ﶔ"] = "همم";
              t["ﶕ"] = "نحم";
              t["ﶖ"] = "نحى";
              t["ﶗ"] = "نجم";
              t["ﶘ"] = "نجم";
              t["ﶙ"] = "نجى";
              t["ﶚ"] = "نمي";
              t["ﶛ"] = "نمى";
              t["ﶜ"] = "يمم";
              t["ﶝ"] = "يمم";
              t["ﶞ"] = "بخي";
              t["ﶟ"] = "تجي";
              t["ﶠ"] = "تجى";
              t["ﶡ"] = "تخي";
              t["ﶢ"] = "تخى";
              t["ﶣ"] = "تمي";
              t["ﶤ"] = "تمى";
              t["ﶥ"] = "جمي";
              t["ﶦ"] = "جحى";
              t["ﶧ"] = "جمى";
              t["ﶨ"] = "سخى";
              t["ﶩ"] = "صحي";
              t["ﶪ"] = "شحي";
              t["ﶫ"] = "ضحي";
              t["ﶬ"] = "لجي";
              t["ﶭ"] = "لمي";
              t["ﶮ"] = "يحي";
              t["ﶯ"] = "يجي";
              t["ﶰ"] = "يمي";
              t["ﶱ"] = "ممي";
              t["ﶲ"] = "قمي";
              t["ﶳ"] = "نحي";
              t["ﶴ"] = "قمح";
              t["ﶵ"] = "لحم";
              t["ﶶ"] = "عمي";
              t["ﶷ"] = "كمي";
              t["ﶸ"] = "نجح";
              t["ﶹ"] = "مخي";
              t["ﶺ"] = "لجم";
              t["ﶻ"] = "كمم";
              t["ﶼ"] = "لجم";
              t["ﶽ"] = "نجح";
              t["ﶾ"] = "جحي";
              t["ﶿ"] = "حجي";
              t["ﷀ"] = "مجي";
              t["ﷁ"] = "فمي";
              t["ﷂ"] = "بحي";
              t["ﷃ"] = "كمم";
              t["ﷄ"] = "عجم";
              t["ﷅ"] = "صمم";
              t["ﷆ"] = "سخي";
              t["ﷇ"] = "نجي";
              t["﹉"] = "‾";
              t["﹊"] = "‾";
              t["﹋"] = "‾";
              t["﹌"] = "‾";
              t["﹍"] = "_";
              t["﹎"] = "_";
              t["﹏"] = "_";
              t["ﺀ"] = "ء";
              t["ﺁ"] = "آ";
              t["ﺂ"] = "آ";
              t["ﺃ"] = "أ";
              t["ﺄ"] = "أ";
              t["ﺅ"] = "ؤ";
              t["ﺆ"] = "ؤ";
              t["ﺇ"] = "إ";
              t["ﺈ"] = "إ";
              t["ﺉ"] = "ئ";
              t["ﺊ"] = "ئ";
              t["ﺋ"] = "ئ";
              t["ﺌ"] = "ئ";
              t["ﺍ"] = "ا";
              t["ﺎ"] = "ا";
              t["ﺏ"] = "ب";
              t["ﺐ"] = "ب";
              t["ﺑ"] = "ب";
              t["ﺒ"] = "ب";
              t["ﺓ"] = "ة";
              t["ﺔ"] = "ة";
              t["ﺕ"] = "ت";
              t["ﺖ"] = "ت";
              t["ﺗ"] = "ت";
              t["ﺘ"] = "ت";
              t["ﺙ"] = "ث";
              t["ﺚ"] = "ث";
              t["ﺛ"] = "ث";
              t["ﺜ"] = "ث";
              t["ﺝ"] = "ج";
              t["ﺞ"] = "ج";
              t["ﺟ"] = "ج";
              t["ﺠ"] = "ج";
              t["ﺡ"] = "ح";
              t["ﺢ"] = "ح";
              t["ﺣ"] = "ح";
              t["ﺤ"] = "ح";
              t["ﺥ"] = "خ";
              t["ﺦ"] = "خ";
              t["ﺧ"] = "خ";
              t["ﺨ"] = "خ";
              t["ﺩ"] = "د";
              t["ﺪ"] = "د";
              t["ﺫ"] = "ذ";
              t["ﺬ"] = "ذ";
              t["ﺭ"] = "ر";
              t["ﺮ"] = "ر";
              t["ﺯ"] = "ز";
              t["ﺰ"] = "ز";
              t["ﺱ"] = "س";
              t["ﺲ"] = "س";
              t["ﺳ"] = "س";
              t["ﺴ"] = "س";
              t["ﺵ"] = "ش";
              t["ﺶ"] = "ش";
              t["ﺷ"] = "ش";
              t["ﺸ"] = "ش";
              t["ﺹ"] = "ص";
              t["ﺺ"] = "ص";
              t["ﺻ"] = "ص";
              t["ﺼ"] = "ص";
              t["ﺽ"] = "ض";
              t["ﺾ"] = "ض";
              t["ﺿ"] = "ض";
              t["ﻀ"] = "ض";
              t["ﻁ"] = "ط";
              t["ﻂ"] = "ط";
              t["ﻃ"] = "ط";
              t["ﻄ"] = "ط";
              t["ﻅ"] = "ظ";
              t["ﻆ"] = "ظ";
              t["ﻇ"] = "ظ";
              t["ﻈ"] = "ظ";
              t["ﻉ"] = "ع";
              t["ﻊ"] = "ع";
              t["ﻋ"] = "ع";
              t["ﻌ"] = "ع";
              t["ﻍ"] = "غ";
              t["ﻎ"] = "غ";
              t["ﻏ"] = "غ";
              t["ﻐ"] = "غ";
              t["ﻑ"] = "ف";
              t["ﻒ"] = "ف";
              t["ﻓ"] = "ف";
              t["ﻔ"] = "ف";
              t["ﻕ"] = "ق";
              t["ﻖ"] = "ق";
              t["ﻗ"] = "ق";
              t["ﻘ"] = "ق";
              t["ﻙ"] = "ك";
              t["ﻚ"] = "ك";
              t["ﻛ"] = "ك";
              t["ﻜ"] = "ك";
              t["ﻝ"] = "ل";
              t["ﻞ"] = "ل";
              t["ﻟ"] = "ل";
              t["ﻠ"] = "ل";
              t["ﻡ"] = "م";
              t["ﻢ"] = "م";
              t["ﻣ"] = "م";
              t["ﻤ"] = "م";
              t["ﻥ"] = "ن";
              t["ﻦ"] = "ن";
              t["ﻧ"] = "ن";
              t["ﻨ"] = "ن";
              t["ﻩ"] = "ه";
              t["ﻪ"] = "ه";
              t["ﻫ"] = "ه";
              t["ﻬ"] = "ه";
              t["ﻭ"] = "و";
              t["ﻮ"] = "و";
              t["ﻯ"] = "ى";
              t["ﻰ"] = "ى";
              t["ﻱ"] = "ي";
              t["ﻲ"] = "ي";
              t["ﻳ"] = "ي";
              t["ﻴ"] = "ي";
              t["ﻵ"] = "لآ";
              t["ﻶ"] = "لآ";
              t["ﻷ"] = "لأ";
              t["ﻸ"] = "لأ";
              t["ﻹ"] = "لإ";
              t["ﻺ"] = "لإ";
              t["ﻻ"] = "لا";
              t["ﻼ"] = "لا";
            });
            function reverseIfRtl(chars) {
              var charsLength = chars.length;
              if (charsLength <= 1 || !isRTLRangeFor(chars.charCodeAt(0))) {
                return chars;
              }
              var s = "";
              for (var ii = charsLength - 1; ii >= 0; ii--) {
                s += chars[ii];
              }
              return s;
            }
            exports3.mapSpecialUnicodeValues = mapSpecialUnicodeValues;
            exports3.reverseIfRtl = reverseIfRtl;
            exports3.getUnicodeRangeFor = getUnicodeRangeFor;
            exports3.getNormalizedUnicodes = getNormalizedUnicodes;
            exports3.getUnicodeForGlyph = getUnicodeForGlyph;
          },
          /* 144 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.FontRendererFactory = void 0;
            var _util = __w_pdfjs_require__(2);
            var _cff_parser = __w_pdfjs_require__(138);
            var _glyphlist = __w_pdfjs_require__(141);
            var _encodings = __w_pdfjs_require__(140);
            var _stream = __w_pdfjs_require__(121);
            var FontRendererFactory = function FontRendererFactoryClosure() {
              function getLong(data, offset) {
                return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
              }
              function getUshort(data, offset) {
                return data[offset] << 8 | data[offset + 1];
              }
              function parseCmap(data, start, end) {
                var offset = getUshort(data, start + 2) === 1 ? getLong(data, start + 8) : getLong(data, start + 16);
                var format = getUshort(data, start + offset);
                var ranges, p, i;
                if (format === 4) {
                  getUshort(data, start + offset + 2);
                  var segCount = getUshort(data, start + offset + 6) >> 1;
                  p = start + offset + 14;
                  ranges = [];
                  for (i = 0; i < segCount; i++, p += 2) {
                    ranges[i] = { end: getUshort(data, p) };
                  }
                  p += 2;
                  for (i = 0; i < segCount; i++, p += 2) {
                    ranges[i].start = getUshort(data, p);
                  }
                  for (i = 0; i < segCount; i++, p += 2) {
                    ranges[i].idDelta = getUshort(data, p);
                  }
                  for (i = 0; i < segCount; i++, p += 2) {
                    var idOffset = getUshort(data, p);
                    if (idOffset === 0) {
                      continue;
                    }
                    ranges[i].ids = [];
                    for (var j = 0, jj = ranges[i].end - ranges[i].start + 1; j < jj; j++) {
                      ranges[i].ids[j] = getUshort(data, p + idOffset);
                      idOffset += 2;
                    }
                  }
                  return ranges;
                } else if (format === 12) {
                  getLong(data, start + offset + 4);
                  var groups = getLong(data, start + offset + 12);
                  p = start + offset + 16;
                  ranges = [];
                  for (i = 0; i < groups; i++) {
                    ranges.push({
                      start: getLong(data, p),
                      end: getLong(data, p + 4),
                      idDelta: getLong(data, p + 8) - getLong(data, p)
                    });
                    p += 12;
                  }
                  return ranges;
                }
                throw new _util.FormatError("unsupported cmap: " + format);
              }
              function parseCff(data, start, end, seacAnalysisEnabled) {
                var properties = {};
                var parser = new _cff_parser.CFFParser(new _stream.Stream(data, start, end - start), properties, seacAnalysisEnabled);
                var cff = parser.parse();
                return {
                  glyphs: cff.charStrings.objects,
                  subrs: cff.topDict.privateDict && cff.topDict.privateDict.subrsIndex && cff.topDict.privateDict.subrsIndex.objects,
                  gsubrs: cff.globalSubrIndex && cff.globalSubrIndex.objects,
                  isCFFCIDFont: cff.isCIDFont,
                  fdSelect: cff.fdSelect,
                  fdArray: cff.fdArray
                };
              }
              function parseGlyfTable(glyf, loca, isGlyphLocationsLong) {
                var itemSize, itemDecode;
                if (isGlyphLocationsLong) {
                  itemSize = 4;
                  itemDecode = function fontItemDecodeLong(data, offset) {
                    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
                  };
                } else {
                  itemSize = 2;
                  itemDecode = function fontItemDecode(data, offset) {
                    return data[offset] << 9 | data[offset + 1] << 1;
                  };
                }
                var glyphs = [];
                var startOffset = itemDecode(loca, 0);
                for (var j = itemSize; j < loca.length; j += itemSize) {
                  var endOffset = itemDecode(loca, j);
                  glyphs.push(glyf.subarray(startOffset, endOffset));
                  startOffset = endOffset;
                }
                return glyphs;
              }
              function lookupCmap(ranges, unicode) {
                var code = unicode.charCodeAt(0), gid = 0;
                var l = 0, r = ranges.length - 1;
                while (l < r) {
                  var c = l + r + 1 >> 1;
                  if (code < ranges[c].start) {
                    r = c - 1;
                  } else {
                    l = c;
                  }
                }
                if (ranges[l].start <= code && code <= ranges[l].end) {
                  gid = ranges[l].idDelta + (ranges[l].ids ? ranges[l].ids[code - ranges[l].start] : code) & 65535;
                }
                return {
                  charCode: code,
                  glyphId: gid
                };
              }
              function compileGlyf(code, cmds, font) {
                function moveTo(x2, y2) {
                  cmds.push({
                    cmd: "moveTo",
                    args: [x2, y2]
                  });
                }
                function lineTo(x2, y2) {
                  cmds.push({
                    cmd: "lineTo",
                    args: [x2, y2]
                  });
                }
                function quadraticCurveTo(xa, ya, x2, y2) {
                  cmds.push({
                    cmd: "quadraticCurveTo",
                    args: [xa, ya, x2, y2]
                  });
                }
                var i = 0;
                var numberOfContours = (code[i] << 24 | code[i + 1] << 16) >> 16;
                var flags;
                var x = 0, y = 0;
                i += 10;
                if (numberOfContours < 0) {
                  do {
                    flags = code[i] << 8 | code[i + 1];
                    var glyphIndex = code[i + 2] << 8 | code[i + 3];
                    i += 4;
                    var arg1, arg2;
                    if (flags & 1) {
                      arg1 = (code[i] << 24 | code[i + 1] << 16) >> 16;
                      arg2 = (code[i + 2] << 24 | code[i + 3] << 16) >> 16;
                      i += 4;
                    } else {
                      arg1 = code[i++];
                      arg2 = code[i++];
                    }
                    if (flags & 2) {
                      x = arg1;
                      y = arg2;
                    } else {
                      x = 0;
                      y = 0;
                    }
                    var scaleX = 1, scaleY = 1, scale01 = 0, scale10 = 0;
                    if (flags & 8) {
                      scaleX = scaleY = (code[i] << 24 | code[i + 1] << 16) / 1073741824;
                      i += 2;
                    } else if (flags & 64) {
                      scaleX = (code[i] << 24 | code[i + 1] << 16) / 1073741824;
                      scaleY = (code[i + 2] << 24 | code[i + 3] << 16) / 1073741824;
                      i += 4;
                    } else if (flags & 128) {
                      scaleX = (code[i] << 24 | code[i + 1] << 16) / 1073741824;
                      scale01 = (code[i + 2] << 24 | code[i + 3] << 16) / 1073741824;
                      scale10 = (code[i + 4] << 24 | code[i + 5] << 16) / 1073741824;
                      scaleY = (code[i + 6] << 24 | code[i + 7] << 16) / 1073741824;
                      i += 8;
                    }
                    var subglyph = font.glyphs[glyphIndex];
                    if (subglyph) {
                      cmds.push({ cmd: "save" });
                      cmds.push({
                        cmd: "transform",
                        args: [scaleX, scale01, scale10, scaleY, x, y]
                      });
                      compileGlyf(subglyph, cmds, font);
                      cmds.push({ cmd: "restore" });
                    }
                  } while (flags & 32);
                } else {
                  var endPtsOfContours = [];
                  var j, jj;
                  for (j = 0; j < numberOfContours; j++) {
                    endPtsOfContours.push(code[i] << 8 | code[i + 1]);
                    i += 2;
                  }
                  var instructionLength = code[i] << 8 | code[i + 1];
                  i += 2 + instructionLength;
                  var numberOfPoints = endPtsOfContours[endPtsOfContours.length - 1] + 1;
                  var points = [];
                  while (points.length < numberOfPoints) {
                    flags = code[i++];
                    var repeat = 1;
                    if (flags & 8) {
                      repeat += code[i++];
                    }
                    while (repeat-- > 0) {
                      points.push({ flags });
                    }
                  }
                  for (j = 0; j < numberOfPoints; j++) {
                    switch (points[j].flags & 18) {
                      case 0:
                        x += (code[i] << 24 | code[i + 1] << 16) >> 16;
                        i += 2;
                        break;
                      case 2:
                        x -= code[i++];
                        break;
                      case 18:
                        x += code[i++];
                        break;
                    }
                    points[j].x = x;
                  }
                  for (j = 0; j < numberOfPoints; j++) {
                    switch (points[j].flags & 36) {
                      case 0:
                        y += (code[i] << 24 | code[i + 1] << 16) >> 16;
                        i += 2;
                        break;
                      case 4:
                        y -= code[i++];
                        break;
                      case 36:
                        y += code[i++];
                        break;
                    }
                    points[j].y = y;
                  }
                  var startPoint = 0;
                  for (i = 0; i < numberOfContours; i++) {
                    var endPoint = endPtsOfContours[i];
                    var contour = points.slice(startPoint, endPoint + 1);
                    if (contour[0].flags & 1) {
                      contour.push(contour[0]);
                    } else if (contour[contour.length - 1].flags & 1) {
                      contour.unshift(contour[contour.length - 1]);
                    } else {
                      var p = {
                        flags: 1,
                        x: (contour[0].x + contour[contour.length - 1].x) / 2,
                        y: (contour[0].y + contour[contour.length - 1].y) / 2
                      };
                      contour.unshift(p);
                      contour.push(p);
                    }
                    moveTo(contour[0].x, contour[0].y);
                    for (j = 1, jj = contour.length; j < jj; j++) {
                      if (contour[j].flags & 1) {
                        lineTo(contour[j].x, contour[j].y);
                      } else if (contour[j + 1].flags & 1) {
                        quadraticCurveTo(contour[j].x, contour[j].y, contour[j + 1].x, contour[j + 1].y);
                        j++;
                      } else {
                        quadraticCurveTo(contour[j].x, contour[j].y, (contour[j].x + contour[j + 1].x) / 2, (contour[j].y + contour[j + 1].y) / 2);
                      }
                    }
                    startPoint = endPoint + 1;
                  }
                }
              }
              function compileCharString(code, cmds, font, glyphId) {
                var stack = [];
                var x = 0, y = 0;
                var stems = 0;
                function moveTo(x2, y2) {
                  cmds.push({
                    cmd: "moveTo",
                    args: [x2, y2]
                  });
                }
                function lineTo(x2, y2) {
                  cmds.push({
                    cmd: "lineTo",
                    args: [x2, y2]
                  });
                }
                function bezierCurveTo(x1, y1, x2, y2, x3, y3) {
                  cmds.push({
                    cmd: "bezierCurveTo",
                    args: [x1, y1, x2, y2, x3, y3]
                  });
                }
                function parse(code2) {
                  var i = 0;
                  while (i < code2.length) {
                    var stackClean = false;
                    var v = code2[i++];
                    var xa, xb, ya, yb, y1, y2, y3, n, subrCode;
                    switch (v) {
                      case 1:
                        stems += stack.length >> 1;
                        stackClean = true;
                        break;
                      case 3:
                        stems += stack.length >> 1;
                        stackClean = true;
                        break;
                      case 4:
                        y += stack.pop();
                        moveTo(x, y);
                        stackClean = true;
                        break;
                      case 5:
                        while (stack.length > 0) {
                          x += stack.shift();
                          y += stack.shift();
                          lineTo(x, y);
                        }
                        break;
                      case 6:
                        while (stack.length > 0) {
                          x += stack.shift();
                          lineTo(x, y);
                          if (stack.length === 0) {
                            break;
                          }
                          y += stack.shift();
                          lineTo(x, y);
                        }
                        break;
                      case 7:
                        while (stack.length > 0) {
                          y += stack.shift();
                          lineTo(x, y);
                          if (stack.length === 0) {
                            break;
                          }
                          x += stack.shift();
                          lineTo(x, y);
                        }
                        break;
                      case 8:
                        while (stack.length > 0) {
                          xa = x + stack.shift();
                          ya = y + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x = xb + stack.shift();
                          y = yb + stack.shift();
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                        }
                        break;
                      case 10:
                        n = stack.pop();
                        subrCode = null;
                        if (font.isCFFCIDFont) {
                          var fdIndex = font.fdSelect.getFDIndex(glyphId);
                          if (fdIndex >= 0 && fdIndex < font.fdArray.length) {
                            var fontDict = font.fdArray[fdIndex], subrs = void 0;
                            if (fontDict.privateDict && fontDict.privateDict.subrsIndex) {
                              subrs = fontDict.privateDict.subrsIndex.objects;
                            }
                            if (subrs) {
                              var numSubrs = subrs.length;
                              n += numSubrs < 1240 ? 107 : numSubrs < 33900 ? 1131 : 32768;
                              subrCode = subrs[n];
                            }
                          } else {
                            (0, _util.warn)("Invalid fd index for glyph index.");
                          }
                        } else {
                          subrCode = font.subrs[n + font.subrsBias];
                        }
                        if (subrCode) {
                          parse(subrCode);
                        }
                        break;
                      case 11:
                        return;
                      case 12:
                        v = code2[i++];
                        switch (v) {
                          case 34:
                            xa = x + stack.shift();
                            xb = xa + stack.shift();
                            y1 = y + stack.shift();
                            x = xb + stack.shift();
                            bezierCurveTo(xa, y, xb, y1, x, y1);
                            xa = x + stack.shift();
                            xb = xa + stack.shift();
                            x = xb + stack.shift();
                            bezierCurveTo(xa, y1, xb, y, x, y);
                            break;
                          case 35:
                            xa = x + stack.shift();
                            ya = y + stack.shift();
                            xb = xa + stack.shift();
                            yb = ya + stack.shift();
                            x = xb + stack.shift();
                            y = yb + stack.shift();
                            bezierCurveTo(xa, ya, xb, yb, x, y);
                            xa = x + stack.shift();
                            ya = y + stack.shift();
                            xb = xa + stack.shift();
                            yb = ya + stack.shift();
                            x = xb + stack.shift();
                            y = yb + stack.shift();
                            bezierCurveTo(xa, ya, xb, yb, x, y);
                            stack.pop();
                            break;
                          case 36:
                            xa = x + stack.shift();
                            y1 = y + stack.shift();
                            xb = xa + stack.shift();
                            y2 = y1 + stack.shift();
                            x = xb + stack.shift();
                            bezierCurveTo(xa, y1, xb, y2, x, y2);
                            xa = x + stack.shift();
                            xb = xa + stack.shift();
                            y3 = y2 + stack.shift();
                            x = xb + stack.shift();
                            bezierCurveTo(xa, y2, xb, y3, x, y);
                            break;
                          case 37:
                            var x0 = x, y0 = y;
                            xa = x + stack.shift();
                            ya = y + stack.shift();
                            xb = xa + stack.shift();
                            yb = ya + stack.shift();
                            x = xb + stack.shift();
                            y = yb + stack.shift();
                            bezierCurveTo(xa, ya, xb, yb, x, y);
                            xa = x + stack.shift();
                            ya = y + stack.shift();
                            xb = xa + stack.shift();
                            yb = ya + stack.shift();
                            x = xb;
                            y = yb;
                            if (Math.abs(x - x0) > Math.abs(y - y0)) {
                              x += stack.shift();
                            } else {
                              y += stack.shift();
                            }
                            bezierCurveTo(xa, ya, xb, yb, x, y);
                            break;
                          default:
                            throw new _util.FormatError("unknown operator: 12 " + v);
                        }
                        break;
                      case 14:
                        if (stack.length >= 4) {
                          var achar = stack.pop();
                          var bchar = stack.pop();
                          y = stack.pop();
                          x = stack.pop();
                          cmds.push({ cmd: "save" });
                          cmds.push({
                            cmd: "translate",
                            args: [x, y]
                          });
                          var cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[achar]]));
                          compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
                          cmds.push({ cmd: "restore" });
                          cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[bchar]]));
                          compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
                        }
                        return;
                      case 18:
                        stems += stack.length >> 1;
                        stackClean = true;
                        break;
                      case 19:
                        stems += stack.length >> 1;
                        i += stems + 7 >> 3;
                        stackClean = true;
                        break;
                      case 20:
                        stems += stack.length >> 1;
                        i += stems + 7 >> 3;
                        stackClean = true;
                        break;
                      case 21:
                        y += stack.pop();
                        x += stack.pop();
                        moveTo(x, y);
                        stackClean = true;
                        break;
                      case 22:
                        x += stack.pop();
                        moveTo(x, y);
                        stackClean = true;
                        break;
                      case 23:
                        stems += stack.length >> 1;
                        stackClean = true;
                        break;
                      case 24:
                        while (stack.length > 2) {
                          xa = x + stack.shift();
                          ya = y + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x = xb + stack.shift();
                          y = yb + stack.shift();
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                        }
                        x += stack.shift();
                        y += stack.shift();
                        lineTo(x, y);
                        break;
                      case 25:
                        while (stack.length > 6) {
                          x += stack.shift();
                          y += stack.shift();
                          lineTo(x, y);
                        }
                        xa = x + stack.shift();
                        ya = y + stack.shift();
                        xb = xa + stack.shift();
                        yb = ya + stack.shift();
                        x = xb + stack.shift();
                        y = yb + stack.shift();
                        bezierCurveTo(xa, ya, xb, yb, x, y);
                        break;
                      case 26:
                        if (stack.length % 2) {
                          x += stack.shift();
                        }
                        while (stack.length > 0) {
                          xa = x;
                          ya = y + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x = xb;
                          y = yb + stack.shift();
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                        }
                        break;
                      case 27:
                        if (stack.length % 2) {
                          y += stack.shift();
                        }
                        while (stack.length > 0) {
                          xa = x + stack.shift();
                          ya = y;
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x = xb + stack.shift();
                          y = yb;
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                        }
                        break;
                      case 28:
                        stack.push((code2[i] << 24 | code2[i + 1] << 16) >> 16);
                        i += 2;
                        break;
                      case 29:
                        n = stack.pop() + font.gsubrsBias;
                        subrCode = font.gsubrs[n];
                        if (subrCode) {
                          parse(subrCode);
                        }
                        break;
                      case 30:
                        while (stack.length > 0) {
                          xa = x;
                          ya = y + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x = xb + stack.shift();
                          y = yb + (stack.length === 1 ? stack.shift() : 0);
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                          if (stack.length === 0) {
                            break;
                          }
                          xa = x + stack.shift();
                          ya = y;
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          y = yb + stack.shift();
                          x = xb + (stack.length === 1 ? stack.shift() : 0);
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                        }
                        break;
                      case 31:
                        while (stack.length > 0) {
                          xa = x + stack.shift();
                          ya = y;
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          y = yb + stack.shift();
                          x = xb + (stack.length === 1 ? stack.shift() : 0);
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                          if (stack.length === 0) {
                            break;
                          }
                          xa = x;
                          ya = y + stack.shift();
                          xb = xa + stack.shift();
                          yb = ya + stack.shift();
                          x = xb + stack.shift();
                          y = yb + (stack.length === 1 ? stack.shift() : 0);
                          bezierCurveTo(xa, ya, xb, yb, x, y);
                        }
                        break;
                      default:
                        if (v < 32) {
                          throw new _util.FormatError("unknown operator: " + v);
                        }
                        if (v < 247) {
                          stack.push(v - 139);
                        } else if (v < 251) {
                          stack.push((v - 247) * 256 + code2[i++] + 108);
                        } else if (v < 255) {
                          stack.push(-(v - 251) * 256 - code2[i++] - 108);
                        } else {
                          stack.push((code2[i] << 24 | code2[i + 1] << 16 | code2[i + 2] << 8 | code2[i + 3]) / 65536);
                          i += 4;
                        }
                        break;
                    }
                    if (stackClean) {
                      stack.length = 0;
                    }
                  }
                }
                parse(code);
              }
              var noop = "";
              function CompiledFont(fontMatrix) {
                this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
                this.fontMatrix = fontMatrix;
              }
              CompiledFont.prototype = {
                getPathJs: function getPathJs(unicode) {
                  var cmap = lookupCmap(this.cmap, unicode);
                  var fn = this.compiledGlyphs[cmap.glyphId];
                  if (!fn) {
                    fn = this.compileGlyph(this.glyphs[cmap.glyphId], cmap.glyphId);
                    this.compiledGlyphs[cmap.glyphId] = fn;
                  }
                  if (this.compiledCharCodeToGlyphId[cmap.charCode] === void 0) {
                    this.compiledCharCodeToGlyphId[cmap.charCode] = cmap.glyphId;
                  }
                  return fn;
                },
                compileGlyph: function compileGlyph(code, glyphId) {
                  if (!code || code.length === 0 || code[0] === 14) {
                    return noop;
                  }
                  var fontMatrix = this.fontMatrix;
                  if (this.isCFFCIDFont) {
                    var fdIndex = this.fdSelect.getFDIndex(glyphId);
                    if (fdIndex >= 0 && fdIndex < this.fdArray.length) {
                      var fontDict = this.fdArray[fdIndex];
                      fontMatrix = fontDict.getByName("FontMatrix") || _util.FONT_IDENTITY_MATRIX;
                    } else {
                      (0, _util.warn)("Invalid fd index for glyph index.");
                    }
                  }
                  var cmds = [];
                  cmds.push({ cmd: "save" });
                  cmds.push({
                    cmd: "transform",
                    args: fontMatrix.slice()
                  });
                  cmds.push({
                    cmd: "scale",
                    args: ["size", "-size"]
                  });
                  this.compileGlyphImpl(code, cmds, glyphId);
                  cmds.push({ cmd: "restore" });
                  return cmds;
                },
                compileGlyphImpl: function compileGlyphImpl() {
                  (0, _util.unreachable)("Children classes should implement this.");
                },
                hasBuiltPath: function hasBuiltPath(unicode) {
                  var cmap = lookupCmap(this.cmap, unicode);
                  return this.compiledGlyphs[cmap.glyphId] !== void 0 && this.compiledCharCodeToGlyphId[cmap.charCode] !== void 0;
                }
              };
              function TrueTypeCompiled(glyphs, cmap, fontMatrix) {
                fontMatrix = fontMatrix || [488e-6, 0, 0, 488e-6, 0, 0];
                CompiledFont.call(this, fontMatrix);
                this.glyphs = glyphs;
                this.cmap = cmap;
              }
              _util.Util.inherit(TrueTypeCompiled, CompiledFont, {
                compileGlyphImpl: function compileGlyphImpl(code, cmds) {
                  compileGlyf(code, cmds, this);
                }
              });
              function Type2Compiled(cffInfo, cmap, fontMatrix, glyphNameMap) {
                fontMatrix = fontMatrix || [1e-3, 0, 0, 1e-3, 0, 0];
                CompiledFont.call(this, fontMatrix);
                this.glyphs = cffInfo.glyphs;
                this.gsubrs = cffInfo.gsubrs || [];
                this.subrs = cffInfo.subrs || [];
                this.cmap = cmap;
                this.glyphNameMap = glyphNameMap || (0, _glyphlist.getGlyphsUnicode)();
                this.gsubrsBias = this.gsubrs.length < 1240 ? 107 : this.gsubrs.length < 33900 ? 1131 : 32768;
                this.subrsBias = this.subrs.length < 1240 ? 107 : this.subrs.length < 33900 ? 1131 : 32768;
                this.isCFFCIDFont = cffInfo.isCFFCIDFont;
                this.fdSelect = cffInfo.fdSelect;
                this.fdArray = cffInfo.fdArray;
              }
              _util.Util.inherit(Type2Compiled, CompiledFont, {
                compileGlyphImpl: function compileGlyphImpl(code, cmds, glyphId) {
                  compileCharString(code, cmds, this, glyphId);
                }
              });
              return {
                create: function FontRendererFactory_create(font, seacAnalysisEnabled) {
                  var data = new Uint8Array(font.data);
                  var cmap, glyf, loca, cff, indexToLocFormat, unitsPerEm;
                  var numTables = getUshort(data, 4);
                  for (var i = 0, p = 12; i < numTables; i++, p += 16) {
                    var tag = (0, _util.bytesToString)(data.subarray(p, p + 4));
                    var offset = getLong(data, p + 8);
                    var length = getLong(data, p + 12);
                    switch (tag) {
                      case "cmap":
                        cmap = parseCmap(data, offset, offset + length);
                        break;
                      case "glyf":
                        glyf = data.subarray(offset, offset + length);
                        break;
                      case "loca":
                        loca = data.subarray(offset, offset + length);
                        break;
                      case "head":
                        unitsPerEm = getUshort(data, offset + 18);
                        indexToLocFormat = getUshort(data, offset + 50);
                        break;
                      case "CFF ":
                        cff = parseCff(data, offset, offset + length, seacAnalysisEnabled);
                        break;
                    }
                  }
                  if (glyf) {
                    var fontMatrix = !unitsPerEm ? font.fontMatrix : [1 / unitsPerEm, 0, 0, 1 / unitsPerEm, 0, 0];
                    return new TrueTypeCompiled(parseGlyfTable(glyf, loca, indexToLocFormat), cmap, fontMatrix);
                  }
                  return new Type2Compiled(cff, cmap, font.fontMatrix, font.glyphNameMap);
                }
              };
            }();
            exports3.FontRendererFactory = FontRendererFactory;
          },
          /* 145 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.Type1Parser = void 0;
            var _util = __w_pdfjs_require__(2);
            var _encodings = __w_pdfjs_require__(140);
            var _stream = __w_pdfjs_require__(121);
            var HINTING_ENABLED = false;
            var Type1CharString = function Type1CharStringClosure() {
              var COMMAND_MAP = {
                "hstem": [1],
                "vstem": [3],
                "vmoveto": [4],
                "rlineto": [5],
                "hlineto": [6],
                "vlineto": [7],
                "rrcurveto": [8],
                "callsubr": [10],
                "flex": [12, 35],
                "drop": [12, 18],
                "endchar": [14],
                "rmoveto": [21],
                "hmoveto": [22],
                "vhcurveto": [30],
                "hvcurveto": [31]
              };
              function Type1CharString2() {
                this.width = 0;
                this.lsb = 0;
                this.flexing = false;
                this.output = [];
                this.stack = [];
              }
              Type1CharString2.prototype = {
                convert: function Type1CharString_convert(encoded, subrs, seacAnalysisEnabled) {
                  var count = encoded.length;
                  var error = false;
                  var wx, sbx, subrNumber;
                  for (var i = 0; i < count; i++) {
                    var value = encoded[i];
                    if (value < 32) {
                      if (value === 12) {
                        value = (value << 8) + encoded[++i];
                      }
                      switch (value) {
                        case 1:
                          if (!HINTING_ENABLED) {
                            this.stack = [];
                            break;
                          }
                          error = this.executeCommand(2, COMMAND_MAP.hstem);
                          break;
                        case 3:
                          if (!HINTING_ENABLED) {
                            this.stack = [];
                            break;
                          }
                          error = this.executeCommand(2, COMMAND_MAP.vstem);
                          break;
                        case 4:
                          if (this.flexing) {
                            if (this.stack.length < 1) {
                              error = true;
                              break;
                            }
                            var dy = this.stack.pop();
                            this.stack.push(0, dy);
                            break;
                          }
                          error = this.executeCommand(1, COMMAND_MAP.vmoveto);
                          break;
                        case 5:
                          error = this.executeCommand(2, COMMAND_MAP.rlineto);
                          break;
                        case 6:
                          error = this.executeCommand(1, COMMAND_MAP.hlineto);
                          break;
                        case 7:
                          error = this.executeCommand(1, COMMAND_MAP.vlineto);
                          break;
                        case 8:
                          error = this.executeCommand(6, COMMAND_MAP.rrcurveto);
                          break;
                        case 9:
                          this.stack = [];
                          break;
                        case 10:
                          if (this.stack.length < 1) {
                            error = true;
                            break;
                          }
                          subrNumber = this.stack.pop();
                          if (!subrs[subrNumber]) {
                            error = true;
                            break;
                          }
                          error = this.convert(subrs[subrNumber], subrs, seacAnalysisEnabled);
                          break;
                        case 11:
                          return error;
                        case 13:
                          if (this.stack.length < 2) {
                            error = true;
                            break;
                          }
                          wx = this.stack.pop();
                          sbx = this.stack.pop();
                          this.lsb = sbx;
                          this.width = wx;
                          this.stack.push(wx, sbx);
                          error = this.executeCommand(2, COMMAND_MAP.hmoveto);
                          break;
                        case 14:
                          this.output.push(COMMAND_MAP.endchar[0]);
                          break;
                        case 21:
                          if (this.flexing) {
                            break;
                          }
                          error = this.executeCommand(2, COMMAND_MAP.rmoveto);
                          break;
                        case 22:
                          if (this.flexing) {
                            this.stack.push(0);
                            break;
                          }
                          error = this.executeCommand(1, COMMAND_MAP.hmoveto);
                          break;
                        case 30:
                          error = this.executeCommand(4, COMMAND_MAP.vhcurveto);
                          break;
                        case 31:
                          error = this.executeCommand(4, COMMAND_MAP.hvcurveto);
                          break;
                        case (12 << 8) + 0:
                          this.stack = [];
                          break;
                        case (12 << 8) + 1:
                          if (!HINTING_ENABLED) {
                            this.stack = [];
                            break;
                          }
                          error = this.executeCommand(2, COMMAND_MAP.vstem);
                          break;
                        case (12 << 8) + 2:
                          if (!HINTING_ENABLED) {
                            this.stack = [];
                            break;
                          }
                          error = this.executeCommand(2, COMMAND_MAP.hstem);
                          break;
                        case (12 << 8) + 6:
                          if (seacAnalysisEnabled) {
                            this.seac = this.stack.splice(-4, 4);
                            error = this.executeCommand(0, COMMAND_MAP.endchar);
                          } else {
                            error = this.executeCommand(4, COMMAND_MAP.endchar);
                          }
                          break;
                        case (12 << 8) + 7:
                          if (this.stack.length < 4) {
                            error = true;
                            break;
                          }
                          this.stack.pop();
                          wx = this.stack.pop();
                          var sby = this.stack.pop();
                          sbx = this.stack.pop();
                          this.lsb = sbx;
                          this.width = wx;
                          this.stack.push(wx, sbx, sby);
                          error = this.executeCommand(3, COMMAND_MAP.rmoveto);
                          break;
                        case (12 << 8) + 12:
                          if (this.stack.length < 2) {
                            error = true;
                            break;
                          }
                          var num2 = this.stack.pop();
                          var num1 = this.stack.pop();
                          this.stack.push(num1 / num2);
                          break;
                        case (12 << 8) + 16:
                          if (this.stack.length < 2) {
                            error = true;
                            break;
                          }
                          subrNumber = this.stack.pop();
                          var numArgs = this.stack.pop();
                          if (subrNumber === 0 && numArgs === 3) {
                            var flexArgs = this.stack.splice(this.stack.length - 17, 17);
                            this.stack.push(flexArgs[2] + flexArgs[0], flexArgs[3] + flexArgs[1], flexArgs[4], flexArgs[5], flexArgs[6], flexArgs[7], flexArgs[8], flexArgs[9], flexArgs[10], flexArgs[11], flexArgs[12], flexArgs[13], flexArgs[14]);
                            error = this.executeCommand(13, COMMAND_MAP.flex, true);
                            this.flexing = false;
                            this.stack.push(flexArgs[15], flexArgs[16]);
                          } else if (subrNumber === 1 && numArgs === 0) {
                            this.flexing = true;
                          }
                          break;
                        case (12 << 8) + 17:
                          break;
                        case (12 << 8) + 33:
                          this.stack = [];
                          break;
                        default:
                          (0, _util.warn)('Unknown type 1 charstring command of "' + value + '"');
                          break;
                      }
                      if (error) {
                        break;
                      }
                      continue;
                    } else if (value <= 246) {
                      value = value - 139;
                    } else if (value <= 250) {
                      value = (value - 247) * 256 + encoded[++i] + 108;
                    } else if (value <= 254) {
                      value = -((value - 251) * 256) - encoded[++i] - 108;
                    } else {
                      value = (encoded[++i] & 255) << 24 | (encoded[++i] & 255) << 16 | (encoded[++i] & 255) << 8 | (encoded[++i] & 255) << 0;
                    }
                    this.stack.push(value);
                  }
                  return error;
                },
                executeCommand: function executeCommand(howManyArgs, command, keepStack) {
                  var stackLength = this.stack.length;
                  if (howManyArgs > stackLength) {
                    return true;
                  }
                  var start = stackLength - howManyArgs;
                  for (var i = start; i < stackLength; i++) {
                    var value = this.stack[i];
                    if (Number.isInteger(value)) {
                      this.output.push(28, value >> 8 & 255, value & 255);
                    } else {
                      value = 65536 * value | 0;
                      this.output.push(255, value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
                    }
                  }
                  this.output.push.apply(this.output, command);
                  if (keepStack) {
                    this.stack.splice(start, howManyArgs);
                  } else {
                    this.stack.length = 0;
                  }
                  return false;
                }
              };
              return Type1CharString2;
            }();
            var Type1Parser = function Type1ParserClosure() {
              var EEXEC_ENCRYPT_KEY = 55665;
              var CHAR_STRS_ENCRYPT_KEY = 4330;
              function isHexDigit(code) {
                return code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102;
              }
              function decrypt(data, key, discardNumber) {
                if (discardNumber >= data.length) {
                  return new Uint8Array(0);
                }
                var r = key | 0, c1 = 52845, c2 = 22719, i, j;
                for (i = 0; i < discardNumber; i++) {
                  r = (data[i] + r) * c1 + c2 & (1 << 16) - 1;
                }
                var count = data.length - discardNumber;
                var decrypted = new Uint8Array(count);
                for (i = discardNumber, j = 0; j < count; i++, j++) {
                  var value = data[i];
                  decrypted[j] = value ^ r >> 8;
                  r = (value + r) * c1 + c2 & (1 << 16) - 1;
                }
                return decrypted;
              }
              function decryptAscii(data, key, discardNumber) {
                var r = key | 0, c1 = 52845, c2 = 22719;
                var count = data.length, maybeLength = count >>> 1;
                var decrypted = new Uint8Array(maybeLength);
                var i, j;
                for (i = 0, j = 0; i < count; i++) {
                  var digit1 = data[i];
                  if (!isHexDigit(digit1)) {
                    continue;
                  }
                  i++;
                  var digit2;
                  while (i < count && !isHexDigit(digit2 = data[i])) {
                    i++;
                  }
                  if (i < count) {
                    var value = parseInt(String.fromCharCode(digit1, digit2), 16);
                    decrypted[j++] = value ^ r >> 8;
                    r = (value + r) * c1 + c2 & (1 << 16) - 1;
                  }
                }
                return Array.prototype.slice.call(decrypted, discardNumber, j);
              }
              function isSpecial(c) {
                return c === 47 || c === 91 || c === 93 || c === 123 || c === 125 || c === 40 || c === 41;
              }
              function Type1Parser2(stream2, encrypted, seacAnalysisEnabled) {
                if (encrypted) {
                  var data = stream2.getBytes();
                  var isBinary = !(isHexDigit(data[0]) && isHexDigit(data[1]) && isHexDigit(data[2]) && isHexDigit(data[3]));
                  stream2 = new _stream.Stream(isBinary ? decrypt(data, EEXEC_ENCRYPT_KEY, 4) : decryptAscii(data, EEXEC_ENCRYPT_KEY, 4));
                }
                this.seacAnalysisEnabled = !!seacAnalysisEnabled;
                this.stream = stream2;
                this.nextChar();
              }
              Type1Parser2.prototype = {
                readNumberArray: function Type1Parser_readNumberArray() {
                  this.getToken();
                  var array = [];
                  while (true) {
                    var token = this.getToken();
                    if (token === null || token === "]" || token === "}") {
                      break;
                    }
                    array.push(parseFloat(token || 0));
                  }
                  return array;
                },
                readNumber: function Type1Parser_readNumber() {
                  var token = this.getToken();
                  return parseFloat(token || 0);
                },
                readInt: function Type1Parser_readInt() {
                  var token = this.getToken();
                  return parseInt(token || 0, 10) | 0;
                },
                readBoolean: function Type1Parser_readBoolean() {
                  var token = this.getToken();
                  return token === "true" ? 1 : 0;
                },
                nextChar: function Type1_nextChar() {
                  return this.currentChar = this.stream.getByte();
                },
                getToken: function Type1Parser_getToken() {
                  var comment = false;
                  var ch = this.currentChar;
                  while (true) {
                    if (ch === -1) {
                      return null;
                    }
                    if (comment) {
                      if (ch === 10 || ch === 13) {
                        comment = false;
                      }
                    } else if (ch === 37) {
                      comment = true;
                    } else if (!(0, _util.isSpace)(ch)) {
                      break;
                    }
                    ch = this.nextChar();
                  }
                  if (isSpecial(ch)) {
                    this.nextChar();
                    return String.fromCharCode(ch);
                  }
                  var token = "";
                  do {
                    token += String.fromCharCode(ch);
                    ch = this.nextChar();
                  } while (ch >= 0 && !(0, _util.isSpace)(ch) && !isSpecial(ch));
                  return token;
                },
                readCharStrings: function Type1Parser_readCharStrings(bytes, lenIV) {
                  if (lenIV === -1) {
                    return bytes;
                  }
                  return decrypt(bytes, CHAR_STRS_ENCRYPT_KEY, lenIV);
                },
                extractFontProgram: function Type1Parser_extractFontProgram() {
                  var stream2 = this.stream;
                  var subrs = [], charstrings = [];
                  var privateData = /* @__PURE__ */ Object.create(null);
                  privateData["lenIV"] = 4;
                  var program = {
                    subrs: [],
                    charstrings: [],
                    properties: { "privateData": privateData }
                  };
                  var token, length, data, lenIV, encoded;
                  while ((token = this.getToken()) !== null) {
                    if (token !== "/") {
                      continue;
                    }
                    token = this.getToken();
                    switch (token) {
                      case "CharStrings":
                        this.getToken();
                        this.getToken();
                        this.getToken();
                        this.getToken();
                        while (true) {
                          token = this.getToken();
                          if (token === null || token === "end") {
                            break;
                          }
                          if (token !== "/") {
                            continue;
                          }
                          var glyph = this.getToken();
                          length = this.readInt();
                          this.getToken();
                          data = length > 0 ? stream2.getBytes(length) : new Uint8Array(0);
                          lenIV = program.properties.privateData["lenIV"];
                          encoded = this.readCharStrings(data, lenIV);
                          this.nextChar();
                          token = this.getToken();
                          if (token === "noaccess") {
                            this.getToken();
                          }
                          charstrings.push({
                            glyph,
                            encoded
                          });
                        }
                        break;
                      case "Subrs":
                        this.readInt();
                        this.getToken();
                        while (this.getToken() === "dup") {
                          var index = this.readInt();
                          length = this.readInt();
                          this.getToken();
                          data = length > 0 ? stream2.getBytes(length) : new Uint8Array(0);
                          lenIV = program.properties.privateData["lenIV"];
                          encoded = this.readCharStrings(data, lenIV);
                          this.nextChar();
                          token = this.getToken();
                          if (token === "noaccess") {
                            this.getToken();
                          }
                          subrs[index] = encoded;
                        }
                        break;
                      case "BlueValues":
                      case "OtherBlues":
                      case "FamilyBlues":
                      case "FamilyOtherBlues":
                        var blueArray = this.readNumberArray();
                        if (blueArray.length > 0 && blueArray.length % 2 === 0 && HINTING_ENABLED) {
                          program.properties.privateData[token] = blueArray;
                        }
                        break;
                      case "StemSnapH":
                      case "StemSnapV":
                        program.properties.privateData[token] = this.readNumberArray();
                        break;
                      case "StdHW":
                      case "StdVW":
                        program.properties.privateData[token] = this.readNumberArray()[0];
                        break;
                      case "BlueShift":
                      case "lenIV":
                      case "BlueFuzz":
                      case "BlueScale":
                      case "LanguageGroup":
                      case "ExpansionFactor":
                        program.properties.privateData[token] = this.readNumber();
                        break;
                      case "ForceBold":
                        program.properties.privateData[token] = this.readBoolean();
                        break;
                    }
                  }
                  for (var i = 0; i < charstrings.length; i++) {
                    glyph = charstrings[i].glyph;
                    encoded = charstrings[i].encoded;
                    var charString = new Type1CharString();
                    var error = charString.convert(encoded, subrs, this.seacAnalysisEnabled);
                    var output = charString.output;
                    if (error) {
                      output = [14];
                    }
                    program.charstrings.push({
                      glyphName: glyph,
                      charstring: output,
                      width: charString.width,
                      lsb: charString.lsb,
                      seac: charString.seac
                    });
                  }
                  return program;
                },
                extractFontHeader: function Type1Parser_extractFontHeader(properties) {
                  var token;
                  while ((token = this.getToken()) !== null) {
                    if (token !== "/") {
                      continue;
                    }
                    token = this.getToken();
                    switch (token) {
                      case "FontMatrix":
                        var matrix = this.readNumberArray();
                        properties.fontMatrix = matrix;
                        break;
                      case "Encoding":
                        var encodingArg = this.getToken();
                        var encoding;
                        if (!/^\d+$/.test(encodingArg)) {
                          encoding = (0, _encodings.getEncoding)(encodingArg);
                        } else {
                          encoding = [];
                          var size = parseInt(encodingArg, 10) | 0;
                          this.getToken();
                          for (var j = 0; j < size; j++) {
                            token = this.getToken();
                            while (token !== "dup" && token !== "def") {
                              token = this.getToken();
                              if (token === null) {
                                return;
                              }
                            }
                            if (token === "def") {
                              break;
                            }
                            var index = this.readInt();
                            this.getToken();
                            var glyph = this.getToken();
                            encoding[index] = glyph;
                            this.getToken();
                          }
                        }
                        properties.builtInEncoding = encoding;
                        break;
                      case "FontBBox":
                        var fontBBox = this.readNumberArray();
                        properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
                        properties.descent = Math.min(fontBBox[1], fontBBox[3]);
                        properties.ascentScaled = true;
                        break;
                    }
                  }
                }
              };
              return Type1Parser2;
            }();
            exports3.Type1Parser = Type1Parser;
          },
          /* 146 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.getTilingPatternIR = exports3.Pattern = void 0;
            var _util = __w_pdfjs_require__(2);
            var _colorspace = __w_pdfjs_require__(132);
            var _primitives = __w_pdfjs_require__(119);
            var ShadingType = {
              FUNCTION_BASED: 1,
              AXIAL: 2,
              RADIAL: 3,
              FREE_FORM_MESH: 4,
              LATTICE_FORM_MESH: 5,
              COONS_PATCH_MESH: 6,
              TENSOR_PATCH_MESH: 7
            };
            var Pattern = function PatternClosure() {
              function Pattern2() {
                (0, _util.unreachable)("should not call Pattern constructor");
              }
              Pattern2.prototype = {
                getPattern: function Pattern_getPattern(ctx) {
                  (0, _util.unreachable)("Should not call Pattern.getStyle: " + ctx);
                }
              };
              Pattern2.parseShading = function(shading, matrix, xref, res, handler, pdfFunctionFactory) {
                var dict = (0, _primitives.isStream)(shading) ? shading.dict : shading;
                var type = dict.get("ShadingType");
                try {
                  switch (type) {
                    case ShadingType.AXIAL:
                    case ShadingType.RADIAL:
                      return new Shadings.RadialAxial(dict, matrix, xref, res, pdfFunctionFactory);
                    case ShadingType.FREE_FORM_MESH:
                    case ShadingType.LATTICE_FORM_MESH:
                    case ShadingType.COONS_PATCH_MESH:
                    case ShadingType.TENSOR_PATCH_MESH:
                      return new Shadings.Mesh(shading, matrix, xref, res, pdfFunctionFactory);
                    default:
                      throw new _util.FormatError("Unsupported ShadingType: " + type);
                  }
                } catch (ex) {
                  if (ex instanceof _util.MissingDataException) {
                    throw ex;
                  }
                  handler.send("UnsupportedFeature", { featureId: _util.UNSUPPORTED_FEATURES.shadingPattern });
                  (0, _util.warn)(ex);
                  return new Shadings.Dummy();
                }
              };
              return Pattern2;
            }();
            var Shadings = {};
            Shadings.SMALL_NUMBER = 1e-6;
            Shadings.RadialAxial = function RadialAxialClosure() {
              function RadialAxial(dict, matrix, xref, res, pdfFunctionFactory) {
                this.matrix = matrix;
                this.coordsArr = dict.getArray("Coords");
                this.shadingType = dict.get("ShadingType");
                this.type = "Pattern";
                var cs = dict.get("ColorSpace", "CS");
                cs = _colorspace.ColorSpace.parse(cs, xref, res, pdfFunctionFactory);
                this.cs = cs;
                var t0 = 0, t1 = 1;
                if (dict.has("Domain")) {
                  var domainArr = dict.getArray("Domain");
                  t0 = domainArr[0];
                  t1 = domainArr[1];
                }
                var extendStart = false, extendEnd = false;
                if (dict.has("Extend")) {
                  var extendArr = dict.getArray("Extend");
                  extendStart = extendArr[0];
                  extendEnd = extendArr[1];
                }
                if (this.shadingType === ShadingType.RADIAL && (!extendStart || !extendEnd)) {
                  var x1 = this.coordsArr[0];
                  var y1 = this.coordsArr[1];
                  var r1 = this.coordsArr[2];
                  var x2 = this.coordsArr[3];
                  var y2 = this.coordsArr[4];
                  var r2 = this.coordsArr[5];
                  var distance = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
                  if (r1 <= r2 + distance && r2 <= r1 + distance) {
                    (0, _util.warn)("Unsupported radial gradient.");
                  }
                }
                this.extendStart = extendStart;
                this.extendEnd = extendEnd;
                var fnObj = dict.get("Function");
                var fn = pdfFunctionFactory.createFromArray(fnObj);
                var diff = t1 - t0;
                var step = diff / 10;
                var colorStops = this.colorStops = [];
                if (t0 >= t1 || step <= 0) {
                  (0, _util.info)("Bad shading domain.");
                  return;
                }
                var color = new Float32Array(cs.numComps), ratio = new Float32Array(1);
                var rgbColor;
                for (var i = t0; i <= t1; i += step) {
                  ratio[0] = i;
                  fn(ratio, 0, color, 0);
                  rgbColor = cs.getRgb(color, 0);
                  var cssColor = _util.Util.makeCssRgb(rgbColor[0], rgbColor[1], rgbColor[2]);
                  colorStops.push([(i - t0) / diff, cssColor]);
                }
                var background = "transparent";
                if (dict.has("Background")) {
                  rgbColor = cs.getRgb(dict.get("Background"), 0);
                  background = _util.Util.makeCssRgb(rgbColor[0], rgbColor[1], rgbColor[2]);
                }
                if (!extendStart) {
                  colorStops.unshift([0, background]);
                  colorStops[1][0] += Shadings.SMALL_NUMBER;
                }
                if (!extendEnd) {
                  colorStops[colorStops.length - 1][0] -= Shadings.SMALL_NUMBER;
                  colorStops.push([1, background]);
                }
                this.colorStops = colorStops;
              }
              RadialAxial.prototype = {
                getIR: function RadialAxial_getIR() {
                  var coordsArr = this.coordsArr;
                  var shadingType = this.shadingType;
                  var type, p0, p1, r0, r1;
                  if (shadingType === ShadingType.AXIAL) {
                    p0 = [coordsArr[0], coordsArr[1]];
                    p1 = [coordsArr[2], coordsArr[3]];
                    r0 = null;
                    r1 = null;
                    type = "axial";
                  } else if (shadingType === ShadingType.RADIAL) {
                    p0 = [coordsArr[0], coordsArr[1]];
                    p1 = [coordsArr[3], coordsArr[4]];
                    r0 = coordsArr[2];
                    r1 = coordsArr[5];
                    type = "radial";
                  } else {
                    (0, _util.unreachable)("getPattern type unknown: " + shadingType);
                  }
                  var matrix = this.matrix;
                  if (matrix) {
                    p0 = _util.Util.applyTransform(p0, matrix);
                    p1 = _util.Util.applyTransform(p1, matrix);
                    if (shadingType === ShadingType.RADIAL) {
                      var scale = _util.Util.singularValueDecompose2dScale(matrix);
                      r0 *= scale[0];
                      r1 *= scale[1];
                    }
                  }
                  return ["RadialAxial", type, this.colorStops, p0, p1, r0, r1];
                }
              };
              return RadialAxial;
            }();
            Shadings.Mesh = function MeshClosure() {
              function MeshStreamReader(stream2, context) {
                this.stream = stream2;
                this.context = context;
                this.buffer = 0;
                this.bufferLength = 0;
                var numComps = context.numComps;
                this.tmpCompsBuf = new Float32Array(numComps);
                var csNumComps = context.colorSpace.numComps;
                this.tmpCsCompsBuf = context.colorFn ? new Float32Array(csNumComps) : this.tmpCompsBuf;
              }
              MeshStreamReader.prototype = {
                get hasData() {
                  if (this.stream.end) {
                    return this.stream.pos < this.stream.end;
                  }
                  if (this.bufferLength > 0) {
                    return true;
                  }
                  var nextByte = this.stream.getByte();
                  if (nextByte < 0) {
                    return false;
                  }
                  this.buffer = nextByte;
                  this.bufferLength = 8;
                  return true;
                },
                readBits: function MeshStreamReader_readBits(n) {
                  var buffer = this.buffer;
                  var bufferLength = this.bufferLength;
                  if (n === 32) {
                    if (bufferLength === 0) {
                      return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
                    }
                    buffer = buffer << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
                    var nextByte = this.stream.getByte();
                    this.buffer = nextByte & (1 << bufferLength) - 1;
                    return (buffer << 8 - bufferLength | (nextByte & 255) >> bufferLength) >>> 0;
                  }
                  if (n === 8 && bufferLength === 0) {
                    return this.stream.getByte();
                  }
                  while (bufferLength < n) {
                    buffer = buffer << 8 | this.stream.getByte();
                    bufferLength += 8;
                  }
                  bufferLength -= n;
                  this.bufferLength = bufferLength;
                  this.buffer = buffer & (1 << bufferLength) - 1;
                  return buffer >> bufferLength;
                },
                align: function MeshStreamReader_align() {
                  this.buffer = 0;
                  this.bufferLength = 0;
                },
                readFlag: function MeshStreamReader_readFlag() {
                  return this.readBits(this.context.bitsPerFlag);
                },
                readCoordinate: function MeshStreamReader_readCoordinate() {
                  var bitsPerCoordinate = this.context.bitsPerCoordinate;
                  var xi = this.readBits(bitsPerCoordinate);
                  var yi = this.readBits(bitsPerCoordinate);
                  var decode = this.context.decode;
                  var scale = bitsPerCoordinate < 32 ? 1 / ((1 << bitsPerCoordinate) - 1) : 23283064365386963e-26;
                  return [xi * scale * (decode[1] - decode[0]) + decode[0], yi * scale * (decode[3] - decode[2]) + decode[2]];
                },
                readComponents: function MeshStreamReader_readComponents() {
                  var numComps = this.context.numComps;
                  var bitsPerComponent = this.context.bitsPerComponent;
                  var scale = bitsPerComponent < 32 ? 1 / ((1 << bitsPerComponent) - 1) : 23283064365386963e-26;
                  var decode = this.context.decode;
                  var components = this.tmpCompsBuf;
                  for (var i = 0, j = 4; i < numComps; i++, j += 2) {
                    var ci = this.readBits(bitsPerComponent);
                    components[i] = ci * scale * (decode[j + 1] - decode[j]) + decode[j];
                  }
                  var color = this.tmpCsCompsBuf;
                  if (this.context.colorFn) {
                    this.context.colorFn(components, 0, color, 0);
                  }
                  return this.context.colorSpace.getRgb(color, 0);
                }
              };
              function decodeType4Shading(mesh, reader) {
                var coords = mesh.coords;
                var colors = mesh.colors;
                var operators = [];
                var ps = [];
                var verticesLeft = 0;
                while (reader.hasData) {
                  var f = reader.readFlag();
                  var coord = reader.readCoordinate();
                  var color = reader.readComponents();
                  if (verticesLeft === 0) {
                    if (!(0 <= f && f <= 2)) {
                      throw new _util.FormatError("Unknown type4 flag");
                    }
                    switch (f) {
                      case 0:
                        verticesLeft = 3;
                        break;
                      case 1:
                        ps.push(ps[ps.length - 2], ps[ps.length - 1]);
                        verticesLeft = 1;
                        break;
                      case 2:
                        ps.push(ps[ps.length - 3], ps[ps.length - 1]);
                        verticesLeft = 1;
                        break;
                    }
                    operators.push(f);
                  }
                  ps.push(coords.length);
                  coords.push(coord);
                  colors.push(color);
                  verticesLeft--;
                  reader.align();
                }
                mesh.figures.push({
                  type: "triangles",
                  coords: new Int32Array(ps),
                  colors: new Int32Array(ps)
                });
              }
              function decodeType5Shading(mesh, reader, verticesPerRow) {
                var coords = mesh.coords;
                var colors = mesh.colors;
                var ps = [];
                while (reader.hasData) {
                  var coord = reader.readCoordinate();
                  var color = reader.readComponents();
                  ps.push(coords.length);
                  coords.push(coord);
                  colors.push(color);
                }
                mesh.figures.push({
                  type: "lattice",
                  coords: new Int32Array(ps),
                  colors: new Int32Array(ps),
                  verticesPerRow
                });
              }
              var MIN_SPLIT_PATCH_CHUNKS_AMOUNT = 3;
              var MAX_SPLIT_PATCH_CHUNKS_AMOUNT = 20;
              var TRIANGLE_DENSITY = 20;
              var getB = /* @__PURE__ */ function getBClosure() {
                function buildB(count) {
                  var lut = [];
                  for (var i = 0; i <= count; i++) {
                    var t = i / count, t_ = 1 - t;
                    lut.push(new Float32Array([t_ * t_ * t_, 3 * t * t_ * t_, 3 * t * t * t_, t * t * t]));
                  }
                  return lut;
                }
                var cache = [];
                return function getB2(count) {
                  if (!cache[count]) {
                    cache[count] = buildB(count);
                  }
                  return cache[count];
                };
              }();
              function buildFigureFromPatch(mesh, index) {
                var figure = mesh.figures[index];
                (0, _util.assert)(figure.type === "patch", "Unexpected patch mesh figure");
                var coords = mesh.coords, colors = mesh.colors;
                var pi = figure.coords;
                var ci = figure.colors;
                var figureMinX = Math.min(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
                var figureMinY = Math.min(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
                var figureMaxX = Math.max(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
                var figureMaxY = Math.max(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
                var splitXBy = Math.ceil((figureMaxX - figureMinX) * TRIANGLE_DENSITY / (mesh.bounds[2] - mesh.bounds[0]));
                splitXBy = Math.max(MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitXBy));
                var splitYBy = Math.ceil((figureMaxY - figureMinY) * TRIANGLE_DENSITY / (mesh.bounds[3] - mesh.bounds[1]));
                splitYBy = Math.max(MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitYBy));
                var verticesPerRow = splitXBy + 1;
                var figureCoords = new Int32Array((splitYBy + 1) * verticesPerRow);
                var figureColors = new Int32Array((splitYBy + 1) * verticesPerRow);
                var k = 0;
                var cl = new Uint8Array(3), cr = new Uint8Array(3);
                var c0 = colors[ci[0]], c1 = colors[ci[1]], c2 = colors[ci[2]], c3 = colors[ci[3]];
                var bRow = getB(splitYBy), bCol = getB(splitXBy);
                for (var row = 0; row <= splitYBy; row++) {
                  cl[0] = (c0[0] * (splitYBy - row) + c2[0] * row) / splitYBy | 0;
                  cl[1] = (c0[1] * (splitYBy - row) + c2[1] * row) / splitYBy | 0;
                  cl[2] = (c0[2] * (splitYBy - row) + c2[2] * row) / splitYBy | 0;
                  cr[0] = (c1[0] * (splitYBy - row) + c3[0] * row) / splitYBy | 0;
                  cr[1] = (c1[1] * (splitYBy - row) + c3[1] * row) / splitYBy | 0;
                  cr[2] = (c1[2] * (splitYBy - row) + c3[2] * row) / splitYBy | 0;
                  for (var col = 0; col <= splitXBy; col++, k++) {
                    if ((row === 0 || row === splitYBy) && (col === 0 || col === splitXBy)) {
                      continue;
                    }
                    var x = 0, y = 0;
                    var q = 0;
                    for (var i = 0; i <= 3; i++) {
                      for (var j = 0; j <= 3; j++, q++) {
                        var m = bRow[row][i] * bCol[col][j];
                        x += coords[pi[q]][0] * m;
                        y += coords[pi[q]][1] * m;
                      }
                    }
                    figureCoords[k] = coords.length;
                    coords.push([x, y]);
                    figureColors[k] = colors.length;
                    var newColor = new Uint8Array(3);
                    newColor[0] = (cl[0] * (splitXBy - col) + cr[0] * col) / splitXBy | 0;
                    newColor[1] = (cl[1] * (splitXBy - col) + cr[1] * col) / splitXBy | 0;
                    newColor[2] = (cl[2] * (splitXBy - col) + cr[2] * col) / splitXBy | 0;
                    colors.push(newColor);
                  }
                }
                figureCoords[0] = pi[0];
                figureColors[0] = ci[0];
                figureCoords[splitXBy] = pi[3];
                figureColors[splitXBy] = ci[1];
                figureCoords[verticesPerRow * splitYBy] = pi[12];
                figureColors[verticesPerRow * splitYBy] = ci[2];
                figureCoords[verticesPerRow * splitYBy + splitXBy] = pi[15];
                figureColors[verticesPerRow * splitYBy + splitXBy] = ci[3];
                mesh.figures[index] = {
                  type: "lattice",
                  coords: figureCoords,
                  colors: figureColors,
                  verticesPerRow
                };
              }
              function decodeType6Shading(mesh, reader) {
                var coords = mesh.coords;
                var colors = mesh.colors;
                var ps = new Int32Array(16);
                var cs = new Int32Array(4);
                while (reader.hasData) {
                  var f = reader.readFlag();
                  if (!(0 <= f && f <= 3)) {
                    throw new _util.FormatError("Unknown type6 flag");
                  }
                  var i, ii;
                  var pi = coords.length;
                  for (i = 0, ii = f !== 0 ? 8 : 12; i < ii; i++) {
                    coords.push(reader.readCoordinate());
                  }
                  var ci = colors.length;
                  for (i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
                    colors.push(reader.readComponents());
                  }
                  var tmp1, tmp2, tmp3, tmp4;
                  switch (f) {
                    case 0:
                      ps[12] = pi + 3;
                      ps[13] = pi + 4;
                      ps[14] = pi + 5;
                      ps[15] = pi + 6;
                      ps[8] = pi + 2;
                      ps[11] = pi + 7;
                      ps[4] = pi + 1;
                      ps[7] = pi + 8;
                      ps[0] = pi;
                      ps[1] = pi + 11;
                      ps[2] = pi + 10;
                      ps[3] = pi + 9;
                      cs[2] = ci + 1;
                      cs[3] = ci + 2;
                      cs[0] = ci;
                      cs[1] = ci + 3;
                      break;
                    case 1:
                      tmp1 = ps[12];
                      tmp2 = ps[13];
                      tmp3 = ps[14];
                      tmp4 = ps[15];
                      ps[12] = tmp4;
                      ps[13] = pi + 0;
                      ps[14] = pi + 1;
                      ps[15] = pi + 2;
                      ps[8] = tmp3;
                      ps[11] = pi + 3;
                      ps[4] = tmp2;
                      ps[7] = pi + 4;
                      ps[0] = tmp1;
                      ps[1] = pi + 7;
                      ps[2] = pi + 6;
                      ps[3] = pi + 5;
                      tmp1 = cs[2];
                      tmp2 = cs[3];
                      cs[2] = tmp2;
                      cs[3] = ci;
                      cs[0] = tmp1;
                      cs[1] = ci + 1;
                      break;
                    case 2:
                      tmp1 = ps[15];
                      tmp2 = ps[11];
                      ps[12] = ps[3];
                      ps[13] = pi + 0;
                      ps[14] = pi + 1;
                      ps[15] = pi + 2;
                      ps[8] = ps[7];
                      ps[11] = pi + 3;
                      ps[4] = tmp2;
                      ps[7] = pi + 4;
                      ps[0] = tmp1;
                      ps[1] = pi + 7;
                      ps[2] = pi + 6;
                      ps[3] = pi + 5;
                      tmp1 = cs[3];
                      cs[2] = cs[1];
                      cs[3] = ci;
                      cs[0] = tmp1;
                      cs[1] = ci + 1;
                      break;
                    case 3:
                      ps[12] = ps[0];
                      ps[13] = pi + 0;
                      ps[14] = pi + 1;
                      ps[15] = pi + 2;
                      ps[8] = ps[1];
                      ps[11] = pi + 3;
                      ps[4] = ps[2];
                      ps[7] = pi + 4;
                      ps[0] = ps[3];
                      ps[1] = pi + 7;
                      ps[2] = pi + 6;
                      ps[3] = pi + 5;
                      cs[2] = cs[0];
                      cs[3] = ci;
                      cs[0] = cs[1];
                      cs[1] = ci + 1;
                      break;
                  }
                  ps[5] = coords.length;
                  coords.push([(-4 * coords[ps[0]][0] - coords[ps[15]][0] + 6 * (coords[ps[4]][0] + coords[ps[1]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[13]][0] + coords[ps[7]][0])) / 9, (-4 * coords[ps[0]][1] - coords[ps[15]][1] + 6 * (coords[ps[4]][1] + coords[ps[1]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[13]][1] + coords[ps[7]][1])) / 9]);
                  ps[6] = coords.length;
                  coords.push([(-4 * coords[ps[3]][0] - coords[ps[12]][0] + 6 * (coords[ps[2]][0] + coords[ps[7]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[4]][0] + coords[ps[14]][0])) / 9, (-4 * coords[ps[3]][1] - coords[ps[12]][1] + 6 * (coords[ps[2]][1] + coords[ps[7]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[4]][1] + coords[ps[14]][1])) / 9]);
                  ps[9] = coords.length;
                  coords.push([(-4 * coords[ps[12]][0] - coords[ps[3]][0] + 6 * (coords[ps[8]][0] + coords[ps[13]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[11]][0] + coords[ps[1]][0])) / 9, (-4 * coords[ps[12]][1] - coords[ps[3]][1] + 6 * (coords[ps[8]][1] + coords[ps[13]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[11]][1] + coords[ps[1]][1])) / 9]);
                  ps[10] = coords.length;
                  coords.push([(-4 * coords[ps[15]][0] - coords[ps[0]][0] + 6 * (coords[ps[11]][0] + coords[ps[14]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[2]][0] + coords[ps[8]][0])) / 9, (-4 * coords[ps[15]][1] - coords[ps[0]][1] + 6 * (coords[ps[11]][1] + coords[ps[14]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[2]][1] + coords[ps[8]][1])) / 9]);
                  mesh.figures.push({
                    type: "patch",
                    coords: new Int32Array(ps),
                    colors: new Int32Array(cs)
                  });
                }
              }
              function decodeType7Shading(mesh, reader) {
                var coords = mesh.coords;
                var colors = mesh.colors;
                var ps = new Int32Array(16);
                var cs = new Int32Array(4);
                while (reader.hasData) {
                  var f = reader.readFlag();
                  if (!(0 <= f && f <= 3)) {
                    throw new _util.FormatError("Unknown type7 flag");
                  }
                  var i, ii;
                  var pi = coords.length;
                  for (i = 0, ii = f !== 0 ? 12 : 16; i < ii; i++) {
                    coords.push(reader.readCoordinate());
                  }
                  var ci = colors.length;
                  for (i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
                    colors.push(reader.readComponents());
                  }
                  var tmp1, tmp2, tmp3, tmp4;
                  switch (f) {
                    case 0:
                      ps[12] = pi + 3;
                      ps[13] = pi + 4;
                      ps[14] = pi + 5;
                      ps[15] = pi + 6;
                      ps[8] = pi + 2;
                      ps[9] = pi + 13;
                      ps[10] = pi + 14;
                      ps[11] = pi + 7;
                      ps[4] = pi + 1;
                      ps[5] = pi + 12;
                      ps[6] = pi + 15;
                      ps[7] = pi + 8;
                      ps[0] = pi;
                      ps[1] = pi + 11;
                      ps[2] = pi + 10;
                      ps[3] = pi + 9;
                      cs[2] = ci + 1;
                      cs[3] = ci + 2;
                      cs[0] = ci;
                      cs[1] = ci + 3;
                      break;
                    case 1:
                      tmp1 = ps[12];
                      tmp2 = ps[13];
                      tmp3 = ps[14];
                      tmp4 = ps[15];
                      ps[12] = tmp4;
                      ps[13] = pi + 0;
                      ps[14] = pi + 1;
                      ps[15] = pi + 2;
                      ps[8] = tmp3;
                      ps[9] = pi + 9;
                      ps[10] = pi + 10;
                      ps[11] = pi + 3;
                      ps[4] = tmp2;
                      ps[5] = pi + 8;
                      ps[6] = pi + 11;
                      ps[7] = pi + 4;
                      ps[0] = tmp1;
                      ps[1] = pi + 7;
                      ps[2] = pi + 6;
                      ps[3] = pi + 5;
                      tmp1 = cs[2];
                      tmp2 = cs[3];
                      cs[2] = tmp2;
                      cs[3] = ci;
                      cs[0] = tmp1;
                      cs[1] = ci + 1;
                      break;
                    case 2:
                      tmp1 = ps[15];
                      tmp2 = ps[11];
                      ps[12] = ps[3];
                      ps[13] = pi + 0;
                      ps[14] = pi + 1;
                      ps[15] = pi + 2;
                      ps[8] = ps[7];
                      ps[9] = pi + 9;
                      ps[10] = pi + 10;
                      ps[11] = pi + 3;
                      ps[4] = tmp2;
                      ps[5] = pi + 8;
                      ps[6] = pi + 11;
                      ps[7] = pi + 4;
                      ps[0] = tmp1;
                      ps[1] = pi + 7;
                      ps[2] = pi + 6;
                      ps[3] = pi + 5;
                      tmp1 = cs[3];
                      cs[2] = cs[1];
                      cs[3] = ci;
                      cs[0] = tmp1;
                      cs[1] = ci + 1;
                      break;
                    case 3:
                      ps[12] = ps[0];
                      ps[13] = pi + 0;
                      ps[14] = pi + 1;
                      ps[15] = pi + 2;
                      ps[8] = ps[1];
                      ps[9] = pi + 9;
                      ps[10] = pi + 10;
                      ps[11] = pi + 3;
                      ps[4] = ps[2];
                      ps[5] = pi + 8;
                      ps[6] = pi + 11;
                      ps[7] = pi + 4;
                      ps[0] = ps[3];
                      ps[1] = pi + 7;
                      ps[2] = pi + 6;
                      ps[3] = pi + 5;
                      cs[2] = cs[0];
                      cs[3] = ci;
                      cs[0] = cs[1];
                      cs[1] = ci + 1;
                      break;
                  }
                  mesh.figures.push({
                    type: "patch",
                    coords: new Int32Array(ps),
                    colors: new Int32Array(cs)
                  });
                }
              }
              function updateBounds(mesh) {
                var minX = mesh.coords[0][0], minY = mesh.coords[0][1], maxX = minX, maxY = minY;
                for (var i = 1, ii = mesh.coords.length; i < ii; i++) {
                  var x = mesh.coords[i][0], y = mesh.coords[i][1];
                  minX = minX > x ? x : minX;
                  minY = minY > y ? y : minY;
                  maxX = maxX < x ? x : maxX;
                  maxY = maxY < y ? y : maxY;
                }
                mesh.bounds = [minX, minY, maxX, maxY];
              }
              function packData(mesh) {
                var i, ii, j, jj;
                var coords = mesh.coords;
                var coordsPacked = new Float32Array(coords.length * 2);
                for (i = 0, j = 0, ii = coords.length; i < ii; i++) {
                  var xy = coords[i];
                  coordsPacked[j++] = xy[0];
                  coordsPacked[j++] = xy[1];
                }
                mesh.coords = coordsPacked;
                var colors = mesh.colors;
                var colorsPacked = new Uint8Array(colors.length * 3);
                for (i = 0, j = 0, ii = colors.length; i < ii; i++) {
                  var c = colors[i];
                  colorsPacked[j++] = c[0];
                  colorsPacked[j++] = c[1];
                  colorsPacked[j++] = c[2];
                }
                mesh.colors = colorsPacked;
                var figures = mesh.figures;
                for (i = 0, ii = figures.length; i < ii; i++) {
                  var figure = figures[i], ps = figure.coords, cs = figure.colors;
                  for (j = 0, jj = ps.length; j < jj; j++) {
                    ps[j] *= 2;
                    cs[j] *= 3;
                  }
                }
              }
              function Mesh(stream2, matrix, xref, res, pdfFunctionFactory) {
                if (!(0, _primitives.isStream)(stream2)) {
                  throw new _util.FormatError("Mesh data is not a stream");
                }
                var dict = stream2.dict;
                this.matrix = matrix;
                this.shadingType = dict.get("ShadingType");
                this.type = "Pattern";
                this.bbox = dict.getArray("BBox");
                var cs = dict.get("ColorSpace", "CS");
                cs = _colorspace.ColorSpace.parse(cs, xref, res, pdfFunctionFactory);
                this.cs = cs;
                this.background = dict.has("Background") ? cs.getRgb(dict.get("Background"), 0) : null;
                var fnObj = dict.get("Function");
                var fn = fnObj ? pdfFunctionFactory.createFromArray(fnObj) : null;
                this.coords = [];
                this.colors = [];
                this.figures = [];
                var decodeContext = {
                  bitsPerCoordinate: dict.get("BitsPerCoordinate"),
                  bitsPerComponent: dict.get("BitsPerComponent"),
                  bitsPerFlag: dict.get("BitsPerFlag"),
                  decode: dict.getArray("Decode"),
                  colorFn: fn,
                  colorSpace: cs,
                  numComps: fn ? 1 : cs.numComps
                };
                var reader = new MeshStreamReader(stream2, decodeContext);
                var patchMesh = false;
                switch (this.shadingType) {
                  case ShadingType.FREE_FORM_MESH:
                    decodeType4Shading(this, reader);
                    break;
                  case ShadingType.LATTICE_FORM_MESH:
                    var verticesPerRow = dict.get("VerticesPerRow") | 0;
                    if (verticesPerRow < 2) {
                      throw new _util.FormatError("Invalid VerticesPerRow");
                    }
                    decodeType5Shading(this, reader, verticesPerRow);
                    break;
                  case ShadingType.COONS_PATCH_MESH:
                    decodeType6Shading(this, reader);
                    patchMesh = true;
                    break;
                  case ShadingType.TENSOR_PATCH_MESH:
                    decodeType7Shading(this, reader);
                    patchMesh = true;
                    break;
                  default:
                    (0, _util.unreachable)("Unsupported mesh type.");
                    break;
                }
                if (patchMesh) {
                  updateBounds(this);
                  for (var i = 0, ii = this.figures.length; i < ii; i++) {
                    buildFigureFromPatch(this, i);
                  }
                }
                updateBounds(this);
                packData(this);
              }
              Mesh.prototype = {
                getIR: function Mesh_getIR() {
                  return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.matrix, this.bbox, this.background];
                }
              };
              return Mesh;
            }();
            Shadings.Dummy = function DummyClosure() {
              function Dummy() {
                this.type = "Pattern";
              }
              Dummy.prototype = {
                getIR: function Dummy_getIR() {
                  return ["Dummy"];
                }
              };
              return Dummy;
            }();
            function getTilingPatternIR(operatorList, dict, args) {
              var matrix = dict.getArray("Matrix");
              var bbox = _util.Util.normalizeRect(dict.getArray("BBox"));
              var xstep = dict.get("XStep");
              var ystep = dict.get("YStep");
              var paintType = dict.get("PaintType");
              var tilingType = dict.get("TilingType");
              if (bbox[2] - bbox[0] === 0 || bbox[3] - bbox[1] === 0) {
                throw new _util.FormatError("Invalid getTilingPatternIR /BBox array: [" + bbox + "].");
              }
              return ["TilingPattern", args, operatorList, matrix, bbox, xstep, ystep, paintType, tilingType];
            }
            exports3.Pattern = Pattern;
            exports3.getTilingPatternIR = getTilingPatternIR;
          },
          /* 147 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.bidi = void 0;
            var _util = __w_pdfjs_require__(2);
            var baseTypes = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"];
            var arabicTypes = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
            function isOdd(i) {
              return (i & 1) !== 0;
            }
            function isEven(i) {
              return (i & 1) === 0;
            }
            function findUnequal(arr, start, value) {
              for (var j = start, jj = arr.length; j < jj; ++j) {
                if (arr[j] !== value) {
                  return j;
                }
              }
              return j;
            }
            function setValues(arr, start, end, value) {
              for (var j = start; j < end; ++j) {
                arr[j] = value;
              }
            }
            function reverseValues(arr, start, end) {
              for (var i = start, j = end - 1; i < j; ++i, --j) {
                var temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
              }
            }
            function createBidiText(str, isLTR, vertical) {
              return {
                str,
                dir: vertical ? "ttb" : isLTR ? "ltr" : "rtl"
              };
            }
            var chars = [];
            var types = [];
            function bidi(str, startLevel, vertical) {
              var isLTR = true;
              var strLength = str.length;
              if (strLength === 0 || vertical) {
                return createBidiText(str, isLTR, vertical);
              }
              chars.length = strLength;
              types.length = strLength;
              var numBidi = 0;
              var i, ii;
              for (i = 0; i < strLength; ++i) {
                chars[i] = str.charAt(i);
                var charCode = str.charCodeAt(i);
                var charType = "L";
                if (charCode <= 255) {
                  charType = baseTypes[charCode];
                } else if (1424 <= charCode && charCode <= 1524) {
                  charType = "R";
                } else if (1536 <= charCode && charCode <= 1791) {
                  charType = arabicTypes[charCode & 255];
                  if (!charType) {
                    (0, _util.warn)("Bidi: invalid Unicode character " + charCode.toString(16));
                  }
                } else if (1792 <= charCode && charCode <= 2220) {
                  charType = "AL";
                }
                if (charType === "R" || charType === "AL" || charType === "AN") {
                  numBidi++;
                }
                types[i] = charType;
              }
              if (numBidi === 0) {
                isLTR = true;
                return createBidiText(str, isLTR);
              }
              if (startLevel === -1) {
                if (numBidi / strLength < 0.3) {
                  isLTR = true;
                  startLevel = 0;
                } else {
                  isLTR = false;
                  startLevel = 1;
                }
              }
              var levels = [];
              for (i = 0; i < strLength; ++i) {
                levels[i] = startLevel;
              }
              var e = isOdd(startLevel) ? "R" : "L";
              var sor = e;
              var eor = sor;
              var lastType = sor;
              for (i = 0; i < strLength; ++i) {
                if (types[i] === "NSM") {
                  types[i] = lastType;
                } else {
                  lastType = types[i];
                }
              }
              lastType = sor;
              var t;
              for (i = 0; i < strLength; ++i) {
                t = types[i];
                if (t === "EN") {
                  types[i] = lastType === "AL" ? "AN" : "EN";
                } else if (t === "R" || t === "L" || t === "AL") {
                  lastType = t;
                }
              }
              for (i = 0; i < strLength; ++i) {
                t = types[i];
                if (t === "AL") {
                  types[i] = "R";
                }
              }
              for (i = 1; i < strLength - 1; ++i) {
                if (types[i] === "ES" && types[i - 1] === "EN" && types[i + 1] === "EN") {
                  types[i] = "EN";
                }
                if (types[i] === "CS" && (types[i - 1] === "EN" || types[i - 1] === "AN") && types[i + 1] === types[i - 1]) {
                  types[i] = types[i - 1];
                }
              }
              for (i = 0; i < strLength; ++i) {
                if (types[i] === "EN") {
                  var j;
                  for (j = i - 1; j >= 0; --j) {
                    if (types[j] !== "ET") {
                      break;
                    }
                    types[j] = "EN";
                  }
                  for (j = i + 1; j < strLength; ++j) {
                    if (types[j] !== "ET") {
                      break;
                    }
                    types[j] = "EN";
                  }
                }
              }
              for (i = 0; i < strLength; ++i) {
                t = types[i];
                if (t === "WS" || t === "ES" || t === "ET" || t === "CS") {
                  types[i] = "ON";
                }
              }
              lastType = sor;
              for (i = 0; i < strLength; ++i) {
                t = types[i];
                if (t === "EN") {
                  types[i] = lastType === "L" ? "L" : "EN";
                } else if (t === "R" || t === "L") {
                  lastType = t;
                }
              }
              for (i = 0; i < strLength; ++i) {
                if (types[i] === "ON") {
                  var end = findUnequal(types, i + 1, "ON");
                  var before = sor;
                  if (i > 0) {
                    before = types[i - 1];
                  }
                  var after = eor;
                  if (end + 1 < strLength) {
                    after = types[end + 1];
                  }
                  if (before !== "L") {
                    before = "R";
                  }
                  if (after !== "L") {
                    after = "R";
                  }
                  if (before === after) {
                    setValues(types, i, end, before);
                  }
                  i = end - 1;
                }
              }
              for (i = 0; i < strLength; ++i) {
                if (types[i] === "ON") {
                  types[i] = e;
                }
              }
              for (i = 0; i < strLength; ++i) {
                t = types[i];
                if (isEven(levels[i])) {
                  if (t === "R") {
                    levels[i] += 1;
                  } else if (t === "AN" || t === "EN") {
                    levels[i] += 2;
                  }
                } else {
                  if (t === "L" || t === "AN" || t === "EN") {
                    levels[i] += 1;
                  }
                }
              }
              var highestLevel = -1;
              var lowestOddLevel = 99;
              var level;
              for (i = 0, ii = levels.length; i < ii; ++i) {
                level = levels[i];
                if (highestLevel < level) {
                  highestLevel = level;
                }
                if (lowestOddLevel > level && isOdd(level)) {
                  lowestOddLevel = level;
                }
              }
              for (level = highestLevel; level >= lowestOddLevel; --level) {
                var start = -1;
                for (i = 0, ii = levels.length; i < ii; ++i) {
                  if (levels[i] < level) {
                    if (start >= 0) {
                      reverseValues(chars, start, i);
                      start = -1;
                    }
                  } else if (start < 0) {
                    start = i;
                  }
                }
                if (start >= 0) {
                  reverseValues(chars, start, levels.length);
                }
              }
              for (i = 0, ii = chars.length; i < ii; ++i) {
                var ch = chars[i];
                if (ch === "<" || ch === ">") {
                  chars[i] = "";
                }
              }
              return createBidiText(chars.join(""), isLTR);
            }
            exports3.bidi = bidi;
          },
          /* 148 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.getMetrics = void 0;
            var _util = __w_pdfjs_require__(2);
            var getMetrics = (0, _util.getLookupTableFactory)(function(t) {
              t["Courier"] = 600;
              t["Courier-Bold"] = 600;
              t["Courier-BoldOblique"] = 600;
              t["Courier-Oblique"] = 600;
              t["Helvetica"] = (0, _util.getLookupTableFactory)(function(t2) {
                t2["space"] = 278;
                t2["exclam"] = 278;
                t2["quotedbl"] = 355;
                t2["numbersign"] = 556;
                t2["dollar"] = 556;
                t2["percent"] = 889;
                t2["ampersand"] = 667;
                t2["quoteright"] = 222;
                t2["parenleft"] = 333;
                t2["parenright"] = 333;
                t2["asterisk"] = 389;
                t2["plus"] = 584;
                t2["comma"] = 278;
                t2["hyphen"] = 333;
                t2["period"] = 278;
                t2["slash"] = 278;
                t2["zero"] = 556;
                t2["one"] = 556;
                t2["two"] = 556;
                t2["three"] = 556;
                t2["four"] = 556;
                t2["five"] = 556;
                t2["six"] = 556;
                t2["seven"] = 556;
                t2["eight"] = 556;
                t2["nine"] = 556;
                t2["colon"] = 278;
                t2["semicolon"] = 278;
                t2["less"] = 584;
                t2["equal"] = 584;
                t2["greater"] = 584;
                t2["question"] = 556;
                t2["at"] = 1015;
                t2["A"] = 667;
                t2["B"] = 667;
                t2["C"] = 722;
                t2["D"] = 722;
                t2["E"] = 667;
                t2["F"] = 611;
                t2["G"] = 778;
                t2["H"] = 722;
                t2["I"] = 278;
                t2["J"] = 500;
                t2["K"] = 667;
                t2["L"] = 556;
                t2["M"] = 833;
                t2["N"] = 722;
                t2["O"] = 778;
                t2["P"] = 667;
                t2["Q"] = 778;
                t2["R"] = 722;
                t2["S"] = 667;
                t2["T"] = 611;
                t2["U"] = 722;
                t2["V"] = 667;
                t2["W"] = 944;
                t2["X"] = 667;
                t2["Y"] = 667;
                t2["Z"] = 611;
                t2["bracketleft"] = 278;
                t2["backslash"] = 278;
                t2["bracketright"] = 278;
                t2["asciicircum"] = 469;
                t2["underscore"] = 556;
                t2["quoteleft"] = 222;
                t2["a"] = 556;
                t2["b"] = 556;
                t2["c"] = 500;
                t2["d"] = 556;
                t2["e"] = 556;
                t2["f"] = 278;
                t2["g"] = 556;
                t2["h"] = 556;
                t2["i"] = 222;
                t2["j"] = 222;
                t2["k"] = 500;
                t2["l"] = 222;
                t2["m"] = 833;
                t2["n"] = 556;
                t2["o"] = 556;
                t2["p"] = 556;
                t2["q"] = 556;
                t2["r"] = 333;
                t2["s"] = 500;
                t2["t"] = 278;
                t2["u"] = 556;
                t2["v"] = 500;
                t2["w"] = 722;
                t2["x"] = 500;
                t2["y"] = 500;
                t2["z"] = 500;
                t2["braceleft"] = 334;
                t2["bar"] = 260;
                t2["braceright"] = 334;
                t2["asciitilde"] = 584;
                t2["exclamdown"] = 333;
                t2["cent"] = 556;
                t2["sterling"] = 556;
                t2["fraction"] = 167;
                t2["yen"] = 556;
                t2["florin"] = 556;
                t2["section"] = 556;
                t2["currency"] = 556;
                t2["quotesingle"] = 191;
                t2["quotedblleft"] = 333;
                t2["guillemotleft"] = 556;
                t2["guilsinglleft"] = 333;
                t2["guilsinglright"] = 333;
                t2["fi"] = 500;
                t2["fl"] = 500;
                t2["endash"] = 556;
                t2["dagger"] = 556;
                t2["daggerdbl"] = 556;
                t2["periodcentered"] = 278;
                t2["paragraph"] = 537;
                t2["bullet"] = 350;
                t2["quotesinglbase"] = 222;
                t2["quotedblbase"] = 333;
                t2["quotedblright"] = 333;
                t2["guillemotright"] = 556;
                t2["ellipsis"] = 1e3;
                t2["perthousand"] = 1e3;
                t2["questiondown"] = 611;
                t2["grave"] = 333;
                t2["acute"] = 333;
                t2["circumflex"] = 333;
                t2["tilde"] = 333;
                t2["macron"] = 333;
                t2["breve"] = 333;
                t2["dotaccent"] = 333;
                t2["dieresis"] = 333;
                t2["ring"] = 333;
                t2["cedilla"] = 333;
                t2["hungarumlaut"] = 333;
                t2["ogonek"] = 333;
                t2["caron"] = 333;
                t2["emdash"] = 1e3;
                t2["AE"] = 1e3;
                t2["ordfeminine"] = 370;
                t2["Lslash"] = 556;
                t2["Oslash"] = 778;
                t2["OE"] = 1e3;
                t2["ordmasculine"] = 365;
                t2["ae"] = 889;
                t2["dotlessi"] = 278;
                t2["lslash"] = 222;
                t2["oslash"] = 611;
                t2["oe"] = 944;
                t2["germandbls"] = 611;
                t2["Idieresis"] = 278;
                t2["eacute"] = 556;
                t2["abreve"] = 556;
                t2["uhungarumlaut"] = 556;
                t2["ecaron"] = 556;
                t2["Ydieresis"] = 667;
                t2["divide"] = 584;
                t2["Yacute"] = 667;
                t2["Acircumflex"] = 667;
                t2["aacute"] = 556;
                t2["Ucircumflex"] = 722;
                t2["yacute"] = 500;
                t2["scommaaccent"] = 500;
                t2["ecircumflex"] = 556;
                t2["Uring"] = 722;
                t2["Udieresis"] = 722;
                t2["aogonek"] = 556;
                t2["Uacute"] = 722;
                t2["uogonek"] = 556;
                t2["Edieresis"] = 667;
                t2["Dcroat"] = 722;
                t2["commaaccent"] = 250;
                t2["copyright"] = 737;
                t2["Emacron"] = 667;
                t2["ccaron"] = 500;
                t2["aring"] = 556;
                t2["Ncommaaccent"] = 722;
                t2["lacute"] = 222;
                t2["agrave"] = 556;
                t2["Tcommaaccent"] = 611;
                t2["Cacute"] = 722;
                t2["atilde"] = 556;
                t2["Edotaccent"] = 667;
                t2["scaron"] = 500;
                t2["scedilla"] = 500;
                t2["iacute"] = 278;
                t2["lozenge"] = 471;
                t2["Rcaron"] = 722;
                t2["Gcommaaccent"] = 778;
                t2["ucircumflex"] = 556;
                t2["acircumflex"] = 556;
                t2["Amacron"] = 667;
                t2["rcaron"] = 333;
                t2["ccedilla"] = 500;
                t2["Zdotaccent"] = 611;
                t2["Thorn"] = 667;
                t2["Omacron"] = 778;
                t2["Racute"] = 722;
                t2["Sacute"] = 667;
                t2["dcaron"] = 643;
                t2["Umacron"] = 722;
                t2["uring"] = 556;
                t2["threesuperior"] = 333;
                t2["Ograve"] = 778;
                t2["Agrave"] = 667;
                t2["Abreve"] = 667;
                t2["multiply"] = 584;
                t2["uacute"] = 556;
                t2["Tcaron"] = 611;
                t2["partialdiff"] = 476;
                t2["ydieresis"] = 500;
                t2["Nacute"] = 722;
                t2["icircumflex"] = 278;
                t2["Ecircumflex"] = 667;
                t2["adieresis"] = 556;
                t2["edieresis"] = 556;
                t2["cacute"] = 500;
                t2["nacute"] = 556;
                t2["umacron"] = 556;
                t2["Ncaron"] = 722;
                t2["Iacute"] = 278;
                t2["plusminus"] = 584;
                t2["brokenbar"] = 260;
                t2["registered"] = 737;
                t2["Gbreve"] = 778;
                t2["Idotaccent"] = 278;
                t2["summation"] = 600;
                t2["Egrave"] = 667;
                t2["racute"] = 333;
                t2["omacron"] = 556;
                t2["Zacute"] = 611;
                t2["Zcaron"] = 611;
                t2["greaterequal"] = 549;
                t2["Eth"] = 722;
                t2["Ccedilla"] = 722;
                t2["lcommaaccent"] = 222;
                t2["tcaron"] = 317;
                t2["eogonek"] = 556;
                t2["Uogonek"] = 722;
                t2["Aacute"] = 667;
                t2["Adieresis"] = 667;
                t2["egrave"] = 556;
                t2["zacute"] = 500;
                t2["iogonek"] = 222;
                t2["Oacute"] = 778;
                t2["oacute"] = 556;
                t2["amacron"] = 556;
                t2["sacute"] = 500;
                t2["idieresis"] = 278;
                t2["Ocircumflex"] = 778;
                t2["Ugrave"] = 722;
                t2["Delta"] = 612;
                t2["thorn"] = 556;
                t2["twosuperior"] = 333;
                t2["Odieresis"] = 778;
                t2["mu"] = 556;
                t2["igrave"] = 278;
                t2["ohungarumlaut"] = 556;
                t2["Eogonek"] = 667;
                t2["dcroat"] = 556;
                t2["threequarters"] = 834;
                t2["Scedilla"] = 667;
                t2["lcaron"] = 299;
                t2["Kcommaaccent"] = 667;
                t2["Lacute"] = 556;
                t2["trademark"] = 1e3;
                t2["edotaccent"] = 556;
                t2["Igrave"] = 278;
                t2["Imacron"] = 278;
                t2["Lcaron"] = 556;
                t2["onehalf"] = 834;
                t2["lessequal"] = 549;
                t2["ocircumflex"] = 556;
                t2["ntilde"] = 556;
                t2["Uhungarumlaut"] = 722;
                t2["Eacute"] = 667;
                t2["emacron"] = 556;
                t2["gbreve"] = 556;
                t2["onequarter"] = 834;
                t2["Scaron"] = 667;
                t2["Scommaaccent"] = 667;
                t2["Ohungarumlaut"] = 778;
                t2["degree"] = 400;
                t2["ograve"] = 556;
                t2["Ccaron"] = 722;
                t2["ugrave"] = 556;
                t2["radical"] = 453;
                t2["Dcaron"] = 722;
                t2["rcommaaccent"] = 333;
                t2["Ntilde"] = 722;
                t2["otilde"] = 556;
                t2["Rcommaaccent"] = 722;
                t2["Lcommaaccent"] = 556;
                t2["Atilde"] = 667;
                t2["Aogonek"] = 667;
                t2["Aring"] = 667;
                t2["Otilde"] = 778;
                t2["zdotaccent"] = 500;
                t2["Ecaron"] = 667;
                t2["Iogonek"] = 278;
                t2["kcommaaccent"] = 500;
                t2["minus"] = 584;
                t2["Icircumflex"] = 278;
                t2["ncaron"] = 556;
                t2["tcommaaccent"] = 278;
                t2["logicalnot"] = 584;
                t2["odieresis"] = 556;
                t2["udieresis"] = 556;
                t2["notequal"] = 549;
                t2["gcommaaccent"] = 556;
                t2["eth"] = 556;
                t2["zcaron"] = 500;
                t2["ncommaaccent"] = 556;
                t2["onesuperior"] = 333;
                t2["imacron"] = 278;
                t2["Euro"] = 556;
              });
              t["Helvetica-Bold"] = (0, _util.getLookupTableFactory)(function(t2) {
                t2["space"] = 278;
                t2["exclam"] = 333;
                t2["quotedbl"] = 474;
                t2["numbersign"] = 556;
                t2["dollar"] = 556;
                t2["percent"] = 889;
                t2["ampersand"] = 722;
                t2["quoteright"] = 278;
                t2["parenleft"] = 333;
                t2["parenright"] = 333;
                t2["asterisk"] = 389;
                t2["plus"] = 584;
                t2["comma"] = 278;
                t2["hyphen"] = 333;
                t2["period"] = 278;
                t2["slash"] = 278;
                t2["zero"] = 556;
                t2["one"] = 556;
                t2["two"] = 556;
                t2["three"] = 556;
                t2["four"] = 556;
                t2["five"] = 556;
                t2["six"] = 556;
                t2["seven"] = 556;
                t2["eight"] = 556;
                t2["nine"] = 556;
                t2["colon"] = 333;
                t2["semicolon"] = 333;
                t2["less"] = 584;
                t2["equal"] = 584;
                t2["greater"] = 584;
                t2["question"] = 611;
                t2["at"] = 975;
                t2["A"] = 722;
                t2["B"] = 722;
                t2["C"] = 722;
                t2["D"] = 722;
                t2["E"] = 667;
                t2["F"] = 611;
                t2["G"] = 778;
                t2["H"] = 722;
                t2["I"] = 278;
                t2["J"] = 556;
                t2["K"] = 722;
                t2["L"] = 611;
                t2["M"] = 833;
                t2["N"] = 722;
                t2["O"] = 778;
                t2["P"] = 667;
                t2["Q"] = 778;
                t2["R"] = 722;
                t2["S"] = 667;
                t2["T"] = 611;
                t2["U"] = 722;
                t2["V"] = 667;
                t2["W"] = 944;
                t2["X"] = 667;
                t2["Y"] = 667;
                t2["Z"] = 611;
                t2["bracketleft"] = 333;
                t2["backslash"] = 278;
                t2["bracketright"] = 333;
                t2["asciicircum"] = 584;
                t2["underscore"] = 556;
                t2["quoteleft"] = 278;
                t2["a"] = 556;
                t2["b"] = 611;
                t2["c"] = 556;
                t2["d"] = 611;
                t2["e"] = 556;
                t2["f"] = 333;
                t2["g"] = 611;
                t2["h"] = 611;
                t2["i"] = 278;
                t2["j"] = 278;
                t2["k"] = 556;
                t2["l"] = 278;
                t2["m"] = 889;
                t2["n"] = 611;
                t2["o"] = 611;
                t2["p"] = 611;
                t2["q"] = 611;
                t2["r"] = 389;
                t2["s"] = 556;
                t2["t"] = 333;
                t2["u"] = 611;
                t2["v"] = 556;
                t2["w"] = 778;
                t2["x"] = 556;
                t2["y"] = 556;
                t2["z"] = 500;
                t2["braceleft"] = 389;
                t2["bar"] = 280;
                t2["braceright"] = 389;
                t2["asciitilde"] = 584;
                t2["exclamdown"] = 333;
                t2["cent"] = 556;
                t2["sterling"] = 556;
                t2["fraction"] = 167;
                t2["yen"] = 556;
                t2["florin"] = 556;
                t2["section"] = 556;
                t2["currency"] = 556;
                t2["quotesingle"] = 238;
                t2["quotedblleft"] = 500;
                t2["guillemotleft"] = 556;
                t2["guilsinglleft"] = 333;
                t2["guilsinglright"] = 333;
                t2["fi"] = 611;
                t2["fl"] = 611;
                t2["endash"] = 556;
                t2["dagger"] = 556;
                t2["daggerdbl"] = 556;
                t2["periodcentered"] = 278;
                t2["paragraph"] = 556;
                t2["bullet"] = 350;
                t2["quotesinglbase"] = 278;
                t2["quotedblbase"] = 500;
                t2["quotedblright"] = 500;
                t2["guillemotright"] = 556;
                t2["ellipsis"] = 1e3;
                t2["perthousand"] = 1e3;
                t2["questiondown"] = 611;
                t2["grave"] = 333;
                t2["acute"] = 333;
                t2["circumflex"] = 333;
                t2["tilde"] = 333;
                t2["macron"] = 333;
                t2["breve"] = 333;
                t2["dotaccent"] = 333;
                t2["dieresis"] = 333;
                t2["ring"] = 333;
                t2["cedilla"] = 333;
                t2["hungarumlaut"] = 333;
                t2["ogonek"] = 333;
                t2["caron"] = 333;
                t2["emdash"] = 1e3;
                t2["AE"] = 1e3;
                t2["ordfeminine"] = 370;
                t2["Lslash"] = 611;
                t2["Oslash"] = 778;
                t2["OE"] = 1e3;
                t2["ordmasculine"] = 365;
                t2["ae"] = 889;
                t2["dotlessi"] = 278;
                t2["lslash"] = 278;
                t2["oslash"] = 611;
                t2["oe"] = 944;
                t2["germandbls"] = 611;
                t2["Idieresis"] = 278;
                t2["eacute"] = 556;
                t2["abreve"] = 556;
                t2["uhungarumlaut"] = 611;
                t2["ecaron"] = 556;
                t2["Ydieresis"] = 667;
                t2["divide"] = 584;
                t2["Yacute"] = 667;
                t2["Acircumflex"] = 722;
                t2["aacute"] = 556;
                t2["Ucircumflex"] = 722;
                t2["yacute"] = 556;
                t2["scommaaccent"] = 556;
                t2["ecircumflex"] = 556;
                t2["Uring"] = 722;
                t2["Udieresis"] = 722;
                t2["aogonek"] = 556;
                t2["Uacute"] = 722;
                t2["uogonek"] = 611;
                t2["Edieresis"] = 667;
                t2["Dcroat"] = 722;
                t2["commaaccent"] = 250;
                t2["copyright"] = 737;
                t2["Emacron"] = 667;
                t2["ccaron"] = 556;
                t2["aring"] = 556;
                t2["Ncommaaccent"] = 722;
                t2["lacute"] = 278;
                t2["agrave"] = 556;
                t2["Tcommaaccent"] = 611;
                t2["Cacute"] = 722;
                t2["atilde"] = 556;
                t2["Edotaccent"] = 667;
                t2["scaron"] = 556;
                t2["scedilla"] = 556;
                t2["iacute"] = 278;
                t2["lozenge"] = 494;
                t2["Rcaron"] = 722;
                t2["Gcommaaccent"] = 778;
                t2["ucircumflex"] = 611;
                t2["acircumflex"] = 556;
                t2["Amacron"] = 722;
                t2["rcaron"] = 389;
                t2["ccedilla"] = 556;
                t2["Zdotaccent"] = 611;
                t2["Thorn"] = 667;
                t2["Omacron"] = 778;
                t2["Racute"] = 722;
                t2["Sacute"] = 667;
                t2["dcaron"] = 743;
                t2["Umacron"] = 722;
                t2["uring"] = 611;
                t2["threesuperior"] = 333;
                t2["Ograve"] = 778;
                t2["Agrave"] = 722;
                t2["Abreve"] = 722;
                t2["multiply"] = 584;
                t2["uacute"] = 611;
                t2["Tcaron"] = 611;
                t2["partialdiff"] = 494;
                t2["ydieresis"] = 556;
                t2["Nacute"] = 722;
                t2["icircumflex"] = 278;
                t2["Ecircumflex"] = 667;
                t2["adieresis"] = 556;
                t2["edieresis"] = 556;
                t2["cacute"] = 556;
                t2["nacute"] = 611;
                t2["umacron"] = 611;
                t2["Ncaron"] = 722;
                t2["Iacute"] = 278;
                t2["plusminus"] = 584;
                t2["brokenbar"] = 280;
                t2["registered"] = 737;
                t2["Gbreve"] = 778;
                t2["Idotaccent"] = 278;
                t2["summation"] = 600;
                t2["Egrave"] = 667;
                t2["racute"] = 389;
                t2["omacron"] = 611;
                t2["Zacute"] = 611;
                t2["Zcaron"] = 611;
                t2["greaterequal"] = 549;
                t2["Eth"] = 722;
                t2["Ccedilla"] = 722;
                t2["lcommaaccent"] = 278;
                t2["tcaron"] = 389;
                t2["eogonek"] = 556;
                t2["Uogonek"] = 722;
                t2["Aacute"] = 722;
                t2["Adieresis"] = 722;
                t2["egrave"] = 556;
                t2["zacute"] = 500;
                t2["iogonek"] = 278;
                t2["Oacute"] = 778;
                t2["oacute"] = 611;
                t2["amacron"] = 556;
                t2["sacute"] = 556;
                t2["idieresis"] = 278;
                t2["Ocircumflex"] = 778;
                t2["Ugrave"] = 722;
                t2["Delta"] = 612;
                t2["thorn"] = 611;
                t2["twosuperior"] = 333;
                t2["Odieresis"] = 778;
                t2["mu"] = 611;
                t2["igrave"] = 278;
                t2["ohungarumlaut"] = 611;
                t2["Eogonek"] = 667;
                t2["dcroat"] = 611;
                t2["threequarters"] = 834;
                t2["Scedilla"] = 667;
                t2["lcaron"] = 400;
                t2["Kcommaaccent"] = 722;
                t2["Lacute"] = 611;
                t2["trademark"] = 1e3;
                t2["edotaccent"] = 556;
                t2["Igrave"] = 278;
                t2["Imacron"] = 278;
                t2["Lcaron"] = 611;
                t2["onehalf"] = 834;
                t2["lessequal"] = 549;
                t2["ocircumflex"] = 611;
                t2["ntilde"] = 611;
                t2["Uhungarumlaut"] = 722;
                t2["Eacute"] = 667;
                t2["emacron"] = 556;
                t2["gbreve"] = 611;
                t2["onequarter"] = 834;
                t2["Scaron"] = 667;
                t2["Scommaaccent"] = 667;
                t2["Ohungarumlaut"] = 778;
                t2["degree"] = 400;
                t2["ograve"] = 611;
                t2["Ccaron"] = 722;
                t2["ugrave"] = 611;
                t2["radical"] = 549;
                t2["Dcaron"] = 722;
                t2["rcommaaccent"] = 389;
                t2["Ntilde"] = 722;
                t2["otilde"] = 611;
                t2["Rcommaaccent"] = 722;
                t2["Lcommaaccent"] = 611;
                t2["Atilde"] = 722;
                t2["Aogonek"] = 722;
                t2["Aring"] = 722;
                t2["Otilde"] = 778;
                t2["zdotaccent"] = 500;
                t2["Ecaron"] = 667;
                t2["Iogonek"] = 278;
                t2["kcommaaccent"] = 556;
                t2["minus"] = 584;
                t2["Icircumflex"] = 278;
                t2["ncaron"] = 611;
                t2["tcommaaccent"] = 333;
                t2["logicalnot"] = 584;
                t2["odieresis"] = 611;
                t2["udieresis"] = 611;
                t2["notequal"] = 549;
                t2["gcommaaccent"] = 611;
                t2["eth"] = 611;
                t2["zcaron"] = 500;
                t2["ncommaaccent"] = 611;
                t2["onesuperior"] = 333;
                t2["imacron"] = 278;
                t2["Euro"] = 556;
              });
              t["Helvetica-BoldOblique"] = (0, _util.getLookupTableFactory)(function(t2) {
                t2["space"] = 278;
                t2["exclam"] = 333;
                t2["quotedbl"] = 474;
                t2["numbersign"] = 556;
                t2["dollar"] = 556;
                t2["percent"] = 889;
                t2["ampersand"] = 722;
                t2["quoteright"] = 278;
                t2["parenleft"] = 333;
                t2["parenright"] = 333;
                t2["asterisk"] = 389;
                t2["plus"] = 584;
                t2["comma"] = 278;
                t2["hyphen"] = 333;
                t2["period"] = 278;
                t2["slash"] = 278;
                t2["zero"] = 556;
                t2["one"] = 556;
                t2["two"] = 556;
                t2["three"] = 556;
                t2["four"] = 556;
                t2["five"] = 556;
                t2["six"] = 556;
                t2["seven"] = 556;
                t2["eight"] = 556;
                t2["nine"] = 556;
                t2["colon"] = 333;
                t2["semicolon"] = 333;
                t2["less"] = 584;
                t2["equal"] = 584;
                t2["greater"] = 584;
                t2["question"] = 611;
                t2["at"] = 975;
                t2["A"] = 722;
                t2["B"] = 722;
                t2["C"] = 722;
                t2["D"] = 722;
                t2["E"] = 667;
                t2["F"] = 611;
                t2["G"] = 778;
                t2["H"] = 722;
                t2["I"] = 278;
                t2["J"] = 556;
                t2["K"] = 722;
                t2["L"] = 611;
                t2["M"] = 833;
                t2["N"] = 722;
                t2["O"] = 778;
                t2["P"] = 667;
                t2["Q"] = 778;
                t2["R"] = 722;
                t2["S"] = 667;
                t2["T"] = 611;
                t2["U"] = 722;
                t2["V"] = 667;
                t2["W"] = 944;
                t2["X"] = 667;
                t2["Y"] = 667;
                t2["Z"] = 611;
                t2["bracketleft"] = 333;
                t2["backslash"] = 278;
                t2["bracketright"] = 333;
                t2["asciicircum"] = 584;
                t2["underscore"] = 556;
                t2["quoteleft"] = 278;
                t2["a"] = 556;
                t2["b"] = 611;
                t2["c"] = 556;
                t2["d"] = 611;
                t2["e"] = 556;
                t2["f"] = 333;
                t2["g"] = 611;
                t2["h"] = 611;
                t2["i"] = 278;
                t2["j"] = 278;
                t2["k"] = 556;
                t2["l"] = 278;
                t2["m"] = 889;
                t2["n"] = 611;
                t2["o"] = 611;
                t2["p"] = 611;
                t2["q"] = 611;
                t2["r"] = 389;
                t2["s"] = 556;
                t2["t"] = 333;
                t2["u"] = 611;
                t2["v"] = 556;
                t2["w"] = 778;
                t2["x"] = 556;
                t2["y"] = 556;
                t2["z"] = 500;
                t2["braceleft"] = 389;
                t2["bar"] = 280;
                t2["braceright"] = 389;
                t2["asciitilde"] = 584;
                t2["exclamdown"] = 333;
                t2["cent"] = 556;
                t2["sterling"] = 556;
                t2["fraction"] = 167;
                t2["yen"] = 556;
                t2["florin"] = 556;
                t2["section"] = 556;
                t2["currency"] = 556;
                t2["quotesingle"] = 238;
                t2["quotedblleft"] = 500;
                t2["guillemotleft"] = 556;
                t2["guilsinglleft"] = 333;
                t2["guilsinglright"] = 333;
                t2["fi"] = 611;
                t2["fl"] = 611;
                t2["endash"] = 556;
                t2["dagger"] = 556;
                t2["daggerdbl"] = 556;
                t2["periodcentered"] = 278;
                t2["paragraph"] = 556;
                t2["bullet"] = 350;
                t2["quotesinglbase"] = 278;
                t2["quotedblbase"] = 500;
                t2["quotedblright"] = 500;
                t2["guillemotright"] = 556;
                t2["ellipsis"] = 1e3;
                t2["perthousand"] = 1e3;
                t2["questiondown"] = 611;
                t2["grave"] = 333;
                t2["acute"] = 333;
                t2["circumflex"] = 333;
                t2["tilde"] = 333;
                t2["macron"] = 333;
                t2["breve"] = 333;
                t2["dotaccent"] = 333;
                t2["dieresis"] = 333;
                t2["ring"] = 333;
                t2["cedilla"] = 333;
                t2["hungarumlaut"] = 333;
                t2["ogonek"] = 333;
                t2["caron"] = 333;
                t2["emdash"] = 1e3;
                t2["AE"] = 1e3;
                t2["ordfeminine"] = 370;
                t2["Lslash"] = 611;
                t2["Oslash"] = 778;
                t2["OE"] = 1e3;
                t2["ordmasculine"] = 365;
                t2["ae"] = 889;
                t2["dotlessi"] = 278;
                t2["lslash"] = 278;
                t2["oslash"] = 611;
                t2["oe"] = 944;
                t2["germandbls"] = 611;
                t2["Idieresis"] = 278;
                t2["eacute"] = 556;
                t2["abreve"] = 556;
                t2["uhungarumlaut"] = 611;
                t2["ecaron"] = 556;
                t2["Ydieresis"] = 667;
                t2["divide"] = 584;
                t2["Yacute"] = 667;
                t2["Acircumflex"] = 722;
                t2["aacute"] = 556;
                t2["Ucircumflex"] = 722;
                t2["yacute"] = 556;
                t2["scommaaccent"] = 556;
                t2["ecircumflex"] = 556;
                t2["Uring"] = 722;
                t2["Udieresis"] = 722;
                t2["aogonek"] = 556;
                t2["Uacute"] = 722;
                t2["uogonek"] = 611;
                t2["Edieresis"] = 667;
                t2["Dcroat"] = 722;
                t2["commaaccent"] = 250;
                t2["copyright"] = 737;
                t2["Emacron"] = 667;
                t2["ccaron"] = 556;
                t2["aring"] = 556;
                t2["Ncommaaccent"] = 722;
                t2["lacute"] = 278;
                t2["agrave"] = 556;
                t2["Tcommaaccent"] = 611;
                t2["Cacute"] = 722;
                t2["atilde"] = 556;
                t2["Edotaccent"] = 667;
                t2["scaron"] = 556;
                t2["scedilla"] = 556;
                t2["iacute"] = 278;
                t2["lozenge"] = 494;
                t2["Rcaron"] = 722;
                t2["Gcommaaccent"] = 778;
                t2["ucircumflex"] = 611;
                t2["acircumflex"] = 556;
                t2["Amacron"] = 722;
                t2["rcaron"] = 389;
                t2["ccedilla"] = 556;
                t2["Zdotaccent"] = 611;
                t2["Thorn"] = 667;
                t2["Omacron"] = 778;
                t2["Racute"] = 722;
                t2["Sacute"] = 667;
                t2["dcaron"] = 743;
                t2["Umacron"] = 722;
                t2["uring"] = 611;
                t2["threesuperior"] = 333;
                t2["Ograve"] = 778;
                t2["Agrave"] = 722;
                t2["Abreve"] = 722;
                t2["multiply"] = 584;
                t2["uacute"] = 611;
                t2["Tcaron"] = 611;
                t2["partialdiff"] = 494;
                t2["ydieresis"] = 556;
                t2["Nacute"] = 722;
                t2["icircumflex"] = 278;
                t2["Ecircumflex"] = 667;
                t2["adieresis"] = 556;
                t2["edieresis"] = 556;
                t2["cacute"] = 556;
                t2["nacute"] = 611;
                t2["umacron"] = 611;
                t2["Ncaron"] = 722;
                t2["Iacute"] = 278;
                t2["plusminus"] = 584;
                t2["brokenbar"] = 280;
                t2["registered"] = 737;
                t2["Gbreve"] = 778;
                t2["Idotaccent"] = 278;
                t2["summation"] = 600;
                t2["Egrave"] = 667;
                t2["racute"] = 389;
                t2["omacron"] = 611;
                t2["Zacute"] = 611;
                t2["Zcaron"] = 611;
                t2["greaterequal"] = 549;
                t2["Eth"] = 722;
                t2["Ccedilla"] = 722;
                t2["lcommaaccent"] = 278;
                t2["tcaron"] = 389;
                t2["eogonek"] = 556;
                t2["Uogonek"] = 722;
                t2["Aacute"] = 722;
                t2["Adieresis"] = 722;
                t2["egrave"] = 556;
                t2["zacute"] = 500;
                t2["iogonek"] = 278;
                t2["Oacute"] = 778;
                t2["oacute"] = 611;
                t2["amacron"] = 556;
                t2["sacute"] = 556;
                t2["idieresis"] = 278;
                t2["Ocircumflex"] = 778;
                t2["Ugrave"] = 722;
                t2["Delta"] = 612;
                t2["thorn"] = 611;
                t2["twosuperior"] = 333;
                t2["Odieresis"] = 778;
                t2["mu"] = 611;
                t2["igrave"] = 278;
                t2["ohungarumlaut"] = 611;
                t2["Eogonek"] = 667;
                t2["dcroat"] = 611;
                t2["threequarters"] = 834;
                t2["Scedilla"] = 667;
                t2["lcaron"] = 400;
                t2["Kcommaaccent"] = 722;
                t2["Lacute"] = 611;
                t2["trademark"] = 1e3;
                t2["edotaccent"] = 556;
                t2["Igrave"] = 278;
                t2["Imacron"] = 278;
                t2["Lcaron"] = 611;
                t2["onehalf"] = 834;
                t2["lessequal"] = 549;
                t2["ocircumflex"] = 611;
                t2["ntilde"] = 611;
                t2["Uhungarumlaut"] = 722;
                t2["Eacute"] = 667;
                t2["emacron"] = 556;
                t2["gbreve"] = 611;
                t2["onequarter"] = 834;
                t2["Scaron"] = 667;
                t2["Scommaaccent"] = 667;
                t2["Ohungarumlaut"] = 778;
                t2["degree"] = 400;
                t2["ograve"] = 611;
                t2["Ccaron"] = 722;
                t2["ugrave"] = 611;
                t2["radical"] = 549;
                t2["Dcaron"] = 722;
                t2["rcommaaccent"] = 389;
                t2["Ntilde"] = 722;
                t2["otilde"] = 611;
                t2["Rcommaaccent"] = 722;
                t2["Lcommaaccent"] = 611;
                t2["Atilde"] = 722;
                t2["Aogonek"] = 722;
                t2["Aring"] = 722;
                t2["Otilde"] = 778;
                t2["zdotaccent"] = 500;
                t2["Ecaron"] = 667;
                t2["Iogonek"] = 278;
                t2["kcommaaccent"] = 556;
                t2["minus"] = 584;
                t2["Icircumflex"] = 278;
                t2["ncaron"] = 611;
                t2["tcommaaccent"] = 333;
                t2["logicalnot"] = 584;
                t2["odieresis"] = 611;
                t2["udieresis"] = 611;
                t2["notequal"] = 549;
                t2["gcommaaccent"] = 611;
                t2["eth"] = 611;
                t2["zcaron"] = 500;
                t2["ncommaaccent"] = 611;
                t2["onesuperior"] = 333;
                t2["imacron"] = 278;
                t2["Euro"] = 556;
              });
              t["Helvetica-Oblique"] = (0, _util.getLookupTableFactory)(function(t2) {
                t2["space"] = 278;
                t2["exclam"] = 278;
                t2["quotedbl"] = 355;
                t2["numbersign"] = 556;
                t2["dollar"] = 556;
                t2["percent"] = 889;
                t2["ampersand"] = 667;
                t2["quoteright"] = 222;
                t2["parenleft"] = 333;
                t2["parenright"] = 333;
                t2["asterisk"] = 389;
                t2["plus"] = 584;
                t2["comma"] = 278;
                t2["hyphen"] = 333;
                t2["period"] = 278;
                t2["slash"] = 278;
                t2["zero"] = 556;
                t2["one"] = 556;
                t2["two"] = 556;
                t2["three"] = 556;
                t2["four"] = 556;
                t2["five"] = 556;
                t2["six"] = 556;
                t2["seven"] = 556;
                t2["eight"] = 556;
                t2["nine"] = 556;
                t2["colon"] = 278;
                t2["semicolon"] = 278;
                t2["less"] = 584;
                t2["equal"] = 584;
                t2["greater"] = 584;
                t2["question"] = 556;
                t2["at"] = 1015;
                t2["A"] = 667;
                t2["B"] = 667;
                t2["C"] = 722;
                t2["D"] = 722;
                t2["E"] = 667;
                t2["F"] = 611;
                t2["G"] = 778;
                t2["H"] = 722;
                t2["I"] = 278;
                t2["J"] = 500;
                t2["K"] = 667;
                t2["L"] = 556;
                t2["M"] = 833;
                t2["N"] = 722;
                t2["O"] = 778;
                t2["P"] = 667;
                t2["Q"] = 778;
                t2["R"] = 722;
                t2["S"] = 667;
                t2["T"] = 611;
                t2["U"] = 722;
                t2["V"] = 667;
                t2["W"] = 944;
                t2["X"] = 667;
                t2["Y"] = 667;
                t2["Z"] = 611;
                t2["bracketleft"] = 278;
                t2["backslash"] = 278;
                t2["bracketright"] = 278;
                t2["asciicircum"] = 469;
                t2["underscore"] = 556;
                t2["quoteleft"] = 222;
                t2["a"] = 556;
                t2["b"] = 556;
                t2["c"] = 500;
                t2["d"] = 556;
                t2["e"] = 556;
                t2["f"] = 278;
                t2["g"] = 556;
                t2["h"] = 556;
                t2["i"] = 222;
                t2["j"] = 222;
                t2["k"] = 500;
                t2["l"] = 222;
                t2["m"] = 833;
                t2["n"] = 556;
                t2["o"] = 556;
                t2["p"] = 556;
                t2["q"] = 556;
                t2["r"] = 333;
                t2["s"] = 500;
                t2["t"] = 278;
                t2["u"] = 556;
                t2["v"] = 500;
                t2["w"] = 722;
                t2["x"] = 500;
                t2["y"] = 500;
                t2["z"] = 500;
                t2["braceleft"] = 334;
                t2["bar"] = 260;
                t2["braceright"] = 334;
                t2["asciitilde"] = 584;
                t2["exclamdown"] = 333;
                t2["cent"] = 556;
                t2["sterling"] = 556;
                t2["fraction"] = 167;
                t2["yen"] = 556;
                t2["florin"] = 556;
                t2["section"] = 556;
                t2["currency"] = 556;
                t2["quotesingle"] = 191;
                t2["quotedblleft"] = 333;
                t2["guillemotleft"] = 556;
                t2["guilsinglleft"] = 333;
                t2["guilsinglright"] = 333;
                t2["fi"] = 500;
                t2["fl"] = 500;
                t2["endash"] = 556;
                t2["dagger"] = 556;
                t2["daggerdbl"] = 556;
                t2["periodcentered"] = 278;
                t2["paragraph"] = 537;
                t2["bullet"] = 350;
                t2["quotesinglbase"] = 222;
                t2["quotedblbase"] = 333;
                t2["quotedblright"] = 333;
                t2["guillemotright"] = 556;
                t2["ellipsis"] = 1e3;
                t2["perthousand"] = 1e3;
                t2["questiondown"] = 611;
                t2["grave"] = 333;
                t2["acute"] = 333;
                t2["circumflex"] = 333;
                t2["tilde"] = 333;
                t2["macron"] = 333;
                t2["breve"] = 333;
                t2["dotaccent"] = 333;
                t2["dieresis"] = 333;
                t2["ring"] = 333;
                t2["cedilla"] = 333;
                t2["hungarumlaut"] = 333;
                t2["ogonek"] = 333;
                t2["caron"] = 333;
                t2["emdash"] = 1e3;
                t2["AE"] = 1e3;
                t2["ordfeminine"] = 370;
                t2["Lslash"] = 556;
                t2["Oslash"] = 778;
                t2["OE"] = 1e3;
                t2["ordmasculine"] = 365;
                t2["ae"] = 889;
                t2["dotlessi"] = 278;
                t2["lslash"] = 222;
                t2["oslash"] = 611;
                t2["oe"] = 944;
                t2["germandbls"] = 611;
                t2["Idieresis"] = 278;
                t2["eacute"] = 556;
                t2["abreve"] = 556;
                t2["uhungarumlaut"] = 556;
                t2["ecaron"] = 556;
                t2["Ydieresis"] = 667;
                t2["divide"] = 584;
                t2["Yacute"] = 667;
                t2["Acircumflex"] = 667;
                t2["aacute"] = 556;
                t2["Ucircumflex"] = 722;
                t2["yacute"] = 500;
                t2["scommaaccent"] = 500;
                t2["ecircumflex"] = 556;
                t2["Uring"] = 722;
                t2["Udieresis"] = 722;
                t2["aogonek"] = 556;
                t2["Uacute"] = 722;
                t2["uogonek"] = 556;
                t2["Edieresis"] = 667;
                t2["Dcroat"] = 722;
                t2["commaaccent"] = 250;
                t2["copyright"] = 737;
                t2["Emacron"] = 667;
                t2["ccaron"] = 500;
                t2["aring"] = 556;
                t2["Ncommaaccent"] = 722;
                t2["lacute"] = 222;
                t2["agrave"] = 556;
                t2["Tcommaaccent"] = 611;
                t2["Cacute"] = 722;
                t2["atilde"] = 556;
                t2["Edotaccent"] = 667;
                t2["scaron"] = 500;
                t2["scedilla"] = 500;
                t2["iacute"] = 278;
                t2["lozenge"] = 471;
                t2["Rcaron"] = 722;
                t2["Gcommaaccent"] = 778;
                t2["ucircumflex"] = 556;
                t2["acircumflex"] = 556;
                t2["Amacron"] = 667;
                t2["rcaron"] = 333;
                t2["ccedilla"] = 500;
                t2["Zdotaccent"] = 611;
                t2["Thorn"] = 667;
                t2["Omacron"] = 778;
                t2["Racute"] = 722;
                t2["Sacute"] = 667;
                t2["dcaron"] = 643;
                t2["Umacron"] = 722;
                t2["uring"] = 556;
                t2["threesuperior"] = 333;
                t2["Ograve"] = 778;
                t2["Agrave"] = 667;
                t2["Abreve"] = 667;
                t2["multiply"] = 584;
                t2["uacute"] = 556;
                t2["Tcaron"] = 611;
                t2["partialdiff"] = 476;
                t2["ydieresis"] = 500;
                t2["Nacute"] = 722;
                t2["icircumflex"] = 278;
                t2["Ecircumflex"] = 667;
                t2["adieresis"] = 556;
                t2["edieresis"] = 556;
                t2["cacute"] = 500;
                t2["nacute"] = 556;
                t2["umacron"] = 556;
                t2["Ncaron"] = 722;
                t2["Iacute"] = 278;
                t2["plusminus"] = 584;
                t2["brokenbar"] = 260;
                t2["registered"] = 737;
                t2["Gbreve"] = 778;
                t2["Idotaccent"] = 278;
                t2["summation"] = 600;
                t2["Egrave"] = 667;
                t2["racute"] = 333;
                t2["omacron"] = 556;
                t2["Zacute"] = 611;
                t2["Zcaron"] = 611;
                t2["greaterequal"] = 549;
                t2["Eth"] = 722;
                t2["Ccedilla"] = 722;
                t2["lcommaaccent"] = 222;
                t2["tcaron"] = 317;
                t2["eogonek"] = 556;
                t2["Uogonek"] = 722;
                t2["Aacute"] = 667;
                t2["Adieresis"] = 667;
                t2["egrave"] = 556;
                t2["zacute"] = 500;
                t2["iogonek"] = 222;
                t2["Oacute"] = 778;
                t2["oacute"] = 556;
                t2["amacron"] = 556;
                t2["sacute"] = 500;
                t2["idieresis"] = 278;
                t2["Ocircumflex"] = 778;
                t2["Ugrave"] = 722;
                t2["Delta"] = 612;
                t2["thorn"] = 556;
                t2["twosuperior"] = 333;
                t2["Odieresis"] = 778;
                t2["mu"] = 556;
                t2["igrave"] = 278;
                t2["ohungarumlaut"] = 556;
                t2["Eogonek"] = 667;
                t2["dcroat"] = 556;
                t2["threequarters"] = 834;
                t2["Scedilla"] = 667;
                t2["lcaron"] = 299;
                t2["Kcommaaccent"] = 667;
                t2["Lacute"] = 556;
                t2["trademark"] = 1e3;
                t2["edotaccent"] = 556;
                t2["Igrave"] = 278;
                t2["Imacron"] = 278;
                t2["Lcaron"] = 556;
                t2["onehalf"] = 834;
                t2["lessequal"] = 549;
                t2["ocircumflex"] = 556;
                t2["ntilde"] = 556;
                t2["Uhungarumlaut"] = 722;
                t2["Eacute"] = 667;
                t2["emacron"] = 556;
                t2["gbreve"] = 556;
                t2["onequarter"] = 834;
                t2["Scaron"] = 667;
                t2["Scommaaccent"] = 667;
                t2["Ohungarumlaut"] = 778;
                t2["degree"] = 400;
                t2["ograve"] = 556;
                t2["Ccaron"] = 722;
                t2["ugrave"] = 556;
                t2["radical"] = 453;
                t2["Dcaron"] = 722;
                t2["rcommaaccent"] = 333;
                t2["Ntilde"] = 722;
                t2["otilde"] = 556;
                t2["Rcommaaccent"] = 722;
                t2["Lcommaaccent"] = 556;
                t2["Atilde"] = 667;
                t2["Aogonek"] = 667;
                t2["Aring"] = 667;
                t2["Otilde"] = 778;
                t2["zdotaccent"] = 500;
                t2["Ecaron"] = 667;
                t2["Iogonek"] = 278;
                t2["kcommaaccent"] = 500;
                t2["minus"] = 584;
                t2["Icircumflex"] = 278;
                t2["ncaron"] = 556;
                t2["tcommaaccent"] = 278;
                t2["logicalnot"] = 584;
                t2["odieresis"] = 556;
                t2["udieresis"] = 556;
                t2["notequal"] = 549;
                t2["gcommaaccent"] = 556;
                t2["eth"] = 556;
                t2["zcaron"] = 500;
                t2["ncommaaccent"] = 556;
                t2["onesuperior"] = 333;
                t2["imacron"] = 278;
                t2["Euro"] = 556;
              });
              t["Symbol"] = (0, _util.getLookupTableFactory)(function(t2) {
                t2["space"] = 250;
                t2["exclam"] = 333;
                t2["universal"] = 713;
                t2["numbersign"] = 500;
                t2["existential"] = 549;
                t2["percent"] = 833;
                t2["ampersand"] = 778;
                t2["suchthat"] = 439;
                t2["parenleft"] = 333;
                t2["parenright"] = 333;
                t2["asteriskmath"] = 500;
                t2["plus"] = 549;
                t2["comma"] = 250;
                t2["minus"] = 549;
                t2["period"] = 250;
                t2["slash"] = 278;
                t2["zero"] = 500;
                t2["one"] = 500;
                t2["two"] = 500;
                t2["three"] = 500;
                t2["four"] = 500;
                t2["five"] = 500;
                t2["six"] = 500;
                t2["seven"] = 500;
                t2["eight"] = 500;
                t2["nine"] = 500;
                t2["colon"] = 278;
                t2["semicolon"] = 278;
                t2["less"] = 549;
                t2["equal"] = 549;
                t2["greater"] = 549;
                t2["question"] = 444;
                t2["congruent"] = 549;
                t2["Alpha"] = 722;
                t2["Beta"] = 667;
                t2["Chi"] = 722;
                t2["Delta"] = 612;
                t2["Epsilon"] = 611;
                t2["Phi"] = 763;
                t2["Gamma"] = 603;
                t2["Eta"] = 722;
                t2["Iota"] = 333;
                t2["theta1"] = 631;
                t2["Kappa"] = 722;
                t2["Lambda"] = 686;
                t2["Mu"] = 889;
                t2["Nu"] = 722;
                t2["Omicron"] = 722;
                t2["Pi"] = 768;
                t2["Theta"] = 741;
                t2["Rho"] = 556;
                t2["Sigma"] = 592;
                t2["Tau"] = 611;
                t2["Upsilon"] = 690;
                t2["sigma1"] = 439;
                t2["Omega"] = 768;
                t2["Xi"] = 645;
                t2["Psi"] = 795;
                t2["Zeta"] = 611;
                t2["bracketleft"] = 333;
                t2["therefore"] = 863;
                t2["bracketright"] = 333;
                t2["perpendicular"] = 658;
                t2["underscore"] = 500;
                t2["radicalex"] = 500;
                t2["alpha"] = 631;
                t2["beta"] = 549;
                t2["chi"] = 549;
                t2["delta"] = 494;
                t2["epsilon"] = 439;
                t2["phi"] = 521;
                t2["gamma"] = 411;
                t2["eta"] = 603;
                t2["iota"] = 329;
                t2["phi1"] = 603;
                t2["kappa"] = 549;
                t2["lambda"] = 549;
                t2["mu"] = 576;
                t2["nu"] = 521;
                t2["omicron"] = 549;
                t2["pi"] = 549;
                t2["theta"] = 521;
                t2["rho"] = 549;
                t2["sigma"] = 603;
                t2["tau"] = 439;
                t2["upsilon"] = 576;
                t2["omega1"] = 713;
                t2["omega"] = 686;
                t2["xi"] = 493;
                t2["psi"] = 686;
                t2["zeta"] = 494;
                t2["braceleft"] = 480;
                t2["bar"] = 200;
                t2["braceright"] = 480;
                t2["similar"] = 549;
                t2["Euro"] = 750;
                t2["Upsilon1"] = 620;
                t2["minute"] = 247;
                t2["lessequal"] = 549;
                t2["fraction"] = 167;
                t2["infinity"] = 713;
                t2["florin"] = 500;
                t2["club"] = 753;
                t2["diamond"] = 753;
                t2["heart"] = 753;
                t2["spade"] = 753;
                t2["arrowboth"] = 1042;
                t2["arrowleft"] = 987;
                t2["arrowup"] = 603;
                t2["arrowright"] = 987;
                t2["arrowdown"] = 603;
                t2["degree"] = 400;
                t2["plusminus"] = 549;
                t2["second"] = 411;
                t2["greaterequal"] = 549;
                t2["multiply"] = 549;
                t2["proportional"] = 713;
                t2["partialdiff"] = 494;
                t2["bullet"] = 460;
                t2["divide"] = 549;
                t2["notequal"] = 549;
                t2["equivalence"] = 549;
                t2["approxequal"] = 549;
                t2["ellipsis"] = 1e3;
                t2["arrowvertex"] = 603;
                t2["arrowhorizex"] = 1e3;
                t2["carriagereturn"] = 658;
                t2["aleph"] = 823;
                t2["Ifraktur"] = 686;
                t2["Rfraktur"] = 795;
                t2["weierstrass"] = 987;
                t2["circlemultiply"] = 768;
                t2["circleplus"] = 768;
                t2["emptyset"] = 823;
                t2["intersection"] = 768;
                t2["union"] = 768;
                t2["propersuperset"] = 713;
                t2["reflexsuperset"] = 713;
                t2["notsubset"] = 713;
                t2["propersubset"] = 713;
                t2["reflexsubset"] = 713;
                t2["element"] = 713;
                t2["notelement"] = 713;
                t2["angle"] = 768;
                t2["gradient"] = 713;
                t2["registerserif"] = 790;
                t2["copyrightserif"] = 790;
                t2["trademarkserif"] = 890;
                t2["product"] = 823;
                t2["radical"] = 549;
                t2["dotmath"] = 250;
                t2["logicalnot"] = 713;
                t2["logicaland"] = 603;
                t2["logicalor"] = 603;
                t2["arrowdblboth"] = 1042;
                t2["arrowdblleft"] = 987;
                t2["arrowdblup"] = 603;
                t2["arrowdblright"] = 987;
                t2["arrowdbldown"] = 603;
                t2["lozenge"] = 494;
                t2["angleleft"] = 329;
                t2["registersans"] = 790;
                t2["copyrightsans"] = 790;
                t2["trademarksans"] = 786;
                t2["summation"] = 713;
                t2["parenlefttp"] = 384;
                t2["parenleftex"] = 384;
                t2["parenleftbt"] = 384;
                t2["bracketlefttp"] = 384;
                t2["bracketleftex"] = 384;
                t2["bracketleftbt"] = 384;
                t2["bracelefttp"] = 494;
                t2["braceleftmid"] = 494;
                t2["braceleftbt"] = 494;
                t2["braceex"] = 494;
                t2["angleright"] = 329;
                t2["integral"] = 274;
                t2["integraltp"] = 686;
                t2["integralex"] = 686;
                t2["integralbt"] = 686;
                t2["parenrighttp"] = 384;
                t2["parenrightex"] = 384;
                t2["parenrightbt"] = 384;
                t2["bracketrighttp"] = 384;
                t2["bracketrightex"] = 384;
                t2["bracketrightbt"] = 384;
                t2["bracerighttp"] = 494;
                t2["bracerightmid"] = 494;
                t2["bracerightbt"] = 494;
                t2["apple"] = 790;
              });
              t["Times-Roman"] = (0, _util.getLookupTableFactory)(function(t2) {
                t2["space"] = 250;
                t2["exclam"] = 333;
                t2["quotedbl"] = 408;
                t2["numbersign"] = 500;
                t2["dollar"] = 500;
                t2["percent"] = 833;
                t2["ampersand"] = 778;
                t2["quoteright"] = 333;
                t2["parenleft"] = 333;
                t2["parenright"] = 333;
                t2["asterisk"] = 500;
                t2["plus"] = 564;
                t2["comma"] = 250;
                t2["hyphen"] = 333;
                t2["period"] = 250;
                t2["slash"] = 278;
                t2["zero"] = 500;
                t2["one"] = 500;
                t2["two"] = 500;
                t2["three"] = 500;
                t2["four"] = 500;
                t2["five"] = 500;
                t2["six"] = 500;
                t2["seven"] = 500;
                t2["eight"] = 500;
                t2["nine"] = 500;
                t2["colon"] = 278;
                t2["semicolon"] = 278;
                t2["less"] = 564;
                t2["equal"] = 564;
                t2["greater"] = 564;
                t2["question"] = 444;
                t2["at"] = 921;
                t2["A"] = 722;
                t2["B"] = 667;
                t2["C"] = 667;
                t2["D"] = 722;
                t2["E"] = 611;
                t2["F"] = 556;
                t2["G"] = 722;
                t2["H"] = 722;
                t2["I"] = 333;
                t2["J"] = 389;
                t2["K"] = 722;
                t2["L"] = 611;
                t2["M"] = 889;
                t2["N"] = 722;
                t2["O"] = 722;
                t2["P"] = 556;
                t2["Q"] = 722;
                t2["R"] = 667;
                t2["S"] = 556;
                t2["T"] = 611;
                t2["U"] = 722;
                t2["V"] = 722;
                t2["W"] = 944;
                t2["X"] = 722;
                t2["Y"] = 722;
                t2["Z"] = 611;
                t2["bracketleft"] = 333;
                t2["backslash"] = 278;
                t2["bracketright"] = 333;
                t2["asciicircum"] = 469;
                t2["underscore"] = 500;
                t2["quoteleft"] = 333;
                t2["a"] = 444;
                t2["b"] = 500;
                t2["c"] = 444;
                t2["d"] = 500;
                t2["e"] = 444;
                t2["f"] = 333;
                t2["g"] = 500;
                t2["h"] = 500;
                t2["i"] = 278;
                t2["j"] = 278;
                t2["k"] = 500;
                t2["l"] = 278;
                t2["m"] = 778;
                t2["n"] = 500;
                t2["o"] = 500;
                t2["p"] = 500;
                t2["q"] = 500;
                t2["r"] = 333;
                t2["s"] = 389;
                t2["t"] = 278;
                t2["u"] = 500;
                t2["v"] = 500;
                t2["w"] = 722;
                t2["x"] = 500;
                t2["y"] = 500;
                t2["z"] = 444;
                t2["braceleft"] = 480;
                t2["bar"] = 200;
                t2["braceright"] = 480;
                t2["asciitilde"] = 541;
                t2["exclamdown"] = 333;
                t2["cent"] = 500;
                t2["sterling"] = 500;
                t2["fraction"] = 167;
                t2["yen"] = 500;
                t2["florin"] = 500;
                t2["section"] = 500;
                t2["currency"] = 500;
                t2["quotesingle"] = 180;
                t2["quotedblleft"] = 444;
                t2["guillemotleft"] = 500;
                t2["guilsinglleft"] = 333;
                t2["guilsinglright"] = 333;
                t2["fi"] = 556;
                t2["fl"] = 556;
                t2["endash"] = 500;
                t2["dagger"] = 500;
                t2["daggerdbl"] = 500;
                t2["periodcentered"] = 250;
                t2["paragraph"] = 453;
                t2["bullet"] = 350;
                t2["quotesinglbase"] = 333;
                t2["quotedblbase"] = 444;
                t2["quotedblright"] = 444;
                t2["guillemotright"] = 500;
                t2["ellipsis"] = 1e3;
                t2["perthousand"] = 1e3;
                t2["questiondown"] = 444;
                t2["grave"] = 333;
                t2["acute"] = 333;
                t2["circumflex"] = 333;
                t2["tilde"] = 333;
                t2["macron"] = 333;
                t2["breve"] = 333;
                t2["dotaccent"] = 333;
                t2["dieresis"] = 333;
                t2["ring"] = 333;
                t2["cedilla"] = 333;
                t2["hungarumlaut"] = 333;
                t2["ogonek"] = 333;
                t2["caron"] = 333;
                t2["emdash"] = 1e3;
                t2["AE"] = 889;
                t2["ordfeminine"] = 276;
                t2["Lslash"] = 611;
                t2["Oslash"] = 722;
                t2["OE"] = 889;
                t2["ordmasculine"] = 310;
                t2["ae"] = 667;
                t2["dotlessi"] = 278;
                t2["lslash"] = 278;
                t2["oslash"] = 500;
                t2["oe"] = 722;
                t2["germandbls"] = 500;
                t2["Idieresis"] = 333;
                t2["eacute"] = 444;
                t2["abreve"] = 444;
                t2["uhungarumlaut"] = 500;
                t2["ecaron"] = 444;
                t2["Ydieresis"] = 722;
                t2["divide"] = 564;
                t2["Yacute"] = 722;
                t2["Acircumflex"] = 722;
                t2["aacute"] = 444;
                t2["Ucircumflex"] = 722;
                t2["yacute"] = 500;
                t2["scommaaccent"] = 389;
                t2["ecircumflex"] = 444;
                t2["Uring"] = 722;
                t2["Udieresis"] = 722;
                t2["aogonek"] = 444;
                t2["Uacute"] = 722;
                t2["uogonek"] = 500;
                t2["Edieresis"] = 611;
                t2["Dcroat"] = 722;
                t2["commaaccent"] = 250;
                t2["copyright"] = 760;
                t2["Emacron"] = 611;
                t2["ccaron"] = 444;
                t2["aring"] = 444;
                t2["Ncommaaccent"] = 722;
                t2["lacute"] = 278;
                t2["agrave"] = 444;
                t2["Tcommaaccent"] = 611;
                t2["Cacute"] = 667;
                t2["atilde"] = 444;
                t2["Edotaccent"] = 611;
                t2["scaron"] = 389;
                t2["scedilla"] = 389;
                t2["iacute"] = 278;
                t2["lozenge"] = 471;
                t2["Rcaron"] = 667;
                t2["Gcommaaccent"] = 722;
                t2["ucircumflex"] = 500;
                t2["acircumflex"] = 444;
                t2["Amacron"] = 722;
                t2["rcaron"] = 333;
                t2["ccedilla"] = 444;
                t2["Zdotaccent"] = 611;
                t2["Thorn"] = 556;
                t2["Omacron"] = 722;
                t2["Racute"] = 667;
                t2["Sacute"] = 556;
                t2["dcaron"] = 588;
                t2["Umacron"] = 722;
                t2["uring"] = 500;
                t2["threesuperior"] = 300;
                t2["Ograve"] = 722;
                t2["Agrave"] = 722;
                t2["Abreve"] = 722;
                t2["multiply"] = 564;
                t2["uacute"] = 500;
                t2["Tcaron"] = 611;
                t2["partialdiff"] = 476;
                t2["ydieresis"] = 500;
                t2["Nacute"] = 722;
                t2["icircumflex"] = 278;
                t2["Ecircumflex"] = 611;
                t2["adieresis"] = 444;
                t2["edieresis"] = 444;
                t2["cacute"] = 444;
                t2["nacute"] = 500;
                t2["umacron"] = 500;
                t2["Ncaron"] = 722;
                t2["Iacute"] = 333;
                t2["plusminus"] = 564;
                t2["brokenbar"] = 200;
                t2["registered"] = 760;
                t2["Gbreve"] = 722;
                t2["Idotaccent"] = 333;
                t2["summation"] = 600;
                t2["Egrave"] = 611;
                t2["racute"] = 333;
                t2["omacron"] = 500;
                t2["Zacute"] = 611;
                t2["Zcaron"] = 611;
                t2["greaterequal"] = 549;
                t2["Eth"] = 722;
                t2["Ccedilla"] = 667;
                t2["lcommaaccent"] = 278;
                t2["tcaron"] = 326;
                t2["eogonek"] = 444;
                t2["Uogonek"] = 722;
                t2["Aacute"] = 722;
                t2["Adieresis"] = 722;
                t2["egrave"] = 444;
                t2["zacute"] = 444;
                t2["iogonek"] = 278;
                t2["Oacute"] = 722;
                t2["oacute"] = 500;
                t2["amacron"] = 444;
                t2["sacute"] = 389;
                t2["idieresis"] = 278;
                t2["Ocircumflex"] = 722;
                t2["Ugrave"] = 722;
                t2["Delta"] = 612;
                t2["thorn"] = 500;
                t2["twosuperior"] = 300;
                t2["Odieresis"] = 722;
                t2["mu"] = 500;
                t2["igrave"] = 278;
                t2["ohungarumlaut"] = 500;
                t2["Eogonek"] = 611;
                t2["dcroat"] = 500;
                t2["threequarters"] = 750;
                t2["Scedilla"] = 556;
                t2["lcaron"] = 344;
                t2["Kcommaaccent"] = 722;
                t2["Lacute"] = 611;
                t2["trademark"] = 980;
                t2["edotaccent"] = 444;
                t2["Igrave"] = 333;
                t2["Imacron"] = 333;
                t2["Lcaron"] = 611;
                t2["onehalf"] = 750;
                t2["lessequal"] = 549;
                t2["ocircumflex"] = 500;
                t2["ntilde"] = 500;
                t2["Uhungarumlaut"] = 722;
                t2["Eacute"] = 611;
                t2["emacron"] = 444;
                t2["gbreve"] = 500;
                t2["onequarter"] = 750;
                t2["Scaron"] = 556;
                t2["Scommaaccent"] = 556;
                t2["Ohungarumlaut"] = 722;
                t2["degree"] = 400;
                t2["ograve"] = 500;
                t2["Ccaron"] = 667;
                t2["ugrave"] = 500;
                t2["radical"] = 453;
                t2["Dcaron"] = 722;
                t2["rcommaaccent"] = 333;
                t2["Ntilde"] = 722;
                t2["otilde"] = 500;
                t2["Rcommaaccent"] = 667;
                t2["Lcommaaccent"] = 611;
                t2["Atilde"] = 722;
                t2["Aogonek"] = 722;
                t2["Aring"] = 722;
                t2["Otilde"] = 722;
                t2["zdotaccent"] = 444;
                t2["Ecaron"] = 611;
                t2["Iogonek"] = 333;
                t2["kcommaaccent"] = 500;
                t2["minus"] = 564;
                t2["Icircumflex"] = 333;
                t2["ncaron"] = 500;
                t2["tcommaaccent"] = 278;
                t2["logicalnot"] = 564;
                t2["odieresis"] = 500;
                t2["udieresis"] = 500;
                t2["notequal"] = 549;
                t2["gcommaaccent"] = 500;
                t2["eth"] = 500;
                t2["zcaron"] = 444;
                t2["ncommaaccent"] = 500;
                t2["onesuperior"] = 300;
                t2["imacron"] = 278;
                t2["Euro"] = 500;
              });
              t["Times-Bold"] = (0, _util.getLookupTableFactory)(function(t2) {
                t2["space"] = 250;
                t2["exclam"] = 333;
                t2["quotedbl"] = 555;
                t2["numbersign"] = 500;
                t2["dollar"] = 500;
                t2["percent"] = 1e3;
                t2["ampersand"] = 833;
                t2["quoteright"] = 333;
                t2["parenleft"] = 333;
                t2["parenright"] = 333;
                t2["asterisk"] = 500;
                t2["plus"] = 570;
                t2["comma"] = 250;
                t2["hyphen"] = 333;
                t2["period"] = 250;
                t2["slash"] = 278;
                t2["zero"] = 500;
                t2["one"] = 500;
                t2["two"] = 500;
                t2["three"] = 500;
                t2["four"] = 500;
                t2["five"] = 500;
                t2["six"] = 500;
                t2["seven"] = 500;
                t2["eight"] = 500;
                t2["nine"] = 500;
                t2["colon"] = 333;
                t2["semicolon"] = 333;
                t2["less"] = 570;
                t2["equal"] = 570;
                t2["greater"] = 570;
                t2["question"] = 500;
                t2["at"] = 930;
                t2["A"] = 722;
                t2["B"] = 667;
                t2["C"] = 722;
                t2["D"] = 722;
                t2["E"] = 667;
                t2["F"] = 611;
                t2["G"] = 778;
                t2["H"] = 778;
                t2["I"] = 389;
                t2["J"] = 500;
                t2["K"] = 778;
                t2["L"] = 667;
                t2["M"] = 944;
                t2["N"] = 722;
                t2["O"] = 778;
                t2["P"] = 611;
                t2["Q"] = 778;
                t2["R"] = 722;
                t2["S"] = 556;
                t2["T"] = 667;
                t2["U"] = 722;
                t2["V"] = 722;
                t2["W"] = 1e3;
                t2["X"] = 722;
                t2["Y"] = 722;
                t2["Z"] = 667;
                t2["bracketleft"] = 333;
                t2["backslash"] = 278;
                t2["bracketright"] = 333;
                t2["asciicircum"] = 581;
                t2["underscore"] = 500;
                t2["quoteleft"] = 333;
                t2["a"] = 500;
                t2["b"] = 556;
                t2["c"] = 444;
                t2["d"] = 556;
                t2["e"] = 444;
                t2["f"] = 333;
                t2["g"] = 500;
                t2["h"] = 556;
                t2["i"] = 278;
                t2["j"] = 333;
                t2["k"] = 556;
                t2["l"] = 278;
                t2["m"] = 833;
                t2["n"] = 556;
                t2["o"] = 500;
                t2["p"] = 556;
                t2["q"] = 556;
                t2["r"] = 444;
                t2["s"] = 389;
                t2["t"] = 333;
                t2["u"] = 556;
                t2["v"] = 500;
                t2["w"] = 722;
                t2["x"] = 500;
                t2["y"] = 500;
                t2["z"] = 444;
                t2["braceleft"] = 394;
                t2["bar"] = 220;
                t2["braceright"] = 394;
                t2["asciitilde"] = 520;
                t2["exclamdown"] = 333;
                t2["cent"] = 500;
                t2["sterling"] = 500;
                t2["fraction"] = 167;
                t2["yen"] = 500;
                t2["florin"] = 500;
                t2["section"] = 500;
                t2["currency"] = 500;
                t2["quotesingle"] = 278;
                t2["quotedblleft"] = 500;
                t2["guillemotleft"] = 500;
                t2["guilsinglleft"] = 333;
                t2["guilsinglright"] = 333;
                t2["fi"] = 556;
                t2["fl"] = 556;
                t2["endash"] = 500;
                t2["dagger"] = 500;
                t2["daggerdbl"] = 500;
                t2["periodcentered"] = 250;
                t2["paragraph"] = 540;
                t2["bullet"] = 350;
                t2["quotesinglbase"] = 333;
                t2["quotedblbase"] = 500;
                t2["quotedblright"] = 500;
                t2["guillemotright"] = 500;
                t2["ellipsis"] = 1e3;
                t2["perthousand"] = 1e3;
                t2["questiondown"] = 500;
                t2["grave"] = 333;
                t2["acute"] = 333;
                t2["circumflex"] = 333;
                t2["tilde"] = 333;
                t2["macron"] = 333;
                t2["breve"] = 333;
                t2["dotaccent"] = 333;
                t2["dieresis"] = 333;
                t2["ring"] = 333;
                t2["cedilla"] = 333;
                t2["hungarumlaut"] = 333;
                t2["ogonek"] = 333;
                t2["caron"] = 333;
                t2["emdash"] = 1e3;
                t2["AE"] = 1e3;
                t2["ordfeminine"] = 300;
                t2["Lslash"] = 667;
                t2["Oslash"] = 778;
                t2["OE"] = 1e3;
                t2["ordmasculine"] = 330;
                t2["ae"] = 722;
                t2["dotlessi"] = 278;
                t2["lslash"] = 278;
                t2["oslash"] = 500;
                t2["oe"] = 722;
                t2["germandbls"] = 556;
                t2["Idieresis"] = 389;
                t2["eacute"] = 444;
                t2["abreve"] = 500;
                t2["uhungarumlaut"] = 556;
                t2["ecaron"] = 444;
                t2["Ydieresis"] = 722;
                t2["divide"] = 570;
                t2["Yacute"] = 722;
                t2["Acircumflex"] = 722;
                t2["aacute"] = 500;
                t2["Ucircumflex"] = 722;
                t2["yacute"] = 500;
                t2["scommaaccent"] = 389;
                t2["ecircumflex"] = 444;
                t2["Uring"] = 722;
                t2["Udieresis"] = 722;
                t2["aogonek"] = 500;
                t2["Uacute"] = 722;
                t2["uogonek"] = 556;
                t2["Edieresis"] = 667;
                t2["Dcroat"] = 722;
                t2["commaaccent"] = 250;
                t2["copyright"] = 747;
                t2["Emacron"] = 667;
                t2["ccaron"] = 444;
                t2["aring"] = 500;
                t2["Ncommaaccent"] = 722;
                t2["lacute"] = 278;
                t2["agrave"] = 500;
                t2["Tcommaaccent"] = 667;
                t2["Cacute"] = 722;
                t2["atilde"] = 500;
                t2["Edotaccent"] = 667;
                t2["scaron"] = 389;
                t2["scedilla"] = 389;
                t2["iacute"] = 278;
                t2["lozenge"] = 494;
                t2["Rcaron"] = 722;
                t2["Gcommaaccent"] = 778;
                t2["ucircumflex"] = 556;
                t2["acircumflex"] = 500;
                t2["Amacron"] = 722;
                t2["rcaron"] = 444;
                t2["ccedilla"] = 444;
                t2["Zdotaccent"] = 667;
                t2["Thorn"] = 611;
                t2["Omacron"] = 778;
                t2["Racute"] = 722;
                t2["Sacute"] = 556;
                t2["dcaron"] = 672;
                t2["Umacron"] = 722;
                t2["uring"] = 556;
                t2["threesuperior"] = 300;
                t2["Ograve"] = 778;
                t2["Agrave"] = 722;
                t2["Abreve"] = 722;
                t2["multiply"] = 570;
                t2["uacute"] = 556;
                t2["Tcaron"] = 667;
                t2["partialdiff"] = 494;
                t2["ydieresis"] = 500;
                t2["Nacute"] = 722;
                t2["icircumflex"] = 278;
                t2["Ecircumflex"] = 667;
                t2["adieresis"] = 500;
                t2["edieresis"] = 444;
                t2["cacute"] = 444;
                t2["nacute"] = 556;
                t2["umacron"] = 556;
                t2["Ncaron"] = 722;
                t2["Iacute"] = 389;
                t2["plusminus"] = 570;
                t2["brokenbar"] = 220;
                t2["registered"] = 747;
                t2["Gbreve"] = 778;
                t2["Idotaccent"] = 389;
                t2["summation"] = 600;
                t2["Egrave"] = 667;
                t2["racute"] = 444;
                t2["omacron"] = 500;
                t2["Zacute"] = 667;
                t2["Zcaron"] = 667;
                t2["greaterequal"] = 549;
                t2["Eth"] = 722;
                t2["Ccedilla"] = 722;
                t2["lcommaaccent"] = 278;
                t2["tcaron"] = 416;
                t2["eogonek"] = 444;
                t2["Uogonek"] = 722;
                t2["Aacute"] = 722;
                t2["Adieresis"] = 722;
                t2["egrave"] = 444;
                t2["zacute"] = 444;
                t2["iogonek"] = 278;
                t2["Oacute"] = 778;
                t2["oacute"] = 500;
                t2["amacron"] = 500;
                t2["sacute"] = 389;
                t2["idieresis"] = 278;
                t2["Ocircumflex"] = 778;
                t2["Ugrave"] = 722;
                t2["Delta"] = 612;
                t2["thorn"] = 556;
                t2["twosuperior"] = 300;
                t2["Odieresis"] = 778;
                t2["mu"] = 556;
                t2["igrave"] = 278;
                t2["ohungarumlaut"] = 500;
                t2["Eogonek"] = 667;
                t2["dcroat"] = 556;
                t2["threequarters"] = 750;
                t2["Scedilla"] = 556;
                t2["lcaron"] = 394;
                t2["Kcommaaccent"] = 778;
                t2["Lacute"] = 667;
                t2["trademark"] = 1e3;
                t2["edotaccent"] = 444;
                t2["Igrave"] = 389;
                t2["Imacron"] = 389;
                t2["Lcaron"] = 667;
                t2["onehalf"] = 750;
                t2["lessequal"] = 549;
                t2["ocircumflex"] = 500;
                t2["ntilde"] = 556;
                t2["Uhungarumlaut"] = 722;
                t2["Eacute"] = 667;
                t2["emacron"] = 444;
                t2["gbreve"] = 500;
                t2["onequarter"] = 750;
                t2["Scaron"] = 556;
                t2["Scommaaccent"] = 556;
                t2["Ohungarumlaut"] = 778;
                t2["degree"] = 400;
                t2["ograve"] = 500;
                t2["Ccaron"] = 722;
                t2["ugrave"] = 556;
                t2["radical"] = 549;
                t2["Dcaron"] = 722;
                t2["rcommaaccent"] = 444;
                t2["Ntilde"] = 722;
                t2["otilde"] = 500;
                t2["Rcommaaccent"] = 722;
                t2["Lcommaaccent"] = 667;
                t2["Atilde"] = 722;
                t2["Aogonek"] = 722;
                t2["Aring"] = 722;
                t2["Otilde"] = 778;
                t2["zdotaccent"] = 444;
                t2["Ecaron"] = 667;
                t2["Iogonek"] = 389;
                t2["kcommaaccent"] = 556;
                t2["minus"] = 570;
                t2["Icircumflex"] = 389;
                t2["ncaron"] = 556;
                t2["tcommaaccent"] = 333;
                t2["logicalnot"] = 570;
                t2["odieresis"] = 500;
                t2["udieresis"] = 556;
                t2["notequal"] = 549;
                t2["gcommaaccent"] = 500;
                t2["eth"] = 500;
                t2["zcaron"] = 444;
                t2["ncommaaccent"] = 556;
                t2["onesuperior"] = 300;
                t2["imacron"] = 278;
                t2["Euro"] = 500;
              });
              t["Times-BoldItalic"] = (0, _util.getLookupTableFactory)(function(t2) {
                t2["space"] = 250;
                t2["exclam"] = 389;
                t2["quotedbl"] = 555;
                t2["numbersign"] = 500;
                t2["dollar"] = 500;
                t2["percent"] = 833;
                t2["ampersand"] = 778;
                t2["quoteright"] = 333;
                t2["parenleft"] = 333;
                t2["parenright"] = 333;
                t2["asterisk"] = 500;
                t2["plus"] = 570;
                t2["comma"] = 250;
                t2["hyphen"] = 333;
                t2["period"] = 250;
                t2["slash"] = 278;
                t2["zero"] = 500;
                t2["one"] = 500;
                t2["two"] = 500;
                t2["three"] = 500;
                t2["four"] = 500;
                t2["five"] = 500;
                t2["six"] = 500;
                t2["seven"] = 500;
                t2["eight"] = 500;
                t2["nine"] = 500;
                t2["colon"] = 333;
                t2["semicolon"] = 333;
                t2["less"] = 570;
                t2["equal"] = 570;
                t2["greater"] = 570;
                t2["question"] = 500;
                t2["at"] = 832;
                t2["A"] = 667;
                t2["B"] = 667;
                t2["C"] = 667;
                t2["D"] = 722;
                t2["E"] = 667;
                t2["F"] = 667;
                t2["G"] = 722;
                t2["H"] = 778;
                t2["I"] = 389;
                t2["J"] = 500;
                t2["K"] = 667;
                t2["L"] = 611;
                t2["M"] = 889;
                t2["N"] = 722;
                t2["O"] = 722;
                t2["P"] = 611;
                t2["Q"] = 722;
                t2["R"] = 667;
                t2["S"] = 556;
                t2["T"] = 611;
                t2["U"] = 722;
                t2["V"] = 667;
                t2["W"] = 889;
                t2["X"] = 667;
                t2["Y"] = 611;
                t2["Z"] = 611;
                t2["bracketleft"] = 333;
                t2["backslash"] = 278;
                t2["bracketright"] = 333;
                t2["asciicircum"] = 570;
                t2["underscore"] = 500;
                t2["quoteleft"] = 333;
                t2["a"] = 500;
                t2["b"] = 500;
                t2["c"] = 444;
                t2["d"] = 500;
                t2["e"] = 444;
                t2["f"] = 333;
                t2["g"] = 500;
                t2["h"] = 556;
                t2["i"] = 278;
                t2["j"] = 278;
                t2["k"] = 500;
                t2["l"] = 278;
                t2["m"] = 778;
                t2["n"] = 556;
                t2["o"] = 500;
                t2["p"] = 500;
                t2["q"] = 500;
                t2["r"] = 389;
                t2["s"] = 389;
                t2["t"] = 278;
                t2["u"] = 556;
                t2["v"] = 444;
                t2["w"] = 667;
                t2["x"] = 500;
                t2["y"] = 444;
                t2["z"] = 389;
                t2["braceleft"] = 348;
                t2["bar"] = 220;
                t2["braceright"] = 348;
                t2["asciitilde"] = 570;
                t2["exclamdown"] = 389;
                t2["cent"] = 500;
                t2["sterling"] = 500;
                t2["fraction"] = 167;
                t2["yen"] = 500;
                t2["florin"] = 500;
                t2["section"] = 500;
                t2["currency"] = 500;
                t2["quotesingle"] = 278;
                t2["quotedblleft"] = 500;
                t2["guillemotleft"] = 500;
                t2["guilsinglleft"] = 333;
                t2["guilsinglright"] = 333;
                t2["fi"] = 556;
                t2["fl"] = 556;
                t2["endash"] = 500;
                t2["dagger"] = 500;
                t2["daggerdbl"] = 500;
                t2["periodcentered"] = 250;
                t2["paragraph"] = 500;
                t2["bullet"] = 350;
                t2["quotesinglbase"] = 333;
                t2["quotedblbase"] = 500;
                t2["quotedblright"] = 500;
                t2["guillemotright"] = 500;
                t2["ellipsis"] = 1e3;
                t2["perthousand"] = 1e3;
                t2["questiondown"] = 500;
                t2["grave"] = 333;
                t2["acute"] = 333;
                t2["circumflex"] = 333;
                t2["tilde"] = 333;
                t2["macron"] = 333;
                t2["breve"] = 333;
                t2["dotaccent"] = 333;
                t2["dieresis"] = 333;
                t2["ring"] = 333;
                t2["cedilla"] = 333;
                t2["hungarumlaut"] = 333;
                t2["ogonek"] = 333;
                t2["caron"] = 333;
                t2["emdash"] = 1e3;
                t2["AE"] = 944;
                t2["ordfeminine"] = 266;
                t2["Lslash"] = 611;
                t2["Oslash"] = 722;
                t2["OE"] = 944;
                t2["ordmasculine"] = 300;
                t2["ae"] = 722;
                t2["dotlessi"] = 278;
                t2["lslash"] = 278;
                t2["oslash"] = 500;
                t2["oe"] = 722;
                t2["germandbls"] = 500;
                t2["Idieresis"] = 389;
                t2["eacute"] = 444;
                t2["abreve"] = 500;
                t2["uhungarumlaut"] = 556;
                t2["ecaron"] = 444;
                t2["Ydieresis"] = 611;
                t2["divide"] = 570;
                t2["Yacute"] = 611;
                t2["Acircumflex"] = 667;
                t2["aacute"] = 500;
                t2["Ucircumflex"] = 722;
                t2["yacute"] = 444;
                t2["scommaaccent"] = 389;
                t2["ecircumflex"] = 444;
                t2["Uring"] = 722;
                t2["Udieresis"] = 722;
                t2["aogonek"] = 500;
                t2["Uacute"] = 722;
                t2["uogonek"] = 556;
                t2["Edieresis"] = 667;
                t2["Dcroat"] = 722;
                t2["commaaccent"] = 250;
                t2["copyright"] = 747;
                t2["Emacron"] = 667;
                t2["ccaron"] = 444;
                t2["aring"] = 500;
                t2["Ncommaaccent"] = 722;
                t2["lacute"] = 278;
                t2["agrave"] = 500;
                t2["Tcommaaccent"] = 611;
                t2["Cacute"] = 667;
                t2["atilde"] = 500;
                t2["Edotaccent"] = 667;
                t2["scaron"] = 389;
                t2["scedilla"] = 389;
                t2["iacute"] = 278;
                t2["lozenge"] = 494;
                t2["Rcaron"] = 667;
                t2["Gcommaaccent"] = 722;
                t2["ucircumflex"] = 556;
                t2["acircumflex"] = 500;
                t2["Amacron"] = 667;
                t2["rcaron"] = 389;
                t2["ccedilla"] = 444;
                t2["Zdotaccent"] = 611;
                t2["Thorn"] = 611;
                t2["Omacron"] = 722;
                t2["Racute"] = 667;
                t2["Sacute"] = 556;
                t2["dcaron"] = 608;
                t2["Umacron"] = 722;
                t2["uring"] = 556;
                t2["threesuperior"] = 300;
                t2["Ograve"] = 722;
                t2["Agrave"] = 667;
                t2["Abreve"] = 667;
                t2["multiply"] = 570;
                t2["uacute"] = 556;
                t2["Tcaron"] = 611;
                t2["partialdiff"] = 494;
                t2["ydieresis"] = 444;
                t2["Nacute"] = 722;
                t2["icircumflex"] = 278;
                t2["Ecircumflex"] = 667;
                t2["adieresis"] = 500;
                t2["edieresis"] = 444;
                t2["cacute"] = 444;
                t2["nacute"] = 556;
                t2["umacron"] = 556;
                t2["Ncaron"] = 722;
                t2["Iacute"] = 389;
                t2["plusminus"] = 570;
                t2["brokenbar"] = 220;
                t2["registered"] = 747;
                t2["Gbreve"] = 722;
                t2["Idotaccent"] = 389;
                t2["summation"] = 600;
                t2["Egrave"] = 667;
                t2["racute"] = 389;
                t2["omacron"] = 500;
                t2["Zacute"] = 611;
                t2["Zcaron"] = 611;
                t2["greaterequal"] = 549;
                t2["Eth"] = 722;
                t2["Ccedilla"] = 667;
                t2["lcommaaccent"] = 278;
                t2["tcaron"] = 366;
                t2["eogonek"] = 444;
                t2["Uogonek"] = 722;
                t2["Aacute"] = 667;
                t2["Adieresis"] = 667;
                t2["egrave"] = 444;
                t2["zacute"] = 389;
                t2["iogonek"] = 278;
                t2["Oacute"] = 722;
                t2["oacute"] = 500;
                t2["amacron"] = 500;
                t2["sacute"] = 389;
                t2["idieresis"] = 278;
                t2["Ocircumflex"] = 722;
                t2["Ugrave"] = 722;
                t2["Delta"] = 612;
                t2["thorn"] = 500;
                t2["twosuperior"] = 300;
                t2["Odieresis"] = 722;
                t2["mu"] = 576;
                t2["igrave"] = 278;
                t2["ohungarumlaut"] = 500;
                t2["Eogonek"] = 667;
                t2["dcroat"] = 500;
                t2["threequarters"] = 750;
                t2["Scedilla"] = 556;
                t2["lcaron"] = 382;
                t2["Kcommaaccent"] = 667;
                t2["Lacute"] = 611;
                t2["trademark"] = 1e3;
                t2["edotaccent"] = 444;
                t2["Igrave"] = 389;
                t2["Imacron"] = 389;
                t2["Lcaron"] = 611;
                t2["onehalf"] = 750;
                t2["lessequal"] = 549;
                t2["ocircumflex"] = 500;
                t2["ntilde"] = 556;
                t2["Uhungarumlaut"] = 722;
                t2["Eacute"] = 667;
                t2["emacron"] = 444;
                t2["gbreve"] = 500;
                t2["onequarter"] = 750;
                t2["Scaron"] = 556;
                t2["Scommaaccent"] = 556;
                t2["Ohungarumlaut"] = 722;
                t2["degree"] = 400;
                t2["ograve"] = 500;
                t2["Ccaron"] = 667;
                t2["ugrave"] = 556;
                t2["radical"] = 549;
                t2["Dcaron"] = 722;
                t2["rcommaaccent"] = 389;
                t2["Ntilde"] = 722;
                t2["otilde"] = 500;
                t2["Rcommaaccent"] = 667;
                t2["Lcommaaccent"] = 611;
                t2["Atilde"] = 667;
                t2["Aogonek"] = 667;
                t2["Aring"] = 667;
                t2["Otilde"] = 722;
                t2["zdotaccent"] = 389;
                t2["Ecaron"] = 667;
                t2["Iogonek"] = 389;
                t2["kcommaaccent"] = 500;
                t2["minus"] = 606;
                t2["Icircumflex"] = 389;
                t2["ncaron"] = 556;
                t2["tcommaaccent"] = 278;
                t2["logicalnot"] = 606;
                t2["odieresis"] = 500;
                t2["udieresis"] = 556;
                t2["notequal"] = 549;
                t2["gcommaaccent"] = 500;
                t2["eth"] = 500;
                t2["zcaron"] = 389;
                t2["ncommaaccent"] = 556;
                t2["onesuperior"] = 300;
                t2["imacron"] = 278;
                t2["Euro"] = 500;
              });
              t["Times-Italic"] = (0, _util.getLookupTableFactory)(function(t2) {
                t2["space"] = 250;
                t2["exclam"] = 333;
                t2["quotedbl"] = 420;
                t2["numbersign"] = 500;
                t2["dollar"] = 500;
                t2["percent"] = 833;
                t2["ampersand"] = 778;
                t2["quoteright"] = 333;
                t2["parenleft"] = 333;
                t2["parenright"] = 333;
                t2["asterisk"] = 500;
                t2["plus"] = 675;
                t2["comma"] = 250;
                t2["hyphen"] = 333;
                t2["period"] = 250;
                t2["slash"] = 278;
                t2["zero"] = 500;
                t2["one"] = 500;
                t2["two"] = 500;
                t2["three"] = 500;
                t2["four"] = 500;
                t2["five"] = 500;
                t2["six"] = 500;
                t2["seven"] = 500;
                t2["eight"] = 500;
                t2["nine"] = 500;
                t2["colon"] = 333;
                t2["semicolon"] = 333;
                t2["less"] = 675;
                t2["equal"] = 675;
                t2["greater"] = 675;
                t2["question"] = 500;
                t2["at"] = 920;
                t2["A"] = 611;
                t2["B"] = 611;
                t2["C"] = 667;
                t2["D"] = 722;
                t2["E"] = 611;
                t2["F"] = 611;
                t2["G"] = 722;
                t2["H"] = 722;
                t2["I"] = 333;
                t2["J"] = 444;
                t2["K"] = 667;
                t2["L"] = 556;
                t2["M"] = 833;
                t2["N"] = 667;
                t2["O"] = 722;
                t2["P"] = 611;
                t2["Q"] = 722;
                t2["R"] = 611;
                t2["S"] = 500;
                t2["T"] = 556;
                t2["U"] = 722;
                t2["V"] = 611;
                t2["W"] = 833;
                t2["X"] = 611;
                t2["Y"] = 556;
                t2["Z"] = 556;
                t2["bracketleft"] = 389;
                t2["backslash"] = 278;
                t2["bracketright"] = 389;
                t2["asciicircum"] = 422;
                t2["underscore"] = 500;
                t2["quoteleft"] = 333;
                t2["a"] = 500;
                t2["b"] = 500;
                t2["c"] = 444;
                t2["d"] = 500;
                t2["e"] = 444;
                t2["f"] = 278;
                t2["g"] = 500;
                t2["h"] = 500;
                t2["i"] = 278;
                t2["j"] = 278;
                t2["k"] = 444;
                t2["l"] = 278;
                t2["m"] = 722;
                t2["n"] = 500;
                t2["o"] = 500;
                t2["p"] = 500;
                t2["q"] = 500;
                t2["r"] = 389;
                t2["s"] = 389;
                t2["t"] = 278;
                t2["u"] = 500;
                t2["v"] = 444;
                t2["w"] = 667;
                t2["x"] = 444;
                t2["y"] = 444;
                t2["z"] = 389;
                t2["braceleft"] = 400;
                t2["bar"] = 275;
                t2["braceright"] = 400;
                t2["asciitilde"] = 541;
                t2["exclamdown"] = 389;
                t2["cent"] = 500;
                t2["sterling"] = 500;
                t2["fraction"] = 167;
                t2["yen"] = 500;
                t2["florin"] = 500;
                t2["section"] = 500;
                t2["currency"] = 500;
                t2["quotesingle"] = 214;
                t2["quotedblleft"] = 556;
                t2["guillemotleft"] = 500;
                t2["guilsinglleft"] = 333;
                t2["guilsinglright"] = 333;
                t2["fi"] = 500;
                t2["fl"] = 500;
                t2["endash"] = 500;
                t2["dagger"] = 500;
                t2["daggerdbl"] = 500;
                t2["periodcentered"] = 250;
                t2["paragraph"] = 523;
                t2["bullet"] = 350;
                t2["quotesinglbase"] = 333;
                t2["quotedblbase"] = 556;
                t2["quotedblright"] = 556;
                t2["guillemotright"] = 500;
                t2["ellipsis"] = 889;
                t2["perthousand"] = 1e3;
                t2["questiondown"] = 500;
                t2["grave"] = 333;
                t2["acute"] = 333;
                t2["circumflex"] = 333;
                t2["tilde"] = 333;
                t2["macron"] = 333;
                t2["breve"] = 333;
                t2["dotaccent"] = 333;
                t2["dieresis"] = 333;
                t2["ring"] = 333;
                t2["cedilla"] = 333;
                t2["hungarumlaut"] = 333;
                t2["ogonek"] = 333;
                t2["caron"] = 333;
                t2["emdash"] = 889;
                t2["AE"] = 889;
                t2["ordfeminine"] = 276;
                t2["Lslash"] = 556;
                t2["Oslash"] = 722;
                t2["OE"] = 944;
                t2["ordmasculine"] = 310;
                t2["ae"] = 667;
                t2["dotlessi"] = 278;
                t2["lslash"] = 278;
                t2["oslash"] = 500;
                t2["oe"] = 667;
                t2["germandbls"] = 500;
                t2["Idieresis"] = 333;
                t2["eacute"] = 444;
                t2["abreve"] = 500;
                t2["uhungarumlaut"] = 500;
                t2["ecaron"] = 444;
                t2["Ydieresis"] = 556;
                t2["divide"] = 675;
                t2["Yacute"] = 556;
                t2["Acircumflex"] = 611;
                t2["aacute"] = 500;
                t2["Ucircumflex"] = 722;
                t2["yacute"] = 444;
                t2["scommaaccent"] = 389;
                t2["ecircumflex"] = 444;
                t2["Uring"] = 722;
                t2["Udieresis"] = 722;
                t2["aogonek"] = 500;
                t2["Uacute"] = 722;
                t2["uogonek"] = 500;
                t2["Edieresis"] = 611;
                t2["Dcroat"] = 722;
                t2["commaaccent"] = 250;
                t2["copyright"] = 760;
                t2["Emacron"] = 611;
                t2["ccaron"] = 444;
                t2["aring"] = 500;
                t2["Ncommaaccent"] = 667;
                t2["lacute"] = 278;
                t2["agrave"] = 500;
                t2["Tcommaaccent"] = 556;
                t2["Cacute"] = 667;
                t2["atilde"] = 500;
                t2["Edotaccent"] = 611;
                t2["scaron"] = 389;
                t2["scedilla"] = 389;
                t2["iacute"] = 278;
                t2["lozenge"] = 471;
                t2["Rcaron"] = 611;
                t2["Gcommaaccent"] = 722;
                t2["ucircumflex"] = 500;
                t2["acircumflex"] = 500;
                t2["Amacron"] = 611;
                t2["rcaron"] = 389;
                t2["ccedilla"] = 444;
                t2["Zdotaccent"] = 556;
                t2["Thorn"] = 611;
                t2["Omacron"] = 722;
                t2["Racute"] = 611;
                t2["Sacute"] = 500;
                t2["dcaron"] = 544;
                t2["Umacron"] = 722;
                t2["uring"] = 500;
                t2["threesuperior"] = 300;
                t2["Ograve"] = 722;
                t2["Agrave"] = 611;
                t2["Abreve"] = 611;
                t2["multiply"] = 675;
                t2["uacute"] = 500;
                t2["Tcaron"] = 556;
                t2["partialdiff"] = 476;
                t2["ydieresis"] = 444;
                t2["Nacute"] = 667;
                t2["icircumflex"] = 278;
                t2["Ecircumflex"] = 611;
                t2["adieresis"] = 500;
                t2["edieresis"] = 444;
                t2["cacute"] = 444;
                t2["nacute"] = 500;
                t2["umacron"] = 500;
                t2["Ncaron"] = 667;
                t2["Iacute"] = 333;
                t2["plusminus"] = 675;
                t2["brokenbar"] = 275;
                t2["registered"] = 760;
                t2["Gbreve"] = 722;
                t2["Idotaccent"] = 333;
                t2["summation"] = 600;
                t2["Egrave"] = 611;
                t2["racute"] = 389;
                t2["omacron"] = 500;
                t2["Zacute"] = 556;
                t2["Zcaron"] = 556;
                t2["greaterequal"] = 549;
                t2["Eth"] = 722;
                t2["Ccedilla"] = 667;
                t2["lcommaaccent"] = 278;
                t2["tcaron"] = 300;
                t2["eogonek"] = 444;
                t2["Uogonek"] = 722;
                t2["Aacute"] = 611;
                t2["Adieresis"] = 611;
                t2["egrave"] = 444;
                t2["zacute"] = 389;
                t2["iogonek"] = 278;
                t2["Oacute"] = 722;
                t2["oacute"] = 500;
                t2["amacron"] = 500;
                t2["sacute"] = 389;
                t2["idieresis"] = 278;
                t2["Ocircumflex"] = 722;
                t2["Ugrave"] = 722;
                t2["Delta"] = 612;
                t2["thorn"] = 500;
                t2["twosuperior"] = 300;
                t2["Odieresis"] = 722;
                t2["mu"] = 500;
                t2["igrave"] = 278;
                t2["ohungarumlaut"] = 500;
                t2["Eogonek"] = 611;
                t2["dcroat"] = 500;
                t2["threequarters"] = 750;
                t2["Scedilla"] = 500;
                t2["lcaron"] = 300;
                t2["Kcommaaccent"] = 667;
                t2["Lacute"] = 556;
                t2["trademark"] = 980;
                t2["edotaccent"] = 444;
                t2["Igrave"] = 333;
                t2["Imacron"] = 333;
                t2["Lcaron"] = 611;
                t2["onehalf"] = 750;
                t2["lessequal"] = 549;
                t2["ocircumflex"] = 500;
                t2["ntilde"] = 500;
                t2["Uhungarumlaut"] = 722;
                t2["Eacute"] = 611;
                t2["emacron"] = 444;
                t2["gbreve"] = 500;
                t2["onequarter"] = 750;
                t2["Scaron"] = 500;
                t2["Scommaaccent"] = 500;
                t2["Ohungarumlaut"] = 722;
                t2["degree"] = 400;
                t2["ograve"] = 500;
                t2["Ccaron"] = 667;
                t2["ugrave"] = 500;
                t2["radical"] = 453;
                t2["Dcaron"] = 722;
                t2["rcommaaccent"] = 389;
                t2["Ntilde"] = 667;
                t2["otilde"] = 500;
                t2["Rcommaaccent"] = 611;
                t2["Lcommaaccent"] = 556;
                t2["Atilde"] = 611;
                t2["Aogonek"] = 611;
                t2["Aring"] = 611;
                t2["Otilde"] = 722;
                t2["zdotaccent"] = 389;
                t2["Ecaron"] = 611;
                t2["Iogonek"] = 333;
                t2["kcommaaccent"] = 444;
                t2["minus"] = 675;
                t2["Icircumflex"] = 333;
                t2["ncaron"] = 500;
                t2["tcommaaccent"] = 278;
                t2["logicalnot"] = 675;
                t2["odieresis"] = 500;
                t2["udieresis"] = 500;
                t2["notequal"] = 549;
                t2["gcommaaccent"] = 500;
                t2["eth"] = 500;
                t2["zcaron"] = 389;
                t2["ncommaaccent"] = 500;
                t2["onesuperior"] = 300;
                t2["imacron"] = 278;
                t2["Euro"] = 500;
              });
              t["ZapfDingbats"] = (0, _util.getLookupTableFactory)(function(t2) {
                t2["space"] = 278;
                t2["a1"] = 974;
                t2["a2"] = 961;
                t2["a202"] = 974;
                t2["a3"] = 980;
                t2["a4"] = 719;
                t2["a5"] = 789;
                t2["a119"] = 790;
                t2["a118"] = 791;
                t2["a117"] = 690;
                t2["a11"] = 960;
                t2["a12"] = 939;
                t2["a13"] = 549;
                t2["a14"] = 855;
                t2["a15"] = 911;
                t2["a16"] = 933;
                t2["a105"] = 911;
                t2["a17"] = 945;
                t2["a18"] = 974;
                t2["a19"] = 755;
                t2["a20"] = 846;
                t2["a21"] = 762;
                t2["a22"] = 761;
                t2["a23"] = 571;
                t2["a24"] = 677;
                t2["a25"] = 763;
                t2["a26"] = 760;
                t2["a27"] = 759;
                t2["a28"] = 754;
                t2["a6"] = 494;
                t2["a7"] = 552;
                t2["a8"] = 537;
                t2["a9"] = 577;
                t2["a10"] = 692;
                t2["a29"] = 786;
                t2["a30"] = 788;
                t2["a31"] = 788;
                t2["a32"] = 790;
                t2["a33"] = 793;
                t2["a34"] = 794;
                t2["a35"] = 816;
                t2["a36"] = 823;
                t2["a37"] = 789;
                t2["a38"] = 841;
                t2["a39"] = 823;
                t2["a40"] = 833;
                t2["a41"] = 816;
                t2["a42"] = 831;
                t2["a43"] = 923;
                t2["a44"] = 744;
                t2["a45"] = 723;
                t2["a46"] = 749;
                t2["a47"] = 790;
                t2["a48"] = 792;
                t2["a49"] = 695;
                t2["a50"] = 776;
                t2["a51"] = 768;
                t2["a52"] = 792;
                t2["a53"] = 759;
                t2["a54"] = 707;
                t2["a55"] = 708;
                t2["a56"] = 682;
                t2["a57"] = 701;
                t2["a58"] = 826;
                t2["a59"] = 815;
                t2["a60"] = 789;
                t2["a61"] = 789;
                t2["a62"] = 707;
                t2["a63"] = 687;
                t2["a64"] = 696;
                t2["a65"] = 689;
                t2["a66"] = 786;
                t2["a67"] = 787;
                t2["a68"] = 713;
                t2["a69"] = 791;
                t2["a70"] = 785;
                t2["a71"] = 791;
                t2["a72"] = 873;
                t2["a73"] = 761;
                t2["a74"] = 762;
                t2["a203"] = 762;
                t2["a75"] = 759;
                t2["a204"] = 759;
                t2["a76"] = 892;
                t2["a77"] = 892;
                t2["a78"] = 788;
                t2["a79"] = 784;
                t2["a81"] = 438;
                t2["a82"] = 138;
                t2["a83"] = 277;
                t2["a84"] = 415;
                t2["a97"] = 392;
                t2["a98"] = 392;
                t2["a99"] = 668;
                t2["a100"] = 668;
                t2["a89"] = 390;
                t2["a90"] = 390;
                t2["a93"] = 317;
                t2["a94"] = 317;
                t2["a91"] = 276;
                t2["a92"] = 276;
                t2["a205"] = 509;
                t2["a85"] = 509;
                t2["a206"] = 410;
                t2["a86"] = 410;
                t2["a87"] = 234;
                t2["a88"] = 234;
                t2["a95"] = 334;
                t2["a96"] = 334;
                t2["a101"] = 732;
                t2["a102"] = 544;
                t2["a103"] = 544;
                t2["a104"] = 910;
                t2["a106"] = 667;
                t2["a107"] = 760;
                t2["a108"] = 760;
                t2["a112"] = 776;
                t2["a111"] = 595;
                t2["a110"] = 694;
                t2["a109"] = 626;
                t2["a120"] = 788;
                t2["a121"] = 788;
                t2["a122"] = 788;
                t2["a123"] = 788;
                t2["a124"] = 788;
                t2["a125"] = 788;
                t2["a126"] = 788;
                t2["a127"] = 788;
                t2["a128"] = 788;
                t2["a129"] = 788;
                t2["a130"] = 788;
                t2["a131"] = 788;
                t2["a132"] = 788;
                t2["a133"] = 788;
                t2["a134"] = 788;
                t2["a135"] = 788;
                t2["a136"] = 788;
                t2["a137"] = 788;
                t2["a138"] = 788;
                t2["a139"] = 788;
                t2["a140"] = 788;
                t2["a141"] = 788;
                t2["a142"] = 788;
                t2["a143"] = 788;
                t2["a144"] = 788;
                t2["a145"] = 788;
                t2["a146"] = 788;
                t2["a147"] = 788;
                t2["a148"] = 788;
                t2["a149"] = 788;
                t2["a150"] = 788;
                t2["a151"] = 788;
                t2["a152"] = 788;
                t2["a153"] = 788;
                t2["a154"] = 788;
                t2["a155"] = 788;
                t2["a156"] = 788;
                t2["a157"] = 788;
                t2["a158"] = 788;
                t2["a159"] = 788;
                t2["a160"] = 894;
                t2["a161"] = 838;
                t2["a163"] = 1016;
                t2["a164"] = 458;
                t2["a196"] = 748;
                t2["a165"] = 924;
                t2["a192"] = 748;
                t2["a166"] = 918;
                t2["a167"] = 927;
                t2["a168"] = 928;
                t2["a169"] = 928;
                t2["a170"] = 834;
                t2["a171"] = 873;
                t2["a172"] = 828;
                t2["a173"] = 924;
                t2["a162"] = 924;
                t2["a174"] = 917;
                t2["a175"] = 930;
                t2["a176"] = 931;
                t2["a177"] = 463;
                t2["a178"] = 883;
                t2["a179"] = 836;
                t2["a193"] = 836;
                t2["a180"] = 867;
                t2["a199"] = 867;
                t2["a181"] = 696;
                t2["a200"] = 696;
                t2["a182"] = 874;
                t2["a201"] = 874;
                t2["a183"] = 760;
                t2["a184"] = 946;
                t2["a197"] = 771;
                t2["a185"] = 865;
                t2["a194"] = 771;
                t2["a198"] = 888;
                t2["a186"] = 967;
                t2["a195"] = 888;
                t2["a187"] = 831;
                t2["a188"] = 873;
                t2["a189"] = 927;
                t2["a190"] = 970;
                t2["a191"] = 918;
              });
            });
            exports3.getMetrics = getMetrics;
          },
          /* 149 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.PostScriptCompiler = exports3.PostScriptEvaluator = exports3.PDFFunctionFactory = exports3.isPDFFunction = void 0;
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var _createClass = /* @__PURE__ */ function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _util = __w_pdfjs_require__(2);
            var _primitives = __w_pdfjs_require__(119);
            var _ps_parser = __w_pdfjs_require__(150);
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var IsEvalSupportedCached = {
              get value() {
                return (0, _util.shadow)(this, "value", (0, _util.isEvalSupported)());
              }
            };
            var PDFFunctionFactory = function() {
              function PDFFunctionFactory2(_ref) {
                var xref = _ref.xref, _ref$isEvalSupported = _ref.isEvalSupported, isEvalSupported = _ref$isEvalSupported === void 0 ? true : _ref$isEvalSupported;
                _classCallCheck(this, PDFFunctionFactory2);
                this.xref = xref;
                this.isEvalSupported = isEvalSupported !== false;
              }
              _createClass(PDFFunctionFactory2, [{
                key: "create",
                value: function create(fn) {
                  return PDFFunction.parse({
                    xref: this.xref,
                    isEvalSupported: this.isEvalSupported,
                    fn
                  });
                }
              }, {
                key: "createFromArray",
                value: function createFromArray(fnObj) {
                  return PDFFunction.parseArray({
                    xref: this.xref,
                    isEvalSupported: this.isEvalSupported,
                    fnObj
                  });
                }
              }]);
              return PDFFunctionFactory2;
            }();
            function toNumberArray(arr) {
              if (!Array.isArray(arr)) {
                return null;
              }
              var length = arr.length;
              for (var i = 0; i < length; i++) {
                if (typeof arr[i] !== "number") {
                  var result = new Array(length);
                  for (var _i = 0; _i < length; _i++) {
                    result[_i] = +arr[_i];
                  }
                  return result;
                }
              }
              return arr;
            }
            var PDFFunction = /* @__PURE__ */ function PDFFunctionClosure() {
              var CONSTRUCT_SAMPLED = 0;
              var CONSTRUCT_INTERPOLATED = 2;
              var CONSTRUCT_STICHED = 3;
              var CONSTRUCT_POSTSCRIPT = 4;
              return {
                getSampleArray: function getSampleArray(size, outputSize, bps, stream2) {
                  var i, ii;
                  var length = 1;
                  for (i = 0, ii = size.length; i < ii; i++) {
                    length *= size[i];
                  }
                  length *= outputSize;
                  var array = new Array(length);
                  var codeSize = 0;
                  var codeBuf = 0;
                  var sampleMul = 1 / (Math.pow(2, bps) - 1);
                  var strBytes = stream2.getBytes((length * bps + 7) / 8);
                  var strIdx = 0;
                  for (i = 0; i < length; i++) {
                    while (codeSize < bps) {
                      codeBuf <<= 8;
                      codeBuf |= strBytes[strIdx++];
                      codeSize += 8;
                    }
                    codeSize -= bps;
                    array[i] = (codeBuf >> codeSize) * sampleMul;
                    codeBuf &= (1 << codeSize) - 1;
                  }
                  return array;
                },
                getIR: function getIR(_ref2) {
                  var xref = _ref2.xref, isEvalSupported = _ref2.isEvalSupported, fn = _ref2.fn;
                  var dict = fn.dict;
                  if (!dict) {
                    dict = fn;
                  }
                  var types = [this.constructSampled, null, this.constructInterpolated, this.constructStiched, this.constructPostScript];
                  var typeNum = dict.get("FunctionType");
                  var typeFn = types[typeNum];
                  if (!typeFn) {
                    throw new _util.FormatError("Unknown type of function");
                  }
                  return typeFn.call(this, {
                    xref,
                    isEvalSupported,
                    fn,
                    dict
                  });
                },
                fromIR: function fromIR(_ref3) {
                  var xref = _ref3.xref, isEvalSupported = _ref3.isEvalSupported, IR = _ref3.IR;
                  var type = IR[0];
                  switch (type) {
                    case CONSTRUCT_SAMPLED:
                      return this.constructSampledFromIR({
                        xref,
                        isEvalSupported,
                        IR
                      });
                    case CONSTRUCT_INTERPOLATED:
                      return this.constructInterpolatedFromIR({
                        xref,
                        isEvalSupported,
                        IR
                      });
                    case CONSTRUCT_STICHED:
                      return this.constructStichedFromIR({
                        xref,
                        isEvalSupported,
                        IR
                      });
                    default:
                      return this.constructPostScriptFromIR({
                        xref,
                        isEvalSupported,
                        IR
                      });
                  }
                },
                parse: function parse(_ref4) {
                  var xref = _ref4.xref, isEvalSupported = _ref4.isEvalSupported, fn = _ref4.fn;
                  var IR = this.getIR({
                    xref,
                    isEvalSupported,
                    fn
                  });
                  return this.fromIR({
                    xref,
                    isEvalSupported,
                    IR
                  });
                },
                parseArray: function parseArray(_ref5) {
                  var xref = _ref5.xref, isEvalSupported = _ref5.isEvalSupported, fnObj = _ref5.fnObj;
                  if (!Array.isArray(fnObj)) {
                    return this.parse({
                      xref,
                      isEvalSupported,
                      fn: fnObj
                    });
                  }
                  var fnArray = [];
                  for (var j = 0, jj = fnObj.length; j < jj; j++) {
                    fnArray.push(this.parse({
                      xref,
                      isEvalSupported,
                      fn: xref.fetchIfRef(fnObj[j])
                    }));
                  }
                  return function(src, srcOffset, dest, destOffset) {
                    for (var i = 0, ii = fnArray.length; i < ii; i++) {
                      fnArray[i](src, srcOffset, dest, destOffset + i);
                    }
                  };
                },
                constructSampled: function constructSampled(_ref6) {
                  var xref = _ref6.xref, isEvalSupported = _ref6.isEvalSupported, fn = _ref6.fn, dict = _ref6.dict;
                  function toMultiArray(arr) {
                    var inputLength = arr.length;
                    var out = [];
                    var index = 0;
                    for (var i2 = 0; i2 < inputLength; i2 += 2) {
                      out[index] = [arr[i2], arr[i2 + 1]];
                      ++index;
                    }
                    return out;
                  }
                  var domain = toNumberArray(dict.getArray("Domain"));
                  var range = toNumberArray(dict.getArray("Range"));
                  if (!domain || !range) {
                    throw new _util.FormatError("No domain or range");
                  }
                  var inputSize = domain.length / 2;
                  var outputSize = range.length / 2;
                  domain = toMultiArray(domain);
                  range = toMultiArray(range);
                  var size = toNumberArray(dict.getArray("Size"));
                  var bps = dict.get("BitsPerSample");
                  var order = dict.get("Order") || 1;
                  if (order !== 1) {
                    (0, _util.info)("No support for cubic spline interpolation: " + order);
                  }
                  var encode = toNumberArray(dict.getArray("Encode"));
                  if (!encode) {
                    encode = [];
                    for (var i = 0; i < inputSize; ++i) {
                      encode.push([0, size[i] - 1]);
                    }
                  } else {
                    encode = toMultiArray(encode);
                  }
                  var decode = toNumberArray(dict.getArray("Decode"));
                  if (!decode) {
                    decode = range;
                  } else {
                    decode = toMultiArray(decode);
                  }
                  var samples = this.getSampleArray(size, outputSize, bps, fn);
                  return [CONSTRUCT_SAMPLED, inputSize, domain, encode, decode, samples, size, outputSize, Math.pow(2, bps) - 1, range];
                },
                constructSampledFromIR: function constructSampledFromIR(_ref7) {
                  var xref = _ref7.xref, isEvalSupported = _ref7.isEvalSupported, IR = _ref7.IR;
                  function interpolate(x, xmin, xmax, ymin, ymax) {
                    return ymin + (x - xmin) * ((ymax - ymin) / (xmax - xmin));
                  }
                  return function constructSampledFromIRResult(src, srcOffset, dest, destOffset) {
                    var m = IR[1];
                    var domain = IR[2];
                    var encode = IR[3];
                    var decode = IR[4];
                    var samples = IR[5];
                    var size = IR[6];
                    var n = IR[7];
                    var range = IR[9];
                    var cubeVertices = 1 << m;
                    var cubeN = new Float64Array(cubeVertices);
                    var cubeVertex = new Uint32Array(cubeVertices);
                    var i, j;
                    for (j = 0; j < cubeVertices; j++) {
                      cubeN[j] = 1;
                    }
                    var k = n, pos = 1;
                    for (i = 0; i < m; ++i) {
                      var domain_2i = domain[i][0];
                      var domain_2i_1 = domain[i][1];
                      var xi = Math.min(Math.max(src[srcOffset + i], domain_2i), domain_2i_1);
                      var e = interpolate(xi, domain_2i, domain_2i_1, encode[i][0], encode[i][1]);
                      var size_i = size[i];
                      e = Math.min(Math.max(e, 0), size_i - 1);
                      var e0 = e < size_i - 1 ? Math.floor(e) : e - 1;
                      var n0 = e0 + 1 - e;
                      var n1 = e - e0;
                      var offset0 = e0 * k;
                      var offset1 = offset0 + k;
                      for (j = 0; j < cubeVertices; j++) {
                        if (j & pos) {
                          cubeN[j] *= n1;
                          cubeVertex[j] += offset1;
                        } else {
                          cubeN[j] *= n0;
                          cubeVertex[j] += offset0;
                        }
                      }
                      k *= size_i;
                      pos <<= 1;
                    }
                    for (j = 0; j < n; ++j) {
                      var rj = 0;
                      for (i = 0; i < cubeVertices; i++) {
                        rj += samples[cubeVertex[i] + j] * cubeN[i];
                      }
                      rj = interpolate(rj, 0, 1, decode[j][0], decode[j][1]);
                      dest[destOffset + j] = Math.min(Math.max(rj, range[j][0]), range[j][1]);
                    }
                  };
                },
                constructInterpolated: function constructInterpolated(_ref8) {
                  var xref = _ref8.xref, isEvalSupported = _ref8.isEvalSupported, fn = _ref8.fn, dict = _ref8.dict;
                  var c0 = toNumberArray(dict.getArray("C0")) || [0];
                  var c1 = toNumberArray(dict.getArray("C1")) || [1];
                  var n = dict.get("N");
                  var length = c0.length;
                  var diff = [];
                  for (var i = 0; i < length; ++i) {
                    diff.push(c1[i] - c0[i]);
                  }
                  return [CONSTRUCT_INTERPOLATED, c0, diff, n];
                },
                constructInterpolatedFromIR: function constructInterpolatedFromIR(_ref9) {
                  var xref = _ref9.xref, isEvalSupported = _ref9.isEvalSupported, IR = _ref9.IR;
                  var c0 = IR[1];
                  var diff = IR[2];
                  var n = IR[3];
                  var length = diff.length;
                  return function constructInterpolatedFromIRResult(src, srcOffset, dest, destOffset) {
                    var x = n === 1 ? src[srcOffset] : Math.pow(src[srcOffset], n);
                    for (var j = 0; j < length; ++j) {
                      dest[destOffset + j] = c0[j] + x * diff[j];
                    }
                  };
                },
                constructStiched: function constructStiched(_ref10) {
                  var xref = _ref10.xref, isEvalSupported = _ref10.isEvalSupported, fn = _ref10.fn, dict = _ref10.dict;
                  var domain = toNumberArray(dict.getArray("Domain"));
                  if (!domain) {
                    throw new _util.FormatError("No domain");
                  }
                  var inputSize = domain.length / 2;
                  if (inputSize !== 1) {
                    throw new _util.FormatError("Bad domain for stiched function");
                  }
                  var fnRefs = dict.get("Functions");
                  var fns = [];
                  for (var i = 0, ii = fnRefs.length; i < ii; ++i) {
                    fns.push(this.parse({
                      xref,
                      isEvalSupported,
                      fn: xref.fetchIfRef(fnRefs[i])
                    }));
                  }
                  var bounds = toNumberArray(dict.getArray("Bounds"));
                  var encode = toNumberArray(dict.getArray("Encode"));
                  return [CONSTRUCT_STICHED, domain, bounds, encode, fns];
                },
                constructStichedFromIR: function constructStichedFromIR(_ref11) {
                  var xref = _ref11.xref, isEvalSupported = _ref11.isEvalSupported, IR = _ref11.IR;
                  var domain = IR[1];
                  var bounds = IR[2];
                  var encode = IR[3];
                  var fns = IR[4];
                  var tmpBuf = new Float32Array(1);
                  return function constructStichedFromIRResult(src, srcOffset, dest, destOffset) {
                    var clip = function constructStichedFromIRClip(v2, min, max) {
                      if (v2 > max) {
                        v2 = max;
                      } else if (v2 < min) {
                        v2 = min;
                      }
                      return v2;
                    };
                    var v = clip(src[srcOffset], domain[0], domain[1]);
                    for (var i = 0, ii = bounds.length; i < ii; ++i) {
                      if (v < bounds[i]) {
                        break;
                      }
                    }
                    var dmin = domain[0];
                    if (i > 0) {
                      dmin = bounds[i - 1];
                    }
                    var dmax = domain[1];
                    if (i < bounds.length) {
                      dmax = bounds[i];
                    }
                    var rmin = encode[2 * i];
                    var rmax = encode[2 * i + 1];
                    tmpBuf[0] = dmin === dmax ? rmin : rmin + (v - dmin) * (rmax - rmin) / (dmax - dmin);
                    fns[i](tmpBuf, 0, dest, destOffset);
                  };
                },
                constructPostScript: function constructPostScript(_ref12) {
                  var xref = _ref12.xref, isEvalSupported = _ref12.isEvalSupported, fn = _ref12.fn, dict = _ref12.dict;
                  var domain = toNumberArray(dict.getArray("Domain"));
                  var range = toNumberArray(dict.getArray("Range"));
                  if (!domain) {
                    throw new _util.FormatError("No domain.");
                  }
                  if (!range) {
                    throw new _util.FormatError("No range.");
                  }
                  var lexer = new _ps_parser.PostScriptLexer(fn);
                  var parser = new _ps_parser.PostScriptParser(lexer);
                  var code = parser.parse();
                  return [CONSTRUCT_POSTSCRIPT, domain, range, code];
                },
                constructPostScriptFromIR: function constructPostScriptFromIR(_ref13) {
                  var xref = _ref13.xref, isEvalSupported = _ref13.isEvalSupported, IR = _ref13.IR;
                  var domain = IR[1];
                  var range = IR[2];
                  var code = IR[3];
                  if (isEvalSupported && IsEvalSupportedCached.value) {
                    var compiled = new PostScriptCompiler().compile(code, domain, range);
                    if (compiled) {
                      return new Function("src", "srcOffset", "dest", "destOffset", compiled);
                    }
                  }
                  (0, _util.info)("Unable to compile PS function");
                  var numOutputs = range.length >> 1;
                  var numInputs = domain.length >> 1;
                  var evaluator = new PostScriptEvaluator(code);
                  var cache = /* @__PURE__ */ Object.create(null);
                  var MAX_CACHE_SIZE = 2048 * 4;
                  var cache_available = MAX_CACHE_SIZE;
                  var tmpBuf = new Float32Array(numInputs);
                  return function constructPostScriptFromIRResult(src, srcOffset, dest, destOffset) {
                    var i, value;
                    var key = "";
                    var input = tmpBuf;
                    for (i = 0; i < numInputs; i++) {
                      value = src[srcOffset + i];
                      input[i] = value;
                      key += value + "_";
                    }
                    var cachedValue = cache[key];
                    if (cachedValue !== void 0) {
                      dest.set(cachedValue, destOffset);
                      return;
                    }
                    var output = new Float32Array(numOutputs);
                    var stack = evaluator.execute(input);
                    var stackIndex = stack.length - numOutputs;
                    for (i = 0; i < numOutputs; i++) {
                      value = stack[stackIndex + i];
                      var bound = range[i * 2];
                      if (value < bound) {
                        value = bound;
                      } else {
                        bound = range[i * 2 + 1];
                        if (value > bound) {
                          value = bound;
                        }
                      }
                      output[i] = value;
                    }
                    if (cache_available > 0) {
                      cache_available--;
                      cache[key] = output;
                    }
                    dest.set(output, destOffset);
                  };
                }
              };
            }();
            function isPDFFunction(v) {
              var fnDict;
              if ((typeof v === "undefined" ? "undefined" : _typeof(v)) !== "object") {
                return false;
              } else if ((0, _primitives.isDict)(v)) {
                fnDict = v;
              } else if ((0, _primitives.isStream)(v)) {
                fnDict = v.dict;
              } else {
                return false;
              }
              return fnDict.has("FunctionType");
            }
            var PostScriptStack = function PostScriptStackClosure() {
              var MAX_STACK_SIZE = 100;
              function PostScriptStack2(initialStack) {
                this.stack = !initialStack ? [] : Array.prototype.slice.call(initialStack, 0);
              }
              PostScriptStack2.prototype = {
                push: function PostScriptStack_push(value) {
                  if (this.stack.length >= MAX_STACK_SIZE) {
                    throw new Error("PostScript function stack overflow.");
                  }
                  this.stack.push(value);
                },
                pop: function PostScriptStack_pop() {
                  if (this.stack.length <= 0) {
                    throw new Error("PostScript function stack underflow.");
                  }
                  return this.stack.pop();
                },
                copy: function PostScriptStack_copy(n) {
                  if (this.stack.length + n >= MAX_STACK_SIZE) {
                    throw new Error("PostScript function stack overflow.");
                  }
                  var stack = this.stack;
                  for (var i = stack.length - n, j = n - 1; j >= 0; j--, i++) {
                    stack.push(stack[i]);
                  }
                },
                index: function PostScriptStack_index(n) {
                  this.push(this.stack[this.stack.length - n - 1]);
                },
                roll: function PostScriptStack_roll(n, p) {
                  var stack = this.stack;
                  var l = stack.length - n;
                  var r = stack.length - 1, c = l + (p - Math.floor(p / n) * n), i, j, t;
                  for (i = l, j = r; i < j; i++, j--) {
                    t = stack[i];
                    stack[i] = stack[j];
                    stack[j] = t;
                  }
                  for (i = l, j = c - 1; i < j; i++, j--) {
                    t = stack[i];
                    stack[i] = stack[j];
                    stack[j] = t;
                  }
                  for (i = c, j = r; i < j; i++, j--) {
                    t = stack[i];
                    stack[i] = stack[j];
                    stack[j] = t;
                  }
                }
              };
              return PostScriptStack2;
            }();
            var PostScriptEvaluator = function PostScriptEvaluatorClosure() {
              function PostScriptEvaluator2(operators) {
                this.operators = operators;
              }
              PostScriptEvaluator2.prototype = {
                execute: function PostScriptEvaluator_execute(initialStack) {
                  var stack = new PostScriptStack(initialStack);
                  var counter = 0;
                  var operators = this.operators;
                  var length = operators.length;
                  var operator, a, b;
                  while (counter < length) {
                    operator = operators[counter++];
                    if (typeof operator === "number") {
                      stack.push(operator);
                      continue;
                    }
                    switch (operator) {
                      case "jz":
                        b = stack.pop();
                        a = stack.pop();
                        if (!a) {
                          counter = b;
                        }
                        break;
                      case "j":
                        a = stack.pop();
                        counter = a;
                        break;
                      case "abs":
                        a = stack.pop();
                        stack.push(Math.abs(a));
                        break;
                      case "add":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a + b);
                        break;
                      case "and":
                        b = stack.pop();
                        a = stack.pop();
                        if ((0, _util.isBool)(a) && (0, _util.isBool)(b)) {
                          stack.push(a && b);
                        } else {
                          stack.push(a & b);
                        }
                        break;
                      case "atan":
                        a = stack.pop();
                        stack.push(Math.atan(a));
                        break;
                      case "bitshift":
                        b = stack.pop();
                        a = stack.pop();
                        if (a > 0) {
                          stack.push(a << b);
                        } else {
                          stack.push(a >> b);
                        }
                        break;
                      case "ceiling":
                        a = stack.pop();
                        stack.push(Math.ceil(a));
                        break;
                      case "copy":
                        a = stack.pop();
                        stack.copy(a);
                        break;
                      case "cos":
                        a = stack.pop();
                        stack.push(Math.cos(a));
                        break;
                      case "cvi":
                        a = stack.pop() | 0;
                        stack.push(a);
                        break;
                      case "cvr":
                        break;
                      case "div":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a / b);
                        break;
                      case "dup":
                        stack.copy(1);
                        break;
                      case "eq":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a === b);
                        break;
                      case "exch":
                        stack.roll(2, 1);
                        break;
                      case "exp":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(Math.pow(a, b));
                        break;
                      case "false":
                        stack.push(false);
                        break;
                      case "floor":
                        a = stack.pop();
                        stack.push(Math.floor(a));
                        break;
                      case "ge":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a >= b);
                        break;
                      case "gt":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a > b);
                        break;
                      case "idiv":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a / b | 0);
                        break;
                      case "index":
                        a = stack.pop();
                        stack.index(a);
                        break;
                      case "le":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a <= b);
                        break;
                      case "ln":
                        a = stack.pop();
                        stack.push(Math.log(a));
                        break;
                      case "log":
                        a = stack.pop();
                        stack.push(Math.log(a) / Math.LN10);
                        break;
                      case "lt":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a < b);
                        break;
                      case "mod":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a % b);
                        break;
                      case "mul":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a * b);
                        break;
                      case "ne":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a !== b);
                        break;
                      case "neg":
                        a = stack.pop();
                        stack.push(-a);
                        break;
                      case "not":
                        a = stack.pop();
                        if ((0, _util.isBool)(a)) {
                          stack.push(!a);
                        } else {
                          stack.push(~a);
                        }
                        break;
                      case "or":
                        b = stack.pop();
                        a = stack.pop();
                        if ((0, _util.isBool)(a) && (0, _util.isBool)(b)) {
                          stack.push(a || b);
                        } else {
                          stack.push(a | b);
                        }
                        break;
                      case "pop":
                        stack.pop();
                        break;
                      case "roll":
                        b = stack.pop();
                        a = stack.pop();
                        stack.roll(a, b);
                        break;
                      case "round":
                        a = stack.pop();
                        stack.push(Math.round(a));
                        break;
                      case "sin":
                        a = stack.pop();
                        stack.push(Math.sin(a));
                        break;
                      case "sqrt":
                        a = stack.pop();
                        stack.push(Math.sqrt(a));
                        break;
                      case "sub":
                        b = stack.pop();
                        a = stack.pop();
                        stack.push(a - b);
                        break;
                      case "true":
                        stack.push(true);
                        break;
                      case "truncate":
                        a = stack.pop();
                        a = a < 0 ? Math.ceil(a) : Math.floor(a);
                        stack.push(a);
                        break;
                      case "xor":
                        b = stack.pop();
                        a = stack.pop();
                        if ((0, _util.isBool)(a) && (0, _util.isBool)(b)) {
                          stack.push(a !== b);
                        } else {
                          stack.push(a ^ b);
                        }
                        break;
                      default:
                        throw new _util.FormatError("Unknown operator " + operator);
                    }
                  }
                  return stack.stack;
                }
              };
              return PostScriptEvaluator2;
            }();
            var PostScriptCompiler = function PostScriptCompilerClosure() {
              function AstNode(type) {
                this.type = type;
              }
              AstNode.prototype.visit = function(visitor) {
                (0, _util.unreachable)("abstract method");
              };
              function AstArgument(index, min, max) {
                AstNode.call(this, "args");
                this.index = index;
                this.min = min;
                this.max = max;
              }
              AstArgument.prototype = Object.create(AstNode.prototype);
              AstArgument.prototype.visit = function(visitor) {
                visitor.visitArgument(this);
              };
              function AstLiteral(number) {
                AstNode.call(this, "literal");
                this.number = number;
                this.min = number;
                this.max = number;
              }
              AstLiteral.prototype = Object.create(AstNode.prototype);
              AstLiteral.prototype.visit = function(visitor) {
                visitor.visitLiteral(this);
              };
              function AstBinaryOperation(op, arg1, arg2, min, max) {
                AstNode.call(this, "binary");
                this.op = op;
                this.arg1 = arg1;
                this.arg2 = arg2;
                this.min = min;
                this.max = max;
              }
              AstBinaryOperation.prototype = Object.create(AstNode.prototype);
              AstBinaryOperation.prototype.visit = function(visitor) {
                visitor.visitBinaryOperation(this);
              };
              function AstMin(arg, max) {
                AstNode.call(this, "max");
                this.arg = arg;
                this.min = arg.min;
                this.max = max;
              }
              AstMin.prototype = Object.create(AstNode.prototype);
              AstMin.prototype.visit = function(visitor) {
                visitor.visitMin(this);
              };
              function AstVariable(index, min, max) {
                AstNode.call(this, "var");
                this.index = index;
                this.min = min;
                this.max = max;
              }
              AstVariable.prototype = Object.create(AstNode.prototype);
              AstVariable.prototype.visit = function(visitor) {
                visitor.visitVariable(this);
              };
              function AstVariableDefinition(variable, arg) {
                AstNode.call(this, "definition");
                this.variable = variable;
                this.arg = arg;
              }
              AstVariableDefinition.prototype = Object.create(AstNode.prototype);
              AstVariableDefinition.prototype.visit = function(visitor) {
                visitor.visitVariableDefinition(this);
              };
              function ExpressionBuilderVisitor() {
                this.parts = [];
              }
              ExpressionBuilderVisitor.prototype = {
                visitArgument: function visitArgument(arg) {
                  this.parts.push("Math.max(", arg.min, ", Math.min(", arg.max, ", src[srcOffset + ", arg.index, "]))");
                },
                visitVariable: function visitVariable(variable) {
                  this.parts.push("v", variable.index);
                },
                visitLiteral: function visitLiteral(literal) {
                  this.parts.push(literal.number);
                },
                visitBinaryOperation: function visitBinaryOperation(operation) {
                  this.parts.push("(");
                  operation.arg1.visit(this);
                  this.parts.push(" ", operation.op, " ");
                  operation.arg2.visit(this);
                  this.parts.push(")");
                },
                visitVariableDefinition: function visitVariableDefinition(definition) {
                  this.parts.push("var ");
                  definition.variable.visit(this);
                  this.parts.push(" = ");
                  definition.arg.visit(this);
                  this.parts.push(";");
                },
                visitMin: function visitMin(max) {
                  this.parts.push("Math.min(");
                  max.arg.visit(this);
                  this.parts.push(", ", max.max, ")");
                },
                toString: function toString() {
                  return this.parts.join("");
                }
              };
              function buildAddOperation(num1, num2) {
                if (num2.type === "literal" && num2.number === 0) {
                  return num1;
                }
                if (num1.type === "literal" && num1.number === 0) {
                  return num2;
                }
                if (num2.type === "literal" && num1.type === "literal") {
                  return new AstLiteral(num1.number + num2.number);
                }
                return new AstBinaryOperation("+", num1, num2, num1.min + num2.min, num1.max + num2.max);
              }
              function buildMulOperation(num1, num2) {
                if (num2.type === "literal") {
                  if (num2.number === 0) {
                    return new AstLiteral(0);
                  } else if (num2.number === 1) {
                    return num1;
                  } else if (num1.type === "literal") {
                    return new AstLiteral(num1.number * num2.number);
                  }
                }
                if (num1.type === "literal") {
                  if (num1.number === 0) {
                    return new AstLiteral(0);
                  } else if (num1.number === 1) {
                    return num2;
                  }
                }
                var min = Math.min(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
                var max = Math.max(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
                return new AstBinaryOperation("*", num1, num2, min, max);
              }
              function buildSubOperation(num1, num2) {
                if (num2.type === "literal") {
                  if (num2.number === 0) {
                    return num1;
                  } else if (num1.type === "literal") {
                    return new AstLiteral(num1.number - num2.number);
                  }
                }
                if (num2.type === "binary" && num2.op === "-" && num1.type === "literal" && num1.number === 1 && num2.arg1.type === "literal" && num2.arg1.number === 1) {
                  return num2.arg2;
                }
                return new AstBinaryOperation("-", num1, num2, num1.min - num2.max, num1.max - num2.min);
              }
              function buildMinOperation(num1, max) {
                if (num1.min >= max) {
                  return new AstLiteral(max);
                } else if (num1.max <= max) {
                  return num1;
                }
                return new AstMin(num1, max);
              }
              function PostScriptCompiler2() {
              }
              PostScriptCompiler2.prototype = {
                compile: function PostScriptCompiler_compile(code, domain, range) {
                  var stack = [];
                  var i, ii;
                  var instructions = [];
                  var inputSize = domain.length >> 1, outputSize = range.length >> 1;
                  var lastRegister = 0;
                  var n, j;
                  var num1, num2, ast1, ast2, tmpVar, item;
                  for (i = 0; i < inputSize; i++) {
                    stack.push(new AstArgument(i, domain[i * 2], domain[i * 2 + 1]));
                  }
                  for (i = 0, ii = code.length; i < ii; i++) {
                    item = code[i];
                    if (typeof item === "number") {
                      stack.push(new AstLiteral(item));
                      continue;
                    }
                    switch (item) {
                      case "add":
                        if (stack.length < 2) {
                          return null;
                        }
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(buildAddOperation(num1, num2));
                        break;
                      case "cvr":
                        if (stack.length < 1) {
                          return null;
                        }
                        break;
                      case "mul":
                        if (stack.length < 2) {
                          return null;
                        }
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(buildMulOperation(num1, num2));
                        break;
                      case "sub":
                        if (stack.length < 2) {
                          return null;
                        }
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(buildSubOperation(num1, num2));
                        break;
                      case "exch":
                        if (stack.length < 2) {
                          return null;
                        }
                        ast1 = stack.pop();
                        ast2 = stack.pop();
                        stack.push(ast1, ast2);
                        break;
                      case "pop":
                        if (stack.length < 1) {
                          return null;
                        }
                        stack.pop();
                        break;
                      case "index":
                        if (stack.length < 1) {
                          return null;
                        }
                        num1 = stack.pop();
                        if (num1.type !== "literal") {
                          return null;
                        }
                        n = num1.number;
                        if (n < 0 || !Number.isInteger(n) || stack.length < n) {
                          return null;
                        }
                        ast1 = stack[stack.length - n - 1];
                        if (ast1.type === "literal" || ast1.type === "var") {
                          stack.push(ast1);
                          break;
                        }
                        tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
                        stack[stack.length - n - 1] = tmpVar;
                        stack.push(tmpVar);
                        instructions.push(new AstVariableDefinition(tmpVar, ast1));
                        break;
                      case "dup":
                        if (stack.length < 1) {
                          return null;
                        }
                        if (typeof code[i + 1] === "number" && code[i + 2] === "gt" && code[i + 3] === i + 7 && code[i + 4] === "jz" && code[i + 5] === "pop" && code[i + 6] === code[i + 1]) {
                          num1 = stack.pop();
                          stack.push(buildMinOperation(num1, code[i + 1]));
                          i += 6;
                          break;
                        }
                        ast1 = stack[stack.length - 1];
                        if (ast1.type === "literal" || ast1.type === "var") {
                          stack.push(ast1);
                          break;
                        }
                        tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
                        stack[stack.length - 1] = tmpVar;
                        stack.push(tmpVar);
                        instructions.push(new AstVariableDefinition(tmpVar, ast1));
                        break;
                      case "roll":
                        if (stack.length < 2) {
                          return null;
                        }
                        num2 = stack.pop();
                        num1 = stack.pop();
                        if (num2.type !== "literal" || num1.type !== "literal") {
                          return null;
                        }
                        j = num2.number;
                        n = num1.number;
                        if (n <= 0 || !Number.isInteger(n) || !Number.isInteger(j) || stack.length < n) {
                          return null;
                        }
                        j = (j % n + n) % n;
                        if (j === 0) {
                          break;
                        }
                        Array.prototype.push.apply(stack, stack.splice(stack.length - n, n - j));
                        break;
                      default:
                        return null;
                    }
                  }
                  if (stack.length !== outputSize) {
                    return null;
                  }
                  var result = [];
                  instructions.forEach(function(instruction) {
                    var statementBuilder = new ExpressionBuilderVisitor();
                    instruction.visit(statementBuilder);
                    result.push(statementBuilder.toString());
                  });
                  stack.forEach(function(expr, i2) {
                    var statementBuilder = new ExpressionBuilderVisitor();
                    expr.visit(statementBuilder);
                    var min = range[i2 * 2], max = range[i2 * 2 + 1];
                    var out = [statementBuilder.toString()];
                    if (min > expr.min) {
                      out.unshift("Math.max(", min, ", ");
                      out.push(")");
                    }
                    if (max < expr.max) {
                      out.unshift("Math.min(", max, ", ");
                      out.push(")");
                    }
                    out.unshift("dest[destOffset + ", i2, "] = ");
                    out.push(";");
                    result.push(out.join(""));
                  });
                  return result.join("\n");
                }
              };
              return PostScriptCompiler2;
            }();
            exports3.isPDFFunction = isPDFFunction;
            exports3.PDFFunctionFactory = PDFFunctionFactory;
            exports3.PostScriptEvaluator = PostScriptEvaluator;
            exports3.PostScriptCompiler = PostScriptCompiler;
          },
          /* 150 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.PostScriptParser = exports3.PostScriptLexer = void 0;
            var _util = __w_pdfjs_require__(2);
            var _primitives = __w_pdfjs_require__(119);
            var PostScriptParser = function PostScriptParserClosure() {
              function PostScriptParser2(lexer) {
                this.lexer = lexer;
                this.operators = [];
                this.token = null;
                this.prev = null;
              }
              PostScriptParser2.prototype = {
                nextToken: function PostScriptParser_nextToken() {
                  this.prev = this.token;
                  this.token = this.lexer.getToken();
                },
                accept: function PostScriptParser_accept(type) {
                  if (this.token.type === type) {
                    this.nextToken();
                    return true;
                  }
                  return false;
                },
                expect: function PostScriptParser_expect(type) {
                  if (this.accept(type)) {
                    return true;
                  }
                  throw new _util.FormatError("Unexpected symbol: found " + this.token.type + " expected " + type + ".");
                },
                parse: function PostScriptParser_parse() {
                  this.nextToken();
                  this.expect(PostScriptTokenTypes.LBRACE);
                  this.parseBlock();
                  this.expect(PostScriptTokenTypes.RBRACE);
                  return this.operators;
                },
                parseBlock: function PostScriptParser_parseBlock() {
                  while (true) {
                    if (this.accept(PostScriptTokenTypes.NUMBER)) {
                      this.operators.push(this.prev.value);
                    } else if (this.accept(PostScriptTokenTypes.OPERATOR)) {
                      this.operators.push(this.prev.value);
                    } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
                      this.parseCondition();
                    } else {
                      return;
                    }
                  }
                },
                parseCondition: function PostScriptParser_parseCondition() {
                  var conditionLocation = this.operators.length;
                  this.operators.push(null, null);
                  this.parseBlock();
                  this.expect(PostScriptTokenTypes.RBRACE);
                  if (this.accept(PostScriptTokenTypes.IF)) {
                    this.operators[conditionLocation] = this.operators.length;
                    this.operators[conditionLocation + 1] = "jz";
                  } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
                    var jumpLocation = this.operators.length;
                    this.operators.push(null, null);
                    var endOfTrue = this.operators.length;
                    this.parseBlock();
                    this.expect(PostScriptTokenTypes.RBRACE);
                    this.expect(PostScriptTokenTypes.IFELSE);
                    this.operators[jumpLocation] = this.operators.length;
                    this.operators[jumpLocation + 1] = "j";
                    this.operators[conditionLocation] = endOfTrue;
                    this.operators[conditionLocation + 1] = "jz";
                  } else {
                    throw new _util.FormatError("PS Function: error parsing conditional.");
                  }
                }
              };
              return PostScriptParser2;
            }();
            var PostScriptTokenTypes = {
              LBRACE: 0,
              RBRACE: 1,
              NUMBER: 2,
              OPERATOR: 3,
              IF: 4,
              IFELSE: 5
            };
            var PostScriptToken = function PostScriptTokenClosure() {
              function PostScriptToken2(type, value) {
                this.type = type;
                this.value = value;
              }
              var opCache = /* @__PURE__ */ Object.create(null);
              PostScriptToken2.getOperator = function PostScriptToken_getOperator(op) {
                var opValue = opCache[op];
                if (opValue) {
                  return opValue;
                }
                return opCache[op] = new PostScriptToken2(PostScriptTokenTypes.OPERATOR, op);
              };
              PostScriptToken2.LBRACE = new PostScriptToken2(PostScriptTokenTypes.LBRACE, "{");
              PostScriptToken2.RBRACE = new PostScriptToken2(PostScriptTokenTypes.RBRACE, "}");
              PostScriptToken2.IF = new PostScriptToken2(PostScriptTokenTypes.IF, "IF");
              PostScriptToken2.IFELSE = new PostScriptToken2(PostScriptTokenTypes.IFELSE, "IFELSE");
              return PostScriptToken2;
            }();
            var PostScriptLexer = function PostScriptLexerClosure() {
              function PostScriptLexer2(stream2) {
                this.stream = stream2;
                this.nextChar();
                this.strBuf = [];
              }
              PostScriptLexer2.prototype = {
                nextChar: function PostScriptLexer_nextChar() {
                  return this.currentChar = this.stream.getByte();
                },
                getToken: function PostScriptLexer_getToken() {
                  var comment = false;
                  var ch = this.currentChar;
                  while (true) {
                    if (ch < 0) {
                      return _primitives.EOF;
                    }
                    if (comment) {
                      if (ch === 10 || ch === 13) {
                        comment = false;
                      }
                    } else if (ch === 37) {
                      comment = true;
                    } else if (!(0, _util.isSpace)(ch)) {
                      break;
                    }
                    ch = this.nextChar();
                  }
                  switch (ch | 0) {
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                    case 43:
                    case 45:
                    case 46:
                      return new PostScriptToken(PostScriptTokenTypes.NUMBER, this.getNumber());
                    case 123:
                      this.nextChar();
                      return PostScriptToken.LBRACE;
                    case 125:
                      this.nextChar();
                      return PostScriptToken.RBRACE;
                  }
                  var strBuf = this.strBuf;
                  strBuf.length = 0;
                  strBuf[0] = String.fromCharCode(ch);
                  while ((ch = this.nextChar()) >= 0 && (ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122)) {
                    strBuf.push(String.fromCharCode(ch));
                  }
                  var str = strBuf.join("");
                  switch (str.toLowerCase()) {
                    case "if":
                      return PostScriptToken.IF;
                    case "ifelse":
                      return PostScriptToken.IFELSE;
                    default:
                      return PostScriptToken.getOperator(str);
                  }
                },
                getNumber: function PostScriptLexer_getNumber() {
                  var ch = this.currentChar;
                  var strBuf = this.strBuf;
                  strBuf.length = 0;
                  strBuf[0] = String.fromCharCode(ch);
                  while ((ch = this.nextChar()) >= 0) {
                    if (ch >= 48 && ch <= 57 || ch === 45 || ch === 46) {
                      strBuf.push(String.fromCharCode(ch));
                    } else {
                      break;
                    }
                  }
                  var value = parseFloat(strBuf.join(""));
                  if (isNaN(value)) {
                    throw new _util.FormatError("Invalid floating point number: " + value);
                  }
                  return value;
                }
              };
              return PostScriptLexer2;
            }();
            exports3.PostScriptLexer = PostScriptLexer;
            exports3.PostScriptParser = PostScriptParser;
          },
          /* 151 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.MurmurHash3_64 = void 0;
            var _util = __w_pdfjs_require__(2);
            var MurmurHash3_64 = function MurmurHash3_64Closure(seed) {
              var MASK_HIGH = 4294901760;
              var MASK_LOW = 65535;
              function MurmurHash3_642(seed2) {
                var SEED = 3285377520;
                this.h1 = seed2 ? seed2 & 4294967295 : SEED;
                this.h2 = seed2 ? seed2 & 4294967295 : SEED;
              }
              MurmurHash3_642.prototype = {
                update: function MurmurHash3_64_update(input) {
                  var data = void 0, length = void 0;
                  if ((0, _util.isString)(input)) {
                    data = new Uint8Array(input.length * 2);
                    length = 0;
                    for (var i = 0, ii = input.length; i < ii; i++) {
                      var code = input.charCodeAt(i);
                      if (code <= 255) {
                        data[length++] = code;
                      } else {
                        data[length++] = code >>> 8;
                        data[length++] = code & 255;
                      }
                    }
                  } else if ((0, _util.isArrayBuffer)(input)) {
                    data = input;
                    length = data.byteLength;
                  } else {
                    throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
                  }
                  var blockCounts = length >> 2;
                  var tailLength = length - blockCounts * 4;
                  var dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
                  var k1 = 0;
                  var k2 = 0;
                  var h1 = this.h1;
                  var h2 = this.h2;
                  var C1 = 3432918353;
                  var C2 = 461845907;
                  var C1_LOW = C1 & MASK_LOW;
                  var C2_LOW = C2 & MASK_LOW;
                  for (var _i = 0; _i < blockCounts; _i++) {
                    if (_i & 1) {
                      k1 = dataUint32[_i];
                      k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                      k1 = k1 << 15 | k1 >>> 17;
                      k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                      h1 ^= k1;
                      h1 = h1 << 13 | h1 >>> 19;
                      h1 = h1 * 5 + 3864292196;
                    } else {
                      k2 = dataUint32[_i];
                      k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
                      k2 = k2 << 15 | k2 >>> 17;
                      k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
                      h2 ^= k2;
                      h2 = h2 << 13 | h2 >>> 19;
                      h2 = h2 * 5 + 3864292196;
                    }
                  }
                  k1 = 0;
                  switch (tailLength) {
                    case 3:
                      k1 ^= data[blockCounts * 4 + 2] << 16;
                    case 2:
                      k1 ^= data[blockCounts * 4 + 1] << 8;
                    case 1:
                      k1 ^= data[blockCounts * 4];
                      k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                      k1 = k1 << 15 | k1 >>> 17;
                      k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                      if (blockCounts & 1) {
                        h1 ^= k1;
                      } else {
                        h2 ^= k1;
                      }
                  }
                  this.h1 = h1;
                  this.h2 = h2;
                  return this;
                },
                hexdigest: function MurmurHash3_64_hexdigest() {
                  var h1 = this.h1;
                  var h2 = this.h2;
                  h1 ^= h2 >>> 1;
                  h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
                  h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
                  h1 ^= h2 >>> 1;
                  h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
                  h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
                  h1 ^= h2 >>> 1;
                  for (var i = 0, arr = [h1, h2], str = ""; i < arr.length; i++) {
                    var hex = (arr[i] >>> 0).toString(16);
                    while (hex.length < 8) {
                      hex = "0" + hex;
                    }
                    str += hex;
                  }
                  return str;
                }
              };
              return MurmurHash3_642;
            }();
            exports3.MurmurHash3_64 = MurmurHash3_64;
          },
          /* 152 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.PDFImage = void 0;
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _util = __w_pdfjs_require__(2);
            var _primitives = __w_pdfjs_require__(119);
            var _colorspace = __w_pdfjs_require__(132);
            var _stream = __w_pdfjs_require__(121);
            var _jpeg_stream = __w_pdfjs_require__(127);
            var _jpx = __w_pdfjs_require__(130);
            var PDFImage = function PDFImageClosure() {
              function handleImageData(image, nativeDecoder) {
                if (nativeDecoder && nativeDecoder.canDecode(image)) {
                  return nativeDecoder.decode(image).catch(function(reason) {
                    (0, _util.warn)("Native image decoding failed -- trying to recover: " + (reason && reason.message));
                    return image;
                  });
                }
                return Promise.resolve(image);
              }
              function decodeAndClamp(value, addend, coefficient, max) {
                value = addend + value * coefficient;
                return value < 0 ? 0 : value > max ? max : value;
              }
              function resizeImageMask(src, bpc, w1, h1, w2, h2) {
                var length = w2 * h2;
                var dest = bpc <= 8 ? new Uint8Array(length) : bpc <= 16 ? new Uint16Array(length) : new Uint32Array(length);
                var xRatio = w1 / w2;
                var yRatio = h1 / h2;
                var i, j, py, newIndex = 0, oldIndex;
                var xScaled = new Uint16Array(w2);
                var w1Scanline = w1;
                for (i = 0; i < w2; i++) {
                  xScaled[i] = Math.floor(i * xRatio);
                }
                for (i = 0; i < h2; i++) {
                  py = Math.floor(i * yRatio) * w1Scanline;
                  for (j = 0; j < w2; j++) {
                    oldIndex = py + xScaled[j];
                    dest[newIndex++] = src[oldIndex];
                  }
                }
                return dest;
              }
              function PDFImage2(_ref) {
                var xref = _ref.xref, res = _ref.res, image = _ref.image, _ref$isInline = _ref.isInline, isInline = _ref$isInline === void 0 ? false : _ref$isInline, _ref$smask = _ref.smask, smask = _ref$smask === void 0 ? null : _ref$smask, _ref$mask = _ref.mask, mask = _ref$mask === void 0 ? null : _ref$mask, _ref$isMask = _ref.isMask, isMask = _ref$isMask === void 0 ? false : _ref$isMask, pdfFunctionFactory = _ref.pdfFunctionFactory;
                this.image = image;
                var dict = image.dict;
                if (dict.has("Filter")) {
                  var filter = dict.get("Filter").name;
                  if (filter === "JPXDecode") {
                    var jpxImage = new _jpx.JpxImage();
                    jpxImage.parseImageProperties(image.stream);
                    image.stream.reset();
                    image.bitsPerComponent = jpxImage.bitsPerComponent;
                    image.numComps = jpxImage.componentsCount;
                  } else if (filter === "JBIG2Decode") {
                    image.bitsPerComponent = 1;
                    image.numComps = 1;
                  }
                }
                this.width = dict.get("Width", "W");
                this.height = dict.get("Height", "H");
                if (this.width < 1 || this.height < 1) {
                  throw new _util.FormatError("Invalid image width: " + this.width + " or " + ("height: " + this.height));
                }
                this.interpolate = dict.get("Interpolate", "I") || false;
                this.imageMask = dict.get("ImageMask", "IM") || false;
                this.matte = dict.get("Matte") || false;
                var bitsPerComponent = image.bitsPerComponent;
                if (!bitsPerComponent) {
                  bitsPerComponent = dict.get("BitsPerComponent", "BPC");
                  if (!bitsPerComponent) {
                    if (this.imageMask) {
                      bitsPerComponent = 1;
                    } else {
                      throw new _util.FormatError("Bits per component missing in image: " + this.imageMask);
                    }
                  }
                }
                this.bpc = bitsPerComponent;
                if (!this.imageMask) {
                  var colorSpace = dict.get("ColorSpace", "CS");
                  if (!colorSpace) {
                    (0, _util.info)("JPX images (which do not require color spaces)");
                    switch (image.numComps) {
                      case 1:
                        colorSpace = _primitives.Name.get("DeviceGray");
                        break;
                      case 3:
                        colorSpace = _primitives.Name.get("DeviceRGB");
                        break;
                      case 4:
                        colorSpace = _primitives.Name.get("DeviceCMYK");
                        break;
                      default:
                        throw new Error("JPX images with " + this.numComps + " color components not supported.");
                    }
                  }
                  var resources = isInline ? res : null;
                  this.colorSpace = _colorspace.ColorSpace.parse(colorSpace, xref, resources, pdfFunctionFactory);
                  this.numComps = this.colorSpace.numComps;
                }
                this.decode = dict.getArray("Decode", "D");
                this.needsDecode = false;
                if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode) || isMask && !_colorspace.ColorSpace.isDefaultDecode(this.decode, 1))) {
                  this.needsDecode = true;
                  var max = (1 << bitsPerComponent) - 1;
                  this.decodeCoefficients = [];
                  this.decodeAddends = [];
                  for (var i = 0, j = 0; i < this.decode.length; i += 2, ++j) {
                    var dmin = this.decode[i];
                    var dmax = this.decode[i + 1];
                    this.decodeCoefficients[j] = dmax - dmin;
                    this.decodeAddends[j] = max * dmin;
                  }
                }
                if (smask) {
                  this.smask = new PDFImage2({
                    xref,
                    res,
                    image: smask,
                    isInline,
                    pdfFunctionFactory
                  });
                } else if (mask) {
                  if ((0, _primitives.isStream)(mask)) {
                    var maskDict = mask.dict, imageMask = maskDict.get("ImageMask", "IM");
                    if (!imageMask) {
                      (0, _util.warn)("Ignoring /Mask in image without /ImageMask.");
                    } else {
                      this.mask = new PDFImage2({
                        xref,
                        res,
                        image: mask,
                        isInline,
                        isMask: true,
                        pdfFunctionFactory
                      });
                    }
                  } else {
                    this.mask = mask;
                  }
                }
              }
              PDFImage2.buildImage = function(_ref2) {
                var handler = _ref2.handler, xref = _ref2.xref, res = _ref2.res, image = _ref2.image, _ref2$isInline = _ref2.isInline, isInline = _ref2$isInline === void 0 ? false : _ref2$isInline, _ref2$nativeDecoder = _ref2.nativeDecoder, nativeDecoder = _ref2$nativeDecoder === void 0 ? null : _ref2$nativeDecoder, pdfFunctionFactory = _ref2.pdfFunctionFactory;
                var imagePromise = handleImageData(image, nativeDecoder);
                var smaskPromise;
                var maskPromise;
                var smask = image.dict.get("SMask");
                var mask = image.dict.get("Mask");
                if (smask) {
                  smaskPromise = handleImageData(smask, nativeDecoder);
                  maskPromise = Promise.resolve(null);
                } else {
                  smaskPromise = Promise.resolve(null);
                  if (mask) {
                    if ((0, _primitives.isStream)(mask)) {
                      maskPromise = handleImageData(mask, nativeDecoder);
                    } else if (Array.isArray(mask)) {
                      maskPromise = Promise.resolve(mask);
                    } else {
                      (0, _util.warn)("Unsupported mask format.");
                      maskPromise = Promise.resolve(null);
                    }
                  } else {
                    maskPromise = Promise.resolve(null);
                  }
                }
                return Promise.all([imagePromise, smaskPromise, maskPromise]).then(function(_ref3) {
                  var _ref4 = _slicedToArray(_ref3, 3), imageData = _ref4[0], smaskData = _ref4[1], maskData = _ref4[2];
                  return new PDFImage2({
                    xref,
                    res,
                    image: imageData,
                    isInline,
                    smask: smaskData,
                    mask: maskData,
                    pdfFunctionFactory
                  });
                });
              };
              PDFImage2.createMask = function(_ref5) {
                var imgArray = _ref5.imgArray, width = _ref5.width, height = _ref5.height, imageIsFromDecodeStream = _ref5.imageIsFromDecodeStream, inverseDecode = _ref5.inverseDecode;
                var computedLength = (width + 7 >> 3) * height;
                var actualLength = imgArray.byteLength;
                var haveFullData = computedLength === actualLength;
                var data, i;
                if (imageIsFromDecodeStream && (!inverseDecode || haveFullData)) {
                  data = imgArray;
                } else if (!inverseDecode) {
                  data = new Uint8Array(actualLength);
                  data.set(imgArray);
                } else {
                  data = new Uint8Array(computedLength);
                  data.set(imgArray);
                  for (i = actualLength; i < computedLength; i++) {
                    data[i] = 255;
                  }
                }
                if (inverseDecode) {
                  for (i = 0; i < actualLength; i++) {
                    data[i] ^= 255;
                  }
                }
                return {
                  data,
                  width,
                  height
                };
              };
              PDFImage2.prototype = {
                get drawWidth() {
                  return Math.max(this.width, this.smask && this.smask.width || 0, this.mask && this.mask.width || 0);
                },
                get drawHeight() {
                  return Math.max(this.height, this.smask && this.smask.height || 0, this.mask && this.mask.height || 0);
                },
                decodeBuffer: function decodeBuffer(buffer) {
                  var bpc = this.bpc;
                  var numComps = this.numComps;
                  var decodeAddends = this.decodeAddends;
                  var decodeCoefficients = this.decodeCoefficients;
                  var max = (1 << bpc) - 1;
                  var i, ii;
                  if (bpc === 1) {
                    for (i = 0, ii = buffer.length; i < ii; i++) {
                      buffer[i] = +!buffer[i];
                    }
                    return;
                  }
                  var index = 0;
                  for (i = 0, ii = this.width * this.height; i < ii; i++) {
                    for (var j = 0; j < numComps; j++) {
                      buffer[index] = decodeAndClamp(buffer[index], decodeAddends[j], decodeCoefficients[j], max);
                      index++;
                    }
                  }
                },
                getComponents: function getComponents(buffer) {
                  var bpc = this.bpc;
                  if (bpc === 8) {
                    return buffer;
                  }
                  var width = this.width;
                  var height = this.height;
                  var numComps = this.numComps;
                  var length = width * height * numComps;
                  var bufferPos = 0;
                  var output = bpc <= 8 ? new Uint8Array(length) : bpc <= 16 ? new Uint16Array(length) : new Uint32Array(length);
                  var rowComps = width * numComps;
                  var max = (1 << bpc) - 1;
                  var i = 0, ii, buf;
                  if (bpc === 1) {
                    var mask, loop1End, loop2End;
                    for (var j = 0; j < height; j++) {
                      loop1End = i + (rowComps & ~7);
                      loop2End = i + rowComps;
                      while (i < loop1End) {
                        buf = buffer[bufferPos++];
                        output[i] = buf >> 7 & 1;
                        output[i + 1] = buf >> 6 & 1;
                        output[i + 2] = buf >> 5 & 1;
                        output[i + 3] = buf >> 4 & 1;
                        output[i + 4] = buf >> 3 & 1;
                        output[i + 5] = buf >> 2 & 1;
                        output[i + 6] = buf >> 1 & 1;
                        output[i + 7] = buf & 1;
                        i += 8;
                      }
                      if (i < loop2End) {
                        buf = buffer[bufferPos++];
                        mask = 128;
                        while (i < loop2End) {
                          output[i++] = +!!(buf & mask);
                          mask >>= 1;
                        }
                      }
                    }
                  } else {
                    var bits = 0;
                    buf = 0;
                    for (i = 0, ii = length; i < ii; ++i) {
                      if (i % rowComps === 0) {
                        buf = 0;
                        bits = 0;
                      }
                      while (bits < bpc) {
                        buf = buf << 8 | buffer[bufferPos++];
                        bits += 8;
                      }
                      var remainingBits = bits - bpc;
                      var value = buf >> remainingBits;
                      output[i] = value < 0 ? 0 : value > max ? max : value;
                      buf = buf & (1 << remainingBits) - 1;
                      bits = remainingBits;
                    }
                  }
                  return output;
                },
                fillOpacity: function fillOpacity(rgbaBuf, width, height, actualHeight, image) {
                  var smask = this.smask;
                  var mask = this.mask;
                  var alphaBuf, sw, sh, i, ii, j;
                  if (smask) {
                    sw = smask.width;
                    sh = smask.height;
                    alphaBuf = new Uint8Array(sw * sh);
                    smask.fillGrayBuffer(alphaBuf);
                    if (sw !== width || sh !== height) {
                      alphaBuf = resizeImageMask(alphaBuf, smask.bpc, sw, sh, width, height);
                    }
                  } else if (mask) {
                    if (mask instanceof PDFImage2) {
                      sw = mask.width;
                      sh = mask.height;
                      alphaBuf = new Uint8Array(sw * sh);
                      mask.numComps = 1;
                      mask.fillGrayBuffer(alphaBuf);
                      for (i = 0, ii = sw * sh; i < ii; ++i) {
                        alphaBuf[i] = 255 - alphaBuf[i];
                      }
                      if (sw !== width || sh !== height) {
                        alphaBuf = resizeImageMask(alphaBuf, mask.bpc, sw, sh, width, height);
                      }
                    } else if (Array.isArray(mask)) {
                      alphaBuf = new Uint8Array(width * height);
                      var numComps = this.numComps;
                      for (i = 0, ii = width * height; i < ii; ++i) {
                        var opacity = 0;
                        var imageOffset = i * numComps;
                        for (j = 0; j < numComps; ++j) {
                          var color = image[imageOffset + j];
                          var maskOffset = j * 2;
                          if (color < mask[maskOffset] || color > mask[maskOffset + 1]) {
                            opacity = 255;
                            break;
                          }
                        }
                        alphaBuf[i] = opacity;
                      }
                    } else {
                      throw new _util.FormatError("Unknown mask format.");
                    }
                  }
                  if (alphaBuf) {
                    for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
                      rgbaBuf[j] = alphaBuf[i];
                    }
                  } else {
                    for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
                      rgbaBuf[j] = 255;
                    }
                  }
                },
                undoPreblend: function undoPreblend(buffer, width, height) {
                  var matte = this.smask && this.smask.matte;
                  if (!matte) {
                    return;
                  }
                  var matteRgb = this.colorSpace.getRgb(matte, 0);
                  var matteR = matteRgb[0];
                  var matteG = matteRgb[1];
                  var matteB = matteRgb[2];
                  var length = width * height * 4;
                  var r, g, b;
                  for (var i = 0; i < length; i += 4) {
                    var alpha = buffer[i + 3];
                    if (alpha === 0) {
                      buffer[i] = 255;
                      buffer[i + 1] = 255;
                      buffer[i + 2] = 255;
                      continue;
                    }
                    var k = 255 / alpha;
                    r = (buffer[i] - matteR) * k + matteR;
                    g = (buffer[i + 1] - matteG) * k + matteG;
                    b = (buffer[i + 2] - matteB) * k + matteB;
                    buffer[i] = r <= 0 ? 0 : r >= 255 ? 255 : r | 0;
                    buffer[i + 1] = g <= 0 ? 0 : g >= 255 ? 255 : g | 0;
                    buffer[i + 2] = b <= 0 ? 0 : b >= 255 ? 255 : b | 0;
                  }
                },
                createImageData: function createImageData() {
                  var forceRGBA = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  var drawWidth = this.drawWidth;
                  var drawHeight = this.drawHeight;
                  var imgData = {
                    width: drawWidth,
                    height: drawHeight
                  };
                  var numComps = this.numComps;
                  var originalWidth = this.width;
                  var originalHeight = this.height;
                  var bpc = this.bpc;
                  var rowBytes = originalWidth * numComps * bpc + 7 >> 3;
                  var imgArray;
                  if (!forceRGBA) {
                    var kind;
                    if (this.colorSpace.name === "DeviceGray" && bpc === 1) {
                      kind = _util.ImageKind.GRAYSCALE_1BPP;
                    } else if (this.colorSpace.name === "DeviceRGB" && bpc === 8 && !this.needsDecode) {
                      kind = _util.ImageKind.RGB_24BPP;
                    }
                    if (kind && !this.smask && !this.mask && drawWidth === originalWidth && drawHeight === originalHeight) {
                      imgData.kind = kind;
                      imgArray = this.getImageBytes(originalHeight * rowBytes);
                      if (this.image instanceof _stream.DecodeStream) {
                        imgData.data = imgArray;
                      } else {
                        var newArray = new Uint8Array(imgArray.length);
                        newArray.set(imgArray);
                        imgData.data = newArray;
                      }
                      if (this.needsDecode) {
                        (0, _util.assert)(kind === _util.ImageKind.GRAYSCALE_1BPP);
                        var buffer = imgData.data;
                        for (var i = 0, ii = buffer.length; i < ii; i++) {
                          buffer[i] ^= 255;
                        }
                      }
                      return imgData;
                    }
                    if (this.image instanceof _jpeg_stream.JpegStream && !this.smask && !this.mask) {
                      var imageLength = originalHeight * rowBytes;
                      switch (this.colorSpace.name) {
                        case "DeviceGray":
                          imageLength *= 3;
                        case "DeviceRGB":
                        case "DeviceCMYK":
                          imgData.kind = _util.ImageKind.RGB_24BPP;
                          imgData.data = this.getImageBytes(imageLength, drawWidth, drawHeight, true);
                          return imgData;
                      }
                    }
                  }
                  imgArray = this.getImageBytes(originalHeight * rowBytes);
                  var actualHeight = 0 | imgArray.length / rowBytes * drawHeight / originalHeight;
                  var comps = this.getComponents(imgArray);
                  var alpha01, maybeUndoPreblend;
                  if (!forceRGBA && !this.smask && !this.mask) {
                    imgData.kind = _util.ImageKind.RGB_24BPP;
                    imgData.data = new Uint8Array(drawWidth * drawHeight * 3);
                    alpha01 = 0;
                    maybeUndoPreblend = false;
                  } else {
                    imgData.kind = _util.ImageKind.RGBA_32BPP;
                    imgData.data = new Uint8Array(drawWidth * drawHeight * 4);
                    alpha01 = 1;
                    maybeUndoPreblend = true;
                    this.fillOpacity(imgData.data, drawWidth, drawHeight, actualHeight, comps);
                  }
                  if (this.needsDecode) {
                    this.decodeBuffer(comps);
                  }
                  this.colorSpace.fillRgb(imgData.data, originalWidth, originalHeight, drawWidth, drawHeight, actualHeight, bpc, comps, alpha01);
                  if (maybeUndoPreblend) {
                    this.undoPreblend(imgData.data, drawWidth, actualHeight);
                  }
                  return imgData;
                },
                fillGrayBuffer: function fillGrayBuffer(buffer) {
                  var numComps = this.numComps;
                  if (numComps !== 1) {
                    throw new _util.FormatError("Reading gray scale from a color image: " + numComps);
                  }
                  var width = this.width;
                  var height = this.height;
                  var bpc = this.bpc;
                  var rowBytes = width * numComps * bpc + 7 >> 3;
                  var imgArray = this.getImageBytes(height * rowBytes);
                  var comps = this.getComponents(imgArray);
                  var i, length;
                  if (bpc === 1) {
                    length = width * height;
                    if (this.needsDecode) {
                      for (i = 0; i < length; ++i) {
                        buffer[i] = comps[i] - 1 & 255;
                      }
                    } else {
                      for (i = 0; i < length; ++i) {
                        buffer[i] = -comps[i] & 255;
                      }
                    }
                    return;
                  }
                  if (this.needsDecode) {
                    this.decodeBuffer(comps);
                  }
                  length = width * height;
                  var scale = 255 / ((1 << bpc) - 1);
                  for (i = 0; i < length; ++i) {
                    buffer[i] = scale * comps[i] | 0;
                  }
                },
                getImageBytes: function getImageBytes(length, drawWidth, drawHeight) {
                  var forceRGB = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                  this.image.reset();
                  this.image.drawWidth = drawWidth || this.width;
                  this.image.drawHeight = drawHeight || this.height;
                  this.image.forceRGB = !!forceRGB;
                  return this.image.getBytes(length);
                }
              };
              return PDFImage2;
            }();
            exports3.PDFImage = PDFImage;
          },
          /* 153 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.MessageHandler = void 0;
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var _util = __w_pdfjs_require__(2);
            function resolveCall(fn, args) {
              var thisArg = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              if (!fn) {
                return Promise.resolve(void 0);
              }
              return new Promise(function(resolve2, reject2) {
                resolve2(fn.apply(thisArg, args));
              });
            }
            function wrapReason(reason) {
              if ((typeof reason === "undefined" ? "undefined" : _typeof(reason)) !== "object") {
                return reason;
              }
              switch (reason.name) {
                case "AbortException":
                  return new _util.AbortException(reason.message);
                case "MissingPDFException":
                  return new _util.MissingPDFException(reason.message);
                case "UnexpectedResponseException":
                  return new _util.UnexpectedResponseException(reason.message, reason.status);
                default:
                  return new _util.UnknownErrorException(reason.message, reason.details);
              }
            }
            function makeReasonSerializable(reason) {
              if (!(reason instanceof Error) || reason instanceof _util.AbortException || reason instanceof _util.MissingPDFException || reason instanceof _util.UnexpectedResponseException || reason instanceof _util.UnknownErrorException) {
                return reason;
              }
              return new _util.UnknownErrorException(reason.message, reason.toString());
            }
            function resolveOrReject(capability, success, reason) {
              if (success) {
                capability.resolve();
              } else {
                capability.reject(reason);
              }
            }
            function finalize(promise) {
              return Promise.resolve(promise).catch(function() {
              });
            }
            function MessageHandler(sourceName, targetName, comObj) {
              var _this = this;
              this.sourceName = sourceName;
              this.targetName = targetName;
              this.comObj = comObj;
              this.callbackId = 1;
              this.streamId = 1;
              this.postMessageTransfers = true;
              this.streamSinks = /* @__PURE__ */ Object.create(null);
              this.streamControllers = /* @__PURE__ */ Object.create(null);
              var callbacksCapabilities = this.callbacksCapabilities = /* @__PURE__ */ Object.create(null);
              var ah = this.actionHandler = /* @__PURE__ */ Object.create(null);
              this._onComObjOnMessage = function(event) {
                var data = event.data;
                if (data.targetName !== _this.sourceName) {
                  return;
                }
                if (data.stream) {
                  _this._processStreamMessage(data);
                } else if (data.isReply) {
                  var callbackId = data.callbackId;
                  if (data.callbackId in callbacksCapabilities) {
                    var callback = callbacksCapabilities[callbackId];
                    delete callbacksCapabilities[callbackId];
                    if ("error" in data) {
                      callback.reject(wrapReason(data.error));
                    } else {
                      callback.resolve(data.data);
                    }
                  } else {
                    throw new Error("Cannot resolve callback " + callbackId);
                  }
                } else if (data.action in ah) {
                  var action = ah[data.action];
                  if (data.callbackId) {
                    var _sourceName = _this.sourceName;
                    var _targetName = data.sourceName;
                    Promise.resolve().then(function() {
                      return action[0].call(action[1], data.data);
                    }).then(function(result) {
                      comObj.postMessage({
                        sourceName: _sourceName,
                        targetName: _targetName,
                        isReply: true,
                        callbackId: data.callbackId,
                        data: result
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName: _sourceName,
                        targetName: _targetName,
                        isReply: true,
                        callbackId: data.callbackId,
                        error: makeReasonSerializable(reason)
                      });
                    });
                  } else if (data.streamId) {
                    _this._createStreamSink(data);
                  } else {
                    action[0].call(action[1], data.data);
                  }
                } else {
                  throw new Error("Unknown action from worker: " + data.action);
                }
              };
              comObj.addEventListener("message", this._onComObjOnMessage);
            }
            MessageHandler.prototype = {
              on: function on(actionName, handler, scope) {
                var ah = this.actionHandler;
                if (ah[actionName]) {
                  throw new Error('There is already an actionName called "' + actionName + '"');
                }
                ah[actionName] = [handler, scope];
              },
              send: function send(actionName, data, transfers) {
                var message = {
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: actionName,
                  data
                };
                this.postMessage(message, transfers);
              },
              sendWithPromise: function sendWithPromise(actionName, data, transfers) {
                var callbackId = this.callbackId++;
                var message = {
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: actionName,
                  data,
                  callbackId
                };
                var capability = (0, _util.createPromiseCapability)();
                this.callbacksCapabilities[callbackId] = capability;
                try {
                  this.postMessage(message, transfers);
                } catch (e) {
                  capability.reject(e);
                }
                return capability.promise;
              },
              sendWithStream: function sendWithStream(actionName, data, queueingStrategy, transfers) {
                var _this2 = this;
                var streamId = this.streamId++;
                var sourceName = this.sourceName;
                var targetName = this.targetName;
                return new _util.ReadableStream({
                  start: function start(controller) {
                    var startCapability = (0, _util.createPromiseCapability)();
                    _this2.streamControllers[streamId] = {
                      controller,
                      startCall: startCapability,
                      isClosed: false
                    };
                    _this2.postMessage({
                      sourceName,
                      targetName,
                      action: actionName,
                      streamId,
                      data,
                      desiredSize: controller.desiredSize
                    });
                    return startCapability.promise;
                  },
                  pull: function pull(controller) {
                    var pullCapability = (0, _util.createPromiseCapability)();
                    _this2.streamControllers[streamId].pullCall = pullCapability;
                    _this2.postMessage({
                      sourceName,
                      targetName,
                      stream: "pull",
                      streamId,
                      desiredSize: controller.desiredSize
                    });
                    return pullCapability.promise;
                  },
                  cancel: function cancel(reason) {
                    var cancelCapability = (0, _util.createPromiseCapability)();
                    _this2.streamControllers[streamId].cancelCall = cancelCapability;
                    _this2.streamControllers[streamId].isClosed = true;
                    _this2.postMessage({
                      sourceName,
                      targetName,
                      stream: "cancel",
                      reason,
                      streamId
                    });
                    return cancelCapability.promise;
                  }
                }, queueingStrategy);
              },
              _createStreamSink: function _createStreamSink(data) {
                var _this3 = this;
                var self2 = this;
                var action = this.actionHandler[data.action];
                var streamId = data.streamId;
                var desiredSize = data.desiredSize;
                var sourceName = this.sourceName;
                var targetName = data.sourceName;
                var capability = (0, _util.createPromiseCapability)();
                var sendStreamRequest = function sendStreamRequest2(_ref) {
                  var stream2 = _ref.stream, chunk = _ref.chunk, transfers = _ref.transfers, success = _ref.success, reason = _ref.reason;
                  _this3.postMessage({
                    sourceName,
                    targetName,
                    stream: stream2,
                    streamId,
                    chunk,
                    success,
                    reason
                  }, transfers);
                };
                var streamSink = {
                  enqueue: function enqueue(chunk) {
                    var size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
                    var transfers = arguments[2];
                    if (this.isCancelled) {
                      return;
                    }
                    var lastDesiredSize = this.desiredSize;
                    this.desiredSize -= size;
                    if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                      this.sinkCapability = (0, _util.createPromiseCapability)();
                      this.ready = this.sinkCapability.promise;
                    }
                    sendStreamRequest({
                      stream: "enqueue",
                      chunk,
                      transfers
                    });
                  },
                  close: function close() {
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    sendStreamRequest({ stream: "close" });
                    delete self2.streamSinks[streamId];
                  },
                  error: function error(reason) {
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    sendStreamRequest({
                      stream: "error",
                      reason
                    });
                  },
                  sinkCapability: capability,
                  onPull: null,
                  onCancel: null,
                  isCancelled: false,
                  desiredSize,
                  ready: null
                };
                streamSink.sinkCapability.resolve();
                streamSink.ready = streamSink.sinkCapability.promise;
                this.streamSinks[streamId] = streamSink;
                resolveCall(action[0], [data.data, streamSink], action[1]).then(function() {
                  sendStreamRequest({
                    stream: "start_complete",
                    success: true
                  });
                }, function(reason) {
                  sendStreamRequest({
                    stream: "start_complete",
                    success: false,
                    reason
                  });
                });
              },
              _processStreamMessage: function _processStreamMessage(data) {
                var _this4 = this;
                var sourceName = this.sourceName;
                var targetName = data.sourceName;
                var streamId = data.streamId;
                var sendStreamResponse = function sendStreamResponse2(_ref2) {
                  var stream2 = _ref2.stream, success = _ref2.success, reason = _ref2.reason;
                  _this4.comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: stream2,
                    success,
                    streamId,
                    reason
                  });
                };
                var deleteStreamController = function deleteStreamController2() {
                  Promise.all([_this4.streamControllers[data.streamId].startCall, _this4.streamControllers[data.streamId].pullCall, _this4.streamControllers[data.streamId].cancelCall].map(function(capability) {
                    return capability && finalize(capability.promise);
                  })).then(function() {
                    delete _this4.streamControllers[data.streamId];
                  });
                };
                switch (data.stream) {
                  case "start_complete":
                    resolveOrReject(this.streamControllers[data.streamId].startCall, data.success, wrapReason(data.reason));
                    break;
                  case "pull_complete":
                    resolveOrReject(this.streamControllers[data.streamId].pullCall, data.success, wrapReason(data.reason));
                    break;
                  case "pull":
                    if (!this.streamSinks[data.streamId]) {
                      sendStreamResponse({
                        stream: "pull_complete",
                        success: true
                      });
                      break;
                    }
                    if (this.streamSinks[data.streamId].desiredSize <= 0 && data.desiredSize > 0) {
                      this.streamSinks[data.streamId].sinkCapability.resolve();
                    }
                    this.streamSinks[data.streamId].desiredSize = data.desiredSize;
                    resolveCall(this.streamSinks[data.streamId].onPull).then(function() {
                      sendStreamResponse({
                        stream: "pull_complete",
                        success: true
                      });
                    }, function(reason) {
                      sendStreamResponse({
                        stream: "pull_complete",
                        success: false,
                        reason
                      });
                    });
                    break;
                  case "enqueue":
                    (0, _util.assert)(this.streamControllers[data.streamId], "enqueue should have stream controller");
                    if (!this.streamControllers[data.streamId].isClosed) {
                      this.streamControllers[data.streamId].controller.enqueue(data.chunk);
                    }
                    break;
                  case "close":
                    (0, _util.assert)(this.streamControllers[data.streamId], "close should have stream controller");
                    if (this.streamControllers[data.streamId].isClosed) {
                      break;
                    }
                    this.streamControllers[data.streamId].isClosed = true;
                    this.streamControllers[data.streamId].controller.close();
                    deleteStreamController();
                    break;
                  case "error":
                    (0, _util.assert)(this.streamControllers[data.streamId], "error should have stream controller");
                    this.streamControllers[data.streamId].controller.error(wrapReason(data.reason));
                    deleteStreamController();
                    break;
                  case "cancel_complete":
                    resolveOrReject(this.streamControllers[data.streamId].cancelCall, data.success, wrapReason(data.reason));
                    deleteStreamController();
                    break;
                  case "cancel":
                    if (!this.streamSinks[data.streamId]) {
                      break;
                    }
                    resolveCall(this.streamSinks[data.streamId].onCancel, [wrapReason(data.reason)]).then(function() {
                      sendStreamResponse({
                        stream: "cancel_complete",
                        success: true
                      });
                    }, function(reason) {
                      sendStreamResponse({
                        stream: "cancel_complete",
                        success: false,
                        reason
                      });
                    });
                    this.streamSinks[data.streamId].sinkCapability.reject(wrapReason(data.reason));
                    this.streamSinks[data.streamId].isCancelled = true;
                    delete this.streamSinks[data.streamId];
                    break;
                  default:
                    throw new Error("Unexpected stream case");
                }
              },
              postMessage: function postMessage2(message, transfers) {
                if (transfers && this.postMessageTransfers) {
                  this.comObj.postMessage(message, transfers);
                } else {
                  this.comObj.postMessage(message);
                }
              },
              destroy: function destroy() {
                this.comObj.removeEventListener("message", this._onComObjOnMessage);
              }
            };
            exports3.MessageHandler = MessageHandler;
          }
          /******/
        ])
      );
    });
  }
});

// browser-external:zlib
var require_zlib = __commonJS({
  "browser-external:zlib"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "zlib" has been externalized for browser compatibility. Cannot access "zlib.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "http" has been externalized for browser compatibility. Cannot access "http.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "https" has been externalized for browser compatibility. Cannot access "https.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/officeparser/pdfjs-dist-build/pdf.js
var require_pdf = __commonJS({
  "node_modules/officeparser/pdfjs-dist-build/pdf.js"(exports2, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports2 === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("pdfjs-dist/build/pdf", [], factory);
      else if (typeof exports2 === "object")
        exports2["pdfjs-dist/build/pdf"] = factory();
      else
        root["pdfjs-dist/build/pdf"] = root.pdfjsLib = factory();
    })(exports2, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __w_pdfjs_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module3 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module3.exports, module3, module3.exports, __w_pdfjs_require__);
            module3.l = true;
            return module3.exports;
          }
          __w_pdfjs_require__.m = modules;
          __w_pdfjs_require__.c = installedModules;
          __w_pdfjs_require__.d = function(exports3, name, getter) {
            if (!__w_pdfjs_require__.o(exports3, name)) {
              Object.defineProperty(exports3, name, { enumerable: true, get: getter });
            }
          };
          __w_pdfjs_require__.r = function(exports3) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports3, "__esModule", { value: true });
          };
          __w_pdfjs_require__.t = function(value, mode) {
            if (mode & 1) value = __w_pdfjs_require__(value);
            if (mode & 8) return value;
            if (mode & 4 && typeof value === "object" && value && value.__esModule) return value;
            var ns = /* @__PURE__ */ Object.create(null);
            __w_pdfjs_require__.r(ns);
            Object.defineProperty(ns, "default", { enumerable: true, value });
            if (mode & 2 && typeof value != "string") for (var key in value) __w_pdfjs_require__.d(ns, key, (function(key2) {
              return value[key2];
            }).bind(null, key));
            return ns;
          };
          __w_pdfjs_require__.n = function(module3) {
            var getter = module3 && module3.__esModule ? (
              /******/
              function getDefault() {
                return module3["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module3;
              }
            );
            __w_pdfjs_require__.d(getter, "a", getter);
            return getter;
          };
          __w_pdfjs_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __w_pdfjs_require__.p = "";
          return __w_pdfjs_require__(__w_pdfjs_require__.s = 0);
        }([
          /* 0 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var pdfjsVersion = "2.0.550";
            var pdfjsBuild = "76337fdc";
            var pdfjsSharedUtil = __w_pdfjs_require__(1);
            var pdfjsDisplayAPI = __w_pdfjs_require__(114);
            var pdfjsDisplayTextLayer = __w_pdfjs_require__(126);
            var pdfjsDisplayAnnotationLayer = __w_pdfjs_require__(127);
            var pdfjsDisplayDOMUtils = __w_pdfjs_require__(115);
            var pdfjsDisplaySVG = __w_pdfjs_require__(128);
            var pdfjsDisplayWorkerOptions = __w_pdfjs_require__(120);
            var pdfjsDisplayAPICompatibility = __w_pdfjs_require__(117);
            {
              var isNodeJS = __w_pdfjs_require__(4);
              if (isNodeJS()) {
                var PDFNodeStream = __w_pdfjs_require__(129).PDFNodeStream;
                pdfjsDisplayAPI.setPDFNetworkStreamFactory(function(params) {
                  return new PDFNodeStream(params);
                });
              } else if (typeof Response !== "undefined" && "body" in Response.prototype && typeof ReadableStream !== "undefined") {
                var PDFFetchStream = __w_pdfjs_require__(132).PDFFetchStream;
                pdfjsDisplayAPI.setPDFNetworkStreamFactory(function(params) {
                  return new PDFFetchStream(params);
                });
              } else {
                var PDFNetworkStream = __w_pdfjs_require__(133).PDFNetworkStream;
                pdfjsDisplayAPI.setPDFNetworkStreamFactory(function(params) {
                  return new PDFNetworkStream(params);
                });
              }
            }
            exports3.build = pdfjsDisplayAPI.build;
            exports3.version = pdfjsDisplayAPI.version;
            exports3.getDocument = pdfjsDisplayAPI.getDocument;
            exports3.LoopbackPort = pdfjsDisplayAPI.LoopbackPort;
            exports3.PDFDataRangeTransport = pdfjsDisplayAPI.PDFDataRangeTransport;
            exports3.PDFWorker = pdfjsDisplayAPI.PDFWorker;
            exports3.renderTextLayer = pdfjsDisplayTextLayer.renderTextLayer;
            exports3.AnnotationLayer = pdfjsDisplayAnnotationLayer.AnnotationLayer;
            exports3.createPromiseCapability = pdfjsSharedUtil.createPromiseCapability;
            exports3.PasswordResponses = pdfjsSharedUtil.PasswordResponses;
            exports3.InvalidPDFException = pdfjsSharedUtil.InvalidPDFException;
            exports3.MissingPDFException = pdfjsSharedUtil.MissingPDFException;
            exports3.SVGGraphics = pdfjsDisplaySVG.SVGGraphics;
            exports3.NativeImageDecoding = pdfjsSharedUtil.NativeImageDecoding;
            exports3.UnexpectedResponseException = pdfjsSharedUtil.UnexpectedResponseException;
            exports3.OPS = pdfjsSharedUtil.OPS;
            exports3.VerbosityLevel = pdfjsSharedUtil.VerbosityLevel;
            exports3.UNSUPPORTED_FEATURES = pdfjsSharedUtil.UNSUPPORTED_FEATURES;
            exports3.createValidAbsoluteUrl = pdfjsSharedUtil.createValidAbsoluteUrl;
            exports3.createObjectURL = pdfjsSharedUtil.createObjectURL;
            exports3.removeNullCharacters = pdfjsSharedUtil.removeNullCharacters;
            exports3.shadow = pdfjsSharedUtil.shadow;
            exports3.createBlob = pdfjsSharedUtil.createBlob;
            exports3.Util = pdfjsSharedUtil.Util;
            exports3.RenderingCancelledException = pdfjsDisplayDOMUtils.RenderingCancelledException;
            exports3.getFilenameFromUrl = pdfjsDisplayDOMUtils.getFilenameFromUrl;
            exports3.LinkTarget = pdfjsDisplayDOMUtils.LinkTarget;
            exports3.addLinkAttributes = pdfjsDisplayDOMUtils.addLinkAttributes;
            exports3.GlobalWorkerOptions = pdfjsDisplayWorkerOptions.GlobalWorkerOptions;
            exports3.apiCompatibilityParams = pdfjsDisplayAPICompatibility.apiCompatibilityParams;
          },
          /* 1 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.unreachable = exports3.warn = exports3.utf8StringToString = exports3.stringToUTF8String = exports3.stringToPDFString = exports3.stringToBytes = exports3.string32 = exports3.shadow = exports3.setVerbosityLevel = exports3.ReadableStream = exports3.removeNullCharacters = exports3.readUint32 = exports3.readUint16 = exports3.readInt8 = exports3.log2 = exports3.isEvalSupported = exports3.isLittleEndian = exports3.createValidAbsoluteUrl = exports3.isSameOrigin = exports3.isSpace = exports3.isString = exports3.isNum = exports3.isEmptyObj = exports3.isBool = exports3.isArrayBuffer = exports3.info = exports3.getVerbosityLevel = exports3.getLookupTableFactory = exports3.getInheritableProperty = exports3.deprecated = exports3.createObjectURL = exports3.createPromiseCapability = exports3.createBlob = exports3.bytesToString = exports3.assert = exports3.arraysToBytes = exports3.arrayByteLength = exports3.FormatError = exports3.XRefParseException = exports3.Util = exports3.UnknownErrorException = exports3.UnexpectedResponseException = exports3.TextRenderingMode = exports3.StreamType = exports3.PasswordResponses = exports3.PasswordException = exports3.NotImplementedException = exports3.NativeImageDecoding = exports3.MissingPDFException = exports3.MissingDataException = exports3.InvalidPDFException = exports3.AbortException = exports3.CMapCompressionType = exports3.ImageKind = exports3.FontType = exports3.AnnotationType = exports3.AnnotationFlag = exports3.AnnotationFieldFlag = exports3.AnnotationBorderStyleType = exports3.UNSUPPORTED_FEATURES = exports3.VerbosityLevel = exports3.OPS = exports3.IDENTITY_MATRIX = exports3.FONT_IDENTITY_MATRIX = void 0;
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            __w_pdfjs_require__(2);
            var _streams_polyfill = __w_pdfjs_require__(112);
            var FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
            var NativeImageDecoding = {
              NONE: "none",
              DECODE: "decode",
              DISPLAY: "display"
            };
            var TextRenderingMode = {
              FILL: 0,
              STROKE: 1,
              FILL_STROKE: 2,
              INVISIBLE: 3,
              FILL_ADD_TO_PATH: 4,
              STROKE_ADD_TO_PATH: 5,
              FILL_STROKE_ADD_TO_PATH: 6,
              ADD_TO_PATH: 7,
              FILL_STROKE_MASK: 3,
              ADD_TO_PATH_FLAG: 4
            };
            var ImageKind = {
              GRAYSCALE_1BPP: 1,
              RGB_24BPP: 2,
              RGBA_32BPP: 3
            };
            var AnnotationType = {
              TEXT: 1,
              LINK: 2,
              FREETEXT: 3,
              LINE: 4,
              SQUARE: 5,
              CIRCLE: 6,
              POLYGON: 7,
              POLYLINE: 8,
              HIGHLIGHT: 9,
              UNDERLINE: 10,
              SQUIGGLY: 11,
              STRIKEOUT: 12,
              STAMP: 13,
              CARET: 14,
              INK: 15,
              POPUP: 16,
              FILEATTACHMENT: 17,
              SOUND: 18,
              MOVIE: 19,
              WIDGET: 20,
              SCREEN: 21,
              PRINTERMARK: 22,
              TRAPNET: 23,
              WATERMARK: 24,
              THREED: 25,
              REDACT: 26
            };
            var AnnotationFlag = {
              INVISIBLE: 1,
              HIDDEN: 2,
              PRINT: 4,
              NOZOOM: 8,
              NOROTATE: 16,
              NOVIEW: 32,
              READONLY: 64,
              LOCKED: 128,
              TOGGLENOVIEW: 256,
              LOCKEDCONTENTS: 512
            };
            var AnnotationFieldFlag = {
              READONLY: 1,
              REQUIRED: 2,
              NOEXPORT: 4,
              MULTILINE: 4096,
              PASSWORD: 8192,
              NOTOGGLETOOFF: 16384,
              RADIO: 32768,
              PUSHBUTTON: 65536,
              COMBO: 131072,
              EDIT: 262144,
              SORT: 524288,
              FILESELECT: 1048576,
              MULTISELECT: 2097152,
              DONOTSPELLCHECK: 4194304,
              DONOTSCROLL: 8388608,
              COMB: 16777216,
              RICHTEXT: 33554432,
              RADIOSINUNISON: 33554432,
              COMMITONSELCHANGE: 67108864
            };
            var AnnotationBorderStyleType = {
              SOLID: 1,
              DASHED: 2,
              BEVELED: 3,
              INSET: 4,
              UNDERLINE: 5
            };
            var StreamType = {
              UNKNOWN: 0,
              FLATE: 1,
              LZW: 2,
              DCT: 3,
              JPX: 4,
              JBIG: 5,
              A85: 6,
              AHX: 7,
              CCF: 8,
              RL: 9
            };
            var FontType = {
              UNKNOWN: 0,
              TYPE1: 1,
              TYPE1C: 2,
              CIDFONTTYPE0: 3,
              CIDFONTTYPE0C: 4,
              TRUETYPE: 5,
              CIDFONTTYPE2: 6,
              TYPE3: 7,
              OPENTYPE: 8,
              TYPE0: 9,
              MMTYPE1: 10
            };
            var VerbosityLevel = {
              ERRORS: 0,
              WARNINGS: 1,
              INFOS: 5
            };
            var CMapCompressionType = {
              NONE: 0,
              BINARY: 1,
              STREAM: 2
            };
            var OPS = {
              dependency: 1,
              setLineWidth: 2,
              setLineCap: 3,
              setLineJoin: 4,
              setMiterLimit: 5,
              setDash: 6,
              setRenderingIntent: 7,
              setFlatness: 8,
              setGState: 9,
              save: 10,
              restore: 11,
              transform: 12,
              moveTo: 13,
              lineTo: 14,
              curveTo: 15,
              curveTo2: 16,
              curveTo3: 17,
              closePath: 18,
              rectangle: 19,
              stroke: 20,
              closeStroke: 21,
              fill: 22,
              eoFill: 23,
              fillStroke: 24,
              eoFillStroke: 25,
              closeFillStroke: 26,
              closeEOFillStroke: 27,
              endPath: 28,
              clip: 29,
              eoClip: 30,
              beginText: 31,
              endText: 32,
              setCharSpacing: 33,
              setWordSpacing: 34,
              setHScale: 35,
              setLeading: 36,
              setFont: 37,
              setTextRenderingMode: 38,
              setTextRise: 39,
              moveText: 40,
              setLeadingMoveText: 41,
              setTextMatrix: 42,
              nextLine: 43,
              showText: 44,
              showSpacedText: 45,
              nextLineShowText: 46,
              nextLineSetSpacingShowText: 47,
              setCharWidth: 48,
              setCharWidthAndBounds: 49,
              setStrokeColorSpace: 50,
              setFillColorSpace: 51,
              setStrokeColor: 52,
              setStrokeColorN: 53,
              setFillColor: 54,
              setFillColorN: 55,
              setStrokeGray: 56,
              setFillGray: 57,
              setStrokeRGBColor: 58,
              setFillRGBColor: 59,
              setStrokeCMYKColor: 60,
              setFillCMYKColor: 61,
              shadingFill: 62,
              beginInlineImage: 63,
              beginImageData: 64,
              endInlineImage: 65,
              paintXObject: 66,
              markPoint: 67,
              markPointProps: 68,
              beginMarkedContent: 69,
              beginMarkedContentProps: 70,
              endMarkedContent: 71,
              beginCompat: 72,
              endCompat: 73,
              paintFormXObjectBegin: 74,
              paintFormXObjectEnd: 75,
              beginGroup: 76,
              endGroup: 77,
              beginAnnotations: 78,
              endAnnotations: 79,
              beginAnnotation: 80,
              endAnnotation: 81,
              paintJpegXObject: 82,
              paintImageMaskXObject: 83,
              paintImageMaskXObjectGroup: 84,
              paintImageXObject: 85,
              paintInlineImageXObject: 86,
              paintInlineImageXObjectGroup: 87,
              paintImageXObjectRepeat: 88,
              paintImageMaskXObjectRepeat: 89,
              paintSolidColorImageMask: 90,
              constructPath: 91
            };
            var verbosity = VerbosityLevel.WARNINGS;
            function setVerbosityLevel(level) {
              if (Number.isInteger(level)) {
                verbosity = level;
              }
            }
            function getVerbosityLevel() {
              return verbosity;
            }
            function info(msg) {
              if (verbosity >= VerbosityLevel.INFOS) {
                console.log("Info: " + msg);
              }
            }
            function warn(msg) {
              if (verbosity >= VerbosityLevel.WARNINGS) {
                console.log("Warning: " + msg);
              }
            }
            function deprecated(details) {
              console.log("Deprecated API usage: " + details);
            }
            function unreachable(msg) {
              throw new Error(msg);
            }
            function assert(cond, msg) {
              if (!cond) {
                unreachable(msg);
              }
            }
            var UNSUPPORTED_FEATURES = {
              unknown: "unknown",
              forms: "forms",
              javaScript: "javaScript",
              smask: "smask",
              shadingPattern: "shadingPattern",
              font: "font"
            };
            function isSameOrigin(baseUrl, otherUrl) {
              try {
                var base = new URL(baseUrl);
                if (!base.origin || base.origin === "null") {
                  return false;
                }
              } catch (e) {
                return false;
              }
              var other = new URL(otherUrl, base);
              return base.origin === other.origin;
            }
            function isValidProtocol(url) {
              if (!url) {
                return false;
              }
              switch (url.protocol) {
                case "http:":
                case "https:":
                case "ftp:":
                case "mailto:":
                case "tel:":
                  return true;
                default:
                  return false;
              }
            }
            function createValidAbsoluteUrl(url, baseUrl) {
              if (!url) {
                return null;
              }
              try {
                var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
                if (isValidProtocol(absoluteUrl)) {
                  return absoluteUrl;
                }
              } catch (ex) {
              }
              return null;
            }
            function shadow(obj, prop, value) {
              Object.defineProperty(obj, prop, {
                value,
                enumerable: true,
                configurable: true,
                writable: false
              });
              return value;
            }
            function getLookupTableFactory(initializer) {
              var lookup;
              return function() {
                if (initializer) {
                  lookup = /* @__PURE__ */ Object.create(null);
                  initializer(lookup);
                  initializer = null;
                }
                return lookup;
              };
            }
            var PasswordResponses = {
              NEED_PASSWORD: 1,
              INCORRECT_PASSWORD: 2
            };
            var PasswordException = function PasswordExceptionClosure() {
              function PasswordException2(msg, code) {
                this.name = "PasswordException";
                this.message = msg;
                this.code = code;
              }
              PasswordException2.prototype = new Error();
              PasswordException2.constructor = PasswordException2;
              return PasswordException2;
            }();
            var UnknownErrorException = function UnknownErrorExceptionClosure() {
              function UnknownErrorException2(msg, details) {
                this.name = "UnknownErrorException";
                this.message = msg;
                this.details = details;
              }
              UnknownErrorException2.prototype = new Error();
              UnknownErrorException2.constructor = UnknownErrorException2;
              return UnknownErrorException2;
            }();
            var InvalidPDFException = function InvalidPDFExceptionClosure() {
              function InvalidPDFException2(msg) {
                this.name = "InvalidPDFException";
                this.message = msg;
              }
              InvalidPDFException2.prototype = new Error();
              InvalidPDFException2.constructor = InvalidPDFException2;
              return InvalidPDFException2;
            }();
            var MissingPDFException = function MissingPDFExceptionClosure() {
              function MissingPDFException2(msg) {
                this.name = "MissingPDFException";
                this.message = msg;
              }
              MissingPDFException2.prototype = new Error();
              MissingPDFException2.constructor = MissingPDFException2;
              return MissingPDFException2;
            }();
            var UnexpectedResponseException = function UnexpectedResponseExceptionClosure() {
              function UnexpectedResponseException2(msg, status) {
                this.name = "UnexpectedResponseException";
                this.message = msg;
                this.status = status;
              }
              UnexpectedResponseException2.prototype = new Error();
              UnexpectedResponseException2.constructor = UnexpectedResponseException2;
              return UnexpectedResponseException2;
            }();
            var NotImplementedException = function NotImplementedExceptionClosure() {
              function NotImplementedException2(msg) {
                this.message = msg;
              }
              NotImplementedException2.prototype = new Error();
              NotImplementedException2.prototype.name = "NotImplementedException";
              NotImplementedException2.constructor = NotImplementedException2;
              return NotImplementedException2;
            }();
            var MissingDataException = function MissingDataExceptionClosure() {
              function MissingDataException2(begin, end) {
                this.begin = begin;
                this.end = end;
                this.message = "Missing data [" + begin + ", " + end + ")";
              }
              MissingDataException2.prototype = new Error();
              MissingDataException2.prototype.name = "MissingDataException";
              MissingDataException2.constructor = MissingDataException2;
              return MissingDataException2;
            }();
            var XRefParseException = function XRefParseExceptionClosure() {
              function XRefParseException2(msg) {
                this.message = msg;
              }
              XRefParseException2.prototype = new Error();
              XRefParseException2.prototype.name = "XRefParseException";
              XRefParseException2.constructor = XRefParseException2;
              return XRefParseException2;
            }();
            var FormatError = function FormatErrorClosure() {
              function FormatError2(msg) {
                this.message = msg;
              }
              FormatError2.prototype = new Error();
              FormatError2.prototype.name = "FormatError";
              FormatError2.constructor = FormatError2;
              return FormatError2;
            }();
            var AbortException = function AbortExceptionClosure() {
              function AbortException2(msg) {
                this.name = "AbortException";
                this.message = msg;
              }
              AbortException2.prototype = new Error();
              AbortException2.constructor = AbortException2;
              return AbortException2;
            }();
            var NullCharactersRegExp = /\x00/g;
            function removeNullCharacters(str) {
              if (typeof str !== "string") {
                warn("The argument for removeNullCharacters must be a string.");
                return str;
              }
              return str.replace(NullCharactersRegExp, "");
            }
            function bytesToString(bytes) {
              assert(bytes !== null && (typeof bytes === "undefined" ? "undefined" : _typeof(bytes)) === "object" && bytes.length !== void 0, "Invalid argument for bytesToString");
              var length = bytes.length;
              var MAX_ARGUMENT_COUNT = 8192;
              if (length < MAX_ARGUMENT_COUNT) {
                return String.fromCharCode.apply(null, bytes);
              }
              var strBuf = [];
              for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
                var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
                var chunk = bytes.subarray(i, chunkEnd);
                strBuf.push(String.fromCharCode.apply(null, chunk));
              }
              return strBuf.join("");
            }
            function stringToBytes2(str) {
              assert(typeof str === "string", "Invalid argument for stringToBytes");
              var length = str.length;
              var bytes = new Uint8Array(length);
              for (var i = 0; i < length; ++i) {
                bytes[i] = str.charCodeAt(i) & 255;
              }
              return bytes;
            }
            function arrayByteLength(arr) {
              if (arr.length !== void 0) {
                return arr.length;
              }
              assert(arr.byteLength !== void 0);
              return arr.byteLength;
            }
            function arraysToBytes(arr) {
              if (arr.length === 1 && arr[0] instanceof Uint8Array) {
                return arr[0];
              }
              var resultLength = 0;
              var i, ii = arr.length;
              var item, itemLength;
              for (i = 0; i < ii; i++) {
                item = arr[i];
                itemLength = arrayByteLength(item);
                resultLength += itemLength;
              }
              var pos = 0;
              var data = new Uint8Array(resultLength);
              for (i = 0; i < ii; i++) {
                item = arr[i];
                if (!(item instanceof Uint8Array)) {
                  if (typeof item === "string") {
                    item = stringToBytes2(item);
                  } else {
                    item = new Uint8Array(item);
                  }
                }
                itemLength = item.byteLength;
                data.set(item, pos);
                pos += itemLength;
              }
              return data;
            }
            function string32(value) {
              return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
            }
            function log2(x) {
              if (x <= 0) {
                return 0;
              }
              return Math.ceil(Math.log2(x));
            }
            function readInt8(data, start) {
              return data[start] << 24 >> 24;
            }
            function readUint16(data, offset) {
              return data[offset] << 8 | data[offset + 1];
            }
            function readUint32(data, offset) {
              return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
            }
            function isLittleEndian() {
              var buffer8 = new Uint8Array(4);
              buffer8[0] = 1;
              var view32 = new Uint32Array(buffer8.buffer, 0, 1);
              return view32[0] === 1;
            }
            function isEvalSupported() {
              try {
                new Function("");
                return true;
              } catch (e) {
                return false;
              }
            }
            function getInheritableProperty(_ref) {
              var dict = _ref.dict, key = _ref.key, _ref$getArray = _ref.getArray, getArray = _ref$getArray === void 0 ? false : _ref$getArray, _ref$stopWhenFound = _ref.stopWhenFound, stopWhenFound = _ref$stopWhenFound === void 0 ? true : _ref$stopWhenFound;
              var LOOP_LIMIT = 100;
              var loopCount = 0;
              var values = void 0;
              while (dict) {
                var value = getArray ? dict.getArray(key) : dict.get(key);
                if (value !== void 0) {
                  if (stopWhenFound) {
                    return value;
                  }
                  if (!values) {
                    values = [];
                  }
                  values.push(value);
                }
                if (++loopCount > LOOP_LIMIT) {
                  warn('getInheritableProperty: maximum loop count exceeded for "' + key + '"');
                  break;
                }
                dict = dict.get("Parent");
              }
              return values;
            }
            var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
            var Util = function UtilClosure() {
              function Util2() {
              }
              var rgbBuf = ["rgb(", 0, ",", 0, ",", 0, ")"];
              Util2.makeCssRgb = function Util_makeCssRgb(r, g, b) {
                rgbBuf[1] = r;
                rgbBuf[3] = g;
                rgbBuf[5] = b;
                return rgbBuf.join("");
              };
              Util2.transform = function Util_transform(m1, m2) {
                return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
              };
              Util2.applyTransform = function Util_applyTransform(p, m) {
                var xt = p[0] * m[0] + p[1] * m[2] + m[4];
                var yt = p[0] * m[1] + p[1] * m[3] + m[5];
                return [xt, yt];
              };
              Util2.applyInverseTransform = function Util_applyInverseTransform(p, m) {
                var d = m[0] * m[3] - m[1] * m[2];
                var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                return [xt, yt];
              };
              Util2.getAxialAlignedBoundingBox = function Util_getAxialAlignedBoundingBox(r, m) {
                var p1 = Util2.applyTransform(r, m);
                var p2 = Util2.applyTransform(r.slice(2, 4), m);
                var p3 = Util2.applyTransform([r[0], r[3]], m);
                var p4 = Util2.applyTransform([r[2], r[1]], m);
                return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
              };
              Util2.inverseTransform = function Util_inverseTransform(m) {
                var d = m[0] * m[3] - m[1] * m[2];
                return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
              };
              Util2.apply3dTransform = function Util_apply3dTransform(m, v) {
                return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
              };
              Util2.singularValueDecompose2dScale = function Util_singularValueDecompose2dScale(m) {
                var transpose = [m[0], m[2], m[1], m[3]];
                var a = m[0] * transpose[0] + m[1] * transpose[2];
                var b = m[0] * transpose[1] + m[1] * transpose[3];
                var c = m[2] * transpose[0] + m[3] * transpose[2];
                var d = m[2] * transpose[1] + m[3] * transpose[3];
                var first = (a + d) / 2;
                var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
                var sx = first + second || 1;
                var sy = first - second || 1;
                return [Math.sqrt(sx), Math.sqrt(sy)];
              };
              Util2.normalizeRect = function Util_normalizeRect(rect) {
                var r = rect.slice(0);
                if (rect[0] > rect[2]) {
                  r[0] = rect[2];
                  r[2] = rect[0];
                }
                if (rect[1] > rect[3]) {
                  r[1] = rect[3];
                  r[3] = rect[1];
                }
                return r;
              };
              Util2.intersect = function Util_intersect(rect1, rect2) {
                function compare(a, b) {
                  return a - b;
                }
                var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare), orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare), result = [];
                rect1 = Util2.normalizeRect(rect1);
                rect2 = Util2.normalizeRect(rect2);
                if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
                  result[0] = orderedX[1];
                  result[2] = orderedX[2];
                } else {
                  return false;
                }
                if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
                  result[1] = orderedY[1];
                  result[3] = orderedY[2];
                } else {
                  return false;
                }
                return result;
              };
              var ROMAN_NUMBER_MAP = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
              Util2.toRoman = function Util_toRoman(number, lowerCase) {
                assert(Number.isInteger(number) && number > 0, "The number should be a positive integer.");
                var pos, romanBuf = [];
                while (number >= 1e3) {
                  number -= 1e3;
                  romanBuf.push("M");
                }
                pos = number / 100 | 0;
                number %= 100;
                romanBuf.push(ROMAN_NUMBER_MAP[pos]);
                pos = number / 10 | 0;
                number %= 10;
                romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
                romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
                var romanStr = romanBuf.join("");
                return lowerCase ? romanStr.toLowerCase() : romanStr;
              };
              Util2.appendToArray = function Util_appendToArray(arr1, arr2) {
                Array.prototype.push.apply(arr1, arr2);
              };
              Util2.prependToArray = function Util_prependToArray(arr1, arr2) {
                Array.prototype.unshift.apply(arr1, arr2);
              };
              Util2.extendObj = function extendObj(obj1, obj2) {
                for (var key in obj2) {
                  obj1[key] = obj2[key];
                }
              };
              Util2.inherit = function Util_inherit(sub, base, prototype) {
                sub.prototype = Object.create(base.prototype);
                sub.prototype.constructor = sub;
                for (var prop in prototype) {
                  sub.prototype[prop] = prototype[prop];
                }
              };
              Util2.loadScript = function Util_loadScript(src, callback) {
                var script = document.createElement("script");
                var loaded = false;
                script.setAttribute("src", src);
                if (callback) {
                  script.onload = function() {
                    if (!loaded) {
                      callback();
                    }
                    loaded = true;
                  };
                }
                document.getElementsByTagName("head")[0].appendChild(script);
              };
              return Util2;
            }();
            var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
            function stringToPDFString(str) {
              var i, n = str.length, strBuf = [];
              if (str[0] === "þ" && str[1] === "ÿ") {
                for (i = 2; i < n; i += 2) {
                  strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
                }
              } else {
                for (i = 0; i < n; ++i) {
                  var code = PDFStringTranslateTable[str.charCodeAt(i)];
                  strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
                }
              }
              return strBuf.join("");
            }
            function stringToUTF8String(str) {
              return decodeURIComponent(escape(str));
            }
            function utf8StringToString(str) {
              return unescape(encodeURIComponent(str));
            }
            function isEmptyObj(obj) {
              for (var key in obj) {
                return false;
              }
              return true;
            }
            function isBool(v) {
              return typeof v === "boolean";
            }
            function isNum(v) {
              return typeof v === "number";
            }
            function isString(v) {
              return typeof v === "string";
            }
            function isArrayBuffer(v) {
              return (typeof v === "undefined" ? "undefined" : _typeof(v)) === "object" && v !== null && v.byteLength !== void 0;
            }
            function isSpace(ch) {
              return ch === 32 || ch === 9 || ch === 13 || ch === 10;
            }
            function createPromiseCapability() {
              var capability = {};
              capability.promise = new Promise(function(resolve2, reject2) {
                capability.resolve = resolve2;
                capability.reject = reject2;
              });
              return capability;
            }
            var createBlob = function createBlob2(data, contentType) {
              if (typeof Blob !== "undefined") {
                return new Blob([data], { type: contentType });
              }
              throw new Error('The "Blob" constructor is not supported.');
            };
            var createObjectURL = /* @__PURE__ */ function createObjectURLClosure() {
              var digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              return function createObjectURL2(data, contentType) {
                var forceDataSchema = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                if (!forceDataSchema && URL.createObjectURL) {
                  var blob = createBlob(data, contentType);
                  return URL.createObjectURL(blob);
                }
                var buffer = "data:" + contentType + ";base64,";
                for (var i = 0, ii = data.length; i < ii; i += 3) {
                  var b1 = data[i] & 255;
                  var b2 = data[i + 1] & 255;
                  var b3 = data[i + 2] & 255;
                  var d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
                  var d3 = i + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
                  var d4 = i + 2 < ii ? b3 & 63 : 64;
                  buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
                }
                return buffer;
              };
            }();
            exports3.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
            exports3.IDENTITY_MATRIX = IDENTITY_MATRIX;
            exports3.OPS = OPS;
            exports3.VerbosityLevel = VerbosityLevel;
            exports3.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
            exports3.AnnotationBorderStyleType = AnnotationBorderStyleType;
            exports3.AnnotationFieldFlag = AnnotationFieldFlag;
            exports3.AnnotationFlag = AnnotationFlag;
            exports3.AnnotationType = AnnotationType;
            exports3.FontType = FontType;
            exports3.ImageKind = ImageKind;
            exports3.CMapCompressionType = CMapCompressionType;
            exports3.AbortException = AbortException;
            exports3.InvalidPDFException = InvalidPDFException;
            exports3.MissingDataException = MissingDataException;
            exports3.MissingPDFException = MissingPDFException;
            exports3.NativeImageDecoding = NativeImageDecoding;
            exports3.NotImplementedException = NotImplementedException;
            exports3.PasswordException = PasswordException;
            exports3.PasswordResponses = PasswordResponses;
            exports3.StreamType = StreamType;
            exports3.TextRenderingMode = TextRenderingMode;
            exports3.UnexpectedResponseException = UnexpectedResponseException;
            exports3.UnknownErrorException = UnknownErrorException;
            exports3.Util = Util;
            exports3.XRefParseException = XRefParseException;
            exports3.FormatError = FormatError;
            exports3.arrayByteLength = arrayByteLength;
            exports3.arraysToBytes = arraysToBytes;
            exports3.assert = assert;
            exports3.bytesToString = bytesToString;
            exports3.createBlob = createBlob;
            exports3.createPromiseCapability = createPromiseCapability;
            exports3.createObjectURL = createObjectURL;
            exports3.deprecated = deprecated;
            exports3.getInheritableProperty = getInheritableProperty;
            exports3.getLookupTableFactory = getLookupTableFactory;
            exports3.getVerbosityLevel = getVerbosityLevel;
            exports3.info = info;
            exports3.isArrayBuffer = isArrayBuffer;
            exports3.isBool = isBool;
            exports3.isEmptyObj = isEmptyObj;
            exports3.isNum = isNum;
            exports3.isString = isString;
            exports3.isSpace = isSpace;
            exports3.isSameOrigin = isSameOrigin;
            exports3.createValidAbsoluteUrl = createValidAbsoluteUrl;
            exports3.isLittleEndian = isLittleEndian;
            exports3.isEvalSupported = isEvalSupported;
            exports3.log2 = log2;
            exports3.readInt8 = readInt8;
            exports3.readUint16 = readUint16;
            exports3.readUint32 = readUint32;
            exports3.removeNullCharacters = removeNullCharacters;
            exports3.ReadableStream = _streams_polyfill.ReadableStream;
            exports3.setVerbosityLevel = setVerbosityLevel;
            exports3.shadow = shadow;
            exports3.string32 = string32;
            exports3.stringToBytes = stringToBytes2;
            exports3.stringToPDFString = stringToPDFString;
            exports3.stringToUTF8String = stringToUTF8String;
            exports3.utf8StringToString = utf8StringToString;
            exports3.warn = warn;
            exports3.unreachable = unreachable;
          },
          /* 2 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var globalScope = __w_pdfjs_require__(3);
            if (!globalScope._pdfjsCompatibilityChecked) {
              globalScope._pdfjsCompatibilityChecked = true;
              var isNodeJS = __w_pdfjs_require__(4);
              var hasDOM = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === "object";
              (function checkNodeBtoa() {
                if (globalScope.btoa || !isNodeJS()) {
                  return;
                }
                globalScope.btoa = function(chars) {
                  return Buffer.from(chars, "binary").toString("base64");
                };
              })();
              (function checkNodeAtob() {
                if (globalScope.atob || !isNodeJS()) {
                  return;
                }
                globalScope.atob = function(input) {
                  return Buffer.from(input, "base64").toString("binary");
                };
              })();
              (function checkCurrentScript() {
                if (!hasDOM) {
                  return;
                }
                if ("currentScript" in document) {
                  return;
                }
                Object.defineProperty(document, "currentScript", {
                  get: function get() {
                    var scripts = document.getElementsByTagName("script");
                    return scripts[scripts.length - 1];
                  },
                  enumerable: true,
                  configurable: true
                });
              })();
              (function checkChildNodeRemove() {
                if (!hasDOM) {
                  return;
                }
                if (typeof Element.prototype.remove !== "undefined") {
                  return;
                }
                Element.prototype.remove = function() {
                  if (this.parentNode) {
                    this.parentNode.removeChild(this);
                  }
                };
              })();
              (function checkStringIncludes() {
                if (String.prototype.includes) {
                  return;
                }
                __w_pdfjs_require__(5);
              })();
              (function checkArrayIncludes() {
                if (Array.prototype.includes) {
                  return;
                }
                __w_pdfjs_require__(33);
              })();
              (function checkMathLog2() {
                if (Math.log2) {
                  return;
                }
                Math.log2 = __w_pdfjs_require__(42);
              })();
              (function checkNumberIsNaN() {
                if (Number.isNaN) {
                  return;
                }
                Number.isNaN = __w_pdfjs_require__(44);
              })();
              (function checkNumberIsInteger() {
                if (Number.isInteger) {
                  return;
                }
                Number.isInteger = __w_pdfjs_require__(46);
              })();
              (function checkPromise() {
                if (globalScope.Promise) {
                  return;
                }
                globalScope.Promise = __w_pdfjs_require__(49);
              })();
              (function checkWeakMap() {
                if (globalScope.WeakMap) {
                  return;
                }
                globalScope.WeakMap = __w_pdfjs_require__(89);
              })();
              (function checkURLConstructor() {
                var hasWorkingUrl = false;
                try {
                  if (typeof URL === "function" && _typeof(URL.prototype) === "object" && "origin" in URL.prototype) {
                    var u = new URL("b", "http://a");
                    u.pathname = "c%20d";
                    hasWorkingUrl = u.href === "http://a/c%20d";
                  }
                } catch (e) {
                }
                if (hasWorkingUrl) {
                  return;
                }
                var relative = /* @__PURE__ */ Object.create(null);
                relative["ftp"] = 21;
                relative["file"] = 0;
                relative["gopher"] = 70;
                relative["http"] = 80;
                relative["https"] = 443;
                relative["ws"] = 80;
                relative["wss"] = 443;
                var relativePathDotMapping = /* @__PURE__ */ Object.create(null);
                relativePathDotMapping["%2e"] = ".";
                relativePathDotMapping[".%2e"] = "..";
                relativePathDotMapping["%2e."] = "..";
                relativePathDotMapping["%2e%2e"] = "..";
                function isRelativeScheme(scheme) {
                  return relative[scheme] !== void 0;
                }
                function invalid() {
                  clear.call(this);
                  this._isInvalid = true;
                }
                function IDNAToASCII(h) {
                  if (h === "") {
                    invalid.call(this);
                  }
                  return h.toLowerCase();
                }
                function percentEscape(c) {
                  var unicode = c.charCodeAt(0);
                  if (unicode > 32 && unicode < 127 && [34, 35, 60, 62, 63, 96].indexOf(unicode) === -1) {
                    return c;
                  }
                  return encodeURIComponent(c);
                }
                function percentEscapeQuery(c) {
                  var unicode = c.charCodeAt(0);
                  if (unicode > 32 && unicode < 127 && [34, 35, 60, 62, 96].indexOf(unicode) === -1) {
                    return c;
                  }
                  return encodeURIComponent(c);
                }
                var EOF, ALPHA = /[a-zA-Z]/, ALPHANUMERIC = /[a-zA-Z0-9\+\-\.]/;
                function parse(input, stateOverride, base) {
                  function err(message) {
                    errors.push(message);
                  }
                  var state = stateOverride || "scheme start", cursor = 0, buffer = "", seenAt = false, seenBracket = false, errors = [];
                  loop: while ((input[cursor - 1] !== EOF || cursor === 0) && !this._isInvalid) {
                    var c = input[cursor];
                    switch (state) {
                      case "scheme start":
                        if (c && ALPHA.test(c)) {
                          buffer += c.toLowerCase();
                          state = "scheme";
                        } else if (!stateOverride) {
                          buffer = "";
                          state = "no scheme";
                          continue;
                        } else {
                          err("Invalid scheme.");
                          break loop;
                        }
                        break;
                      case "scheme":
                        if (c && ALPHANUMERIC.test(c)) {
                          buffer += c.toLowerCase();
                        } else if (c === ":") {
                          this._scheme = buffer;
                          buffer = "";
                          if (stateOverride) {
                            break loop;
                          }
                          if (isRelativeScheme(this._scheme)) {
                            this._isRelative = true;
                          }
                          if (this._scheme === "file") {
                            state = "relative";
                          } else if (this._isRelative && base && base._scheme === this._scheme) {
                            state = "relative or authority";
                          } else if (this._isRelative) {
                            state = "authority first slash";
                          } else {
                            state = "scheme data";
                          }
                        } else if (!stateOverride) {
                          buffer = "";
                          cursor = 0;
                          state = "no scheme";
                          continue;
                        } else if (c === EOF) {
                          break loop;
                        } else {
                          err("Code point not allowed in scheme: " + c);
                          break loop;
                        }
                        break;
                      case "scheme data":
                        if (c === "?") {
                          this._query = "?";
                          state = "query";
                        } else if (c === "#") {
                          this._fragment = "#";
                          state = "fragment";
                        } else {
                          if (c !== EOF && c !== "	" && c !== "\n" && c !== "\r") {
                            this._schemeData += percentEscape(c);
                          }
                        }
                        break;
                      case "no scheme":
                        if (!base || !isRelativeScheme(base._scheme)) {
                          err("Missing scheme.");
                          invalid.call(this);
                        } else {
                          state = "relative";
                          continue;
                        }
                        break;
                      case "relative or authority":
                        if (c === "/" && input[cursor + 1] === "/") {
                          state = "authority ignore slashes";
                        } else {
                          err("Expected /, got: " + c);
                          state = "relative";
                          continue;
                        }
                        break;
                      case "relative":
                        this._isRelative = true;
                        if (this._scheme !== "file") {
                          this._scheme = base._scheme;
                        }
                        if (c === EOF) {
                          this._host = base._host;
                          this._port = base._port;
                          this._path = base._path.slice();
                          this._query = base._query;
                          this._username = base._username;
                          this._password = base._password;
                          break loop;
                        } else if (c === "/" || c === "\\") {
                          if (c === "\\") {
                            err("\\ is an invalid code point.");
                          }
                          state = "relative slash";
                        } else if (c === "?") {
                          this._host = base._host;
                          this._port = base._port;
                          this._path = base._path.slice();
                          this._query = "?";
                          this._username = base._username;
                          this._password = base._password;
                          state = "query";
                        } else if (c === "#") {
                          this._host = base._host;
                          this._port = base._port;
                          this._path = base._path.slice();
                          this._query = base._query;
                          this._fragment = "#";
                          this._username = base._username;
                          this._password = base._password;
                          state = "fragment";
                        } else {
                          var nextC = input[cursor + 1];
                          var nextNextC = input[cursor + 2];
                          if (this._scheme !== "file" || !ALPHA.test(c) || nextC !== ":" && nextC !== "|" || nextNextC !== EOF && nextNextC !== "/" && nextNextC !== "\\" && nextNextC !== "?" && nextNextC !== "#") {
                            this._host = base._host;
                            this._port = base._port;
                            this._username = base._username;
                            this._password = base._password;
                            this._path = base._path.slice();
                            this._path.pop();
                          }
                          state = "relative path";
                          continue;
                        }
                        break;
                      case "relative slash":
                        if (c === "/" || c === "\\") {
                          if (c === "\\") {
                            err("\\ is an invalid code point.");
                          }
                          if (this._scheme === "file") {
                            state = "file host";
                          } else {
                            state = "authority ignore slashes";
                          }
                        } else {
                          if (this._scheme !== "file") {
                            this._host = base._host;
                            this._port = base._port;
                            this._username = base._username;
                            this._password = base._password;
                          }
                          state = "relative path";
                          continue;
                        }
                        break;
                      case "authority first slash":
                        if (c === "/") {
                          state = "authority second slash";
                        } else {
                          err("Expected '/', got: " + c);
                          state = "authority ignore slashes";
                          continue;
                        }
                        break;
                      case "authority second slash":
                        state = "authority ignore slashes";
                        if (c !== "/") {
                          err("Expected '/', got: " + c);
                          continue;
                        }
                        break;
                      case "authority ignore slashes":
                        if (c !== "/" && c !== "\\") {
                          state = "authority";
                          continue;
                        } else {
                          err("Expected authority, got: " + c);
                        }
                        break;
                      case "authority":
                        if (c === "@") {
                          if (seenAt) {
                            err("@ already seen.");
                            buffer += "%40";
                          }
                          seenAt = true;
                          for (var i = 0; i < buffer.length; i++) {
                            var cp = buffer[i];
                            if (cp === "	" || cp === "\n" || cp === "\r") {
                              err("Invalid whitespace in authority.");
                              continue;
                            }
                            if (cp === ":" && this._password === null) {
                              this._password = "";
                              continue;
                            }
                            var tempC = percentEscape(cp);
                            if (this._password !== null) {
                              this._password += tempC;
                            } else {
                              this._username += tempC;
                            }
                          }
                          buffer = "";
                        } else if (c === EOF || c === "/" || c === "\\" || c === "?" || c === "#") {
                          cursor -= buffer.length;
                          buffer = "";
                          state = "host";
                          continue;
                        } else {
                          buffer += c;
                        }
                        break;
                      case "file host":
                        if (c === EOF || c === "/" || c === "\\" || c === "?" || c === "#") {
                          if (buffer.length === 2 && ALPHA.test(buffer[0]) && (buffer[1] === ":" || buffer[1] === "|")) {
                            state = "relative path";
                          } else if (buffer.length === 0) {
                            state = "relative path start";
                          } else {
                            this._host = IDNAToASCII.call(this, buffer);
                            buffer = "";
                            state = "relative path start";
                          }
                          continue;
                        } else if (c === "	" || c === "\n" || c === "\r") {
                          err("Invalid whitespace in file host.");
                        } else {
                          buffer += c;
                        }
                        break;
                      case "host":
                      case "hostname":
                        if (c === ":" && !seenBracket) {
                          this._host = IDNAToASCII.call(this, buffer);
                          buffer = "";
                          state = "port";
                          if (stateOverride === "hostname") {
                            break loop;
                          }
                        } else if (c === EOF || c === "/" || c === "\\" || c === "?" || c === "#") {
                          this._host = IDNAToASCII.call(this, buffer);
                          buffer = "";
                          state = "relative path start";
                          if (stateOverride) {
                            break loop;
                          }
                          continue;
                        } else if (c !== "	" && c !== "\n" && c !== "\r") {
                          if (c === "[") {
                            seenBracket = true;
                          } else if (c === "]") {
                            seenBracket = false;
                          }
                          buffer += c;
                        } else {
                          err("Invalid code point in host/hostname: " + c);
                        }
                        break;
                      case "port":
                        if (/[0-9]/.test(c)) {
                          buffer += c;
                        } else if (c === EOF || c === "/" || c === "\\" || c === "?" || c === "#" || stateOverride) {
                          if (buffer !== "") {
                            var temp = parseInt(buffer, 10);
                            if (temp !== relative[this._scheme]) {
                              this._port = temp + "";
                            }
                            buffer = "";
                          }
                          if (stateOverride) {
                            break loop;
                          }
                          state = "relative path start";
                          continue;
                        } else if (c === "	" || c === "\n" || c === "\r") {
                          err("Invalid code point in port: " + c);
                        } else {
                          invalid.call(this);
                        }
                        break;
                      case "relative path start":
                        if (c === "\\") {
                          err("'\\' not allowed in path.");
                        }
                        state = "relative path";
                        if (c !== "/" && c !== "\\") {
                          continue;
                        }
                        break;
                      case "relative path":
                        if (c === EOF || c === "/" || c === "\\" || !stateOverride && (c === "?" || c === "#")) {
                          if (c === "\\") {
                            err("\\ not allowed in relative path.");
                          }
                          var tmp;
                          if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {
                            buffer = tmp;
                          }
                          if (buffer === "..") {
                            this._path.pop();
                            if (c !== "/" && c !== "\\") {
                              this._path.push("");
                            }
                          } else if (buffer === "." && c !== "/" && c !== "\\") {
                            this._path.push("");
                          } else if (buffer !== ".") {
                            if (this._scheme === "file" && this._path.length === 0 && buffer.length === 2 && ALPHA.test(buffer[0]) && buffer[1] === "|") {
                              buffer = buffer[0] + ":";
                            }
                            this._path.push(buffer);
                          }
                          buffer = "";
                          if (c === "?") {
                            this._query = "?";
                            state = "query";
                          } else if (c === "#") {
                            this._fragment = "#";
                            state = "fragment";
                          }
                        } else if (c !== "	" && c !== "\n" && c !== "\r") {
                          buffer += percentEscape(c);
                        }
                        break;
                      case "query":
                        if (!stateOverride && c === "#") {
                          this._fragment = "#";
                          state = "fragment";
                        } else if (c !== EOF && c !== "	" && c !== "\n" && c !== "\r") {
                          this._query += percentEscapeQuery(c);
                        }
                        break;
                      case "fragment":
                        if (c !== EOF && c !== "	" && c !== "\n" && c !== "\r") {
                          this._fragment += c;
                        }
                        break;
                    }
                    cursor++;
                  }
                }
                function clear() {
                  this._scheme = "";
                  this._schemeData = "";
                  this._username = "";
                  this._password = null;
                  this._host = "";
                  this._port = "";
                  this._path = [];
                  this._query = "";
                  this._fragment = "";
                  this._isInvalid = false;
                  this._isRelative = false;
                }
                function JURL(url, base) {
                  if (base !== void 0 && !(base instanceof JURL)) {
                    base = new JURL(String(base));
                  }
                  this._url = url;
                  clear.call(this);
                  var input = url.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, "");
                  parse.call(this, input, null, base);
                }
                JURL.prototype = {
                  toString: function toString() {
                    return this.href;
                  },
                  get href() {
                    if (this._isInvalid) {
                      return this._url;
                    }
                    var authority = "";
                    if (this._username !== "" || this._password !== null) {
                      authority = this._username + (this._password !== null ? ":" + this._password : "") + "@";
                    }
                    return this.protocol + (this._isRelative ? "//" + authority + this.host : "") + this.pathname + this._query + this._fragment;
                  },
                  set href(value) {
                    clear.call(this);
                    parse.call(this, value);
                  },
                  get protocol() {
                    return this._scheme + ":";
                  },
                  set protocol(value) {
                    if (this._isInvalid) {
                      return;
                    }
                    parse.call(this, value + ":", "scheme start");
                  },
                  get host() {
                    return this._isInvalid ? "" : this._port ? this._host + ":" + this._port : this._host;
                  },
                  set host(value) {
                    if (this._isInvalid || !this._isRelative) {
                      return;
                    }
                    parse.call(this, value, "host");
                  },
                  get hostname() {
                    return this._host;
                  },
                  set hostname(value) {
                    if (this._isInvalid || !this._isRelative) {
                      return;
                    }
                    parse.call(this, value, "hostname");
                  },
                  get port() {
                    return this._port;
                  },
                  set port(value) {
                    if (this._isInvalid || !this._isRelative) {
                      return;
                    }
                    parse.call(this, value, "port");
                  },
                  get pathname() {
                    return this._isInvalid ? "" : this._isRelative ? "/" + this._path.join("/") : this._schemeData;
                  },
                  set pathname(value) {
                    if (this._isInvalid || !this._isRelative) {
                      return;
                    }
                    this._path = [];
                    parse.call(this, value, "relative path start");
                  },
                  get search() {
                    return this._isInvalid || !this._query || this._query === "?" ? "" : this._query;
                  },
                  set search(value) {
                    if (this._isInvalid || !this._isRelative) {
                      return;
                    }
                    this._query = "?";
                    if (value[0] === "?") {
                      value = value.slice(1);
                    }
                    parse.call(this, value, "query");
                  },
                  get hash() {
                    return this._isInvalid || !this._fragment || this._fragment === "#" ? "" : this._fragment;
                  },
                  set hash(value) {
                    if (this._isInvalid) {
                      return;
                    }
                    this._fragment = "#";
                    if (value[0] === "#") {
                      value = value.slice(1);
                    }
                    parse.call(this, value, "fragment");
                  },
                  get origin() {
                    var host;
                    if (this._isInvalid || !this._scheme) {
                      return "";
                    }
                    switch (this._scheme) {
                      case "data":
                      case "file":
                      case "javascript":
                      case "mailto":
                        return "null";
                      case "blob":
                        try {
                          return new JURL(this._schemeData).origin || "null";
                        } catch (_) {
                        }
                        return "null";
                    }
                    host = this.host;
                    if (!host) {
                      return "";
                    }
                    return this._scheme + "://" + host;
                  }
                };
                var OriginalURL = globalScope.URL;
                if (OriginalURL) {
                  JURL.createObjectURL = function(blob) {
                    return OriginalURL.createObjectURL.apply(OriginalURL, arguments);
                  };
                  JURL.revokeObjectURL = function(url) {
                    OriginalURL.revokeObjectURL(url);
                  };
                }
                globalScope.URL = JURL;
              })();
              (function checkObjectValues() {
                if (Object.values) {
                  return;
                }
                Object.values = __w_pdfjs_require__(109);
              })();
            }
          },
          /* 3 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = typeof window !== "undefined" && window.Math === Math ? window : typeof global !== "undefined" && global.Math === Math ? global : typeof self !== "undefined" && self.Math === Math ? self : {};
          },
          /* 4 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            module3.exports = function isNodeJS() {
              return (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process + "" === "[object process]";
            };
          },
          /* 5 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(6);
            module3.exports = __w_pdfjs_require__(9).String.includes;
          },
          /* 6 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(7);
            var context = __w_pdfjs_require__(25);
            var INCLUDES = "includes";
            $export($export.P + $export.F * __w_pdfjs_require__(32)(INCLUDES), "String", {
              includes: function includes(searchString) {
                return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
          },
          /* 7 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var global2 = __w_pdfjs_require__(8);
            var core = __w_pdfjs_require__(9);
            var hide = __w_pdfjs_require__(10);
            var redefine = __w_pdfjs_require__(20);
            var ctx = __w_pdfjs_require__(23);
            var PROTOTYPE = "prototype";
            var $export = function $export2(type, name, source) {
              var IS_FORCED = type & $export2.F;
              var IS_GLOBAL = type & $export2.G;
              var IS_STATIC = type & $export2.S;
              var IS_PROTO = type & $export2.P;
              var IS_BIND = type & $export2.B;
              var target = IS_GLOBAL ? global2 : IS_STATIC ? global2[name] || (global2[name] = {}) : (global2[name] || {})[PROTOTYPE];
              var exports4 = IS_GLOBAL ? core : core[name] || (core[name] = {});
              var expProto = exports4[PROTOTYPE] || (exports4[PROTOTYPE] = {});
              var key, own, out, exp;
              if (IS_GLOBAL) source = name;
              for (key in source) {
                own = !IS_FORCED && target && target[key] !== void 0;
                out = (own ? target : source)[key];
                exp = IS_BIND && own ? ctx(out, global2) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
                if (target) redefine(target, key, out, type & $export2.U);
                if (exports4[key] != out) hide(exports4, key, exp);
                if (IS_PROTO && expProto[key] != out) expProto[key] = out;
              }
            };
            global2.core = core;
            $export.F = 1;
            $export.G = 2;
            $export.S = 4;
            $export.P = 8;
            $export.B = 16;
            $export.W = 32;
            $export.U = 64;
            $export.R = 128;
            module3.exports = $export;
          },
          /* 8 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var global2 = module3.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
            if (typeof __g == "number") __g = global2;
          },
          /* 9 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var core = module3.exports = { version: "2.5.7" };
            if (typeof __e == "number") __e = core;
          },
          /* 10 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var dP = __w_pdfjs_require__(11);
            var createDesc = __w_pdfjs_require__(19);
            module3.exports = __w_pdfjs_require__(15) ? function(object, key, value) {
              return dP.f(object, key, createDesc(1, value));
            } : function(object, key, value) {
              object[key] = value;
              return object;
            };
          },
          /* 11 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var anObject = __w_pdfjs_require__(12);
            var IE8_DOM_DEFINE = __w_pdfjs_require__(14);
            var toPrimitive = __w_pdfjs_require__(18);
            var dP = Object.defineProperty;
            exports3.f = __w_pdfjs_require__(15) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
              anObject(O);
              P = toPrimitive(P, true);
              anObject(Attributes);
              if (IE8_DOM_DEFINE) try {
                return dP(O, P, Attributes);
              } catch (e) {
              }
              if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
              if ("value" in Attributes) O[P] = Attributes.value;
              return O;
            };
          },
          /* 12 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(13);
            module3.exports = function(it) {
              if (!isObject(it)) throw TypeError(it + " is not an object!");
              return it;
            };
          },
          /* 13 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            module3.exports = function(it) {
              return (typeof it === "undefined" ? "undefined" : _typeof(it)) === "object" ? it !== null : typeof it === "function";
            };
          },
          /* 14 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = !__w_pdfjs_require__(15) && !__w_pdfjs_require__(16)(function() {
              return Object.defineProperty(__w_pdfjs_require__(17)("div"), "a", {
                get: function get() {
                  return 7;
                }
              }).a != 7;
            });
          },
          /* 15 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = !__w_pdfjs_require__(16)(function() {
              return Object.defineProperty({}, "a", {
                get: function get() {
                  return 7;
                }
              }).a != 7;
            });
          },
          /* 16 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = function(exec) {
              try {
                return !!exec();
              } catch (e) {
                return true;
              }
            };
          },
          /* 17 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(13);
            var document2 = __w_pdfjs_require__(8).document;
            var is = isObject(document2) && isObject(document2.createElement);
            module3.exports = function(it) {
              return is ? document2.createElement(it) : {};
            };
          },
          /* 18 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(13);
            module3.exports = function(it, S) {
              if (!isObject(it)) return it;
              var fn, val;
              if (S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it))) return val;
              if (typeof (fn = it.valueOf) == "function" && !isObject(val = fn.call(it))) return val;
              if (!S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it))) return val;
              throw TypeError("Can't convert object to primitive value");
            };
          },
          /* 19 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = function(bitmap, value) {
              return {
                enumerable: !(bitmap & 1),
                configurable: !(bitmap & 2),
                writable: !(bitmap & 4),
                value
              };
            };
          },
          /* 20 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var global2 = __w_pdfjs_require__(8);
            var hide = __w_pdfjs_require__(10);
            var has = __w_pdfjs_require__(21);
            var SRC = __w_pdfjs_require__(22)("src");
            var TO_STRING = "toString";
            var $toString = Function[TO_STRING];
            var TPL = ("" + $toString).split(TO_STRING);
            __w_pdfjs_require__(9).inspectSource = function(it) {
              return $toString.call(it);
            };
            (module3.exports = function(O, key, val, safe) {
              var isFunction = typeof val == "function";
              if (isFunction) has(val, "name") || hide(val, "name", key);
              if (O[key] === val) return;
              if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? "" + O[key] : TPL.join(String(key)));
              if (O === global2) {
                O[key] = val;
              } else if (!safe) {
                delete O[key];
                hide(O, key, val);
              } else if (O[key]) {
                O[key] = val;
              } else {
                hide(O, key, val);
              }
            })(Function.prototype, TO_STRING, function toString() {
              return typeof this == "function" && this[SRC] || $toString.call(this);
            });
          },
          /* 21 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var hasOwnProperty = {}.hasOwnProperty;
            module3.exports = function(it, key) {
              return hasOwnProperty.call(it, key);
            };
          },
          /* 22 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var id = 0;
            var px = Math.random();
            module3.exports = function(key) {
              return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
            };
          },
          /* 23 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var aFunction = __w_pdfjs_require__(24);
            module3.exports = function(fn, that, length) {
              aFunction(fn);
              if (that === void 0) return fn;
              switch (length) {
                case 1:
                  return function(a) {
                    return fn.call(that, a);
                  };
                case 2:
                  return function(a, b) {
                    return fn.call(that, a, b);
                  };
                case 3:
                  return function(a, b, c) {
                    return fn.call(that, a, b, c);
                  };
              }
              return function() {
                return fn.apply(that, arguments);
              };
            };
          },
          /* 24 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = function(it) {
              if (typeof it != "function") throw TypeError(it + " is not a function!");
              return it;
            };
          },
          /* 25 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isRegExp = __w_pdfjs_require__(26);
            var defined = __w_pdfjs_require__(31);
            module3.exports = function(that, searchString, NAME) {
              if (isRegExp(searchString)) throw TypeError("String#" + NAME + " doesn't accept regex!");
              return String(defined(that));
            };
          },
          /* 26 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(13);
            var cof = __w_pdfjs_require__(27);
            var MATCH = __w_pdfjs_require__(28)("match");
            module3.exports = function(it) {
              var isRegExp;
              return isObject(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : cof(it) == "RegExp");
            };
          },
          /* 27 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var toString = {}.toString;
            module3.exports = function(it) {
              return toString.call(it).slice(8, -1);
            };
          },
          /* 28 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var store = __w_pdfjs_require__(29)("wks");
            var uid = __w_pdfjs_require__(22);
            var _Symbol = __w_pdfjs_require__(8).Symbol;
            var USE_SYMBOL = typeof _Symbol == "function";
            var $exports = module3.exports = function(name) {
              return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)("Symbol." + name));
            };
            $exports.store = store;
          },
          /* 29 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var core = __w_pdfjs_require__(9);
            var global2 = __w_pdfjs_require__(8);
            var SHARED = "__core-js_shared__";
            var store = global2[SHARED] || (global2[SHARED] = {});
            (module3.exports = function(key, value) {
              return store[key] || (store[key] = value !== void 0 ? value : {});
            })("versions", []).push({
              version: core.version,
              mode: __w_pdfjs_require__(30) ? "pure" : "global",
              copyright: "© 2018 Denis Pushkarev (zloirock.ru)"
            });
          },
          /* 30 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = false;
          },
          /* 31 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = function(it) {
              if (it == void 0) throw TypeError("Can't call method on  " + it);
              return it;
            };
          },
          /* 32 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var MATCH = __w_pdfjs_require__(28)("match");
            module3.exports = function(KEY) {
              var re = /./;
              try {
                "/./"[KEY](re);
              } catch (e) {
                try {
                  re[MATCH] = false;
                  return !"/./"[KEY](re);
                } catch (f) {
                }
              }
              return true;
            };
          },
          /* 33 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(34);
            module3.exports = __w_pdfjs_require__(9).Array.includes;
          },
          /* 34 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(7);
            var $includes = __w_pdfjs_require__(35)(true);
            $export($export.P, "Array", {
              includes: function includes(el) {
                return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
            __w_pdfjs_require__(41)("includes");
          },
          /* 35 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var toIObject = __w_pdfjs_require__(36);
            var toLength = __w_pdfjs_require__(38);
            var toAbsoluteIndex = __w_pdfjs_require__(40);
            module3.exports = function(IS_INCLUDES) {
              return function($this, el, fromIndex) {
                var O = toIObject($this);
                var length = toLength(O.length);
                var index = toAbsoluteIndex(fromIndex, length);
                var value;
                if (IS_INCLUDES && el != el) while (length > index) {
                  value = O[index++];
                  if (value != value) return true;
                }
                else for (; length > index; index++) {
                  if (IS_INCLUDES || index in O) {
                    if (O[index] === el) return IS_INCLUDES || index || 0;
                  }
                }
                return !IS_INCLUDES && -1;
              };
            };
          },
          /* 36 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var IObject = __w_pdfjs_require__(37);
            var defined = __w_pdfjs_require__(31);
            module3.exports = function(it) {
              return IObject(defined(it));
            };
          },
          /* 37 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var cof = __w_pdfjs_require__(27);
            module3.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
              return cof(it) == "String" ? it.split("") : Object(it);
            };
          },
          /* 38 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var toInteger = __w_pdfjs_require__(39);
            var min = Math.min;
            module3.exports = function(it) {
              return it > 0 ? min(toInteger(it), 9007199254740991) : 0;
            };
          },
          /* 39 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var ceil = Math.ceil;
            var floor = Math.floor;
            module3.exports = function(it) {
              return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
            };
          },
          /* 40 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var toInteger = __w_pdfjs_require__(39);
            var max = Math.max;
            var min = Math.min;
            module3.exports = function(index, length) {
              index = toInteger(index);
              return index < 0 ? max(index + length, 0) : min(index, length);
            };
          },
          /* 41 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var UNSCOPABLES = __w_pdfjs_require__(28)("unscopables");
            var ArrayProto = Array.prototype;
            if (ArrayProto[UNSCOPABLES] == void 0) __w_pdfjs_require__(10)(ArrayProto, UNSCOPABLES, {});
            module3.exports = function(key) {
              ArrayProto[UNSCOPABLES][key] = true;
            };
          },
          /* 42 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(43);
            module3.exports = __w_pdfjs_require__(9).Math.log2;
          },
          /* 43 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(7);
            $export($export.S, "Math", {
              log2: function log2(x) {
                return Math.log(x) / Math.LN2;
              }
            });
          },
          /* 44 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(45);
            module3.exports = __w_pdfjs_require__(9).Number.isNaN;
          },
          /* 45 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(7);
            $export($export.S, "Number", {
              isNaN: function isNaN2(number) {
                return number != number;
              }
            });
          },
          /* 46 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(47);
            module3.exports = __w_pdfjs_require__(9).Number.isInteger;
          },
          /* 47 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(7);
            $export($export.S, "Number", { isInteger: __w_pdfjs_require__(48) });
          },
          /* 48 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(13);
            var floor = Math.floor;
            module3.exports = function isInteger(it) {
              return !isObject(it) && isFinite(it) && floor(it) === it;
            };
          },
          /* 49 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(50);
            __w_pdfjs_require__(52);
            __w_pdfjs_require__(67);
            __w_pdfjs_require__(70);
            __w_pdfjs_require__(87);
            __w_pdfjs_require__(88);
            module3.exports = __w_pdfjs_require__(9).Promise;
          },
          /* 50 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var classof = __w_pdfjs_require__(51);
            var test = {};
            test[__w_pdfjs_require__(28)("toStringTag")] = "z";
            if (test + "" != "[object z]") {
              __w_pdfjs_require__(20)(Object.prototype, "toString", function toString() {
                return "[object " + classof(this) + "]";
              }, true);
            }
          },
          /* 51 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var cof = __w_pdfjs_require__(27);
            var TAG = __w_pdfjs_require__(28)("toStringTag");
            var ARG = cof(/* @__PURE__ */ function() {
              return arguments;
            }()) == "Arguments";
            var tryGet = function tryGet2(it, key) {
              try {
                return it[key];
              } catch (e) {
              }
            };
            module3.exports = function(it) {
              var O, T, B;
              return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T = tryGet(O = Object(it), TAG)) == "string" ? T : ARG ? cof(O) : (B = cof(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
            };
          },
          /* 52 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $at = __w_pdfjs_require__(53)(true);
            __w_pdfjs_require__(54)(String, "String", function(iterated) {
              this._t = String(iterated);
              this._i = 0;
            }, function() {
              var O = this._t;
              var index = this._i;
              var point;
              if (index >= O.length) return {
                value: void 0,
                done: true
              };
              point = $at(O, index);
              this._i += point.length;
              return {
                value: point,
                done: false
              };
            });
          },
          /* 53 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var toInteger = __w_pdfjs_require__(39);
            var defined = __w_pdfjs_require__(31);
            module3.exports = function(TO_STRING) {
              return function(that, pos) {
                var s = String(defined(that));
                var i = toInteger(pos);
                var l = s.length;
                var a, b;
                if (i < 0 || i >= l) return TO_STRING ? "" : void 0;
                a = s.charCodeAt(i);
                return a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
              };
            };
          },
          /* 54 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var LIBRARY = __w_pdfjs_require__(30);
            var $export = __w_pdfjs_require__(7);
            var redefine = __w_pdfjs_require__(20);
            var hide = __w_pdfjs_require__(10);
            var Iterators = __w_pdfjs_require__(55);
            var $iterCreate = __w_pdfjs_require__(56);
            var setToStringTag = __w_pdfjs_require__(64);
            var getPrototypeOf = __w_pdfjs_require__(65);
            var ITERATOR = __w_pdfjs_require__(28)("iterator");
            var BUGGY = !([].keys && "next" in [].keys());
            var FF_ITERATOR = "@@iterator";
            var KEYS = "keys";
            var VALUES = "values";
            var returnThis = function returnThis2() {
              return this;
            };
            module3.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
              $iterCreate(Constructor, NAME, next);
              var getMethod = function getMethod2(kind) {
                if (!BUGGY && kind in proto) return proto[kind];
                switch (kind) {
                  case KEYS:
                    return function keys() {
                      return new Constructor(this, kind);
                    };
                  case VALUES:
                    return function values() {
                      return new Constructor(this, kind);
                    };
                }
                return function entries() {
                  return new Constructor(this, kind);
                };
              };
              var TAG = NAME + " Iterator";
              var DEF_VALUES = DEFAULT == VALUES;
              var VALUES_BUG = false;
              var proto = Base.prototype;
              var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
              var $default = $native || getMethod(DEFAULT);
              var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : void 0;
              var $anyNative = NAME == "Array" ? proto.entries || $native : $native;
              var methods, key, IteratorPrototype;
              if ($anyNative) {
                IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
                if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
                  setToStringTag(IteratorPrototype, TAG, true);
                  if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != "function") hide(IteratorPrototype, ITERATOR, returnThis);
                }
              }
              if (DEF_VALUES && $native && $native.name !== VALUES) {
                VALUES_BUG = true;
                $default = function values() {
                  return $native.call(this);
                };
              }
              if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
                hide(proto, ITERATOR, $default);
              }
              Iterators[NAME] = $default;
              Iterators[TAG] = returnThis;
              if (DEFAULT) {
                methods = {
                  values: DEF_VALUES ? $default : getMethod(VALUES),
                  keys: IS_SET ? $default : getMethod(KEYS),
                  entries: $entries
                };
                if (FORCED) for (key in methods) {
                  if (!(key in proto)) redefine(proto, key, methods[key]);
                }
                else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
              }
              return methods;
            };
          },
          /* 55 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = {};
          },
          /* 56 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var create = __w_pdfjs_require__(57);
            var descriptor = __w_pdfjs_require__(19);
            var setToStringTag = __w_pdfjs_require__(64);
            var IteratorPrototype = {};
            __w_pdfjs_require__(10)(IteratorPrototype, __w_pdfjs_require__(28)("iterator"), function() {
              return this;
            });
            module3.exports = function(Constructor, NAME, next) {
              Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
              setToStringTag(Constructor, NAME + " Iterator");
            };
          },
          /* 57 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var anObject = __w_pdfjs_require__(12);
            var dPs = __w_pdfjs_require__(58);
            var enumBugKeys = __w_pdfjs_require__(62);
            var IE_PROTO = __w_pdfjs_require__(61)("IE_PROTO");
            var Empty = function Empty2() {
            };
            var PROTOTYPE = "prototype";
            var _createDict = function createDict() {
              var iframe = __w_pdfjs_require__(17)("iframe");
              var i = enumBugKeys.length;
              var lt = "<";
              var gt = ">";
              var iframeDocument;
              iframe.style.display = "none";
              __w_pdfjs_require__(63).appendChild(iframe);
              iframe.src = "javascript:";
              iframeDocument = iframe.contentWindow.document;
              iframeDocument.open();
              iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
              iframeDocument.close();
              _createDict = iframeDocument.F;
              while (i--) {
                delete _createDict[PROTOTYPE][enumBugKeys[i]];
              }
              return _createDict();
            };
            module3.exports = Object.create || function create(O, Properties) {
              var result;
              if (O !== null) {
                Empty[PROTOTYPE] = anObject(O);
                result = new Empty();
                Empty[PROTOTYPE] = null;
                result[IE_PROTO] = O;
              } else result = _createDict();
              return Properties === void 0 ? result : dPs(result, Properties);
            };
          },
          /* 58 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var dP = __w_pdfjs_require__(11);
            var anObject = __w_pdfjs_require__(12);
            var getKeys = __w_pdfjs_require__(59);
            module3.exports = __w_pdfjs_require__(15) ? Object.defineProperties : function defineProperties(O, Properties) {
              anObject(O);
              var keys = getKeys(Properties);
              var length = keys.length;
              var i = 0;
              var P;
              while (length > i) {
                dP.f(O, P = keys[i++], Properties[P]);
              }
              return O;
            };
          },
          /* 59 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $keys = __w_pdfjs_require__(60);
            var enumBugKeys = __w_pdfjs_require__(62);
            module3.exports = Object.keys || function keys(O) {
              return $keys(O, enumBugKeys);
            };
          },
          /* 60 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var has = __w_pdfjs_require__(21);
            var toIObject = __w_pdfjs_require__(36);
            var arrayIndexOf = __w_pdfjs_require__(35)(false);
            var IE_PROTO = __w_pdfjs_require__(61)("IE_PROTO");
            module3.exports = function(object, names) {
              var O = toIObject(object);
              var i = 0;
              var result = [];
              var key;
              for (key in O) {
                if (key != IE_PROTO) has(O, key) && result.push(key);
              }
              while (names.length > i) {
                if (has(O, key = names[i++])) {
                  ~arrayIndexOf(result, key) || result.push(key);
                }
              }
              return result;
            };
          },
          /* 61 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var shared = __w_pdfjs_require__(29)("keys");
            var uid = __w_pdfjs_require__(22);
            module3.exports = function(key) {
              return shared[key] || (shared[key] = uid(key));
            };
          },
          /* 62 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
          },
          /* 63 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var document2 = __w_pdfjs_require__(8).document;
            module3.exports = document2 && document2.documentElement;
          },
          /* 64 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var def = __w_pdfjs_require__(11).f;
            var has = __w_pdfjs_require__(21);
            var TAG = __w_pdfjs_require__(28)("toStringTag");
            module3.exports = function(it, tag, stat) {
              if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
                configurable: true,
                value: tag
              });
            };
          },
          /* 65 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var has = __w_pdfjs_require__(21);
            var toObject = __w_pdfjs_require__(66);
            var IE_PROTO = __w_pdfjs_require__(61)("IE_PROTO");
            var ObjectProto = Object.prototype;
            module3.exports = Object.getPrototypeOf || function(O) {
              O = toObject(O);
              if (has(O, IE_PROTO)) return O[IE_PROTO];
              if (typeof O.constructor == "function" && O instanceof O.constructor) {
                return O.constructor.prototype;
              }
              return O instanceof Object ? ObjectProto : null;
            };
          },
          /* 66 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var defined = __w_pdfjs_require__(31);
            module3.exports = function(it) {
              return Object(defined(it));
            };
          },
          /* 67 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $iterators = __w_pdfjs_require__(68);
            var getKeys = __w_pdfjs_require__(59);
            var redefine = __w_pdfjs_require__(20);
            var global2 = __w_pdfjs_require__(8);
            var hide = __w_pdfjs_require__(10);
            var Iterators = __w_pdfjs_require__(55);
            var wks = __w_pdfjs_require__(28);
            var ITERATOR = wks("iterator");
            var TO_STRING_TAG = wks("toStringTag");
            var ArrayValues = Iterators.Array;
            var DOMIterables = {
              CSSRuleList: true,
              CSSStyleDeclaration: false,
              CSSValueList: false,
              ClientRectList: false,
              DOMRectList: false,
              DOMStringList: false,
              DOMTokenList: true,
              DataTransferItemList: false,
              FileList: false,
              HTMLAllCollection: false,
              HTMLCollection: false,
              HTMLFormElement: false,
              HTMLSelectElement: false,
              MediaList: true,
              MimeTypeArray: false,
              NamedNodeMap: false,
              NodeList: true,
              PaintRequestList: false,
              Plugin: false,
              PluginArray: false,
              SVGLengthList: false,
              SVGNumberList: false,
              SVGPathSegList: false,
              SVGPointList: false,
              SVGStringList: false,
              SVGTransformList: false,
              SourceBufferList: false,
              StyleSheetList: true,
              TextTrackCueList: false,
              TextTrackList: false,
              TouchList: false
            };
            for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
              var NAME = collections[i];
              var explicit = DOMIterables[NAME];
              var Collection = global2[NAME];
              var proto = Collection && Collection.prototype;
              var key;
              if (proto) {
                if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
                if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
                Iterators[NAME] = ArrayValues;
                if (explicit) for (key in $iterators) {
                  if (!proto[key]) redefine(proto, key, $iterators[key], true);
                }
              }
            }
          },
          /* 68 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var addToUnscopables = __w_pdfjs_require__(41);
            var step = __w_pdfjs_require__(69);
            var Iterators = __w_pdfjs_require__(55);
            var toIObject = __w_pdfjs_require__(36);
            module3.exports = __w_pdfjs_require__(54)(Array, "Array", function(iterated, kind) {
              this._t = toIObject(iterated);
              this._i = 0;
              this._k = kind;
            }, function() {
              var O = this._t;
              var kind = this._k;
              var index = this._i++;
              if (!O || index >= O.length) {
                this._t = void 0;
                return step(1);
              }
              if (kind == "keys") return step(0, index);
              if (kind == "values") return step(0, O[index]);
              return step(0, [index, O[index]]);
            }, "values");
            Iterators.Arguments = Iterators.Array;
            addToUnscopables("keys");
            addToUnscopables("values");
            addToUnscopables("entries");
          },
          /* 69 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = function(done, value) {
              return {
                value,
                done: !!done
              };
            };
          },
          /* 70 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var LIBRARY = __w_pdfjs_require__(30);
            var global2 = __w_pdfjs_require__(8);
            var ctx = __w_pdfjs_require__(23);
            var classof = __w_pdfjs_require__(51);
            var $export = __w_pdfjs_require__(7);
            var isObject = __w_pdfjs_require__(13);
            var aFunction = __w_pdfjs_require__(24);
            var anInstance = __w_pdfjs_require__(71);
            var forOf = __w_pdfjs_require__(72);
            var speciesConstructor = __w_pdfjs_require__(76);
            var task = __w_pdfjs_require__(77).set;
            var microtask = __w_pdfjs_require__(79)();
            var newPromiseCapabilityModule = __w_pdfjs_require__(80);
            var perform = __w_pdfjs_require__(81);
            var userAgent = __w_pdfjs_require__(82);
            var promiseResolve = __w_pdfjs_require__(83);
            var PROMISE = "Promise";
            var TypeError2 = global2.TypeError;
            var process2 = global2.process;
            var versions = process2 && process2.versions;
            var v8 = versions && versions.v8 || "";
            var $Promise = global2[PROMISE];
            var isNode = classof(process2) == "process";
            var empty = function empty2() {
            };
            var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
            var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
            var USE_NATIVE = !!function() {
              try {
                var promise = $Promise.resolve(1);
                var FakePromise = (promise.constructor = {})[__w_pdfjs_require__(28)("species")] = function(exec) {
                  exec(empty, empty);
                };
                return (isNode || typeof PromiseRejectionEvent == "function") && promise.then(empty) instanceof FakePromise && v8.indexOf("6.6") !== 0 && userAgent.indexOf("Chrome/66") === -1;
              } catch (e) {
              }
            }();
            var isThenable = function isThenable2(it) {
              var then;
              return isObject(it) && typeof (then = it.then) == "function" ? then : false;
            };
            var notify = function notify2(promise, isReject) {
              if (promise._n) return;
              promise._n = true;
              var chain = promise._c;
              microtask(function() {
                var value = promise._v;
                var ok = promise._s == 1;
                var i = 0;
                var run = function run2(reaction) {
                  var handler = ok ? reaction.ok : reaction.fail;
                  var resolve2 = reaction.resolve;
                  var reject2 = reaction.reject;
                  var domain = reaction.domain;
                  var result, then, exited;
                  try {
                    if (handler) {
                      if (!ok) {
                        if (promise._h == 2) onHandleUnhandled(promise);
                        promise._h = 1;
                      }
                      if (handler === true) result = value;
                      else {
                        if (domain) domain.enter();
                        result = handler(value);
                        if (domain) {
                          domain.exit();
                          exited = true;
                        }
                      }
                      if (result === reaction.promise) {
                        reject2(TypeError2("Promise-chain cycle"));
                      } else if (then = isThenable(result)) {
                        then.call(result, resolve2, reject2);
                      } else resolve2(result);
                    } else reject2(value);
                  } catch (e) {
                    if (domain && !exited) domain.exit();
                    reject2(e);
                  }
                };
                while (chain.length > i) {
                  run(chain[i++]);
                }
                promise._c = [];
                promise._n = false;
                if (isReject && !promise._h) onUnhandled(promise);
              });
            };
            var onUnhandled = function onUnhandled2(promise) {
              task.call(global2, function() {
                var value = promise._v;
                var unhandled = isUnhandled(promise);
                var result, handler, console2;
                if (unhandled) {
                  result = perform(function() {
                    if (isNode) {
                      process2.emit("unhandledRejection", value, promise);
                    } else if (handler = global2.onunhandledrejection) {
                      handler({
                        promise,
                        reason: value
                      });
                    } else if ((console2 = global2.console) && console2.error) {
                      console2.error("Unhandled promise rejection", value);
                    }
                  });
                  promise._h = isNode || isUnhandled(promise) ? 2 : 1;
                }
                promise._a = void 0;
                if (unhandled && result.e) throw result.v;
              });
            };
            var isUnhandled = function isUnhandled2(promise) {
              return promise._h !== 1 && (promise._a || promise._c).length === 0;
            };
            var onHandleUnhandled = function onHandleUnhandled2(promise) {
              task.call(global2, function() {
                var handler;
                if (isNode) {
                  process2.emit("rejectionHandled", promise);
                } else if (handler = global2.onrejectionhandled) {
                  handler({
                    promise,
                    reason: promise._v
                  });
                }
              });
            };
            var $reject = function $reject2(value) {
              var promise = this;
              if (promise._d) return;
              promise._d = true;
              promise = promise._w || promise;
              promise._v = value;
              promise._s = 2;
              if (!promise._a) promise._a = promise._c.slice();
              notify(promise, true);
            };
            var $resolve = function $resolve2(value) {
              var promise = this;
              var then;
              if (promise._d) return;
              promise._d = true;
              promise = promise._w || promise;
              try {
                if (promise === value) throw TypeError2("Promise can't be resolved itself");
                if (then = isThenable(value)) {
                  microtask(function() {
                    var wrapper = {
                      _w: promise,
                      _d: false
                    };
                    try {
                      then.call(value, ctx($resolve2, wrapper, 1), ctx($reject, wrapper, 1));
                    } catch (e) {
                      $reject.call(wrapper, e);
                    }
                  });
                } else {
                  promise._v = value;
                  promise._s = 1;
                  notify(promise, false);
                }
              } catch (e) {
                $reject.call({
                  _w: promise,
                  _d: false
                }, e);
              }
            };
            if (!USE_NATIVE) {
              $Promise = function Promise2(executor) {
                anInstance(this, $Promise, PROMISE, "_h");
                aFunction(executor);
                Internal.call(this);
                try {
                  executor(ctx($resolve, this, 1), ctx($reject, this, 1));
                } catch (err) {
                  $reject.call(this, err);
                }
              };
              Internal = function Promise2(executor) {
                this._c = [];
                this._a = void 0;
                this._s = 0;
                this._d = false;
                this._v = void 0;
                this._h = 0;
                this._n = false;
              };
              Internal.prototype = __w_pdfjs_require__(84)($Promise.prototype, {
                then: function then(onFulfilled, onRejected) {
                  var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
                  reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
                  reaction.fail = typeof onRejected == "function" && onRejected;
                  reaction.domain = isNode ? process2.domain : void 0;
                  this._c.push(reaction);
                  if (this._a) this._a.push(reaction);
                  if (this._s) notify(this, false);
                  return reaction.promise;
                },
                "catch": function _catch(onRejected) {
                  return this.then(void 0, onRejected);
                }
              });
              OwnPromiseCapability = function OwnPromiseCapability2() {
                var promise = new Internal();
                this.promise = promise;
                this.resolve = ctx($resolve, promise, 1);
                this.reject = ctx($reject, promise, 1);
              };
              newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability2(C) {
                return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
              };
            }
            $export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
            __w_pdfjs_require__(64)($Promise, PROMISE);
            __w_pdfjs_require__(85)(PROMISE);
            Wrapper = __w_pdfjs_require__(9)[PROMISE];
            $export($export.S + $export.F * !USE_NATIVE, PROMISE, {
              reject: function reject2(r) {
                var capability = newPromiseCapability(this);
                var $$reject = capability.reject;
                $$reject(r);
                return capability.promise;
              }
            });
            $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
              resolve: function resolve2(x) {
                return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
              }
            });
            $export($export.S + $export.F * !(USE_NATIVE && __w_pdfjs_require__(86)(function(iter) {
              $Promise.all(iter)["catch"](empty);
            })), PROMISE, {
              all: function all(iterable) {
                var C = this;
                var capability = newPromiseCapability(C);
                var resolve2 = capability.resolve;
                var reject2 = capability.reject;
                var result = perform(function() {
                  var values = [];
                  var index = 0;
                  var remaining = 1;
                  forOf(iterable, false, function(promise) {
                    var $index = index++;
                    var alreadyCalled = false;
                    values.push(void 0);
                    remaining++;
                    C.resolve(promise).then(function(value) {
                      if (alreadyCalled) return;
                      alreadyCalled = true;
                      values[$index] = value;
                      --remaining || resolve2(values);
                    }, reject2);
                  });
                  --remaining || resolve2(values);
                });
                if (result.e) reject2(result.v);
                return capability.promise;
              },
              race: function race(iterable) {
                var C = this;
                var capability = newPromiseCapability(C);
                var reject2 = capability.reject;
                var result = perform(function() {
                  forOf(iterable, false, function(promise) {
                    C.resolve(promise).then(capability.resolve, reject2);
                  });
                });
                if (result.e) reject2(result.v);
                return capability.promise;
              }
            });
          },
          /* 71 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = function(it, Constructor, name, forbiddenField) {
              if (!(it instanceof Constructor) || forbiddenField !== void 0 && forbiddenField in it) {
                throw TypeError(name + ": incorrect invocation!");
              }
              return it;
            };
          },
          /* 72 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var ctx = __w_pdfjs_require__(23);
            var call = __w_pdfjs_require__(73);
            var isArrayIter = __w_pdfjs_require__(74);
            var anObject = __w_pdfjs_require__(12);
            var toLength = __w_pdfjs_require__(38);
            var getIterFn = __w_pdfjs_require__(75);
            var BREAK = {};
            var RETURN = {};
            var _exports = module3.exports = function(iterable, entries, fn, that, ITERATOR) {
              var iterFn = ITERATOR ? function() {
                return iterable;
              } : getIterFn(iterable);
              var f = ctx(fn, that, entries ? 2 : 1);
              var index = 0;
              var length, step, iterator, result;
              if (typeof iterFn != "function") throw TypeError(iterable + " is not iterable!");
              if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
                result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
                if (result === BREAK || result === RETURN) return result;
              }
              else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
                result = call(iterator, f, step.value, entries);
                if (result === BREAK || result === RETURN) return result;
              }
            };
            _exports.BREAK = BREAK;
            _exports.RETURN = RETURN;
          },
          /* 73 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var anObject = __w_pdfjs_require__(12);
            module3.exports = function(iterator, fn, value, entries) {
              try {
                return entries ? fn(anObject(value)[0], value[1]) : fn(value);
              } catch (e) {
                var ret = iterator["return"];
                if (ret !== void 0) anObject(ret.call(iterator));
                throw e;
              }
            };
          },
          /* 74 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var Iterators = __w_pdfjs_require__(55);
            var ITERATOR = __w_pdfjs_require__(28)("iterator");
            var ArrayProto = Array.prototype;
            module3.exports = function(it) {
              return it !== void 0 && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
            };
          },
          /* 75 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var classof = __w_pdfjs_require__(51);
            var ITERATOR = __w_pdfjs_require__(28)("iterator");
            var Iterators = __w_pdfjs_require__(55);
            module3.exports = __w_pdfjs_require__(9).getIteratorMethod = function(it) {
              if (it != void 0) return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
            };
          },
          /* 76 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var anObject = __w_pdfjs_require__(12);
            var aFunction = __w_pdfjs_require__(24);
            var SPECIES = __w_pdfjs_require__(28)("species");
            module3.exports = function(O, D) {
              var C = anObject(O).constructor;
              var S;
              return C === void 0 || (S = anObject(C)[SPECIES]) == void 0 ? D : aFunction(S);
            };
          },
          /* 77 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var ctx = __w_pdfjs_require__(23);
            var invoke = __w_pdfjs_require__(78);
            var html = __w_pdfjs_require__(63);
            var cel = __w_pdfjs_require__(17);
            var global2 = __w_pdfjs_require__(8);
            var process2 = global2.process;
            var setTask = global2.setImmediate;
            var clearTask = global2.clearImmediate;
            var MessageChannel = global2.MessageChannel;
            var Dispatch = global2.Dispatch;
            var counter = 0;
            var queue = {};
            var ONREADYSTATECHANGE = "onreadystatechange";
            var defer, channel, port;
            var run = function run2() {
              var id = +this;
              if (queue.hasOwnProperty(id)) {
                var fn = queue[id];
                delete queue[id];
                fn();
              }
            };
            var listener = function listener2(event) {
              run.call(event.data);
            };
            if (!setTask || !clearTask) {
              setTask = function setImmediate2(fn) {
                var args = [];
                var i = 1;
                while (arguments.length > i) {
                  args.push(arguments[i++]);
                }
                queue[++counter] = function() {
                  invoke(typeof fn == "function" ? fn : Function(fn), args);
                };
                defer(counter);
                return counter;
              };
              clearTask = function clearImmediate(id) {
                delete queue[id];
              };
              if (__w_pdfjs_require__(27)(process2) == "process") {
                defer = function defer2(id) {
                  process2.nextTick(ctx(run, id, 1));
                };
              } else if (Dispatch && Dispatch.now) {
                defer = function defer2(id) {
                  Dispatch.now(ctx(run, id, 1));
                };
              } else if (MessageChannel) {
                channel = new MessageChannel();
                port = channel.port2;
                channel.port1.onmessage = listener;
                defer = ctx(port.postMessage, port, 1);
              } else if (global2.addEventListener && typeof postMessage == "function" && !global2.importScripts) {
                defer = function defer2(id) {
                  global2.postMessage(id + "", "*");
                };
                global2.addEventListener("message", listener, false);
              } else if (ONREADYSTATECHANGE in cel("script")) {
                defer = function defer2(id) {
                  html.appendChild(cel("script"))[ONREADYSTATECHANGE] = function() {
                    html.removeChild(this);
                    run.call(id);
                  };
                };
              } else {
                defer = function defer2(id) {
                  setTimeout(ctx(run, id, 1), 0);
                };
              }
            }
            module3.exports = {
              set: setTask,
              clear: clearTask
            };
          },
          /* 78 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = function(fn, args, that) {
              var un = that === void 0;
              switch (args.length) {
                case 0:
                  return un ? fn() : fn.call(that);
                case 1:
                  return un ? fn(args[0]) : fn.call(that, args[0]);
                case 2:
                  return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
                case 3:
                  return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
                case 4:
                  return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
              }
              return fn.apply(that, args);
            };
          },
          /* 79 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var global2 = __w_pdfjs_require__(8);
            var macrotask = __w_pdfjs_require__(77).set;
            var Observer = global2.MutationObserver || global2.WebKitMutationObserver;
            var process2 = global2.process;
            var Promise2 = global2.Promise;
            var isNode = __w_pdfjs_require__(27)(process2) == "process";
            module3.exports = function() {
              var head, last, notify;
              var flush = function flush2() {
                var parent, fn;
                if (isNode && (parent = process2.domain)) parent.exit();
                while (head) {
                  fn = head.fn;
                  head = head.next;
                  try {
                    fn();
                  } catch (e) {
                    if (head) notify();
                    else last = void 0;
                    throw e;
                  }
                }
                last = void 0;
                if (parent) parent.enter();
              };
              if (isNode) {
                notify = function notify2() {
                  process2.nextTick(flush);
                };
              } else if (Observer && !(global2.navigator && global2.navigator.standalone)) {
                var toggle = true;
                var node = document.createTextNode("");
                new Observer(flush).observe(node, { characterData: true });
                notify = function notify2() {
                  node.data = toggle = !toggle;
                };
              } else if (Promise2 && Promise2.resolve) {
                var promise = Promise2.resolve(void 0);
                notify = function notify2() {
                  promise.then(flush);
                };
              } else {
                notify = function notify2() {
                  macrotask.call(global2, flush);
                };
              }
              return function(fn) {
                var task = {
                  fn,
                  next: void 0
                };
                if (last) last.next = task;
                if (!head) {
                  head = task;
                  notify();
                }
                last = task;
              };
            };
          },
          /* 80 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var aFunction = __w_pdfjs_require__(24);
            function PromiseCapability(C) {
              var resolve2, reject2;
              this.promise = new C(function($$resolve, $$reject) {
                if (resolve2 !== void 0 || reject2 !== void 0) throw TypeError("Bad Promise constructor");
                resolve2 = $$resolve;
                reject2 = $$reject;
              });
              this.resolve = aFunction(resolve2);
              this.reject = aFunction(reject2);
            }
            module3.exports.f = function(C) {
              return new PromiseCapability(C);
            };
          },
          /* 81 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            module3.exports = function(exec) {
              try {
                return {
                  e: false,
                  v: exec()
                };
              } catch (e) {
                return {
                  e: true,
                  v: e
                };
              }
            };
          },
          /* 82 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var global2 = __w_pdfjs_require__(8);
            var navigator2 = global2.navigator;
            module3.exports = navigator2 && navigator2.userAgent || "";
          },
          /* 83 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var anObject = __w_pdfjs_require__(12);
            var isObject = __w_pdfjs_require__(13);
            var newPromiseCapability = __w_pdfjs_require__(80);
            module3.exports = function(C, x) {
              anObject(C);
              if (isObject(x) && x.constructor === C) return x;
              var promiseCapability = newPromiseCapability.f(C);
              var resolve2 = promiseCapability.resolve;
              resolve2(x);
              return promiseCapability.promise;
            };
          },
          /* 84 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var redefine = __w_pdfjs_require__(20);
            module3.exports = function(target, src, safe) {
              for (var key in src) {
                redefine(target, key, src[key], safe);
              }
              return target;
            };
          },
          /* 85 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var global2 = __w_pdfjs_require__(8);
            var dP = __w_pdfjs_require__(11);
            var DESCRIPTORS = __w_pdfjs_require__(15);
            var SPECIES = __w_pdfjs_require__(28)("species");
            module3.exports = function(KEY) {
              var C = global2[KEY];
              if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
                configurable: true,
                get: function get() {
                  return this;
                }
              });
            };
          },
          /* 86 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var ITERATOR = __w_pdfjs_require__(28)("iterator");
            var SAFE_CLOSING = false;
            try {
              var riter = [7][ITERATOR]();
              riter["return"] = function() {
                SAFE_CLOSING = true;
              };
              Array.from(riter, function() {
                throw 2;
              });
            } catch (e) {
            }
            module3.exports = function(exec, skipClosing) {
              if (!skipClosing && !SAFE_CLOSING) return false;
              var safe = false;
              try {
                var arr = [7];
                var iter = arr[ITERATOR]();
                iter.next = function() {
                  return { done: safe = true };
                };
                arr[ITERATOR] = function() {
                  return iter;
                };
                exec(arr);
              } catch (e) {
              }
              return safe;
            };
          },
          /* 87 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(7);
            var core = __w_pdfjs_require__(9);
            var global2 = __w_pdfjs_require__(8);
            var speciesConstructor = __w_pdfjs_require__(76);
            var promiseResolve = __w_pdfjs_require__(83);
            $export($export.P + $export.R, "Promise", {
              "finally": function _finally(onFinally) {
                var C = speciesConstructor(this, core.Promise || global2.Promise);
                var isFunction = typeof onFinally == "function";
                return this.then(isFunction ? function(x) {
                  return promiseResolve(C, onFinally()).then(function() {
                    return x;
                  });
                } : onFinally, isFunction ? function(e) {
                  return promiseResolve(C, onFinally()).then(function() {
                    throw e;
                  });
                } : onFinally);
              }
            });
          },
          /* 88 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(7);
            var newPromiseCapability = __w_pdfjs_require__(80);
            var perform = __w_pdfjs_require__(81);
            $export($export.S, "Promise", {
              "try": function _try(callbackfn) {
                var promiseCapability = newPromiseCapability.f(this);
                var result = perform(callbackfn);
                (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
                return promiseCapability.promise;
              }
            });
          },
          /* 89 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(50);
            __w_pdfjs_require__(67);
            __w_pdfjs_require__(90);
            __w_pdfjs_require__(105);
            __w_pdfjs_require__(107);
            module3.exports = __w_pdfjs_require__(9).WeakMap;
          },
          /* 90 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var each = __w_pdfjs_require__(91)(0);
            var redefine = __w_pdfjs_require__(20);
            var meta = __w_pdfjs_require__(95);
            var assign = __w_pdfjs_require__(96);
            var weak = __w_pdfjs_require__(99);
            var isObject = __w_pdfjs_require__(13);
            var fails = __w_pdfjs_require__(16);
            var validate = __w_pdfjs_require__(100);
            var WEAK_MAP = "WeakMap";
            var getWeak = meta.getWeak;
            var isExtensible = Object.isExtensible;
            var uncaughtFrozenStore = weak.ufstore;
            var tmp = {};
            var InternalMap;
            var wrapper = function wrapper2(get) {
              return function WeakMap2() {
                return get(this, arguments.length > 0 ? arguments[0] : void 0);
              };
            };
            var methods = {
              get: function get(key) {
                if (isObject(key)) {
                  var data = getWeak(key);
                  if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
                  return data ? data[this._i] : void 0;
                }
              },
              set: function set(key, value) {
                return weak.def(validate(this, WEAK_MAP), key, value);
              }
            };
            var $WeakMap = module3.exports = __w_pdfjs_require__(101)(WEAK_MAP, wrapper, methods, weak, true, true);
            if (fails(function() {
              return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7;
            })) {
              InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
              assign(InternalMap.prototype, methods);
              meta.NEED = true;
              each(["delete", "has", "get", "set"], function(key) {
                var proto = $WeakMap.prototype;
                var method = proto[key];
                redefine(proto, key, function(a, b) {
                  if (isObject(a) && !isExtensible(a)) {
                    if (!this._f) this._f = new InternalMap();
                    var result = this._f[key](a, b);
                    return key == "set" ? this : result;
                  }
                  return method.call(this, a, b);
                });
              });
            }
          },
          /* 91 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var ctx = __w_pdfjs_require__(23);
            var IObject = __w_pdfjs_require__(37);
            var toObject = __w_pdfjs_require__(66);
            var toLength = __w_pdfjs_require__(38);
            var asc = __w_pdfjs_require__(92);
            module3.exports = function(TYPE, $create) {
              var IS_MAP = TYPE == 1;
              var IS_FILTER = TYPE == 2;
              var IS_SOME = TYPE == 3;
              var IS_EVERY = TYPE == 4;
              var IS_FIND_INDEX = TYPE == 6;
              var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
              var create = $create || asc;
              return function($this, callbackfn, that) {
                var O = toObject($this);
                var self2 = IObject(O);
                var f = ctx(callbackfn, that, 3);
                var length = toLength(self2.length);
                var index = 0;
                var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0;
                var val, res;
                for (; length > index; index++) {
                  if (NO_HOLES || index in self2) {
                    val = self2[index];
                    res = f(val, index, O);
                    if (TYPE) {
                      if (IS_MAP) result[index] = res;
                      else if (res) switch (TYPE) {
                        case 3:
                          return true;
                        case 5:
                          return val;
                        case 6:
                          return index;
                        case 2:
                          result.push(val);
                      }
                      else if (IS_EVERY) return false;
                    }
                  }
                }
                return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
              };
            };
          },
          /* 92 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var speciesConstructor = __w_pdfjs_require__(93);
            module3.exports = function(original, length) {
              return new (speciesConstructor(original))(length);
            };
          },
          /* 93 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(13);
            var isArray = __w_pdfjs_require__(94);
            var SPECIES = __w_pdfjs_require__(28)("species");
            module3.exports = function(original) {
              var C;
              if (isArray(original)) {
                C = original.constructor;
                if (typeof C == "function" && (C === Array || isArray(C.prototype))) C = void 0;
                if (isObject(C)) {
                  C = C[SPECIES];
                  if (C === null) C = void 0;
                }
              }
              return C === void 0 ? Array : C;
            };
          },
          /* 94 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var cof = __w_pdfjs_require__(27);
            module3.exports = Array.isArray || function isArray(arg) {
              return cof(arg) == "Array";
            };
          },
          /* 95 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var META = __w_pdfjs_require__(22)("meta");
            var isObject = __w_pdfjs_require__(13);
            var has = __w_pdfjs_require__(21);
            var setDesc = __w_pdfjs_require__(11).f;
            var id = 0;
            var isExtensible = Object.isExtensible || function() {
              return true;
            };
            var FREEZE = !__w_pdfjs_require__(16)(function() {
              return isExtensible(Object.preventExtensions({}));
            });
            var setMeta = function setMeta2(it) {
              setDesc(it, META, {
                value: {
                  i: "O" + ++id,
                  w: {}
                }
              });
            };
            var fastKey = function fastKey2(it, create) {
              if (!isObject(it)) return (typeof it === "undefined" ? "undefined" : _typeof(it)) == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
              if (!has(it, META)) {
                if (!isExtensible(it)) return "F";
                if (!create) return "E";
                setMeta(it);
              }
              return it[META].i;
            };
            var getWeak = function getWeak2(it, create) {
              if (!has(it, META)) {
                if (!isExtensible(it)) return true;
                if (!create) return false;
                setMeta(it);
              }
              return it[META].w;
            };
            var onFreeze = function onFreeze2(it) {
              if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
              return it;
            };
            var meta = module3.exports = {
              KEY: META,
              NEED: false,
              fastKey,
              getWeak,
              onFreeze
            };
          },
          /* 96 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var getKeys = __w_pdfjs_require__(59);
            var gOPS = __w_pdfjs_require__(97);
            var pIE = __w_pdfjs_require__(98);
            var toObject = __w_pdfjs_require__(66);
            var IObject = __w_pdfjs_require__(37);
            var $assign = Object.assign;
            module3.exports = !$assign || __w_pdfjs_require__(16)(function() {
              var A = {};
              var B = {};
              var S = Symbol();
              var K = "abcdefghijklmnopqrst";
              A[S] = 7;
              K.split("").forEach(function(k) {
                B[k] = k;
              });
              return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join("") != K;
            }) ? function assign(target, source) {
              var T = toObject(target);
              var aLen = arguments.length;
              var index = 1;
              var getSymbols = gOPS.f;
              var isEnum = pIE.f;
              while (aLen > index) {
                var S = IObject(arguments[index++]);
                var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
                var length = keys.length;
                var j = 0;
                var key;
                while (length > j) {
                  if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
                }
              }
              return T;
            } : $assign;
          },
          /* 97 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            exports3.f = Object.getOwnPropertySymbols;
          },
          /* 98 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            exports3.f = {}.propertyIsEnumerable;
          },
          /* 99 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var redefineAll = __w_pdfjs_require__(84);
            var getWeak = __w_pdfjs_require__(95).getWeak;
            var anObject = __w_pdfjs_require__(12);
            var isObject = __w_pdfjs_require__(13);
            var anInstance = __w_pdfjs_require__(71);
            var forOf = __w_pdfjs_require__(72);
            var createArrayMethod = __w_pdfjs_require__(91);
            var $has = __w_pdfjs_require__(21);
            var validate = __w_pdfjs_require__(100);
            var arrayFind = createArrayMethod(5);
            var arrayFindIndex = createArrayMethod(6);
            var id = 0;
            var uncaughtFrozenStore = function uncaughtFrozenStore2(that) {
              return that._l || (that._l = new UncaughtFrozenStore());
            };
            var UncaughtFrozenStore = function UncaughtFrozenStore2() {
              this.a = [];
            };
            var findUncaughtFrozen = function findUncaughtFrozen2(store, key) {
              return arrayFind(store.a, function(it) {
                return it[0] === key;
              });
            };
            UncaughtFrozenStore.prototype = {
              get: function get(key) {
                var entry = findUncaughtFrozen(this, key);
                if (entry) return entry[1];
              },
              has: function has(key) {
                return !!findUncaughtFrozen(this, key);
              },
              set: function set(key, value) {
                var entry = findUncaughtFrozen(this, key);
                if (entry) entry[1] = value;
                else this.a.push([key, value]);
              },
              "delete": function _delete(key) {
                var index = arrayFindIndex(this.a, function(it) {
                  return it[0] === key;
                });
                if (~index) this.a.splice(index, 1);
                return !!~index;
              }
            };
            module3.exports = {
              getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
                var C = wrapper(function(that, iterable) {
                  anInstance(that, C, NAME, "_i");
                  that._t = NAME;
                  that._i = id++;
                  that._l = void 0;
                  if (iterable != void 0) forOf(iterable, IS_MAP, that[ADDER], that);
                });
                redefineAll(C.prototype, {
                  "delete": function _delete(key) {
                    if (!isObject(key)) return false;
                    var data = getWeak(key);
                    if (data === true) return uncaughtFrozenStore(validate(this, NAME))["delete"](key);
                    return data && $has(data, this._i) && delete data[this._i];
                  },
                  has: function has(key) {
                    if (!isObject(key)) return false;
                    var data = getWeak(key);
                    if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
                    return data && $has(data, this._i);
                  }
                });
                return C;
              },
              def: function def(that, key, value) {
                var data = getWeak(anObject(key), true);
                if (data === true) uncaughtFrozenStore(that).set(key, value);
                else data[that._i] = value;
                return that;
              },
              ufstore: uncaughtFrozenStore
            };
          },
          /* 100 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(13);
            module3.exports = function(it, TYPE) {
              if (!isObject(it) || it._t !== TYPE) throw TypeError("Incompatible receiver, " + TYPE + " required!");
              return it;
            };
          },
          /* 101 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var global2 = __w_pdfjs_require__(8);
            var $export = __w_pdfjs_require__(7);
            var redefine = __w_pdfjs_require__(20);
            var redefineAll = __w_pdfjs_require__(84);
            var meta = __w_pdfjs_require__(95);
            var forOf = __w_pdfjs_require__(72);
            var anInstance = __w_pdfjs_require__(71);
            var isObject = __w_pdfjs_require__(13);
            var fails = __w_pdfjs_require__(16);
            var $iterDetect = __w_pdfjs_require__(86);
            var setToStringTag = __w_pdfjs_require__(64);
            var inheritIfRequired = __w_pdfjs_require__(102);
            module3.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
              var Base = global2[NAME];
              var C = Base;
              var ADDER = IS_MAP ? "set" : "add";
              var proto = C && C.prototype;
              var O = {};
              var fixMethod = function fixMethod2(KEY) {
                var fn = proto[KEY];
                redefine(proto, KEY, KEY == "delete" ? function(a) {
                  return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
                } : KEY == "has" ? function has(a) {
                  return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
                } : KEY == "get" ? function get(a) {
                  return IS_WEAK && !isObject(a) ? void 0 : fn.call(this, a === 0 ? 0 : a);
                } : KEY == "add" ? function add(a) {
                  fn.call(this, a === 0 ? 0 : a);
                  return this;
                } : function set(a, b) {
                  fn.call(this, a === 0 ? 0 : a, b);
                  return this;
                });
              };
              if (typeof C != "function" || !(IS_WEAK || proto.forEach && !fails(function() {
                new C().entries().next();
              }))) {
                C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
                redefineAll(C.prototype, methods);
                meta.NEED = true;
              } else {
                var instance = new C();
                var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
                var THROWS_ON_PRIMITIVES = fails(function() {
                  instance.has(1);
                });
                var ACCEPT_ITERABLES = $iterDetect(function(iter) {
                  new C(iter);
                });
                var BUGGY_ZERO = !IS_WEAK && fails(function() {
                  var $instance = new C();
                  var index = 5;
                  while (index--) {
                    $instance[ADDER](index, index);
                  }
                  return !$instance.has(-0);
                });
                if (!ACCEPT_ITERABLES) {
                  C = wrapper(function(target, iterable) {
                    anInstance(target, C, NAME);
                    var that = inheritIfRequired(new Base(), target, C);
                    if (iterable != void 0) forOf(iterable, IS_MAP, that[ADDER], that);
                    return that;
                  });
                  C.prototype = proto;
                  proto.constructor = C;
                }
                if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
                  fixMethod("delete");
                  fixMethod("has");
                  IS_MAP && fixMethod("get");
                }
                if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
                if (IS_WEAK && proto.clear) delete proto.clear;
              }
              setToStringTag(C, NAME);
              O[NAME] = C;
              $export($export.G + $export.W + $export.F * (C != Base), O);
              if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
              return C;
            };
          },
          /* 102 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(13);
            var setPrototypeOf = __w_pdfjs_require__(103).set;
            module3.exports = function(that, target, C) {
              var S = target.constructor;
              var P;
              if (S !== C && typeof S == "function" && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
                setPrototypeOf(that, P);
              }
              return that;
            };
          },
          /* 103 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(13);
            var anObject = __w_pdfjs_require__(12);
            var check = function check2(O, proto) {
              anObject(O);
              if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
            };
            module3.exports = {
              set: Object.setPrototypeOf || ("__proto__" in {} ? function(test, buggy, set) {
                try {
                  set = __w_pdfjs_require__(23)(Function.call, __w_pdfjs_require__(104).f(Object.prototype, "__proto__").set, 2);
                  set(test, []);
                  buggy = !(test instanceof Array);
                } catch (e) {
                  buggy = true;
                }
                return function setPrototypeOf(O, proto) {
                  check(O, proto);
                  if (buggy) O.__proto__ = proto;
                  else set(O, proto);
                  return O;
                };
              }({}, false) : void 0),
              check
            };
          },
          /* 104 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var pIE = __w_pdfjs_require__(98);
            var createDesc = __w_pdfjs_require__(19);
            var toIObject = __w_pdfjs_require__(36);
            var toPrimitive = __w_pdfjs_require__(18);
            var has = __w_pdfjs_require__(21);
            var IE8_DOM_DEFINE = __w_pdfjs_require__(14);
            var gOPD = Object.getOwnPropertyDescriptor;
            exports3.f = __w_pdfjs_require__(15) ? gOPD : function getOwnPropertyDescriptor(O, P) {
              O = toIObject(O);
              P = toPrimitive(P, true);
              if (IE8_DOM_DEFINE) try {
                return gOPD(O, P);
              } catch (e) {
              }
              if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
            };
          },
          /* 105 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(106)("WeakMap");
          },
          /* 106 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(7);
            module3.exports = function(COLLECTION) {
              $export($export.S, COLLECTION, {
                of: function of() {
                  var length = arguments.length;
                  var A = new Array(length);
                  while (length--) {
                    A[length] = arguments[length];
                  }
                  return new this(A);
                }
              });
            };
          },
          /* 107 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(108)("WeakMap");
          },
          /* 108 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(7);
            var aFunction = __w_pdfjs_require__(24);
            var ctx = __w_pdfjs_require__(23);
            var forOf = __w_pdfjs_require__(72);
            module3.exports = function(COLLECTION) {
              $export($export.S, COLLECTION, {
                from: function from(source) {
                  var mapFn = arguments[1];
                  var mapping, A, n, cb;
                  aFunction(this);
                  mapping = mapFn !== void 0;
                  if (mapping) aFunction(mapFn);
                  if (source == void 0) return new this();
                  A = [];
                  if (mapping) {
                    n = 0;
                    cb = ctx(mapFn, arguments[2], 2);
                    forOf(source, false, function(nextItem) {
                      A.push(cb(nextItem, n++));
                    });
                  } else {
                    forOf(source, false, A.push, A);
                  }
                  return new this(A);
                }
              });
            };
          },
          /* 109 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            __w_pdfjs_require__(110);
            module3.exports = __w_pdfjs_require__(9).Object.values;
          },
          /* 110 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var $export = __w_pdfjs_require__(7);
            var $values = __w_pdfjs_require__(111)(false);
            $export($export.S, "Object", {
              values: function values(it) {
                return $values(it);
              }
            });
          },
          /* 111 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var getKeys = __w_pdfjs_require__(59);
            var toIObject = __w_pdfjs_require__(36);
            var isEnum = __w_pdfjs_require__(98).f;
            module3.exports = function(isEntries) {
              return function(it) {
                var O = toIObject(it);
                var keys = getKeys(O);
                var length = keys.length;
                var i = 0;
                var result = [];
                var key;
                while (length > i) {
                  if (isEnum.call(O, key = keys[i++])) {
                    result.push(isEntries ? [key, O[key]] : O[key]);
                  }
                }
                return result;
              };
            };
          },
          /* 112 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var isReadableStreamSupported = false;
            if (typeof ReadableStream !== "undefined") {
              try {
                new ReadableStream({
                  start: function start(controller) {
                    controller.close();
                  }
                });
                isReadableStreamSupported = true;
              } catch (e) {
              }
            }
            if (isReadableStreamSupported) {
              exports3.ReadableStream = ReadableStream;
            } else {
              exports3.ReadableStream = __w_pdfjs_require__(113).ReadableStream;
            }
          },
          /* 113 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            (function(e, a) {
              for (var i in a) {
                e[i] = a[i];
              }
            })(exports3, function(modules) {
              var installedModules = {};
              function __w_pdfjs_require__2(moduleId) {
                if (installedModules[moduleId]) return installedModules[moduleId].exports;
                var module4 = installedModules[moduleId] = {
                  i: moduleId,
                  l: false,
                  exports: {}
                };
                modules[moduleId].call(module4.exports, module4, module4.exports, __w_pdfjs_require__2);
                module4.l = true;
                return module4.exports;
              }
              __w_pdfjs_require__2.m = modules;
              __w_pdfjs_require__2.c = installedModules;
              __w_pdfjs_require__2.i = function(value) {
                return value;
              };
              __w_pdfjs_require__2.d = function(exports4, name, getter) {
                if (!__w_pdfjs_require__2.o(exports4, name)) {
                  Object.defineProperty(exports4, name, {
                    configurable: false,
                    enumerable: true,
                    get: getter
                  });
                }
              };
              __w_pdfjs_require__2.n = function(module4) {
                var getter = module4 && module4.__esModule ? function getDefault() {
                  return module4["default"];
                } : function getModuleExports() {
                  return module4;
                };
                __w_pdfjs_require__2.d(getter, "a", getter);
                return getter;
              };
              __w_pdfjs_require__2.o = function(object, property) {
                return Object.prototype.hasOwnProperty.call(object, property);
              };
              __w_pdfjs_require__2.p = "";
              return __w_pdfjs_require__2(__w_pdfjs_require__2.s = 7);
            }([function(module4, exports4, __w_pdfjs_require__2) {
              "use strict";
              var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function(obj) {
                return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
              } : function(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
              };
              var _require = __w_pdfjs_require__2(1), assert = _require.assert;
              function IsPropertyKey(argument) {
                return typeof argument === "string" || (typeof argument === "undefined" ? "undefined" : _typeof(argument)) === "symbol";
              }
              exports4.typeIsObject = function(x) {
                return (typeof x === "undefined" ? "undefined" : _typeof(x)) === "object" && x !== null || typeof x === "function";
              };
              exports4.createDataProperty = function(o, p, v) {
                assert(exports4.typeIsObject(o));
                Object.defineProperty(o, p, {
                  value: v,
                  writable: true,
                  enumerable: true,
                  configurable: true
                });
              };
              exports4.createArrayFromList = function(elements) {
                return elements.slice();
              };
              exports4.ArrayBufferCopy = function(dest, destOffset, src, srcOffset, n) {
                new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
              };
              exports4.CreateIterResultObject = function(value, done) {
                assert(typeof done === "boolean");
                var obj = {};
                Object.defineProperty(obj, "value", {
                  value,
                  enumerable: true,
                  writable: true,
                  configurable: true
                });
                Object.defineProperty(obj, "done", {
                  value: done,
                  enumerable: true,
                  writable: true,
                  configurable: true
                });
                return obj;
              };
              exports4.IsFiniteNonNegativeNumber = function(v) {
                if (Number.isNaN(v)) {
                  return false;
                }
                if (v === Infinity) {
                  return false;
                }
                if (v < 0) {
                  return false;
                }
                return true;
              };
              function Call(F, V, args) {
                if (typeof F !== "function") {
                  throw new TypeError("Argument is not a function");
                }
                return Function.prototype.apply.call(F, V, args);
              }
              exports4.InvokeOrNoop = function(O, P, args) {
                assert(O !== void 0);
                assert(IsPropertyKey(P));
                assert(Array.isArray(args));
                var method = O[P];
                if (method === void 0) {
                  return void 0;
                }
                return Call(method, O, args);
              };
              exports4.PromiseInvokeOrNoop = function(O, P, args) {
                assert(O !== void 0);
                assert(IsPropertyKey(P));
                assert(Array.isArray(args));
                try {
                  return Promise.resolve(exports4.InvokeOrNoop(O, P, args));
                } catch (returnValueE) {
                  return Promise.reject(returnValueE);
                }
              };
              exports4.PromiseInvokeOrPerformFallback = function(O, P, args, F, argsF) {
                assert(O !== void 0);
                assert(IsPropertyKey(P));
                assert(Array.isArray(args));
                assert(Array.isArray(argsF));
                var method = void 0;
                try {
                  method = O[P];
                } catch (methodE) {
                  return Promise.reject(methodE);
                }
                if (method === void 0) {
                  return F.apply(null, argsF);
                }
                try {
                  return Promise.resolve(Call(method, O, args));
                } catch (e) {
                  return Promise.reject(e);
                }
              };
              exports4.TransferArrayBuffer = function(O) {
                return O.slice();
              };
              exports4.ValidateAndNormalizeHighWaterMark = function(highWaterMark) {
                highWaterMark = Number(highWaterMark);
                if (Number.isNaN(highWaterMark) || highWaterMark < 0) {
                  throw new RangeError("highWaterMark property of a queuing strategy must be non-negative and non-NaN");
                }
                return highWaterMark;
              };
              exports4.ValidateAndNormalizeQueuingStrategy = function(size, highWaterMark) {
                if (size !== void 0 && typeof size !== "function") {
                  throw new TypeError("size property of a queuing strategy must be a function");
                }
                highWaterMark = exports4.ValidateAndNormalizeHighWaterMark(highWaterMark);
                return {
                  size,
                  highWaterMark
                };
              };
            }, function(module4, exports4, __w_pdfjs_require__2) {
              "use strict";
              function rethrowAssertionErrorRejection(e) {
                if (e && e.constructor === AssertionError) {
                  setTimeout(function() {
                    throw e;
                  }, 0);
                }
              }
              function AssertionError(message) {
                this.name = "AssertionError";
                this.message = message || "";
                this.stack = new Error().stack;
              }
              AssertionError.prototype = Object.create(Error.prototype);
              AssertionError.prototype.constructor = AssertionError;
              function assert(value, message) {
                if (!value) {
                  throw new AssertionError(message);
                }
              }
              module4.exports = {
                rethrowAssertionErrorRejection,
                AssertionError,
                assert
              };
            }, function(module4, exports4, __w_pdfjs_require__2) {
              "use strict";
              var _createClass = /* @__PURE__ */ function() {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function(Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var _require = __w_pdfjs_require__2(0), InvokeOrNoop = _require.InvokeOrNoop, PromiseInvokeOrNoop = _require.PromiseInvokeOrNoop, ValidateAndNormalizeQueuingStrategy = _require.ValidateAndNormalizeQueuingStrategy, typeIsObject = _require.typeIsObject;
              var _require2 = __w_pdfjs_require__2(1), assert = _require2.assert, rethrowAssertionErrorRejection = _require2.rethrowAssertionErrorRejection;
              var _require3 = __w_pdfjs_require__2(3), DequeueValue = _require3.DequeueValue, EnqueueValueWithSize = _require3.EnqueueValueWithSize, PeekQueueValue = _require3.PeekQueueValue, ResetQueue = _require3.ResetQueue;
              var WritableStream = function() {
                function WritableStream2() {
                  var underlyingSink = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, size = _ref.size, _ref$highWaterMark = _ref.highWaterMark, highWaterMark = _ref$highWaterMark === void 0 ? 1 : _ref$highWaterMark;
                  _classCallCheck(this, WritableStream2);
                  this._state = "writable";
                  this._storedError = void 0;
                  this._writer = void 0;
                  this._writableStreamController = void 0;
                  this._writeRequests = [];
                  this._inFlightWriteRequest = void 0;
                  this._closeRequest = void 0;
                  this._inFlightCloseRequest = void 0;
                  this._pendingAbortRequest = void 0;
                  this._backpressure = false;
                  var type = underlyingSink.type;
                  if (type !== void 0) {
                    throw new RangeError("Invalid type is specified");
                  }
                  this._writableStreamController = new WritableStreamDefaultController(this, underlyingSink, size, highWaterMark);
                  this._writableStreamController.__startSteps();
                }
                _createClass(WritableStream2, [{
                  key: "abort",
                  value: function abort(reason) {
                    if (IsWritableStream(this) === false) {
                      return Promise.reject(streamBrandCheckException("abort"));
                    }
                    if (IsWritableStreamLocked(this) === true) {
                      return Promise.reject(new TypeError("Cannot abort a stream that already has a writer"));
                    }
                    return WritableStreamAbort(this, reason);
                  }
                }, {
                  key: "getWriter",
                  value: function getWriter() {
                    if (IsWritableStream(this) === false) {
                      throw streamBrandCheckException("getWriter");
                    }
                    return AcquireWritableStreamDefaultWriter(this);
                  }
                }, {
                  key: "locked",
                  get: function get() {
                    if (IsWritableStream(this) === false) {
                      throw streamBrandCheckException("locked");
                    }
                    return IsWritableStreamLocked(this);
                  }
                }]);
                return WritableStream2;
              }();
              module4.exports = {
                AcquireWritableStreamDefaultWriter,
                IsWritableStream,
                IsWritableStreamLocked,
                WritableStream,
                WritableStreamAbort,
                WritableStreamDefaultControllerError,
                WritableStreamDefaultWriterCloseWithErrorPropagation,
                WritableStreamDefaultWriterRelease,
                WritableStreamDefaultWriterWrite,
                WritableStreamCloseQueuedOrInFlight
              };
              function AcquireWritableStreamDefaultWriter(stream2) {
                return new WritableStreamDefaultWriter(stream2);
              }
              function IsWritableStream(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
                  return false;
                }
                return true;
              }
              function IsWritableStreamLocked(stream2) {
                assert(IsWritableStream(stream2) === true, "IsWritableStreamLocked should only be used on known writable streams");
                if (stream2._writer === void 0) {
                  return false;
                }
                return true;
              }
              function WritableStreamAbort(stream2, reason) {
                var state = stream2._state;
                if (state === "closed") {
                  return Promise.resolve(void 0);
                }
                if (state === "errored") {
                  return Promise.reject(stream2._storedError);
                }
                var error = new TypeError("Requested to abort");
                if (stream2._pendingAbortRequest !== void 0) {
                  return Promise.reject(error);
                }
                assert(state === "writable" || state === "erroring", "state must be writable or erroring");
                var wasAlreadyErroring = false;
                if (state === "erroring") {
                  wasAlreadyErroring = true;
                  reason = void 0;
                }
                var promise = new Promise(function(resolve2, reject2) {
                  stream2._pendingAbortRequest = {
                    _resolve: resolve2,
                    _reject: reject2,
                    _reason: reason,
                    _wasAlreadyErroring: wasAlreadyErroring
                  };
                });
                if (wasAlreadyErroring === false) {
                  WritableStreamStartErroring(stream2, error);
                }
                return promise;
              }
              function WritableStreamAddWriteRequest(stream2) {
                assert(IsWritableStreamLocked(stream2) === true);
                assert(stream2._state === "writable");
                var promise = new Promise(function(resolve2, reject2) {
                  var writeRequest = {
                    _resolve: resolve2,
                    _reject: reject2
                  };
                  stream2._writeRequests.push(writeRequest);
                });
                return promise;
              }
              function WritableStreamDealWithRejection(stream2, error) {
                var state = stream2._state;
                if (state === "writable") {
                  WritableStreamStartErroring(stream2, error);
                  return;
                }
                assert(state === "erroring");
                WritableStreamFinishErroring(stream2);
              }
              function WritableStreamStartErroring(stream2, reason) {
                assert(stream2._storedError === void 0, "stream._storedError === undefined");
                assert(stream2._state === "writable", "state must be writable");
                var controller = stream2._writableStreamController;
                assert(controller !== void 0, "controller must not be undefined");
                stream2._state = "erroring";
                stream2._storedError = reason;
                var writer = stream2._writer;
                if (writer !== void 0) {
                  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
                }
                if (WritableStreamHasOperationMarkedInFlight(stream2) === false && controller._started === true) {
                  WritableStreamFinishErroring(stream2);
                }
              }
              function WritableStreamFinishErroring(stream2) {
                assert(stream2._state === "erroring", "stream._state === erroring");
                assert(WritableStreamHasOperationMarkedInFlight(stream2) === false, "WritableStreamHasOperationMarkedInFlight(stream) === false");
                stream2._state = "errored";
                stream2._writableStreamController.__errorSteps();
                var storedError = stream2._storedError;
                for (var i = 0; i < stream2._writeRequests.length; i++) {
                  var writeRequest = stream2._writeRequests[i];
                  writeRequest._reject(storedError);
                }
                stream2._writeRequests = [];
                if (stream2._pendingAbortRequest === void 0) {
                  WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream2);
                  return;
                }
                var abortRequest = stream2._pendingAbortRequest;
                stream2._pendingAbortRequest = void 0;
                if (abortRequest._wasAlreadyErroring === true) {
                  abortRequest._reject(storedError);
                  WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream2);
                  return;
                }
                var promise = stream2._writableStreamController.__abortSteps(abortRequest._reason);
                promise.then(function() {
                  abortRequest._resolve();
                  WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream2);
                }, function(reason) {
                  abortRequest._reject(reason);
                  WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream2);
                });
              }
              function WritableStreamFinishInFlightWrite(stream2) {
                assert(stream2._inFlightWriteRequest !== void 0);
                stream2._inFlightWriteRequest._resolve(void 0);
                stream2._inFlightWriteRequest = void 0;
              }
              function WritableStreamFinishInFlightWriteWithError(stream2, error) {
                assert(stream2._inFlightWriteRequest !== void 0);
                stream2._inFlightWriteRequest._reject(error);
                stream2._inFlightWriteRequest = void 0;
                assert(stream2._state === "writable" || stream2._state === "erroring");
                WritableStreamDealWithRejection(stream2, error);
              }
              function WritableStreamFinishInFlightClose(stream2) {
                assert(stream2._inFlightCloseRequest !== void 0);
                stream2._inFlightCloseRequest._resolve(void 0);
                stream2._inFlightCloseRequest = void 0;
                var state = stream2._state;
                assert(state === "writable" || state === "erroring");
                if (state === "erroring") {
                  stream2._storedError = void 0;
                  if (stream2._pendingAbortRequest !== void 0) {
                    stream2._pendingAbortRequest._resolve();
                    stream2._pendingAbortRequest = void 0;
                  }
                }
                stream2._state = "closed";
                var writer = stream2._writer;
                if (writer !== void 0) {
                  defaultWriterClosedPromiseResolve(writer);
                }
                assert(stream2._pendingAbortRequest === void 0, "stream._pendingAbortRequest === undefined");
                assert(stream2._storedError === void 0, "stream._storedError === undefined");
              }
              function WritableStreamFinishInFlightCloseWithError(stream2, error) {
                assert(stream2._inFlightCloseRequest !== void 0);
                stream2._inFlightCloseRequest._reject(error);
                stream2._inFlightCloseRequest = void 0;
                assert(stream2._state === "writable" || stream2._state === "erroring");
                if (stream2._pendingAbortRequest !== void 0) {
                  stream2._pendingAbortRequest._reject(error);
                  stream2._pendingAbortRequest = void 0;
                }
                WritableStreamDealWithRejection(stream2, error);
              }
              function WritableStreamCloseQueuedOrInFlight(stream2) {
                if (stream2._closeRequest === void 0 && stream2._inFlightCloseRequest === void 0) {
                  return false;
                }
                return true;
              }
              function WritableStreamHasOperationMarkedInFlight(stream2) {
                if (stream2._inFlightWriteRequest === void 0 && stream2._inFlightCloseRequest === void 0) {
                  return false;
                }
                return true;
              }
              function WritableStreamMarkCloseRequestInFlight(stream2) {
                assert(stream2._inFlightCloseRequest === void 0);
                assert(stream2._closeRequest !== void 0);
                stream2._inFlightCloseRequest = stream2._closeRequest;
                stream2._closeRequest = void 0;
              }
              function WritableStreamMarkFirstWriteRequestInFlight(stream2) {
                assert(stream2._inFlightWriteRequest === void 0, "there must be no pending write request");
                assert(stream2._writeRequests.length !== 0, "writeRequests must not be empty");
                stream2._inFlightWriteRequest = stream2._writeRequests.shift();
              }
              function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream2) {
                assert(stream2._state === "errored", '_stream_.[[state]] is `"errored"`');
                if (stream2._closeRequest !== void 0) {
                  assert(stream2._inFlightCloseRequest === void 0);
                  stream2._closeRequest._reject(stream2._storedError);
                  stream2._closeRequest = void 0;
                }
                var writer = stream2._writer;
                if (writer !== void 0) {
                  defaultWriterClosedPromiseReject(writer, stream2._storedError);
                  writer._closedPromise.catch(function() {
                  });
                }
              }
              function WritableStreamUpdateBackpressure(stream2, backpressure) {
                assert(stream2._state === "writable");
                assert(WritableStreamCloseQueuedOrInFlight(stream2) === false);
                var writer = stream2._writer;
                if (writer !== void 0 && backpressure !== stream2._backpressure) {
                  if (backpressure === true) {
                    defaultWriterReadyPromiseReset(writer);
                  } else {
                    assert(backpressure === false);
                    defaultWriterReadyPromiseResolve(writer);
                  }
                }
                stream2._backpressure = backpressure;
              }
              var WritableStreamDefaultWriter = function() {
                function WritableStreamDefaultWriter2(stream2) {
                  _classCallCheck(this, WritableStreamDefaultWriter2);
                  if (IsWritableStream(stream2) === false) {
                    throw new TypeError("WritableStreamDefaultWriter can only be constructed with a WritableStream instance");
                  }
                  if (IsWritableStreamLocked(stream2) === true) {
                    throw new TypeError("This stream has already been locked for exclusive writing by another writer");
                  }
                  this._ownerWritableStream = stream2;
                  stream2._writer = this;
                  var state = stream2._state;
                  if (state === "writable") {
                    if (WritableStreamCloseQueuedOrInFlight(stream2) === false && stream2._backpressure === true) {
                      defaultWriterReadyPromiseInitialize(this);
                    } else {
                      defaultWriterReadyPromiseInitializeAsResolved(this);
                    }
                    defaultWriterClosedPromiseInitialize(this);
                  } else if (state === "erroring") {
                    defaultWriterReadyPromiseInitializeAsRejected(this, stream2._storedError);
                    this._readyPromise.catch(function() {
                    });
                    defaultWriterClosedPromiseInitialize(this);
                  } else if (state === "closed") {
                    defaultWriterReadyPromiseInitializeAsResolved(this);
                    defaultWriterClosedPromiseInitializeAsResolved(this);
                  } else {
                    assert(state === "errored", "state must be errored");
                    var storedError = stream2._storedError;
                    defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
                    this._readyPromise.catch(function() {
                    });
                    defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
                    this._closedPromise.catch(function() {
                    });
                  }
                }
                _createClass(WritableStreamDefaultWriter2, [{
                  key: "abort",
                  value: function abort(reason) {
                    if (IsWritableStreamDefaultWriter(this) === false) {
                      return Promise.reject(defaultWriterBrandCheckException("abort"));
                    }
                    if (this._ownerWritableStream === void 0) {
                      return Promise.reject(defaultWriterLockException("abort"));
                    }
                    return WritableStreamDefaultWriterAbort(this, reason);
                  }
                }, {
                  key: "close",
                  value: function close() {
                    if (IsWritableStreamDefaultWriter(this) === false) {
                      return Promise.reject(defaultWriterBrandCheckException("close"));
                    }
                    var stream2 = this._ownerWritableStream;
                    if (stream2 === void 0) {
                      return Promise.reject(defaultWriterLockException("close"));
                    }
                    if (WritableStreamCloseQueuedOrInFlight(stream2) === true) {
                      return Promise.reject(new TypeError("cannot close an already-closing stream"));
                    }
                    return WritableStreamDefaultWriterClose(this);
                  }
                }, {
                  key: "releaseLock",
                  value: function releaseLock() {
                    if (IsWritableStreamDefaultWriter(this) === false) {
                      throw defaultWriterBrandCheckException("releaseLock");
                    }
                    var stream2 = this._ownerWritableStream;
                    if (stream2 === void 0) {
                      return;
                    }
                    assert(stream2._writer !== void 0);
                    WritableStreamDefaultWriterRelease(this);
                  }
                }, {
                  key: "write",
                  value: function write(chunk) {
                    if (IsWritableStreamDefaultWriter(this) === false) {
                      return Promise.reject(defaultWriterBrandCheckException("write"));
                    }
                    if (this._ownerWritableStream === void 0) {
                      return Promise.reject(defaultWriterLockException("write to"));
                    }
                    return WritableStreamDefaultWriterWrite(this, chunk);
                  }
                }, {
                  key: "closed",
                  get: function get() {
                    if (IsWritableStreamDefaultWriter(this) === false) {
                      return Promise.reject(defaultWriterBrandCheckException("closed"));
                    }
                    return this._closedPromise;
                  }
                }, {
                  key: "desiredSize",
                  get: function get() {
                    if (IsWritableStreamDefaultWriter(this) === false) {
                      throw defaultWriterBrandCheckException("desiredSize");
                    }
                    if (this._ownerWritableStream === void 0) {
                      throw defaultWriterLockException("desiredSize");
                    }
                    return WritableStreamDefaultWriterGetDesiredSize(this);
                  }
                }, {
                  key: "ready",
                  get: function get() {
                    if (IsWritableStreamDefaultWriter(this) === false) {
                      return Promise.reject(defaultWriterBrandCheckException("ready"));
                    }
                    return this._readyPromise;
                  }
                }]);
                return WritableStreamDefaultWriter2;
              }();
              function IsWritableStreamDefaultWriter(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
                  return false;
                }
                return true;
              }
              function WritableStreamDefaultWriterAbort(writer, reason) {
                var stream2 = writer._ownerWritableStream;
                assert(stream2 !== void 0);
                return WritableStreamAbort(stream2, reason);
              }
              function WritableStreamDefaultWriterClose(writer) {
                var stream2 = writer._ownerWritableStream;
                assert(stream2 !== void 0);
                var state = stream2._state;
                if (state === "closed" || state === "errored") {
                  return Promise.reject(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed"));
                }
                assert(state === "writable" || state === "erroring");
                assert(WritableStreamCloseQueuedOrInFlight(stream2) === false);
                var promise = new Promise(function(resolve2, reject2) {
                  var closeRequest = {
                    _resolve: resolve2,
                    _reject: reject2
                  };
                  stream2._closeRequest = closeRequest;
                });
                if (stream2._backpressure === true && state === "writable") {
                  defaultWriterReadyPromiseResolve(writer);
                }
                WritableStreamDefaultControllerClose(stream2._writableStreamController);
                return promise;
              }
              function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
                var stream2 = writer._ownerWritableStream;
                assert(stream2 !== void 0);
                var state = stream2._state;
                if (WritableStreamCloseQueuedOrInFlight(stream2) === true || state === "closed") {
                  return Promise.resolve();
                }
                if (state === "errored") {
                  return Promise.reject(stream2._storedError);
                }
                assert(state === "writable" || state === "erroring");
                return WritableStreamDefaultWriterClose(writer);
              }
              function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
                if (writer._closedPromiseState === "pending") {
                  defaultWriterClosedPromiseReject(writer, error);
                } else {
                  defaultWriterClosedPromiseResetToRejected(writer, error);
                }
                writer._closedPromise.catch(function() {
                });
              }
              function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
                if (writer._readyPromiseState === "pending") {
                  defaultWriterReadyPromiseReject(writer, error);
                } else {
                  defaultWriterReadyPromiseResetToRejected(writer, error);
                }
                writer._readyPromise.catch(function() {
                });
              }
              function WritableStreamDefaultWriterGetDesiredSize(writer) {
                var stream2 = writer._ownerWritableStream;
                var state = stream2._state;
                if (state === "errored" || state === "erroring") {
                  return null;
                }
                if (state === "closed") {
                  return 0;
                }
                return WritableStreamDefaultControllerGetDesiredSize(stream2._writableStreamController);
              }
              function WritableStreamDefaultWriterRelease(writer) {
                var stream2 = writer._ownerWritableStream;
                assert(stream2 !== void 0);
                assert(stream2._writer === writer);
                var releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
                WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
                WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
                stream2._writer = void 0;
                writer._ownerWritableStream = void 0;
              }
              function WritableStreamDefaultWriterWrite(writer, chunk) {
                var stream2 = writer._ownerWritableStream;
                assert(stream2 !== void 0);
                var controller = stream2._writableStreamController;
                var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
                if (stream2 !== writer._ownerWritableStream) {
                  return Promise.reject(defaultWriterLockException("write to"));
                }
                var state = stream2._state;
                if (state === "errored") {
                  return Promise.reject(stream2._storedError);
                }
                if (WritableStreamCloseQueuedOrInFlight(stream2) === true || state === "closed") {
                  return Promise.reject(new TypeError("The stream is closing or closed and cannot be written to"));
                }
                if (state === "erroring") {
                  return Promise.reject(stream2._storedError);
                }
                assert(state === "writable");
                var promise = WritableStreamAddWriteRequest(stream2);
                WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
                return promise;
              }
              var WritableStreamDefaultController = function() {
                function WritableStreamDefaultController2(stream2, underlyingSink, size, highWaterMark) {
                  _classCallCheck(this, WritableStreamDefaultController2);
                  if (IsWritableStream(stream2) === false) {
                    throw new TypeError("WritableStreamDefaultController can only be constructed with a WritableStream instance");
                  }
                  if (stream2._writableStreamController !== void 0) {
                    throw new TypeError("WritableStreamDefaultController instances can only be created by the WritableStream constructor");
                  }
                  this._controlledWritableStream = stream2;
                  this._underlyingSink = underlyingSink;
                  this._queue = void 0;
                  this._queueTotalSize = void 0;
                  ResetQueue(this);
                  this._started = false;
                  var normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
                  this._strategySize = normalizedStrategy.size;
                  this._strategyHWM = normalizedStrategy.highWaterMark;
                  var backpressure = WritableStreamDefaultControllerGetBackpressure(this);
                  WritableStreamUpdateBackpressure(stream2, backpressure);
                }
                _createClass(WritableStreamDefaultController2, [{
                  key: "error",
                  value: function error(e) {
                    if (IsWritableStreamDefaultController(this) === false) {
                      throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");
                    }
                    var state = this._controlledWritableStream._state;
                    if (state !== "writable") {
                      return;
                    }
                    WritableStreamDefaultControllerError(this, e);
                  }
                }, {
                  key: "__abortSteps",
                  value: function __abortSteps(reason) {
                    return PromiseInvokeOrNoop(this._underlyingSink, "abort", [reason]);
                  }
                }, {
                  key: "__errorSteps",
                  value: function __errorSteps() {
                    ResetQueue(this);
                  }
                }, {
                  key: "__startSteps",
                  value: function __startSteps() {
                    var _this = this;
                    var startResult = InvokeOrNoop(this._underlyingSink, "start", [this]);
                    var stream2 = this._controlledWritableStream;
                    Promise.resolve(startResult).then(function() {
                      assert(stream2._state === "writable" || stream2._state === "erroring");
                      _this._started = true;
                      WritableStreamDefaultControllerAdvanceQueueIfNeeded(_this);
                    }, function(r) {
                      assert(stream2._state === "writable" || stream2._state === "erroring");
                      _this._started = true;
                      WritableStreamDealWithRejection(stream2, r);
                    }).catch(rethrowAssertionErrorRejection);
                  }
                }]);
                return WritableStreamDefaultController2;
              }();
              function WritableStreamDefaultControllerClose(controller) {
                EnqueueValueWithSize(controller, "close", 0);
                WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
              }
              function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
                var strategySize = controller._strategySize;
                if (strategySize === void 0) {
                  return 1;
                }
                try {
                  return strategySize(chunk);
                } catch (chunkSizeE) {
                  WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
                  return 1;
                }
              }
              function WritableStreamDefaultControllerGetDesiredSize(controller) {
                return controller._strategyHWM - controller._queueTotalSize;
              }
              function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
                var writeRecord = { chunk };
                try {
                  EnqueueValueWithSize(controller, writeRecord, chunkSize);
                } catch (enqueueE) {
                  WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
                  return;
                }
                var stream2 = controller._controlledWritableStream;
                if (WritableStreamCloseQueuedOrInFlight(stream2) === false && stream2._state === "writable") {
                  var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
                  WritableStreamUpdateBackpressure(stream2, backpressure);
                }
                WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
              }
              function IsWritableStreamDefaultController(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_underlyingSink")) {
                  return false;
                }
                return true;
              }
              function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
                var stream2 = controller._controlledWritableStream;
                if (controller._started === false) {
                  return;
                }
                if (stream2._inFlightWriteRequest !== void 0) {
                  return;
                }
                var state = stream2._state;
                if (state === "closed" || state === "errored") {
                  return;
                }
                if (state === "erroring") {
                  WritableStreamFinishErroring(stream2);
                  return;
                }
                if (controller._queue.length === 0) {
                  return;
                }
                var writeRecord = PeekQueueValue(controller);
                if (writeRecord === "close") {
                  WritableStreamDefaultControllerProcessClose(controller);
                } else {
                  WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);
                }
              }
              function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
                if (controller._controlledWritableStream._state === "writable") {
                  WritableStreamDefaultControllerError(controller, error);
                }
              }
              function WritableStreamDefaultControllerProcessClose(controller) {
                var stream2 = controller._controlledWritableStream;
                WritableStreamMarkCloseRequestInFlight(stream2);
                DequeueValue(controller);
                assert(controller._queue.length === 0, "queue must be empty once the final write record is dequeued");
                var sinkClosePromise = PromiseInvokeOrNoop(controller._underlyingSink, "close", []);
                sinkClosePromise.then(function() {
                  WritableStreamFinishInFlightClose(stream2);
                }, function(reason) {
                  WritableStreamFinishInFlightCloseWithError(stream2, reason);
                }).catch(rethrowAssertionErrorRejection);
              }
              function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
                var stream2 = controller._controlledWritableStream;
                WritableStreamMarkFirstWriteRequestInFlight(stream2);
                var sinkWritePromise = PromiseInvokeOrNoop(controller._underlyingSink, "write", [chunk, controller]);
                sinkWritePromise.then(function() {
                  WritableStreamFinishInFlightWrite(stream2);
                  var state = stream2._state;
                  assert(state === "writable" || state === "erroring");
                  DequeueValue(controller);
                  if (WritableStreamCloseQueuedOrInFlight(stream2) === false && state === "writable") {
                    var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
                    WritableStreamUpdateBackpressure(stream2, backpressure);
                  }
                  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
                }, function(reason) {
                  WritableStreamFinishInFlightWriteWithError(stream2, reason);
                }).catch(rethrowAssertionErrorRejection);
              }
              function WritableStreamDefaultControllerGetBackpressure(controller) {
                var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
                return desiredSize <= 0;
              }
              function WritableStreamDefaultControllerError(controller, error) {
                var stream2 = controller._controlledWritableStream;
                assert(stream2._state === "writable");
                WritableStreamStartErroring(stream2, error);
              }
              function streamBrandCheckException(name) {
                return new TypeError("WritableStream.prototype." + name + " can only be used on a WritableStream");
              }
              function defaultWriterBrandCheckException(name) {
                return new TypeError("WritableStreamDefaultWriter.prototype." + name + " can only be used on a WritableStreamDefaultWriter");
              }
              function defaultWriterLockException(name) {
                return new TypeError("Cannot " + name + " a stream using a released writer");
              }
              function defaultWriterClosedPromiseInitialize(writer) {
                writer._closedPromise = new Promise(function(resolve2, reject2) {
                  writer._closedPromise_resolve = resolve2;
                  writer._closedPromise_reject = reject2;
                  writer._closedPromiseState = "pending";
                });
              }
              function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
                writer._closedPromise = Promise.reject(reason);
                writer._closedPromise_resolve = void 0;
                writer._closedPromise_reject = void 0;
                writer._closedPromiseState = "rejected";
              }
              function defaultWriterClosedPromiseInitializeAsResolved(writer) {
                writer._closedPromise = Promise.resolve(void 0);
                writer._closedPromise_resolve = void 0;
                writer._closedPromise_reject = void 0;
                writer._closedPromiseState = "resolved";
              }
              function defaultWriterClosedPromiseReject(writer, reason) {
                assert(writer._closedPromise_resolve !== void 0, "writer._closedPromise_resolve !== undefined");
                assert(writer._closedPromise_reject !== void 0, "writer._closedPromise_reject !== undefined");
                assert(writer._closedPromiseState === "pending", "writer._closedPromiseState is pending");
                writer._closedPromise_reject(reason);
                writer._closedPromise_resolve = void 0;
                writer._closedPromise_reject = void 0;
                writer._closedPromiseState = "rejected";
              }
              function defaultWriterClosedPromiseResetToRejected(writer, reason) {
                assert(writer._closedPromise_resolve === void 0, "writer._closedPromise_resolve === undefined");
                assert(writer._closedPromise_reject === void 0, "writer._closedPromise_reject === undefined");
                assert(writer._closedPromiseState !== "pending", "writer._closedPromiseState is not pending");
                writer._closedPromise = Promise.reject(reason);
                writer._closedPromiseState = "rejected";
              }
              function defaultWriterClosedPromiseResolve(writer) {
                assert(writer._closedPromise_resolve !== void 0, "writer._closedPromise_resolve !== undefined");
                assert(writer._closedPromise_reject !== void 0, "writer._closedPromise_reject !== undefined");
                assert(writer._closedPromiseState === "pending", "writer._closedPromiseState is pending");
                writer._closedPromise_resolve(void 0);
                writer._closedPromise_resolve = void 0;
                writer._closedPromise_reject = void 0;
                writer._closedPromiseState = "resolved";
              }
              function defaultWriterReadyPromiseInitialize(writer) {
                writer._readyPromise = new Promise(function(resolve2, reject2) {
                  writer._readyPromise_resolve = resolve2;
                  writer._readyPromise_reject = reject2;
                });
                writer._readyPromiseState = "pending";
              }
              function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
                writer._readyPromise = Promise.reject(reason);
                writer._readyPromise_resolve = void 0;
                writer._readyPromise_reject = void 0;
                writer._readyPromiseState = "rejected";
              }
              function defaultWriterReadyPromiseInitializeAsResolved(writer) {
                writer._readyPromise = Promise.resolve(void 0);
                writer._readyPromise_resolve = void 0;
                writer._readyPromise_reject = void 0;
                writer._readyPromiseState = "fulfilled";
              }
              function defaultWriterReadyPromiseReject(writer, reason) {
                assert(writer._readyPromise_resolve !== void 0, "writer._readyPromise_resolve !== undefined");
                assert(writer._readyPromise_reject !== void 0, "writer._readyPromise_reject !== undefined");
                writer._readyPromise_reject(reason);
                writer._readyPromise_resolve = void 0;
                writer._readyPromise_reject = void 0;
                writer._readyPromiseState = "rejected";
              }
              function defaultWriterReadyPromiseReset(writer) {
                assert(writer._readyPromise_resolve === void 0, "writer._readyPromise_resolve === undefined");
                assert(writer._readyPromise_reject === void 0, "writer._readyPromise_reject === undefined");
                writer._readyPromise = new Promise(function(resolve2, reject2) {
                  writer._readyPromise_resolve = resolve2;
                  writer._readyPromise_reject = reject2;
                });
                writer._readyPromiseState = "pending";
              }
              function defaultWriterReadyPromiseResetToRejected(writer, reason) {
                assert(writer._readyPromise_resolve === void 0, "writer._readyPromise_resolve === undefined");
                assert(writer._readyPromise_reject === void 0, "writer._readyPromise_reject === undefined");
                writer._readyPromise = Promise.reject(reason);
                writer._readyPromiseState = "rejected";
              }
              function defaultWriterReadyPromiseResolve(writer) {
                assert(writer._readyPromise_resolve !== void 0, "writer._readyPromise_resolve !== undefined");
                assert(writer._readyPromise_reject !== void 0, "writer._readyPromise_reject !== undefined");
                writer._readyPromise_resolve(void 0);
                writer._readyPromise_resolve = void 0;
                writer._readyPromise_reject = void 0;
                writer._readyPromiseState = "fulfilled";
              }
            }, function(module4, exports4, __w_pdfjs_require__2) {
              "use strict";
              var _require = __w_pdfjs_require__2(0), IsFiniteNonNegativeNumber = _require.IsFiniteNonNegativeNumber;
              var _require2 = __w_pdfjs_require__2(1), assert = _require2.assert;
              exports4.DequeueValue = function(container) {
                assert("_queue" in container && "_queueTotalSize" in container, "Spec-level failure: DequeueValue should only be used on containers with [[queue]] and [[queueTotalSize]].");
                assert(container._queue.length > 0, "Spec-level failure: should never dequeue from an empty queue.");
                var pair = container._queue.shift();
                container._queueTotalSize -= pair.size;
                if (container._queueTotalSize < 0) {
                  container._queueTotalSize = 0;
                }
                return pair.value;
              };
              exports4.EnqueueValueWithSize = function(container, value, size) {
                assert("_queue" in container && "_queueTotalSize" in container, "Spec-level failure: EnqueueValueWithSize should only be used on containers with [[queue]] and [[queueTotalSize]].");
                size = Number(size);
                if (!IsFiniteNonNegativeNumber(size)) {
                  throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
                }
                container._queue.push({
                  value,
                  size
                });
                container._queueTotalSize += size;
              };
              exports4.PeekQueueValue = function(container) {
                assert("_queue" in container && "_queueTotalSize" in container, "Spec-level failure: PeekQueueValue should only be used on containers with [[queue]] and [[queueTotalSize]].");
                assert(container._queue.length > 0, "Spec-level failure: should never peek at an empty queue.");
                var pair = container._queue[0];
                return pair.value;
              };
              exports4.ResetQueue = function(container) {
                assert("_queue" in container && "_queueTotalSize" in container, "Spec-level failure: ResetQueue should only be used on containers with [[queue]] and [[queueTotalSize]].");
                container._queue = [];
                container._queueTotalSize = 0;
              };
            }, function(module4, exports4, __w_pdfjs_require__2) {
              "use strict";
              var _createClass = /* @__PURE__ */ function() {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function(Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var _require = __w_pdfjs_require__2(0), ArrayBufferCopy = _require.ArrayBufferCopy, CreateIterResultObject = _require.CreateIterResultObject, IsFiniteNonNegativeNumber = _require.IsFiniteNonNegativeNumber, InvokeOrNoop = _require.InvokeOrNoop, PromiseInvokeOrNoop = _require.PromiseInvokeOrNoop, TransferArrayBuffer = _require.TransferArrayBuffer, ValidateAndNormalizeQueuingStrategy = _require.ValidateAndNormalizeQueuingStrategy, ValidateAndNormalizeHighWaterMark = _require.ValidateAndNormalizeHighWaterMark;
              var _require2 = __w_pdfjs_require__2(0), createArrayFromList = _require2.createArrayFromList, createDataProperty = _require2.createDataProperty, typeIsObject = _require2.typeIsObject;
              var _require3 = __w_pdfjs_require__2(1), assert = _require3.assert, rethrowAssertionErrorRejection = _require3.rethrowAssertionErrorRejection;
              var _require4 = __w_pdfjs_require__2(3), DequeueValue = _require4.DequeueValue, EnqueueValueWithSize = _require4.EnqueueValueWithSize, ResetQueue = _require4.ResetQueue;
              var _require5 = __w_pdfjs_require__2(2), AcquireWritableStreamDefaultWriter = _require5.AcquireWritableStreamDefaultWriter, IsWritableStream = _require5.IsWritableStream, IsWritableStreamLocked = _require5.IsWritableStreamLocked, WritableStreamAbort = _require5.WritableStreamAbort, WritableStreamDefaultWriterCloseWithErrorPropagation = _require5.WritableStreamDefaultWriterCloseWithErrorPropagation, WritableStreamDefaultWriterRelease = _require5.WritableStreamDefaultWriterRelease, WritableStreamDefaultWriterWrite = _require5.WritableStreamDefaultWriterWrite, WritableStreamCloseQueuedOrInFlight = _require5.WritableStreamCloseQueuedOrInFlight;
              var ReadableStream2 = function() {
                function ReadableStream3() {
                  var underlyingSource = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, size = _ref.size, highWaterMark = _ref.highWaterMark;
                  _classCallCheck(this, ReadableStream3);
                  this._state = "readable";
                  this._reader = void 0;
                  this._storedError = void 0;
                  this._disturbed = false;
                  this._readableStreamController = void 0;
                  var type = underlyingSource.type;
                  var typeString = String(type);
                  if (typeString === "bytes") {
                    if (highWaterMark === void 0) {
                      highWaterMark = 0;
                    }
                    this._readableStreamController = new ReadableByteStreamController(this, underlyingSource, highWaterMark);
                  } else if (type === void 0) {
                    if (highWaterMark === void 0) {
                      highWaterMark = 1;
                    }
                    this._readableStreamController = new ReadableStreamDefaultController(this, underlyingSource, size, highWaterMark);
                  } else {
                    throw new RangeError("Invalid type is specified");
                  }
                }
                _createClass(ReadableStream3, [{
                  key: "cancel",
                  value: function cancel(reason) {
                    if (IsReadableStream(this) === false) {
                      return Promise.reject(streamBrandCheckException("cancel"));
                    }
                    if (IsReadableStreamLocked(this) === true) {
                      return Promise.reject(new TypeError("Cannot cancel a stream that already has a reader"));
                    }
                    return ReadableStreamCancel(this, reason);
                  }
                }, {
                  key: "getReader",
                  value: function getReader() {
                    var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mode = _ref2.mode;
                    if (IsReadableStream(this) === false) {
                      throw streamBrandCheckException("getReader");
                    }
                    if (mode === void 0) {
                      return AcquireReadableStreamDefaultReader(this);
                    }
                    mode = String(mode);
                    if (mode === "byob") {
                      return AcquireReadableStreamBYOBReader(this);
                    }
                    throw new RangeError("Invalid mode is specified");
                  }
                }, {
                  key: "pipeThrough",
                  value: function pipeThrough(_ref3, options2) {
                    var writable = _ref3.writable, readable = _ref3.readable;
                    var promise = this.pipeTo(writable, options2);
                    ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise);
                    return readable;
                  }
                }, {
                  key: "pipeTo",
                  value: function pipeTo(dest) {
                    var _this = this;
                    var _ref4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, preventClose = _ref4.preventClose, preventAbort = _ref4.preventAbort, preventCancel = _ref4.preventCancel;
                    if (IsReadableStream(this) === false) {
                      return Promise.reject(streamBrandCheckException("pipeTo"));
                    }
                    if (IsWritableStream(dest) === false) {
                      return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
                    }
                    preventClose = Boolean(preventClose);
                    preventAbort = Boolean(preventAbort);
                    preventCancel = Boolean(preventCancel);
                    if (IsReadableStreamLocked(this) === true) {
                      return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
                    }
                    if (IsWritableStreamLocked(dest) === true) {
                      return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
                    }
                    var reader = AcquireReadableStreamDefaultReader(this);
                    var writer = AcquireWritableStreamDefaultWriter(dest);
                    var shuttingDown = false;
                    var currentWrite = Promise.resolve();
                    return new Promise(function(resolve2, reject2) {
                      function pipeLoop() {
                        currentWrite = Promise.resolve();
                        if (shuttingDown === true) {
                          return Promise.resolve();
                        }
                        return writer._readyPromise.then(function() {
                          return ReadableStreamDefaultReaderRead(reader).then(function(_ref5) {
                            var value = _ref5.value, done = _ref5.done;
                            if (done === true) {
                              return;
                            }
                            currentWrite = WritableStreamDefaultWriterWrite(writer, value).catch(function() {
                            });
                          });
                        }).then(pipeLoop);
                      }
                      isOrBecomesErrored(_this, reader._closedPromise, function(storedError) {
                        if (preventAbort === false) {
                          shutdownWithAction(function() {
                            return WritableStreamAbort(dest, storedError);
                          }, true, storedError);
                        } else {
                          shutdown(true, storedError);
                        }
                      });
                      isOrBecomesErrored(dest, writer._closedPromise, function(storedError) {
                        if (preventCancel === false) {
                          shutdownWithAction(function() {
                            return ReadableStreamCancel(_this, storedError);
                          }, true, storedError);
                        } else {
                          shutdown(true, storedError);
                        }
                      });
                      isOrBecomesClosed(_this, reader._closedPromise, function() {
                        if (preventClose === false) {
                          shutdownWithAction(function() {
                            return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
                          });
                        } else {
                          shutdown();
                        }
                      });
                      if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === "closed") {
                        var destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
                        if (preventCancel === false) {
                          shutdownWithAction(function() {
                            return ReadableStreamCancel(_this, destClosed);
                          }, true, destClosed);
                        } else {
                          shutdown(true, destClosed);
                        }
                      }
                      pipeLoop().catch(function(err) {
                        currentWrite = Promise.resolve();
                        rethrowAssertionErrorRejection(err);
                      });
                      function waitForWritesToFinish() {
                        var oldCurrentWrite = currentWrite;
                        return currentWrite.then(function() {
                          return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0;
                        });
                      }
                      function isOrBecomesErrored(stream2, promise, action) {
                        if (stream2._state === "errored") {
                          action(stream2._storedError);
                        } else {
                          promise.catch(action).catch(rethrowAssertionErrorRejection);
                        }
                      }
                      function isOrBecomesClosed(stream2, promise, action) {
                        if (stream2._state === "closed") {
                          action();
                        } else {
                          promise.then(action).catch(rethrowAssertionErrorRejection);
                        }
                      }
                      function shutdownWithAction(action, originalIsError, originalError) {
                        if (shuttingDown === true) {
                          return;
                        }
                        shuttingDown = true;
                        if (dest._state === "writable" && WritableStreamCloseQueuedOrInFlight(dest) === false) {
                          waitForWritesToFinish().then(doTheRest);
                        } else {
                          doTheRest();
                        }
                        function doTheRest() {
                          action().then(function() {
                            return finalize(originalIsError, originalError);
                          }, function(newError) {
                            return finalize(true, newError);
                          }).catch(rethrowAssertionErrorRejection);
                        }
                      }
                      function shutdown(isError, error) {
                        if (shuttingDown === true) {
                          return;
                        }
                        shuttingDown = true;
                        if (dest._state === "writable" && WritableStreamCloseQueuedOrInFlight(dest) === false) {
                          waitForWritesToFinish().then(function() {
                            return finalize(isError, error);
                          }).catch(rethrowAssertionErrorRejection);
                        } else {
                          finalize(isError, error);
                        }
                      }
                      function finalize(isError, error) {
                        WritableStreamDefaultWriterRelease(writer);
                        ReadableStreamReaderGenericRelease(reader);
                        if (isError) {
                          reject2(error);
                        } else {
                          resolve2(void 0);
                        }
                      }
                    });
                  }
                }, {
                  key: "tee",
                  value: function tee() {
                    if (IsReadableStream(this) === false) {
                      throw streamBrandCheckException("tee");
                    }
                    var branches = ReadableStreamTee(this, false);
                    return createArrayFromList(branches);
                  }
                }, {
                  key: "locked",
                  get: function get() {
                    if (IsReadableStream(this) === false) {
                      throw streamBrandCheckException("locked");
                    }
                    return IsReadableStreamLocked(this);
                  }
                }]);
                return ReadableStream3;
              }();
              module4.exports = {
                ReadableStream: ReadableStream2,
                IsReadableStreamDisturbed,
                ReadableStreamDefaultControllerClose,
                ReadableStreamDefaultControllerEnqueue,
                ReadableStreamDefaultControllerError,
                ReadableStreamDefaultControllerGetDesiredSize
              };
              function AcquireReadableStreamBYOBReader(stream2) {
                return new ReadableStreamBYOBReader(stream2);
              }
              function AcquireReadableStreamDefaultReader(stream2) {
                return new ReadableStreamDefaultReader(stream2);
              }
              function IsReadableStream(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
                  return false;
                }
                return true;
              }
              function IsReadableStreamDisturbed(stream2) {
                assert(IsReadableStream(stream2) === true, "IsReadableStreamDisturbed should only be used on known readable streams");
                return stream2._disturbed;
              }
              function IsReadableStreamLocked(stream2) {
                assert(IsReadableStream(stream2) === true, "IsReadableStreamLocked should only be used on known readable streams");
                if (stream2._reader === void 0) {
                  return false;
                }
                return true;
              }
              function ReadableStreamTee(stream2, cloneForBranch2) {
                assert(IsReadableStream(stream2) === true);
                assert(typeof cloneForBranch2 === "boolean");
                var reader = AcquireReadableStreamDefaultReader(stream2);
                var teeState = {
                  closedOrErrored: false,
                  canceled1: false,
                  canceled2: false,
                  reason1: void 0,
                  reason2: void 0
                };
                teeState.promise = new Promise(function(resolve2) {
                  teeState._resolve = resolve2;
                });
                var pull = create_ReadableStreamTeePullFunction();
                pull._reader = reader;
                pull._teeState = teeState;
                pull._cloneForBranch2 = cloneForBranch2;
                var cancel1 = create_ReadableStreamTeeBranch1CancelFunction();
                cancel1._stream = stream2;
                cancel1._teeState = teeState;
                var cancel2 = create_ReadableStreamTeeBranch2CancelFunction();
                cancel2._stream = stream2;
                cancel2._teeState = teeState;
                var underlyingSource1 = Object.create(Object.prototype);
                createDataProperty(underlyingSource1, "pull", pull);
                createDataProperty(underlyingSource1, "cancel", cancel1);
                var branch1Stream = new ReadableStream2(underlyingSource1);
                var underlyingSource2 = Object.create(Object.prototype);
                createDataProperty(underlyingSource2, "pull", pull);
                createDataProperty(underlyingSource2, "cancel", cancel2);
                var branch2Stream = new ReadableStream2(underlyingSource2);
                pull._branch1 = branch1Stream._readableStreamController;
                pull._branch2 = branch2Stream._readableStreamController;
                reader._closedPromise.catch(function(r) {
                  if (teeState.closedOrErrored === true) {
                    return;
                  }
                  ReadableStreamDefaultControllerError(pull._branch1, r);
                  ReadableStreamDefaultControllerError(pull._branch2, r);
                  teeState.closedOrErrored = true;
                });
                return [branch1Stream, branch2Stream];
              }
              function create_ReadableStreamTeePullFunction() {
                function f() {
                  var reader = f._reader, branch1 = f._branch1, branch2 = f._branch2, teeState = f._teeState;
                  return ReadableStreamDefaultReaderRead(reader).then(function(result) {
                    assert(typeIsObject(result));
                    var value = result.value;
                    var done = result.done;
                    assert(typeof done === "boolean");
                    if (done === true && teeState.closedOrErrored === false) {
                      if (teeState.canceled1 === false) {
                        ReadableStreamDefaultControllerClose(branch1);
                      }
                      if (teeState.canceled2 === false) {
                        ReadableStreamDefaultControllerClose(branch2);
                      }
                      teeState.closedOrErrored = true;
                    }
                    if (teeState.closedOrErrored === true) {
                      return;
                    }
                    var value1 = value;
                    var value2 = value;
                    if (teeState.canceled1 === false) {
                      ReadableStreamDefaultControllerEnqueue(branch1, value1);
                    }
                    if (teeState.canceled2 === false) {
                      ReadableStreamDefaultControllerEnqueue(branch2, value2);
                    }
                  });
                }
                return f;
              }
              function create_ReadableStreamTeeBranch1CancelFunction() {
                function f(reason) {
                  var stream2 = f._stream, teeState = f._teeState;
                  teeState.canceled1 = true;
                  teeState.reason1 = reason;
                  if (teeState.canceled2 === true) {
                    var compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]);
                    var cancelResult = ReadableStreamCancel(stream2, compositeReason);
                    teeState._resolve(cancelResult);
                  }
                  return teeState.promise;
                }
                return f;
              }
              function create_ReadableStreamTeeBranch2CancelFunction() {
                function f(reason) {
                  var stream2 = f._stream, teeState = f._teeState;
                  teeState.canceled2 = true;
                  teeState.reason2 = reason;
                  if (teeState.canceled1 === true) {
                    var compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]);
                    var cancelResult = ReadableStreamCancel(stream2, compositeReason);
                    teeState._resolve(cancelResult);
                  }
                  return teeState.promise;
                }
                return f;
              }
              function ReadableStreamAddReadIntoRequest(stream2) {
                assert(IsReadableStreamBYOBReader(stream2._reader) === true);
                assert(stream2._state === "readable" || stream2._state === "closed");
                var promise = new Promise(function(resolve2, reject2) {
                  var readIntoRequest = {
                    _resolve: resolve2,
                    _reject: reject2
                  };
                  stream2._reader._readIntoRequests.push(readIntoRequest);
                });
                return promise;
              }
              function ReadableStreamAddReadRequest(stream2) {
                assert(IsReadableStreamDefaultReader(stream2._reader) === true);
                assert(stream2._state === "readable");
                var promise = new Promise(function(resolve2, reject2) {
                  var readRequest = {
                    _resolve: resolve2,
                    _reject: reject2
                  };
                  stream2._reader._readRequests.push(readRequest);
                });
                return promise;
              }
              function ReadableStreamCancel(stream2, reason) {
                stream2._disturbed = true;
                if (stream2._state === "closed") {
                  return Promise.resolve(void 0);
                }
                if (stream2._state === "errored") {
                  return Promise.reject(stream2._storedError);
                }
                ReadableStreamClose(stream2);
                var sourceCancelPromise = stream2._readableStreamController.__cancelSteps(reason);
                return sourceCancelPromise.then(function() {
                  return void 0;
                });
              }
              function ReadableStreamClose(stream2) {
                assert(stream2._state === "readable");
                stream2._state = "closed";
                var reader = stream2._reader;
                if (reader === void 0) {
                  return void 0;
                }
                if (IsReadableStreamDefaultReader(reader) === true) {
                  for (var i = 0; i < reader._readRequests.length; i++) {
                    var _resolve = reader._readRequests[i]._resolve;
                    _resolve(CreateIterResultObject(void 0, true));
                  }
                  reader._readRequests = [];
                }
                defaultReaderClosedPromiseResolve(reader);
                return void 0;
              }
              function ReadableStreamError(stream2, e) {
                assert(IsReadableStream(stream2) === true, "stream must be ReadableStream");
                assert(stream2._state === "readable", "state must be readable");
                stream2._state = "errored";
                stream2._storedError = e;
                var reader = stream2._reader;
                if (reader === void 0) {
                  return void 0;
                }
                if (IsReadableStreamDefaultReader(reader) === true) {
                  for (var i = 0; i < reader._readRequests.length; i++) {
                    var readRequest = reader._readRequests[i];
                    readRequest._reject(e);
                  }
                  reader._readRequests = [];
                } else {
                  assert(IsReadableStreamBYOBReader(reader), "reader must be ReadableStreamBYOBReader");
                  for (var _i = 0; _i < reader._readIntoRequests.length; _i++) {
                    var readIntoRequest = reader._readIntoRequests[_i];
                    readIntoRequest._reject(e);
                  }
                  reader._readIntoRequests = [];
                }
                defaultReaderClosedPromiseReject(reader, e);
                reader._closedPromise.catch(function() {
                });
              }
              function ReadableStreamFulfillReadIntoRequest(stream2, chunk, done) {
                var reader = stream2._reader;
                assert(reader._readIntoRequests.length > 0);
                var readIntoRequest = reader._readIntoRequests.shift();
                readIntoRequest._resolve(CreateIterResultObject(chunk, done));
              }
              function ReadableStreamFulfillReadRequest(stream2, chunk, done) {
                var reader = stream2._reader;
                assert(reader._readRequests.length > 0);
                var readRequest = reader._readRequests.shift();
                readRequest._resolve(CreateIterResultObject(chunk, done));
              }
              function ReadableStreamGetNumReadIntoRequests(stream2) {
                return stream2._reader._readIntoRequests.length;
              }
              function ReadableStreamGetNumReadRequests(stream2) {
                return stream2._reader._readRequests.length;
              }
              function ReadableStreamHasBYOBReader(stream2) {
                var reader = stream2._reader;
                if (reader === void 0) {
                  return false;
                }
                if (IsReadableStreamBYOBReader(reader) === false) {
                  return false;
                }
                return true;
              }
              function ReadableStreamHasDefaultReader(stream2) {
                var reader = stream2._reader;
                if (reader === void 0) {
                  return false;
                }
                if (IsReadableStreamDefaultReader(reader) === false) {
                  return false;
                }
                return true;
              }
              var ReadableStreamDefaultReader = function() {
                function ReadableStreamDefaultReader2(stream2) {
                  _classCallCheck(this, ReadableStreamDefaultReader2);
                  if (IsReadableStream(stream2) === false) {
                    throw new TypeError("ReadableStreamDefaultReader can only be constructed with a ReadableStream instance");
                  }
                  if (IsReadableStreamLocked(stream2) === true) {
                    throw new TypeError("This stream has already been locked for exclusive reading by another reader");
                  }
                  ReadableStreamReaderGenericInitialize(this, stream2);
                  this._readRequests = [];
                }
                _createClass(ReadableStreamDefaultReader2, [{
                  key: "cancel",
                  value: function cancel(reason) {
                    if (IsReadableStreamDefaultReader(this) === false) {
                      return Promise.reject(defaultReaderBrandCheckException("cancel"));
                    }
                    if (this._ownerReadableStream === void 0) {
                      return Promise.reject(readerLockException("cancel"));
                    }
                    return ReadableStreamReaderGenericCancel(this, reason);
                  }
                }, {
                  key: "read",
                  value: function read() {
                    if (IsReadableStreamDefaultReader(this) === false) {
                      return Promise.reject(defaultReaderBrandCheckException("read"));
                    }
                    if (this._ownerReadableStream === void 0) {
                      return Promise.reject(readerLockException("read from"));
                    }
                    return ReadableStreamDefaultReaderRead(this);
                  }
                }, {
                  key: "releaseLock",
                  value: function releaseLock() {
                    if (IsReadableStreamDefaultReader(this) === false) {
                      throw defaultReaderBrandCheckException("releaseLock");
                    }
                    if (this._ownerReadableStream === void 0) {
                      return;
                    }
                    if (this._readRequests.length > 0) {
                      throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
                    }
                    ReadableStreamReaderGenericRelease(this);
                  }
                }, {
                  key: "closed",
                  get: function get() {
                    if (IsReadableStreamDefaultReader(this) === false) {
                      return Promise.reject(defaultReaderBrandCheckException("closed"));
                    }
                    return this._closedPromise;
                  }
                }]);
                return ReadableStreamDefaultReader2;
              }();
              var ReadableStreamBYOBReader = function() {
                function ReadableStreamBYOBReader2(stream2) {
                  _classCallCheck(this, ReadableStreamBYOBReader2);
                  if (!IsReadableStream(stream2)) {
                    throw new TypeError("ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a byte source");
                  }
                  if (IsReadableByteStreamController(stream2._readableStreamController) === false) {
                    throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
                  }
                  if (IsReadableStreamLocked(stream2)) {
                    throw new TypeError("This stream has already been locked for exclusive reading by another reader");
                  }
                  ReadableStreamReaderGenericInitialize(this, stream2);
                  this._readIntoRequests = [];
                }
                _createClass(ReadableStreamBYOBReader2, [{
                  key: "cancel",
                  value: function cancel(reason) {
                    if (!IsReadableStreamBYOBReader(this)) {
                      return Promise.reject(byobReaderBrandCheckException("cancel"));
                    }
                    if (this._ownerReadableStream === void 0) {
                      return Promise.reject(readerLockException("cancel"));
                    }
                    return ReadableStreamReaderGenericCancel(this, reason);
                  }
                }, {
                  key: "read",
                  value: function read(view) {
                    if (!IsReadableStreamBYOBReader(this)) {
                      return Promise.reject(byobReaderBrandCheckException("read"));
                    }
                    if (this._ownerReadableStream === void 0) {
                      return Promise.reject(readerLockException("read from"));
                    }
                    if (!ArrayBuffer.isView(view)) {
                      return Promise.reject(new TypeError("view must be an array buffer view"));
                    }
                    if (view.byteLength === 0) {
                      return Promise.reject(new TypeError("view must have non-zero byteLength"));
                    }
                    return ReadableStreamBYOBReaderRead(this, view);
                  }
                }, {
                  key: "releaseLock",
                  value: function releaseLock() {
                    if (!IsReadableStreamBYOBReader(this)) {
                      throw byobReaderBrandCheckException("releaseLock");
                    }
                    if (this._ownerReadableStream === void 0) {
                      return;
                    }
                    if (this._readIntoRequests.length > 0) {
                      throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
                    }
                    ReadableStreamReaderGenericRelease(this);
                  }
                }, {
                  key: "closed",
                  get: function get() {
                    if (!IsReadableStreamBYOBReader(this)) {
                      return Promise.reject(byobReaderBrandCheckException("closed"));
                    }
                    return this._closedPromise;
                  }
                }]);
                return ReadableStreamBYOBReader2;
              }();
              function IsReadableStreamBYOBReader(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
                  return false;
                }
                return true;
              }
              function IsReadableStreamDefaultReader(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
                  return false;
                }
                return true;
              }
              function ReadableStreamReaderGenericInitialize(reader, stream2) {
                reader._ownerReadableStream = stream2;
                stream2._reader = reader;
                if (stream2._state === "readable") {
                  defaultReaderClosedPromiseInitialize(reader);
                } else if (stream2._state === "closed") {
                  defaultReaderClosedPromiseInitializeAsResolved(reader);
                } else {
                  assert(stream2._state === "errored", "state must be errored");
                  defaultReaderClosedPromiseInitializeAsRejected(reader, stream2._storedError);
                  reader._closedPromise.catch(function() {
                  });
                }
              }
              function ReadableStreamReaderGenericCancel(reader, reason) {
                var stream2 = reader._ownerReadableStream;
                assert(stream2 !== void 0);
                return ReadableStreamCancel(stream2, reason);
              }
              function ReadableStreamReaderGenericRelease(reader) {
                assert(reader._ownerReadableStream !== void 0);
                assert(reader._ownerReadableStream._reader === reader);
                if (reader._ownerReadableStream._state === "readable") {
                  defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
                } else {
                  defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
                }
                reader._closedPromise.catch(function() {
                });
                reader._ownerReadableStream._reader = void 0;
                reader._ownerReadableStream = void 0;
              }
              function ReadableStreamBYOBReaderRead(reader, view) {
                var stream2 = reader._ownerReadableStream;
                assert(stream2 !== void 0);
                stream2._disturbed = true;
                if (stream2._state === "errored") {
                  return Promise.reject(stream2._storedError);
                }
                return ReadableByteStreamControllerPullInto(stream2._readableStreamController, view);
              }
              function ReadableStreamDefaultReaderRead(reader) {
                var stream2 = reader._ownerReadableStream;
                assert(stream2 !== void 0);
                stream2._disturbed = true;
                if (stream2._state === "closed") {
                  return Promise.resolve(CreateIterResultObject(void 0, true));
                }
                if (stream2._state === "errored") {
                  return Promise.reject(stream2._storedError);
                }
                assert(stream2._state === "readable");
                return stream2._readableStreamController.__pullSteps();
              }
              var ReadableStreamDefaultController = function() {
                function ReadableStreamDefaultController2(stream2, underlyingSource, size, highWaterMark) {
                  _classCallCheck(this, ReadableStreamDefaultController2);
                  if (IsReadableStream(stream2) === false) {
                    throw new TypeError("ReadableStreamDefaultController can only be constructed with a ReadableStream instance");
                  }
                  if (stream2._readableStreamController !== void 0) {
                    throw new TypeError("ReadableStreamDefaultController instances can only be created by the ReadableStream constructor");
                  }
                  this._controlledReadableStream = stream2;
                  this._underlyingSource = underlyingSource;
                  this._queue = void 0;
                  this._queueTotalSize = void 0;
                  ResetQueue(this);
                  this._started = false;
                  this._closeRequested = false;
                  this._pullAgain = false;
                  this._pulling = false;
                  var normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
                  this._strategySize = normalizedStrategy.size;
                  this._strategyHWM = normalizedStrategy.highWaterMark;
                  var controller = this;
                  var startResult = InvokeOrNoop(underlyingSource, "start", [this]);
                  Promise.resolve(startResult).then(function() {
                    controller._started = true;
                    assert(controller._pulling === false);
                    assert(controller._pullAgain === false);
                    ReadableStreamDefaultControllerCallPullIfNeeded(controller);
                  }, function(r) {
                    ReadableStreamDefaultControllerErrorIfNeeded(controller, r);
                  }).catch(rethrowAssertionErrorRejection);
                }
                _createClass(ReadableStreamDefaultController2, [{
                  key: "close",
                  value: function close() {
                    if (IsReadableStreamDefaultController(this) === false) {
                      throw defaultControllerBrandCheckException("close");
                    }
                    if (this._closeRequested === true) {
                      throw new TypeError("The stream has already been closed; do not close it again!");
                    }
                    var state = this._controlledReadableStream._state;
                    if (state !== "readable") {
                      throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
                    }
                    ReadableStreamDefaultControllerClose(this);
                  }
                }, {
                  key: "enqueue",
                  value: function enqueue(chunk) {
                    if (IsReadableStreamDefaultController(this) === false) {
                      throw defaultControllerBrandCheckException("enqueue");
                    }
                    if (this._closeRequested === true) {
                      throw new TypeError("stream is closed or draining");
                    }
                    var state = this._controlledReadableStream._state;
                    if (state !== "readable") {
                      throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
                    }
                    return ReadableStreamDefaultControllerEnqueue(this, chunk);
                  }
                }, {
                  key: "error",
                  value: function error(e) {
                    if (IsReadableStreamDefaultController(this) === false) {
                      throw defaultControllerBrandCheckException("error");
                    }
                    var stream2 = this._controlledReadableStream;
                    if (stream2._state !== "readable") {
                      throw new TypeError("The stream is " + stream2._state + " and so cannot be errored");
                    }
                    ReadableStreamDefaultControllerError(this, e);
                  }
                }, {
                  key: "__cancelSteps",
                  value: function __cancelSteps(reason) {
                    ResetQueue(this);
                    return PromiseInvokeOrNoop(this._underlyingSource, "cancel", [reason]);
                  }
                }, {
                  key: "__pullSteps",
                  value: function __pullSteps() {
                    var stream2 = this._controlledReadableStream;
                    if (this._queue.length > 0) {
                      var chunk = DequeueValue(this);
                      if (this._closeRequested === true && this._queue.length === 0) {
                        ReadableStreamClose(stream2);
                      } else {
                        ReadableStreamDefaultControllerCallPullIfNeeded(this);
                      }
                      return Promise.resolve(CreateIterResultObject(chunk, false));
                    }
                    var pendingPromise = ReadableStreamAddReadRequest(stream2);
                    ReadableStreamDefaultControllerCallPullIfNeeded(this);
                    return pendingPromise;
                  }
                }, {
                  key: "desiredSize",
                  get: function get() {
                    if (IsReadableStreamDefaultController(this) === false) {
                      throw defaultControllerBrandCheckException("desiredSize");
                    }
                    return ReadableStreamDefaultControllerGetDesiredSize(this);
                  }
                }]);
                return ReadableStreamDefaultController2;
              }();
              function IsReadableStreamDefaultController(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_underlyingSource")) {
                  return false;
                }
                return true;
              }
              function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
                var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
                if (shouldPull === false) {
                  return void 0;
                }
                if (controller._pulling === true) {
                  controller._pullAgain = true;
                  return void 0;
                }
                assert(controller._pullAgain === false);
                controller._pulling = true;
                var pullPromise = PromiseInvokeOrNoop(controller._underlyingSource, "pull", [controller]);
                pullPromise.then(function() {
                  controller._pulling = false;
                  if (controller._pullAgain === true) {
                    controller._pullAgain = false;
                    return ReadableStreamDefaultControllerCallPullIfNeeded(controller);
                  }
                  return void 0;
                }, function(e) {
                  ReadableStreamDefaultControllerErrorIfNeeded(controller, e);
                }).catch(rethrowAssertionErrorRejection);
                return void 0;
              }
              function ReadableStreamDefaultControllerShouldCallPull(controller) {
                var stream2 = controller._controlledReadableStream;
                if (stream2._state === "closed" || stream2._state === "errored") {
                  return false;
                }
                if (controller._closeRequested === true) {
                  return false;
                }
                if (controller._started === false) {
                  return false;
                }
                if (IsReadableStreamLocked(stream2) === true && ReadableStreamGetNumReadRequests(stream2) > 0) {
                  return true;
                }
                var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
                if (desiredSize > 0) {
                  return true;
                }
                return false;
              }
              function ReadableStreamDefaultControllerClose(controller) {
                var stream2 = controller._controlledReadableStream;
                assert(controller._closeRequested === false);
                assert(stream2._state === "readable");
                controller._closeRequested = true;
                if (controller._queue.length === 0) {
                  ReadableStreamClose(stream2);
                }
              }
              function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
                var stream2 = controller._controlledReadableStream;
                assert(controller._closeRequested === false);
                assert(stream2._state === "readable");
                if (IsReadableStreamLocked(stream2) === true && ReadableStreamGetNumReadRequests(stream2) > 0) {
                  ReadableStreamFulfillReadRequest(stream2, chunk, false);
                } else {
                  var chunkSize = 1;
                  if (controller._strategySize !== void 0) {
                    var strategySize = controller._strategySize;
                    try {
                      chunkSize = strategySize(chunk);
                    } catch (chunkSizeE) {
                      ReadableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
                      throw chunkSizeE;
                    }
                  }
                  try {
                    EnqueueValueWithSize(controller, chunk, chunkSize);
                  } catch (enqueueE) {
                    ReadableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
                    throw enqueueE;
                  }
                }
                ReadableStreamDefaultControllerCallPullIfNeeded(controller);
                return void 0;
              }
              function ReadableStreamDefaultControllerError(controller, e) {
                var stream2 = controller._controlledReadableStream;
                assert(stream2._state === "readable");
                ResetQueue(controller);
                ReadableStreamError(stream2, e);
              }
              function ReadableStreamDefaultControllerErrorIfNeeded(controller, e) {
                if (controller._controlledReadableStream._state === "readable") {
                  ReadableStreamDefaultControllerError(controller, e);
                }
              }
              function ReadableStreamDefaultControllerGetDesiredSize(controller) {
                var stream2 = controller._controlledReadableStream;
                var state = stream2._state;
                if (state === "errored") {
                  return null;
                }
                if (state === "closed") {
                  return 0;
                }
                return controller._strategyHWM - controller._queueTotalSize;
              }
              var ReadableStreamBYOBRequest = function() {
                function ReadableStreamBYOBRequest2(controller, view) {
                  _classCallCheck(this, ReadableStreamBYOBRequest2);
                  this._associatedReadableByteStreamController = controller;
                  this._view = view;
                }
                _createClass(ReadableStreamBYOBRequest2, [{
                  key: "respond",
                  value: function respond(bytesWritten) {
                    if (IsReadableStreamBYOBRequest(this) === false) {
                      throw byobRequestBrandCheckException("respond");
                    }
                    if (this._associatedReadableByteStreamController === void 0) {
                      throw new TypeError("This BYOB request has been invalidated");
                    }
                    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
                  }
                }, {
                  key: "respondWithNewView",
                  value: function respondWithNewView(view) {
                    if (IsReadableStreamBYOBRequest(this) === false) {
                      throw byobRequestBrandCheckException("respond");
                    }
                    if (this._associatedReadableByteStreamController === void 0) {
                      throw new TypeError("This BYOB request has been invalidated");
                    }
                    if (!ArrayBuffer.isView(view)) {
                      throw new TypeError("You can only respond with array buffer views");
                    }
                    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
                  }
                }, {
                  key: "view",
                  get: function get() {
                    return this._view;
                  }
                }]);
                return ReadableStreamBYOBRequest2;
              }();
              var ReadableByteStreamController = function() {
                function ReadableByteStreamController2(stream2, underlyingByteSource, highWaterMark) {
                  _classCallCheck(this, ReadableByteStreamController2);
                  if (IsReadableStream(stream2) === false) {
                    throw new TypeError("ReadableByteStreamController can only be constructed with a ReadableStream instance given a byte source");
                  }
                  if (stream2._readableStreamController !== void 0) {
                    throw new TypeError("ReadableByteStreamController instances can only be created by the ReadableStream constructor given a byte source");
                  }
                  this._controlledReadableStream = stream2;
                  this._underlyingByteSource = underlyingByteSource;
                  this._pullAgain = false;
                  this._pulling = false;
                  ReadableByteStreamControllerClearPendingPullIntos(this);
                  this._queue = this._queueTotalSize = void 0;
                  ResetQueue(this);
                  this._closeRequested = false;
                  this._started = false;
                  this._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);
                  var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
                  if (autoAllocateChunkSize !== void 0) {
                    if (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {
                      throw new RangeError("autoAllocateChunkSize must be a positive integer");
                    }
                  }
                  this._autoAllocateChunkSize = autoAllocateChunkSize;
                  this._pendingPullIntos = [];
                  var controller = this;
                  var startResult = InvokeOrNoop(underlyingByteSource, "start", [this]);
                  Promise.resolve(startResult).then(function() {
                    controller._started = true;
                    assert(controller._pulling === false);
                    assert(controller._pullAgain === false);
                    ReadableByteStreamControllerCallPullIfNeeded(controller);
                  }, function(r) {
                    if (stream2._state === "readable") {
                      ReadableByteStreamControllerError(controller, r);
                    }
                  }).catch(rethrowAssertionErrorRejection);
                }
                _createClass(ReadableByteStreamController2, [{
                  key: "close",
                  value: function close() {
                    if (IsReadableByteStreamController(this) === false) {
                      throw byteStreamControllerBrandCheckException("close");
                    }
                    if (this._closeRequested === true) {
                      throw new TypeError("The stream has already been closed; do not close it again!");
                    }
                    var state = this._controlledReadableStream._state;
                    if (state !== "readable") {
                      throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
                    }
                    ReadableByteStreamControllerClose(this);
                  }
                }, {
                  key: "enqueue",
                  value: function enqueue(chunk) {
                    if (IsReadableByteStreamController(this) === false) {
                      throw byteStreamControllerBrandCheckException("enqueue");
                    }
                    if (this._closeRequested === true) {
                      throw new TypeError("stream is closed or draining");
                    }
                    var state = this._controlledReadableStream._state;
                    if (state !== "readable") {
                      throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
                    }
                    if (!ArrayBuffer.isView(chunk)) {
                      throw new TypeError("You can only enqueue array buffer views when using a ReadableByteStreamController");
                    }
                    ReadableByteStreamControllerEnqueue(this, chunk);
                  }
                }, {
                  key: "error",
                  value: function error(e) {
                    if (IsReadableByteStreamController(this) === false) {
                      throw byteStreamControllerBrandCheckException("error");
                    }
                    var stream2 = this._controlledReadableStream;
                    if (stream2._state !== "readable") {
                      throw new TypeError("The stream is " + stream2._state + " and so cannot be errored");
                    }
                    ReadableByteStreamControllerError(this, e);
                  }
                }, {
                  key: "__cancelSteps",
                  value: function __cancelSteps(reason) {
                    if (this._pendingPullIntos.length > 0) {
                      var firstDescriptor = this._pendingPullIntos[0];
                      firstDescriptor.bytesFilled = 0;
                    }
                    ResetQueue(this);
                    return PromiseInvokeOrNoop(this._underlyingByteSource, "cancel", [reason]);
                  }
                }, {
                  key: "__pullSteps",
                  value: function __pullSteps() {
                    var stream2 = this._controlledReadableStream;
                    assert(ReadableStreamHasDefaultReader(stream2) === true);
                    if (this._queueTotalSize > 0) {
                      assert(ReadableStreamGetNumReadRequests(stream2) === 0);
                      var entry = this._queue.shift();
                      this._queueTotalSize -= entry.byteLength;
                      ReadableByteStreamControllerHandleQueueDrain(this);
                      var view = void 0;
                      try {
                        view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
                      } catch (viewE) {
                        return Promise.reject(viewE);
                      }
                      return Promise.resolve(CreateIterResultObject(view, false));
                    }
                    var autoAllocateChunkSize = this._autoAllocateChunkSize;
                    if (autoAllocateChunkSize !== void 0) {
                      var buffer = void 0;
                      try {
                        buffer = new ArrayBuffer(autoAllocateChunkSize);
                      } catch (bufferE) {
                        return Promise.reject(bufferE);
                      }
                      var pullIntoDescriptor = {
                        buffer,
                        byteOffset: 0,
                        byteLength: autoAllocateChunkSize,
                        bytesFilled: 0,
                        elementSize: 1,
                        ctor: Uint8Array,
                        readerType: "default"
                      };
                      this._pendingPullIntos.push(pullIntoDescriptor);
                    }
                    var promise = ReadableStreamAddReadRequest(stream2);
                    ReadableByteStreamControllerCallPullIfNeeded(this);
                    return promise;
                  }
                }, {
                  key: "byobRequest",
                  get: function get() {
                    if (IsReadableByteStreamController(this) === false) {
                      throw byteStreamControllerBrandCheckException("byobRequest");
                    }
                    if (this._byobRequest === void 0 && this._pendingPullIntos.length > 0) {
                      var firstDescriptor = this._pendingPullIntos[0];
                      var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
                      this._byobRequest = new ReadableStreamBYOBRequest(this, view);
                    }
                    return this._byobRequest;
                  }
                }, {
                  key: "desiredSize",
                  get: function get() {
                    if (IsReadableByteStreamController(this) === false) {
                      throw byteStreamControllerBrandCheckException("desiredSize");
                    }
                    return ReadableByteStreamControllerGetDesiredSize(this);
                  }
                }]);
                return ReadableByteStreamController2;
              }();
              function IsReadableByteStreamController(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_underlyingByteSource")) {
                  return false;
                }
                return true;
              }
              function IsReadableStreamBYOBRequest(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
                  return false;
                }
                return true;
              }
              function ReadableByteStreamControllerCallPullIfNeeded(controller) {
                var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
                if (shouldPull === false) {
                  return void 0;
                }
                if (controller._pulling === true) {
                  controller._pullAgain = true;
                  return void 0;
                }
                assert(controller._pullAgain === false);
                controller._pulling = true;
                var pullPromise = PromiseInvokeOrNoop(controller._underlyingByteSource, "pull", [controller]);
                pullPromise.then(function() {
                  controller._pulling = false;
                  if (controller._pullAgain === true) {
                    controller._pullAgain = false;
                    ReadableByteStreamControllerCallPullIfNeeded(controller);
                  }
                }, function(e) {
                  if (controller._controlledReadableStream._state === "readable") {
                    ReadableByteStreamControllerError(controller, e);
                  }
                }).catch(rethrowAssertionErrorRejection);
                return void 0;
              }
              function ReadableByteStreamControllerClearPendingPullIntos(controller) {
                ReadableByteStreamControllerInvalidateBYOBRequest(controller);
                controller._pendingPullIntos = [];
              }
              function ReadableByteStreamControllerCommitPullIntoDescriptor(stream2, pullIntoDescriptor) {
                assert(stream2._state !== "errored", "state must not be errored");
                var done = false;
                if (stream2._state === "closed") {
                  assert(pullIntoDescriptor.bytesFilled === 0);
                  done = true;
                }
                var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
                if (pullIntoDescriptor.readerType === "default") {
                  ReadableStreamFulfillReadRequest(stream2, filledView, done);
                } else {
                  assert(pullIntoDescriptor.readerType === "byob");
                  ReadableStreamFulfillReadIntoRequest(stream2, filledView, done);
                }
              }
              function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
                var bytesFilled = pullIntoDescriptor.bytesFilled;
                var elementSize = pullIntoDescriptor.elementSize;
                assert(bytesFilled <= pullIntoDescriptor.byteLength);
                assert(bytesFilled % elementSize === 0);
                return new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
              }
              function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
                controller._queue.push({
                  buffer,
                  byteOffset,
                  byteLength
                });
                controller._queueTotalSize += byteLength;
              }
              function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
                var elementSize = pullIntoDescriptor.elementSize;
                var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
                var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
                var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
                var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
                var totalBytesToCopyRemaining = maxBytesToCopy;
                var ready = false;
                if (maxAlignedBytes > currentAlignedBytes) {
                  totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
                  ready = true;
                }
                var queue = controller._queue;
                while (totalBytesToCopyRemaining > 0) {
                  var headOfQueue = queue[0];
                  var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
                  var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
                  ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
                  if (headOfQueue.byteLength === bytesToCopy) {
                    queue.shift();
                  } else {
                    headOfQueue.byteOffset += bytesToCopy;
                    headOfQueue.byteLength -= bytesToCopy;
                  }
                  controller._queueTotalSize -= bytesToCopy;
                  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
                  totalBytesToCopyRemaining -= bytesToCopy;
                }
                if (ready === false) {
                  assert(controller._queueTotalSize === 0, "queue must be empty");
                  assert(pullIntoDescriptor.bytesFilled > 0);
                  assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);
                }
                return ready;
              }
              function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
                assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos[0] === pullIntoDescriptor);
                ReadableByteStreamControllerInvalidateBYOBRequest(controller);
                pullIntoDescriptor.bytesFilled += size;
              }
              function ReadableByteStreamControllerHandleQueueDrain(controller) {
                assert(controller._controlledReadableStream._state === "readable");
                if (controller._queueTotalSize === 0 && controller._closeRequested === true) {
                  ReadableStreamClose(controller._controlledReadableStream);
                } else {
                  ReadableByteStreamControllerCallPullIfNeeded(controller);
                }
              }
              function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
                if (controller._byobRequest === void 0) {
                  return;
                }
                controller._byobRequest._associatedReadableByteStreamController = void 0;
                controller._byobRequest._view = void 0;
                controller._byobRequest = void 0;
              }
              function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
                assert(controller._closeRequested === false);
                while (controller._pendingPullIntos.length > 0) {
                  if (controller._queueTotalSize === 0) {
                    return;
                  }
                  var pullIntoDescriptor = controller._pendingPullIntos[0];
                  if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {
                    ReadableByteStreamControllerShiftPendingPullInto(controller);
                    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor);
                  }
                }
              }
              function ReadableByteStreamControllerPullInto(controller, view) {
                var stream2 = controller._controlledReadableStream;
                var elementSize = 1;
                if (view.constructor !== DataView) {
                  elementSize = view.constructor.BYTES_PER_ELEMENT;
                }
                var ctor = view.constructor;
                var pullIntoDescriptor = {
                  buffer: view.buffer,
                  byteOffset: view.byteOffset,
                  byteLength: view.byteLength,
                  bytesFilled: 0,
                  elementSize,
                  ctor,
                  readerType: "byob"
                };
                if (controller._pendingPullIntos.length > 0) {
                  pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);
                  controller._pendingPullIntos.push(pullIntoDescriptor);
                  return ReadableStreamAddReadIntoRequest(stream2);
                }
                if (stream2._state === "closed") {
                  var emptyView = new view.constructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
                  return Promise.resolve(CreateIterResultObject(emptyView, true));
                }
                if (controller._queueTotalSize > 0) {
                  if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {
                    var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
                    ReadableByteStreamControllerHandleQueueDrain(controller);
                    return Promise.resolve(CreateIterResultObject(filledView, false));
                  }
                  if (controller._closeRequested === true) {
                    var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
                    ReadableByteStreamControllerError(controller, e);
                    return Promise.reject(e);
                  }
                }
                pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);
                controller._pendingPullIntos.push(pullIntoDescriptor);
                var promise = ReadableStreamAddReadIntoRequest(stream2);
                ReadableByteStreamControllerCallPullIfNeeded(controller);
                return promise;
              }
              function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
                firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
                assert(firstDescriptor.bytesFilled === 0, "bytesFilled must be 0");
                var stream2 = controller._controlledReadableStream;
                if (ReadableStreamHasBYOBReader(stream2) === true) {
                  while (ReadableStreamGetNumReadIntoRequests(stream2) > 0) {
                    var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
                    ReadableByteStreamControllerCommitPullIntoDescriptor(stream2, pullIntoDescriptor);
                  }
                }
              }
              function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
                if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {
                  throw new RangeError("bytesWritten out of range");
                }
                ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
                if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
                  return;
                }
                ReadableByteStreamControllerShiftPendingPullInto(controller);
                var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
                if (remainderSize > 0) {
                  var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
                  var remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);
                  ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
                }
                pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);
                pullIntoDescriptor.bytesFilled -= remainderSize;
                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor);
                ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
              }
              function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
                var firstDescriptor = controller._pendingPullIntos[0];
                var stream2 = controller._controlledReadableStream;
                if (stream2._state === "closed") {
                  if (bytesWritten !== 0) {
                    throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
                  }
                  ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
                } else {
                  assert(stream2._state === "readable");
                  ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
                }
              }
              function ReadableByteStreamControllerShiftPendingPullInto(controller) {
                var descriptor = controller._pendingPullIntos.shift();
                ReadableByteStreamControllerInvalidateBYOBRequest(controller);
                return descriptor;
              }
              function ReadableByteStreamControllerShouldCallPull(controller) {
                var stream2 = controller._controlledReadableStream;
                if (stream2._state !== "readable") {
                  return false;
                }
                if (controller._closeRequested === true) {
                  return false;
                }
                if (controller._started === false) {
                  return false;
                }
                if (ReadableStreamHasDefaultReader(stream2) === true && ReadableStreamGetNumReadRequests(stream2) > 0) {
                  return true;
                }
                if (ReadableStreamHasBYOBReader(stream2) === true && ReadableStreamGetNumReadIntoRequests(stream2) > 0) {
                  return true;
                }
                if (ReadableByteStreamControllerGetDesiredSize(controller) > 0) {
                  return true;
                }
                return false;
              }
              function ReadableByteStreamControllerClose(controller) {
                var stream2 = controller._controlledReadableStream;
                assert(controller._closeRequested === false);
                assert(stream2._state === "readable");
                if (controller._queueTotalSize > 0) {
                  controller._closeRequested = true;
                  return;
                }
                if (controller._pendingPullIntos.length > 0) {
                  var firstPendingPullInto = controller._pendingPullIntos[0];
                  if (firstPendingPullInto.bytesFilled > 0) {
                    var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
                    ReadableByteStreamControllerError(controller, e);
                    throw e;
                  }
                }
                ReadableStreamClose(stream2);
              }
              function ReadableByteStreamControllerEnqueue(controller, chunk) {
                var stream2 = controller._controlledReadableStream;
                assert(controller._closeRequested === false);
                assert(stream2._state === "readable");
                var buffer = chunk.buffer;
                var byteOffset = chunk.byteOffset;
                var byteLength = chunk.byteLength;
                var transferredBuffer = TransferArrayBuffer(buffer);
                if (ReadableStreamHasDefaultReader(stream2) === true) {
                  if (ReadableStreamGetNumReadRequests(stream2) === 0) {
                    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
                  } else {
                    assert(controller._queue.length === 0);
                    var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
                    ReadableStreamFulfillReadRequest(stream2, transferredView, false);
                  }
                } else if (ReadableStreamHasBYOBReader(stream2) === true) {
                  ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
                  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
                } else {
                  assert(IsReadableStreamLocked(stream2) === false, "stream must not be locked");
                  ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
                }
              }
              function ReadableByteStreamControllerError(controller, e) {
                var stream2 = controller._controlledReadableStream;
                assert(stream2._state === "readable");
                ReadableByteStreamControllerClearPendingPullIntos(controller);
                ResetQueue(controller);
                ReadableStreamError(stream2, e);
              }
              function ReadableByteStreamControllerGetDesiredSize(controller) {
                var stream2 = controller._controlledReadableStream;
                var state = stream2._state;
                if (state === "errored") {
                  return null;
                }
                if (state === "closed") {
                  return 0;
                }
                return controller._strategyHWM - controller._queueTotalSize;
              }
              function ReadableByteStreamControllerRespond(controller, bytesWritten) {
                bytesWritten = Number(bytesWritten);
                if (IsFiniteNonNegativeNumber(bytesWritten) === false) {
                  throw new RangeError("bytesWritten must be a finite");
                }
                assert(controller._pendingPullIntos.length > 0);
                ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
              }
              function ReadableByteStreamControllerRespondWithNewView(controller, view) {
                assert(controller._pendingPullIntos.length > 0);
                var firstDescriptor = controller._pendingPullIntos[0];
                if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
                  throw new RangeError("The region specified by view does not match byobRequest");
                }
                if (firstDescriptor.byteLength !== view.byteLength) {
                  throw new RangeError("The buffer of view has different capacity than byobRequest");
                }
                firstDescriptor.buffer = view.buffer;
                ReadableByteStreamControllerRespondInternal(controller, view.byteLength);
              }
              function streamBrandCheckException(name) {
                return new TypeError("ReadableStream.prototype." + name + " can only be used on a ReadableStream");
              }
              function readerLockException(name) {
                return new TypeError("Cannot " + name + " a stream using a released reader");
              }
              function defaultReaderBrandCheckException(name) {
                return new TypeError("ReadableStreamDefaultReader.prototype." + name + " can only be used on a ReadableStreamDefaultReader");
              }
              function defaultReaderClosedPromiseInitialize(reader) {
                reader._closedPromise = new Promise(function(resolve2, reject2) {
                  reader._closedPromise_resolve = resolve2;
                  reader._closedPromise_reject = reject2;
                });
              }
              function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
                reader._closedPromise = Promise.reject(reason);
                reader._closedPromise_resolve = void 0;
                reader._closedPromise_reject = void 0;
              }
              function defaultReaderClosedPromiseInitializeAsResolved(reader) {
                reader._closedPromise = Promise.resolve(void 0);
                reader._closedPromise_resolve = void 0;
                reader._closedPromise_reject = void 0;
              }
              function defaultReaderClosedPromiseReject(reader, reason) {
                assert(reader._closedPromise_resolve !== void 0);
                assert(reader._closedPromise_reject !== void 0);
                reader._closedPromise_reject(reason);
                reader._closedPromise_resolve = void 0;
                reader._closedPromise_reject = void 0;
              }
              function defaultReaderClosedPromiseResetToRejected(reader, reason) {
                assert(reader._closedPromise_resolve === void 0);
                assert(reader._closedPromise_reject === void 0);
                reader._closedPromise = Promise.reject(reason);
              }
              function defaultReaderClosedPromiseResolve(reader) {
                assert(reader._closedPromise_resolve !== void 0);
                assert(reader._closedPromise_reject !== void 0);
                reader._closedPromise_resolve(void 0);
                reader._closedPromise_resolve = void 0;
                reader._closedPromise_reject = void 0;
              }
              function byobReaderBrandCheckException(name) {
                return new TypeError("ReadableStreamBYOBReader.prototype." + name + " can only be used on a ReadableStreamBYOBReader");
              }
              function defaultControllerBrandCheckException(name) {
                return new TypeError("ReadableStreamDefaultController.prototype." + name + " can only be used on a ReadableStreamDefaultController");
              }
              function byobRequestBrandCheckException(name) {
                return new TypeError("ReadableStreamBYOBRequest.prototype." + name + " can only be used on a ReadableStreamBYOBRequest");
              }
              function byteStreamControllerBrandCheckException(name) {
                return new TypeError("ReadableByteStreamController.prototype." + name + " can only be used on a ReadableByteStreamController");
              }
              function ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise) {
                try {
                  Promise.prototype.then.call(promise, void 0, function() {
                  });
                } catch (e) {
                }
              }
            }, function(module4, exports4, __w_pdfjs_require__2) {
              "use strict";
              var transformStream = __w_pdfjs_require__2(6);
              var readableStream2 = __w_pdfjs_require__2(4);
              var writableStream = __w_pdfjs_require__2(2);
              exports4.TransformStream = transformStream.TransformStream;
              exports4.ReadableStream = readableStream2.ReadableStream;
              exports4.IsReadableStreamDisturbed = readableStream2.IsReadableStreamDisturbed;
              exports4.ReadableStreamDefaultControllerClose = readableStream2.ReadableStreamDefaultControllerClose;
              exports4.ReadableStreamDefaultControllerEnqueue = readableStream2.ReadableStreamDefaultControllerEnqueue;
              exports4.ReadableStreamDefaultControllerError = readableStream2.ReadableStreamDefaultControllerError;
              exports4.ReadableStreamDefaultControllerGetDesiredSize = readableStream2.ReadableStreamDefaultControllerGetDesiredSize;
              exports4.AcquireWritableStreamDefaultWriter = writableStream.AcquireWritableStreamDefaultWriter;
              exports4.IsWritableStream = writableStream.IsWritableStream;
              exports4.IsWritableStreamLocked = writableStream.IsWritableStreamLocked;
              exports4.WritableStream = writableStream.WritableStream;
              exports4.WritableStreamAbort = writableStream.WritableStreamAbort;
              exports4.WritableStreamDefaultControllerError = writableStream.WritableStreamDefaultControllerError;
              exports4.WritableStreamDefaultWriterCloseWithErrorPropagation = writableStream.WritableStreamDefaultWriterCloseWithErrorPropagation;
              exports4.WritableStreamDefaultWriterRelease = writableStream.WritableStreamDefaultWriterRelease;
              exports4.WritableStreamDefaultWriterWrite = writableStream.WritableStreamDefaultWriterWrite;
            }, function(module4, exports4, __w_pdfjs_require__2) {
              "use strict";
              var _createClass = /* @__PURE__ */ function() {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function(Constructor, protoProps, staticProps) {
                  if (protoProps) defineProperties(Constructor.prototype, protoProps);
                  if (staticProps) defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var _require = __w_pdfjs_require__2(1), assert = _require.assert;
              var _require2 = __w_pdfjs_require__2(0), InvokeOrNoop = _require2.InvokeOrNoop, PromiseInvokeOrPerformFallback = _require2.PromiseInvokeOrPerformFallback, PromiseInvokeOrNoop = _require2.PromiseInvokeOrNoop, typeIsObject = _require2.typeIsObject;
              var _require3 = __w_pdfjs_require__2(4), ReadableStream2 = _require3.ReadableStream, ReadableStreamDefaultControllerClose = _require3.ReadableStreamDefaultControllerClose, ReadableStreamDefaultControllerEnqueue = _require3.ReadableStreamDefaultControllerEnqueue, ReadableStreamDefaultControllerError = _require3.ReadableStreamDefaultControllerError, ReadableStreamDefaultControllerGetDesiredSize = _require3.ReadableStreamDefaultControllerGetDesiredSize;
              var _require4 = __w_pdfjs_require__2(2), WritableStream = _require4.WritableStream, WritableStreamDefaultControllerError = _require4.WritableStreamDefaultControllerError;
              function TransformStreamCloseReadable(transformStream) {
                if (transformStream._errored === true) {
                  throw new TypeError("TransformStream is already errored");
                }
                if (transformStream._readableClosed === true) {
                  throw new TypeError("Readable side is already closed");
                }
                TransformStreamCloseReadableInternal(transformStream);
              }
              function TransformStreamEnqueueToReadable(transformStream, chunk) {
                if (transformStream._errored === true) {
                  throw new TypeError("TransformStream is already errored");
                }
                if (transformStream._readableClosed === true) {
                  throw new TypeError("Readable side is already closed");
                }
                var controller = transformStream._readableController;
                try {
                  ReadableStreamDefaultControllerEnqueue(controller, chunk);
                } catch (e) {
                  transformStream._readableClosed = true;
                  TransformStreamErrorIfNeeded(transformStream, e);
                  throw transformStream._storedError;
                }
                var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
                var maybeBackpressure = desiredSize <= 0;
                if (maybeBackpressure === true && transformStream._backpressure === false) {
                  TransformStreamSetBackpressure(transformStream, true);
                }
              }
              function TransformStreamError(transformStream, e) {
                if (transformStream._errored === true) {
                  throw new TypeError("TransformStream is already errored");
                }
                TransformStreamErrorInternal(transformStream, e);
              }
              function TransformStreamCloseReadableInternal(transformStream) {
                assert(transformStream._errored === false);
                assert(transformStream._readableClosed === false);
                try {
                  ReadableStreamDefaultControllerClose(transformStream._readableController);
                } catch (e) {
                  assert(false);
                }
                transformStream._readableClosed = true;
              }
              function TransformStreamErrorIfNeeded(transformStream, e) {
                if (transformStream._errored === false) {
                  TransformStreamErrorInternal(transformStream, e);
                }
              }
              function TransformStreamErrorInternal(transformStream, e) {
                assert(transformStream._errored === false);
                transformStream._errored = true;
                transformStream._storedError = e;
                if (transformStream._writableDone === false) {
                  WritableStreamDefaultControllerError(transformStream._writableController, e);
                }
                if (transformStream._readableClosed === false) {
                  ReadableStreamDefaultControllerError(transformStream._readableController, e);
                }
              }
              function TransformStreamReadableReadyPromise(transformStream) {
                assert(transformStream._backpressureChangePromise !== void 0, "_backpressureChangePromise should have been initialized");
                if (transformStream._backpressure === false) {
                  return Promise.resolve();
                }
                assert(transformStream._backpressure === true, "_backpressure should have been initialized");
                return transformStream._backpressureChangePromise;
              }
              function TransformStreamSetBackpressure(transformStream, backpressure) {
                assert(transformStream._backpressure !== backpressure, "TransformStreamSetBackpressure() should be called only when backpressure is changed");
                if (transformStream._backpressureChangePromise !== void 0) {
                  transformStream._backpressureChangePromise_resolve(backpressure);
                }
                transformStream._backpressureChangePromise = new Promise(function(resolve2) {
                  transformStream._backpressureChangePromise_resolve = resolve2;
                });
                transformStream._backpressureChangePromise.then(function(resolution) {
                  assert(resolution !== backpressure, "_backpressureChangePromise should be fulfilled only when backpressure is changed");
                });
                transformStream._backpressure = backpressure;
              }
              function TransformStreamDefaultTransform(chunk, transformStreamController) {
                var transformStream = transformStreamController._controlledTransformStream;
                TransformStreamEnqueueToReadable(transformStream, chunk);
                return Promise.resolve();
              }
              function TransformStreamTransform(transformStream, chunk) {
                assert(transformStream._errored === false);
                assert(transformStream._transforming === false);
                assert(transformStream._backpressure === false);
                transformStream._transforming = true;
                var transformer = transformStream._transformer;
                var controller = transformStream._transformStreamController;
                var transformPromise = PromiseInvokeOrPerformFallback(transformer, "transform", [chunk, controller], TransformStreamDefaultTransform, [chunk, controller]);
                return transformPromise.then(function() {
                  transformStream._transforming = false;
                  return TransformStreamReadableReadyPromise(transformStream);
                }, function(e) {
                  TransformStreamErrorIfNeeded(transformStream, e);
                  return Promise.reject(e);
                });
              }
              function IsTransformStreamDefaultController(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
                  return false;
                }
                return true;
              }
              function IsTransformStream(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
                  return false;
                }
                return true;
              }
              var TransformStreamSink = function() {
                function TransformStreamSink2(transformStream, startPromise) {
                  _classCallCheck(this, TransformStreamSink2);
                  this._transformStream = transformStream;
                  this._startPromise = startPromise;
                }
                _createClass(TransformStreamSink2, [{
                  key: "start",
                  value: function start(c) {
                    var transformStream = this._transformStream;
                    transformStream._writableController = c;
                    return this._startPromise.then(function() {
                      return TransformStreamReadableReadyPromise(transformStream);
                    });
                  }
                }, {
                  key: "write",
                  value: function write(chunk) {
                    var transformStream = this._transformStream;
                    return TransformStreamTransform(transformStream, chunk);
                  }
                }, {
                  key: "abort",
                  value: function abort() {
                    var transformStream = this._transformStream;
                    transformStream._writableDone = true;
                    TransformStreamErrorInternal(transformStream, new TypeError("Writable side aborted"));
                  }
                }, {
                  key: "close",
                  value: function close() {
                    var transformStream = this._transformStream;
                    assert(transformStream._transforming === false);
                    transformStream._writableDone = true;
                    var flushPromise = PromiseInvokeOrNoop(transformStream._transformer, "flush", [transformStream._transformStreamController]);
                    return flushPromise.then(function() {
                      if (transformStream._errored === true) {
                        return Promise.reject(transformStream._storedError);
                      }
                      if (transformStream._readableClosed === false) {
                        TransformStreamCloseReadableInternal(transformStream);
                      }
                      return Promise.resolve();
                    }).catch(function(r) {
                      TransformStreamErrorIfNeeded(transformStream, r);
                      return Promise.reject(transformStream._storedError);
                    });
                  }
                }]);
                return TransformStreamSink2;
              }();
              var TransformStreamSource = function() {
                function TransformStreamSource2(transformStream, startPromise) {
                  _classCallCheck(this, TransformStreamSource2);
                  this._transformStream = transformStream;
                  this._startPromise = startPromise;
                }
                _createClass(TransformStreamSource2, [{
                  key: "start",
                  value: function start(c) {
                    var transformStream = this._transformStream;
                    transformStream._readableController = c;
                    return this._startPromise.then(function() {
                      assert(transformStream._backpressureChangePromise !== void 0, "_backpressureChangePromise should have been initialized");
                      if (transformStream._backpressure === true) {
                        return Promise.resolve();
                      }
                      assert(transformStream._backpressure === false, "_backpressure should have been initialized");
                      return transformStream._backpressureChangePromise;
                    });
                  }
                }, {
                  key: "pull",
                  value: function pull() {
                    var transformStream = this._transformStream;
                    assert(transformStream._backpressure === true, "pull() should be never called while _backpressure is false");
                    assert(transformStream._backpressureChangePromise !== void 0, "_backpressureChangePromise should have been initialized");
                    TransformStreamSetBackpressure(transformStream, false);
                    return transformStream._backpressureChangePromise;
                  }
                }, {
                  key: "cancel",
                  value: function cancel() {
                    var transformStream = this._transformStream;
                    transformStream._readableClosed = true;
                    TransformStreamErrorInternal(transformStream, new TypeError("Readable side canceled"));
                  }
                }]);
                return TransformStreamSource2;
              }();
              var TransformStreamDefaultController = function() {
                function TransformStreamDefaultController2(transformStream) {
                  _classCallCheck(this, TransformStreamDefaultController2);
                  if (IsTransformStream(transformStream) === false) {
                    throw new TypeError("TransformStreamDefaultController can only be constructed with a TransformStream instance");
                  }
                  if (transformStream._transformStreamController !== void 0) {
                    throw new TypeError("TransformStreamDefaultController instances can only be created by the TransformStream constructor");
                  }
                  this._controlledTransformStream = transformStream;
                }
                _createClass(TransformStreamDefaultController2, [{
                  key: "enqueue",
                  value: function enqueue(chunk) {
                    if (IsTransformStreamDefaultController(this) === false) {
                      throw defaultControllerBrandCheckException("enqueue");
                    }
                    TransformStreamEnqueueToReadable(this._controlledTransformStream, chunk);
                  }
                }, {
                  key: "close",
                  value: function close() {
                    if (IsTransformStreamDefaultController(this) === false) {
                      throw defaultControllerBrandCheckException("close");
                    }
                    TransformStreamCloseReadable(this._controlledTransformStream);
                  }
                }, {
                  key: "error",
                  value: function error(reason) {
                    if (IsTransformStreamDefaultController(this) === false) {
                      throw defaultControllerBrandCheckException("error");
                    }
                    TransformStreamError(this._controlledTransformStream, reason);
                  }
                }, {
                  key: "desiredSize",
                  get: function get() {
                    if (IsTransformStreamDefaultController(this) === false) {
                      throw defaultControllerBrandCheckException("desiredSize");
                    }
                    var transformStream = this._controlledTransformStream;
                    var readableController = transformStream._readableController;
                    return ReadableStreamDefaultControllerGetDesiredSize(readableController);
                  }
                }]);
                return TransformStreamDefaultController2;
              }();
              var TransformStream = function() {
                function TransformStream2() {
                  var transformer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  _classCallCheck(this, TransformStream2);
                  this._transformer = transformer;
                  var readableStrategy = transformer.readableStrategy, writableStrategy = transformer.writableStrategy;
                  this._transforming = false;
                  this._errored = false;
                  this._storedError = void 0;
                  this._writableController = void 0;
                  this._readableController = void 0;
                  this._transformStreamController = void 0;
                  this._writableDone = false;
                  this._readableClosed = false;
                  this._backpressure = void 0;
                  this._backpressureChangePromise = void 0;
                  this._backpressureChangePromise_resolve = void 0;
                  this._transformStreamController = new TransformStreamDefaultController(this);
                  var startPromise_resolve = void 0;
                  var startPromise = new Promise(function(resolve2) {
                    startPromise_resolve = resolve2;
                  });
                  var source = new TransformStreamSource(this, startPromise);
                  this._readable = new ReadableStream2(source, readableStrategy);
                  var sink = new TransformStreamSink(this, startPromise);
                  this._writable = new WritableStream(sink, writableStrategy);
                  assert(this._writableController !== void 0);
                  assert(this._readableController !== void 0);
                  var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(this._readableController);
                  TransformStreamSetBackpressure(this, desiredSize <= 0);
                  var transformStream = this;
                  var startResult = InvokeOrNoop(transformer, "start", [transformStream._transformStreamController]);
                  startPromise_resolve(startResult);
                  startPromise.catch(function(e) {
                    if (transformStream._errored === false) {
                      transformStream._errored = true;
                      transformStream._storedError = e;
                    }
                  });
                }
                _createClass(TransformStream2, [{
                  key: "readable",
                  get: function get() {
                    if (IsTransformStream(this) === false) {
                      throw streamBrandCheckException("readable");
                    }
                    return this._readable;
                  }
                }, {
                  key: "writable",
                  get: function get() {
                    if (IsTransformStream(this) === false) {
                      throw streamBrandCheckException("writable");
                    }
                    return this._writable;
                  }
                }]);
                return TransformStream2;
              }();
              module4.exports = { TransformStream };
              function defaultControllerBrandCheckException(name) {
                return new TypeError("TransformStreamDefaultController.prototype." + name + " can only be used on a TransformStreamDefaultController");
              }
              function streamBrandCheckException(name) {
                return new TypeError("TransformStream.prototype." + name + " can only be used on a TransformStream");
              }
            }, function(module4, exports4, __w_pdfjs_require__2) {
              module4.exports = __w_pdfjs_require__2(5);
            }]));
          },
          /* 114 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.build = exports3.version = exports3.setPDFNetworkStreamFactory = exports3.PDFPageProxy = exports3.PDFDocumentProxy = exports3.PDFWorker = exports3.PDFDataRangeTransport = exports3.LoopbackPort = exports3.getDocument = void 0;
            var _createClass = /* @__PURE__ */ function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var _util = __w_pdfjs_require__(1);
            var _dom_utils = __w_pdfjs_require__(115);
            var _font_loader = __w_pdfjs_require__(116);
            var _api_compatibility = __w_pdfjs_require__(117);
            var _canvas = __w_pdfjs_require__(118);
            var _global_scope = __w_pdfjs_require__(3);
            var _global_scope2 = _interopRequireDefault(_global_scope);
            var _worker_options = __w_pdfjs_require__(120);
            var _message_handler = __w_pdfjs_require__(121);
            var _metadata = __w_pdfjs_require__(122);
            var _transport_stream = __w_pdfjs_require__(124);
            var _webgl = __w_pdfjs_require__(125);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var DEFAULT_RANGE_CHUNK_SIZE = 65536;
            var isWorkerDisabled = false;
            var workerSrc = void 0;
            var pdfjsFilePath = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : null;
            var fakeWorkerFilesLoader = null;
            var useRequireEnsure = false;
            {
              if (typeof window === "undefined") {
                isWorkerDisabled = true;
                if (typeof __require.ensure === "undefined") {
                  __require.ensure = require_browser2();
                }
                useRequireEnsure = true;
              } else if (typeof __require !== "undefined" && typeof __require.ensure === "function") {
                useRequireEnsure = true;
              }
              if (typeof requirejs !== "undefined" && requirejs.toUrl) {
                workerSrc = requirejs.toUrl("pdfjs-dist/build/pdf.worker.js");
              }
              var dynamicLoaderSupported = typeof requirejs !== "undefined" && requirejs.load;
              fakeWorkerFilesLoader = useRequireEnsure ? function(callback) {
                __require.ensure([], function() {
                  var worker;
                  worker = require_pdf_worker();
                  callback(worker.WorkerMessageHandler);
                });
              } : dynamicLoaderSupported ? function(callback) {
                requirejs(["pdfjs-dist/build/pdf.worker"], function(worker) {
                  callback(worker.WorkerMessageHandler);
                });
              } : null;
            }
            var createPDFNetworkStream;
            function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
              createPDFNetworkStream = pdfNetworkStreamFactory;
            }
            function getDocument(src) {
              var task = new PDFDocumentLoadingTask();
              var source;
              if (typeof src === "string") {
                source = { url: src };
              } else if ((0, _util.isArrayBuffer)(src)) {
                source = { data: src };
              } else if (src instanceof PDFDataRangeTransport) {
                source = { range: src };
              } else {
                if ((typeof src === "undefined" ? "undefined" : _typeof(src)) !== "object") {
                  throw new Error("Invalid parameter in getDocument, need either Uint8Array, string or a parameter object");
                }
                if (!src.url && !src.data && !src.range) {
                  throw new Error("Invalid parameter object: need either .data, .range or .url");
                }
                source = src;
              }
              var params = /* @__PURE__ */ Object.create(null);
              var rangeTransport = null;
              var worker = null;
              var CMapReaderFactory = _dom_utils.DOMCMapReaderFactory;
              for (var key in source) {
                if (key === "url" && typeof window !== "undefined") {
                  params[key] = new URL(source[key], window.location).href;
                  continue;
                } else if (key === "range") {
                  rangeTransport = source[key];
                  continue;
                } else if (key === "worker") {
                  worker = source[key];
                  continue;
                } else if (key === "data" && !(source[key] instanceof Uint8Array)) {
                  var pdfBytes = source[key];
                  if (typeof pdfBytes === "string") {
                    params[key] = (0, _util.stringToBytes)(pdfBytes);
                  } else if ((typeof pdfBytes === "undefined" ? "undefined" : _typeof(pdfBytes)) === "object" && pdfBytes !== null && !isNaN(pdfBytes.length)) {
                    params[key] = new Uint8Array(pdfBytes);
                  } else if ((0, _util.isArrayBuffer)(pdfBytes)) {
                    params[key] = new Uint8Array(pdfBytes);
                  } else {
                    throw new Error("Invalid PDF binary data: either typed array, string or array-like object is expected in the data property.");
                  }
                  continue;
                } else if (key === "CMapReaderFactory") {
                  CMapReaderFactory = source[key];
                  continue;
                }
                params[key] = source[key];
              }
              params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;
              params.ignoreErrors = params.stopAtErrors !== true;
              params.pdfBug = params.pdfBug === true;
              var NativeImageDecoderValues = Object.values(_util.NativeImageDecoding);
              if (params.nativeImageDecoderSupport === void 0 || !NativeImageDecoderValues.includes(params.nativeImageDecoderSupport)) {
                params.nativeImageDecoderSupport = _api_compatibility.apiCompatibilityParams.nativeImageDecoderSupport || _util.NativeImageDecoding.DECODE;
              }
              if (!Number.isInteger(params.maxImageSize)) {
                params.maxImageSize = -1;
              }
              if (typeof params.isEvalSupported !== "boolean") {
                params.isEvalSupported = true;
              }
              if (typeof params.disableFontFace !== "boolean") {
                params.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || false;
              }
              if (typeof params.disableRange !== "boolean") {
                params.disableRange = _api_compatibility.apiCompatibilityParams.disableRange || false;
              }
              if (typeof params.disableStream !== "boolean") {
                params.disableStream = _api_compatibility.apiCompatibilityParams.disableStream || false;
              }
              if (typeof params.disableAutoFetch !== "boolean") {
                params.disableAutoFetch = false;
              }
              if (typeof params.disableCreateObjectURL !== "boolean") {
                params.disableCreateObjectURL = _api_compatibility.apiCompatibilityParams.disableCreateObjectURL || false;
              }
              (0, _util.setVerbosityLevel)(params.verbosity);
              if (!worker) {
                var workerParams = {
                  postMessageTransfers: params.postMessageTransfers,
                  verbosity: params.verbosity
                };
                var workerPort = _worker_options.GlobalWorkerOptions.workerPort;
                if (workerPort) {
                  workerParams.port = workerPort;
                  worker = PDFWorker.fromPort(workerParams);
                } else {
                  worker = new PDFWorker(workerParams);
                }
                task._worker = worker;
              }
              var docId = task.docId;
              worker.promise.then(function() {
                if (task.destroyed) {
                  throw new Error("Loading aborted");
                }
                return _fetchDocument(worker, params, rangeTransport, docId).then(function(workerId) {
                  if (task.destroyed) {
                    throw new Error("Loading aborted");
                  }
                  var networkStream = void 0;
                  if (rangeTransport) {
                    networkStream = new _transport_stream.PDFDataTransportStream({
                      length: params.length,
                      initialData: params.initialData,
                      disableRange: params.disableRange,
                      disableStream: params.disableStream
                    }, rangeTransport);
                  } else if (!params.data) {
                    networkStream = createPDFNetworkStream({
                      url: params.url,
                      length: params.length,
                      httpHeaders: params.httpHeaders,
                      withCredentials: params.withCredentials,
                      rangeChunkSize: params.rangeChunkSize,
                      disableRange: params.disableRange,
                      disableStream: params.disableStream
                    });
                  }
                  var messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);
                  messageHandler.postMessageTransfers = worker.postMessageTransfers;
                  var transport = new WorkerTransport(messageHandler, task, networkStream, params, CMapReaderFactory);
                  task._transport = transport;
                  messageHandler.send("Ready", null);
                });
              }).catch(task._capability.reject);
              return task;
            }
            function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {
              if (worker.destroyed) {
                return Promise.reject(new Error("Worker was destroyed"));
              }
              if (pdfDataRangeTransport) {
                source.length = pdfDataRangeTransport.length;
                source.initialData = pdfDataRangeTransport.initialData;
              }
              return worker.messageHandler.sendWithPromise("GetDocRequest", {
                docId,
                apiVersion: "2.0.550",
                source: {
                  data: source.data,
                  url: source.url,
                  password: source.password,
                  disableAutoFetch: source.disableAutoFetch,
                  rangeChunkSize: source.rangeChunkSize,
                  length: source.length
                },
                maxImageSize: source.maxImageSize,
                disableFontFace: source.disableFontFace,
                disableCreateObjectURL: source.disableCreateObjectURL,
                postMessageTransfers: worker.postMessageTransfers,
                docBaseUrl: source.docBaseUrl,
                nativeImageDecoderSupport: source.nativeImageDecoderSupport,
                ignoreErrors: source.ignoreErrors,
                isEvalSupported: source.isEvalSupported
              }).then(function(workerId) {
                if (worker.destroyed) {
                  throw new Error("Worker was destroyed");
                }
                return workerId;
              });
            }
            var PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {
              var nextDocumentId = 0;
              function PDFDocumentLoadingTask2() {
                this._capability = (0, _util.createPromiseCapability)();
                this._transport = null;
                this._worker = null;
                this.docId = "d" + nextDocumentId++;
                this.destroyed = false;
                this.onPassword = null;
                this.onProgress = null;
                this.onUnsupportedFeature = null;
              }
              PDFDocumentLoadingTask2.prototype = {
                get promise() {
                  return this._capability.promise;
                },
                destroy: function destroy() {
                  var _this = this;
                  this.destroyed = true;
                  var transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();
                  return transportDestroyed.then(function() {
                    _this._transport = null;
                    if (_this._worker) {
                      _this._worker.destroy();
                      _this._worker = null;
                    }
                  });
                },
                then: function PDFDocumentLoadingTask_then(onFulfilled, onRejected) {
                  return this.promise.then.apply(this.promise, arguments);
                }
              };
              return PDFDocumentLoadingTask2;
            }();
            var PDFDataRangeTransport = function pdfDataRangeTransportClosure() {
              function PDFDataRangeTransport2(length, initialData) {
                this.length = length;
                this.initialData = initialData;
                this._rangeListeners = [];
                this._progressListeners = [];
                this._progressiveReadListeners = [];
                this._readyCapability = (0, _util.createPromiseCapability)();
              }
              PDFDataRangeTransport2.prototype = {
                addRangeListener: function PDFDataRangeTransport_addRangeListener(listener) {
                  this._rangeListeners.push(listener);
                },
                addProgressListener: function PDFDataRangeTransport_addProgressListener(listener) {
                  this._progressListeners.push(listener);
                },
                addProgressiveReadListener: function PDFDataRangeTransport_addProgressiveReadListener(listener) {
                  this._progressiveReadListeners.push(listener);
                },
                onDataRange: function PDFDataRangeTransport_onDataRange(begin, chunk) {
                  var listeners = this._rangeListeners;
                  for (var i = 0, n = listeners.length; i < n; ++i) {
                    listeners[i](begin, chunk);
                  }
                },
                onDataProgress: function PDFDataRangeTransport_onDataProgress(loaded) {
                  var _this2 = this;
                  this._readyCapability.promise.then(function() {
                    var listeners = _this2._progressListeners;
                    for (var i = 0, n = listeners.length; i < n; ++i) {
                      listeners[i](loaded);
                    }
                  });
                },
                onDataProgressiveRead: function PDFDataRangeTransport_onDataProgress(chunk) {
                  var _this3 = this;
                  this._readyCapability.promise.then(function() {
                    var listeners = _this3._progressiveReadListeners;
                    for (var i = 0, n = listeners.length; i < n; ++i) {
                      listeners[i](chunk);
                    }
                  });
                },
                transportReady: function PDFDataRangeTransport_transportReady() {
                  this._readyCapability.resolve();
                },
                requestDataRange: function PDFDataRangeTransport_requestDataRange(begin, end) {
                  (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
                },
                abort: function PDFDataRangeTransport_abort() {
                }
              };
              return PDFDataRangeTransport2;
            }();
            var PDFDocumentProxy = function PDFDocumentProxyClosure() {
              function PDFDocumentProxy2(pdfInfo, transport, loadingTask) {
                this.pdfInfo = pdfInfo;
                this.transport = transport;
                this.loadingTask = loadingTask;
              }
              PDFDocumentProxy2.prototype = {
                get numPages() {
                  return this.pdfInfo.numPages;
                },
                get fingerprint() {
                  return this.pdfInfo.fingerprint;
                },
                getPage: function getPage(pageNumber) {
                  return this.transport.getPage(pageNumber);
                },
                getPageIndex: function PDFDocumentProxy_getPageIndex(ref) {
                  return this.transport.getPageIndex(ref);
                },
                getDestinations: function PDFDocumentProxy_getDestinations() {
                  return this.transport.getDestinations();
                },
                getDestination: function PDFDocumentProxy_getDestination(id) {
                  return this.transport.getDestination(id);
                },
                getPageLabels: function PDFDocumentProxy_getPageLabels() {
                  return this.transport.getPageLabels();
                },
                getPageMode: function getPageMode() {
                  return this.transport.getPageMode();
                },
                getAttachments: function PDFDocumentProxy_getAttachments() {
                  return this.transport.getAttachments();
                },
                getJavaScript: function getJavaScript() {
                  return this.transport.getJavaScript();
                },
                getOutline: function PDFDocumentProxy_getOutline() {
                  return this.transport.getOutline();
                },
                getMetadata: function PDFDocumentProxy_getMetadata() {
                  return this.transport.getMetadata();
                },
                getData: function PDFDocumentProxy_getData() {
                  return this.transport.getData();
                },
                getDownloadInfo: function PDFDocumentProxy_getDownloadInfo() {
                  return this.transport.downloadInfoCapability.promise;
                },
                getStats: function PDFDocumentProxy_getStats() {
                  return this.transport.getStats();
                },
                cleanup: function PDFDocumentProxy_cleanup() {
                  this.transport.startCleanup();
                },
                destroy: function PDFDocumentProxy_destroy() {
                  return this.loadingTask.destroy();
                },
                get loadingParams() {
                  return this.transport.loadingParams;
                }
              };
              return PDFDocumentProxy2;
            }();
            var PDFPageProxy = function PDFPageProxyClosure() {
              function PDFPageProxy2(pageIndex, pageInfo, transport) {
                var pdfBug = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                this.pageIndex = pageIndex;
                this.pageInfo = pageInfo;
                this.transport = transport;
                this._stats = pdfBug ? new _dom_utils.StatTimer() : _dom_utils.DummyStatTimer;
                this._pdfBug = pdfBug;
                this.commonObjs = transport.commonObjs;
                this.objs = new PDFObjects();
                this.cleanupAfterRender = false;
                this.pendingCleanup = false;
                this.intentStates = /* @__PURE__ */ Object.create(null);
                this.destroyed = false;
              }
              PDFPageProxy2.prototype = {
                get pageNumber() {
                  return this.pageIndex + 1;
                },
                get rotate() {
                  return this.pageInfo.rotate;
                },
                get ref() {
                  return this.pageInfo.ref;
                },
                get userUnit() {
                  return this.pageInfo.userUnit;
                },
                get view() {
                  return this.pageInfo.view;
                },
                getViewport: function getViewport(scale) {
                  var rotate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.rotate;
                  var dontFlip = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  return new _dom_utils.PageViewport({
                    viewBox: this.view,
                    scale,
                    rotation: rotate,
                    dontFlip
                  });
                },
                getAnnotations: function PDFPageProxy_getAnnotations(params) {
                  var intent = params && params.intent || null;
                  if (!this.annotationsPromise || this.annotationsIntent !== intent) {
                    this.annotationsPromise = this.transport.getAnnotations(this.pageIndex, intent);
                    this.annotationsIntent = intent;
                  }
                  return this.annotationsPromise;
                },
                render: function PDFPageProxy_render(params) {
                  var _this4 = this;
                  var stats = this._stats;
                  stats.time("Overall");
                  this.pendingCleanup = false;
                  var renderingIntent = params.intent === "print" ? "print" : "display";
                  var canvasFactory = params.canvasFactory || new _dom_utils.DOMCanvasFactory();
                  var webGLContext = new _webgl.WebGLContext({ enable: params.enableWebGL });
                  if (!this.intentStates[renderingIntent]) {
                    this.intentStates[renderingIntent] = /* @__PURE__ */ Object.create(null);
                  }
                  var intentState = this.intentStates[renderingIntent];
                  if (!intentState.displayReadyCapability) {
                    intentState.receivingOperatorList = true;
                    intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
                    intentState.operatorList = {
                      fnArray: [],
                      argsArray: [],
                      lastChunk: false
                    };
                    stats.time("Page Request");
                    this.transport.messageHandler.send("RenderPageRequest", {
                      pageIndex: this.pageNumber - 1,
                      intent: renderingIntent,
                      renderInteractiveForms: params.renderInteractiveForms === true
                    });
                  }
                  var complete = function complete2(error) {
                    var i = intentState.renderTasks.indexOf(internalRenderTask);
                    if (i >= 0) {
                      intentState.renderTasks.splice(i, 1);
                    }
                    if (_this4.cleanupAfterRender) {
                      _this4.pendingCleanup = true;
                    }
                    _this4._tryCleanup();
                    if (error) {
                      internalRenderTask.capability.reject(error);
                    } else {
                      internalRenderTask.capability.resolve();
                    }
                    stats.timeEnd("Rendering");
                    stats.timeEnd("Overall");
                  };
                  var internalRenderTask = new InternalRenderTask(complete, params, this.objs, this.commonObjs, intentState.operatorList, this.pageNumber, canvasFactory, webGLContext, this._pdfBug);
                  internalRenderTask.useRequestAnimationFrame = renderingIntent !== "print";
                  if (!intentState.renderTasks) {
                    intentState.renderTasks = [];
                  }
                  intentState.renderTasks.push(internalRenderTask);
                  var renderTask = internalRenderTask.task;
                  intentState.displayReadyCapability.promise.then(function(transparency) {
                    if (_this4.pendingCleanup) {
                      complete();
                      return;
                    }
                    stats.time("Rendering");
                    internalRenderTask.initializeGraphics(transparency);
                    internalRenderTask.operatorListChanged();
                  }).catch(complete);
                  return renderTask;
                },
                getOperatorList: function PDFPageProxy_getOperatorList() {
                  function operatorListChanged() {
                    if (intentState.operatorList.lastChunk) {
                      intentState.opListReadCapability.resolve(intentState.operatorList);
                      var i = intentState.renderTasks.indexOf(opListTask);
                      if (i >= 0) {
                        intentState.renderTasks.splice(i, 1);
                      }
                    }
                  }
                  var renderingIntent = "oplist";
                  if (!this.intentStates[renderingIntent]) {
                    this.intentStates[renderingIntent] = /* @__PURE__ */ Object.create(null);
                  }
                  var intentState = this.intentStates[renderingIntent];
                  var opListTask;
                  if (!intentState.opListReadCapability) {
                    opListTask = {};
                    opListTask.operatorListChanged = operatorListChanged;
                    intentState.receivingOperatorList = true;
                    intentState.opListReadCapability = (0, _util.createPromiseCapability)();
                    intentState.renderTasks = [];
                    intentState.renderTasks.push(opListTask);
                    intentState.operatorList = {
                      fnArray: [],
                      argsArray: [],
                      lastChunk: false
                    };
                    this.transport.messageHandler.send("RenderPageRequest", {
                      pageIndex: this.pageIndex,
                      intent: renderingIntent
                    });
                  }
                  return intentState.opListReadCapability.promise;
                },
                streamTextContent: function streamTextContent() {
                  var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  var TEXT_CONTENT_CHUNK_SIZE = 100;
                  return this.transport.messageHandler.sendWithStream("GetTextContent", {
                    pageIndex: this.pageNumber - 1,
                    normalizeWhitespace: params.normalizeWhitespace === true,
                    combineTextItems: params.disableCombineTextItems !== true
                  }, {
                    highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
                    size: function size(textContent) {
                      return textContent.items.length;
                    }
                  });
                },
                getTextContent: function PDFPageProxy_getTextContent(params) {
                  params = params || {};
                  var readableStream2 = this.streamTextContent(params);
                  return new Promise(function(resolve2, reject2) {
                    function pump() {
                      reader.read().then(function(_ref) {
                        var value = _ref.value, done = _ref.done;
                        if (done) {
                          resolve2(textContent);
                          return;
                        }
                        _util.Util.extendObj(textContent.styles, value.styles);
                        _util.Util.appendToArray(textContent.items, value.items);
                        pump();
                      }, reject2);
                    }
                    var reader = readableStream2.getReader();
                    var textContent = {
                      items: [],
                      styles: /* @__PURE__ */ Object.create(null)
                    };
                    pump();
                  });
                },
                _destroy: function PDFPageProxy_destroy() {
                  this.destroyed = true;
                  this.transport.pageCache[this.pageIndex] = null;
                  var waitOn = [];
                  Object.keys(this.intentStates).forEach(function(intent) {
                    if (intent === "oplist") {
                      return;
                    }
                    var intentState = this.intentStates[intent];
                    intentState.renderTasks.forEach(function(renderTask) {
                      var renderCompleted = renderTask.capability.promise.catch(function() {
                      });
                      waitOn.push(renderCompleted);
                      renderTask.cancel();
                    });
                  }, this);
                  this.objs.clear();
                  this.annotationsPromise = null;
                  this.pendingCleanup = false;
                  return Promise.all(waitOn);
                },
                cleanup: function cleanup() {
                  var resetStats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  this.pendingCleanup = true;
                  this._tryCleanup(resetStats);
                },
                _tryCleanup: function _tryCleanup() {
                  var resetStats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  if (!this.pendingCleanup || Object.keys(this.intentStates).some(function(intent) {
                    var intentState = this.intentStates[intent];
                    return intentState.renderTasks.length !== 0 || intentState.receivingOperatorList;
                  }, this)) {
                    return;
                  }
                  Object.keys(this.intentStates).forEach(function(intent) {
                    delete this.intentStates[intent];
                  }, this);
                  this.objs.clear();
                  this.annotationsPromise = null;
                  if (resetStats && this._stats instanceof _dom_utils.StatTimer) {
                    this._stats = new _dom_utils.StatTimer();
                  }
                  this.pendingCleanup = false;
                },
                _startRenderPage: function PDFPageProxy_startRenderPage(transparency, intent) {
                  var intentState = this.intentStates[intent];
                  if (intentState.displayReadyCapability) {
                    intentState.displayReadyCapability.resolve(transparency);
                  }
                },
                _renderPageChunk: function PDFPageProxy_renderPageChunk(operatorListChunk, intent) {
                  var intentState = this.intentStates[intent];
                  var i, ii;
                  for (i = 0, ii = operatorListChunk.length; i < ii; i++) {
                    intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
                    intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
                  }
                  intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
                  for (i = 0; i < intentState.renderTasks.length; i++) {
                    intentState.renderTasks[i].operatorListChanged();
                  }
                  if (operatorListChunk.lastChunk) {
                    intentState.receivingOperatorList = false;
                    this._tryCleanup();
                  }
                },
                get stats() {
                  return this._stats instanceof _dom_utils.StatTimer ? this._stats : null;
                }
              };
              return PDFPageProxy2;
            }();
            var LoopbackPort = function() {
              function LoopbackPort2() {
                var defer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                _classCallCheck(this, LoopbackPort2);
                this._listeners = [];
                this._defer = defer;
                this._deferred = Promise.resolve(void 0);
              }
              _createClass(LoopbackPort2, [{
                key: "postMessage",
                value: function postMessage2(obj, transfers) {
                  var _this5 = this;
                  function cloneValue(value) {
                    if ((typeof value === "undefined" ? "undefined" : _typeof(value)) !== "object" || value === null) {
                      return value;
                    }
                    if (cloned.has(value)) {
                      return cloned.get(value);
                    }
                    var result;
                    var buffer;
                    if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {
                      var transferable = transfers && transfers.includes(buffer);
                      if (value === buffer) {
                        result = value;
                      } else if (transferable) {
                        result = new value.constructor(buffer, value.byteOffset, value.byteLength);
                      } else {
                        result = new value.constructor(value);
                      }
                      cloned.set(value, result);
                      return result;
                    }
                    result = Array.isArray(value) ? [] : {};
                    cloned.set(value, result);
                    for (var i in value) {
                      var desc, p = value;
                      while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {
                        p = Object.getPrototypeOf(p);
                      }
                      if (typeof desc.value === "undefined" || typeof desc.value === "function") {
                        continue;
                      }
                      result[i] = cloneValue(desc.value);
                    }
                    return result;
                  }
                  if (!this._defer) {
                    this._listeners.forEach(function(listener) {
                      listener.call(this, { data: obj });
                    }, this);
                    return;
                  }
                  var cloned = /* @__PURE__ */ new WeakMap();
                  var e = { data: cloneValue(obj) };
                  this._deferred.then(function() {
                    _this5._listeners.forEach(function(listener) {
                      listener.call(this, e);
                    }, _this5);
                  });
                }
              }, {
                key: "addEventListener",
                value: function addEventListener(name, listener) {
                  this._listeners.push(listener);
                }
              }, {
                key: "removeEventListener",
                value: function removeEventListener(name, listener) {
                  var i = this._listeners.indexOf(listener);
                  this._listeners.splice(i, 1);
                }
              }, {
                key: "terminate",
                value: function terminate() {
                  this._listeners = [];
                }
              }]);
              return LoopbackPort2;
            }();
            var PDFWorker = function PDFWorkerClosure() {
              var nextFakeWorkerId = 0;
              function getWorkerSrc() {
                if (_worker_options.GlobalWorkerOptions.workerSrc) {
                  return _worker_options.GlobalWorkerOptions.workerSrc;
                }
                if (typeof workerSrc !== "undefined") {
                  return workerSrc;
                }
                if (pdfjsFilePath) {
                  return pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
                }
                throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
              }
              function getMainThreadWorkerMessageHandler() {
                if (typeof window === "undefined") {
                  return null;
                }
                return window.pdfjsWorker && window.pdfjsWorker.WorkerMessageHandler;
              }
              var fakeWorkerFilesLoadedCapability = void 0;
              function setupFakeWorkerGlobal() {
                if (fakeWorkerFilesLoadedCapability) {
                  return fakeWorkerFilesLoadedCapability.promise;
                }
                fakeWorkerFilesLoadedCapability = (0, _util.createPromiseCapability)();
                var mainWorkerMessageHandler = getMainThreadWorkerMessageHandler();
                if (mainWorkerMessageHandler) {
                  fakeWorkerFilesLoadedCapability.resolve(mainWorkerMessageHandler);
                  return fakeWorkerFilesLoadedCapability.promise;
                }
                var loader = fakeWorkerFilesLoader || function(callback) {
                  _util.Util.loadScript(getWorkerSrc(), function() {
                    callback(window.pdfjsWorker.WorkerMessageHandler);
                  });
                };
                loader(fakeWorkerFilesLoadedCapability.resolve);
                return fakeWorkerFilesLoadedCapability.promise;
              }
              function createCDNWrapper(url) {
                var wrapper = "importScripts('" + url + "');";
                return URL.createObjectURL(new Blob([wrapper]));
              }
              var pdfWorkerPorts = /* @__PURE__ */ new WeakMap();
              function PDFWorker2() {
                var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref2$name = _ref2.name, name = _ref2$name === void 0 ? null : _ref2$name, _ref2$port = _ref2.port, port = _ref2$port === void 0 ? null : _ref2$port, _ref2$postMessageTran = _ref2.postMessageTransfers, postMessageTransfers = _ref2$postMessageTran === void 0 ? true : _ref2$postMessageTran, _ref2$verbosity = _ref2.verbosity, verbosity = _ref2$verbosity === void 0 ? null : _ref2$verbosity;
                if (port && pdfWorkerPorts.has(port)) {
                  throw new Error("Cannot use more than one PDFWorker per port");
                }
                this.name = name;
                this.destroyed = false;
                this.postMessageTransfers = postMessageTransfers !== false;
                this.verbosity = (0, _util.isNum)(verbosity) ? verbosity : (0, _util.getVerbosityLevel)();
                this._readyCapability = (0, _util.createPromiseCapability)();
                this._port = null;
                this._webWorker = null;
                this._messageHandler = null;
                if (port) {
                  pdfWorkerPorts.set(port, this);
                  this._initializeFromPort(port);
                  return;
                }
                this._initialize();
              }
              PDFWorker2.prototype = {
                get promise() {
                  return this._readyCapability.promise;
                },
                get port() {
                  return this._port;
                },
                get messageHandler() {
                  return this._messageHandler;
                },
                _initializeFromPort: function PDFWorker_initializeFromPort(port) {
                  this._port = port;
                  this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);
                  this._messageHandler.on("ready", function() {
                  });
                  this._readyCapability.resolve();
                },
                _initialize: function PDFWorker_initialize() {
                  var _this6 = this;
                  if (typeof Worker !== "undefined" && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) {
                    var workerSrc2 = getWorkerSrc();
                    try {
                      if (!(0, _util.isSameOrigin)(window.location.href, workerSrc2)) {
                        workerSrc2 = createCDNWrapper(new URL(workerSrc2, window.location).href);
                      }
                      var worker = new Worker(workerSrc2);
                      var messageHandler = new _message_handler.MessageHandler("main", "worker", worker);
                      var terminateEarly = function terminateEarly2() {
                        worker.removeEventListener("error", onWorkerError);
                        messageHandler.destroy();
                        worker.terminate();
                        if (_this6.destroyed) {
                          _this6._readyCapability.reject(new Error("Worker was destroyed"));
                        } else {
                          _this6._setupFakeWorker();
                        }
                      };
                      var onWorkerError = function onWorkerError2() {
                        if (!_this6._webWorker) {
                          terminateEarly();
                        }
                      };
                      worker.addEventListener("error", onWorkerError);
                      messageHandler.on("test", function(data) {
                        worker.removeEventListener("error", onWorkerError);
                        if (_this6.destroyed) {
                          terminateEarly();
                          return;
                        }
                        var supportTypedArray = data && data.supportTypedArray;
                        if (supportTypedArray) {
                          _this6._messageHandler = messageHandler;
                          _this6._port = worker;
                          _this6._webWorker = worker;
                          if (!data.supportTransfers) {
                            _this6.postMessageTransfers = false;
                          }
                          _this6._readyCapability.resolve();
                          messageHandler.send("configure", { verbosity: _this6.verbosity });
                        } else {
                          _this6._setupFakeWorker();
                          messageHandler.destroy();
                          worker.terminate();
                        }
                      });
                      messageHandler.on("ready", function(data) {
                        worker.removeEventListener("error", onWorkerError);
                        if (_this6.destroyed) {
                          terminateEarly();
                          return;
                        }
                        try {
                          sendTest();
                        } catch (e) {
                          _this6._setupFakeWorker();
                        }
                      });
                      var sendTest = function sendTest2() {
                        var testObj = new Uint8Array([_this6.postMessageTransfers ? 255 : 0]);
                        try {
                          messageHandler.send("test", testObj, [testObj.buffer]);
                        } catch (ex) {
                          (0, _util.info)("Cannot use postMessage transfers");
                          testObj[0] = 0;
                          messageHandler.send("test", testObj);
                        }
                      };
                      sendTest();
                      return;
                    } catch (e) {
                      (0, _util.info)("The worker has been disabled.");
                    }
                  }
                  this._setupFakeWorker();
                },
                _setupFakeWorker: function PDFWorker_setupFakeWorker() {
                  var _this7 = this;
                  if (!isWorkerDisabled) {
                    (0, _util.warn)("Setting up fake worker.");
                    isWorkerDisabled = true;
                  }
                  setupFakeWorkerGlobal().then(function(WorkerMessageHandler) {
                    if (_this7.destroyed) {
                      _this7._readyCapability.reject(new Error("Worker was destroyed"));
                      return;
                    }
                    var isTypedArraysPresent = Uint8Array !== Float32Array;
                    var port = new LoopbackPort(isTypedArraysPresent);
                    _this7._port = port;
                    var id = "fake" + nextFakeWorkerId++;
                    var workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
                    WorkerMessageHandler.setup(workerHandler, port);
                    var messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
                    _this7._messageHandler = messageHandler;
                    _this7._readyCapability.resolve();
                  });
                },
                destroy: function PDFWorker_destroy() {
                  this.destroyed = true;
                  if (this._webWorker) {
                    this._webWorker.terminate();
                    this._webWorker = null;
                  }
                  pdfWorkerPorts.delete(this._port);
                  this._port = null;
                  if (this._messageHandler) {
                    this._messageHandler.destroy();
                    this._messageHandler = null;
                  }
                }
              };
              PDFWorker2.fromPort = function(params) {
                if (pdfWorkerPorts.has(params.port)) {
                  return pdfWorkerPorts.get(params.port);
                }
                return new PDFWorker2(params);
              };
              PDFWorker2.getWorkerSrc = function() {
                return getWorkerSrc();
              };
              return PDFWorker2;
            }();
            var WorkerTransport = function WorkerTransportClosure() {
              function WorkerTransport2(messageHandler, loadingTask, networkStream, params, CMapReaderFactory) {
                this.messageHandler = messageHandler;
                this.loadingTask = loadingTask;
                this.commonObjs = new PDFObjects();
                this.fontLoader = new _font_loader.FontLoader(loadingTask.docId);
                this._params = params;
                this.CMapReaderFactory = new CMapReaderFactory({
                  baseUrl: params.cMapUrl,
                  isCompressed: params.cMapPacked
                });
                this.destroyed = false;
                this.destroyCapability = null;
                this._passwordCapability = null;
                this._networkStream = networkStream;
                this._fullReader = null;
                this._lastProgress = null;
                this.pageCache = [];
                this.pagePromises = [];
                this.downloadInfoCapability = (0, _util.createPromiseCapability)();
                this.setupMessageHandler();
              }
              WorkerTransport2.prototype = {
                destroy: function WorkerTransport_destroy() {
                  var _this8 = this;
                  if (this.destroyCapability) {
                    return this.destroyCapability.promise;
                  }
                  this.destroyed = true;
                  this.destroyCapability = (0, _util.createPromiseCapability)();
                  if (this._passwordCapability) {
                    this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
                  }
                  var waitOn = [];
                  this.pageCache.forEach(function(page) {
                    if (page) {
                      waitOn.push(page._destroy());
                    }
                  });
                  this.pageCache = [];
                  this.pagePromises = [];
                  var terminated = this.messageHandler.sendWithPromise("Terminate", null);
                  waitOn.push(terminated);
                  Promise.all(waitOn).then(function() {
                    _this8.fontLoader.clear();
                    if (_this8._networkStream) {
                      _this8._networkStream.cancelAllRequests();
                    }
                    if (_this8.messageHandler) {
                      _this8.messageHandler.destroy();
                      _this8.messageHandler = null;
                    }
                    _this8.destroyCapability.resolve();
                  }, this.destroyCapability.reject);
                  return this.destroyCapability.promise;
                },
                setupMessageHandler: function WorkerTransport_setupMessageHandler() {
                  var messageHandler = this.messageHandler;
                  var loadingTask = this.loadingTask;
                  messageHandler.on("GetReader", function(data, sink) {
                    var _this9 = this;
                    (0, _util.assert)(this._networkStream);
                    this._fullReader = this._networkStream.getFullReader();
                    this._fullReader.onProgress = function(evt) {
                      _this9._lastProgress = {
                        loaded: evt.loaded,
                        total: evt.total
                      };
                    };
                    sink.onPull = function() {
                      _this9._fullReader.read().then(function(_ref3) {
                        var value = _ref3.value, done = _ref3.done;
                        if (done) {
                          sink.close();
                          return;
                        }
                        (0, _util.assert)((0, _util.isArrayBuffer)(value));
                        sink.enqueue(new Uint8Array(value), 1, [value]);
                      }).catch(function(reason) {
                        sink.error(reason);
                      });
                    };
                    sink.onCancel = function(reason) {
                      _this9._fullReader.cancel(reason);
                    };
                  }, this);
                  messageHandler.on("ReaderHeadersReady", function(data) {
                    var _this10 = this;
                    var headersCapability = (0, _util.createPromiseCapability)();
                    var fullReader = this._fullReader;
                    fullReader.headersReady.then(function() {
                      if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                        if (_this10._lastProgress) {
                          var _loadingTask = _this10.loadingTask;
                          if (_loadingTask.onProgress) {
                            _loadingTask.onProgress(_this10._lastProgress);
                          }
                        }
                        fullReader.onProgress = function(evt) {
                          var loadingTask2 = _this10.loadingTask;
                          if (loadingTask2.onProgress) {
                            loadingTask2.onProgress({
                              loaded: evt.loaded,
                              total: evt.total
                            });
                          }
                        };
                      }
                      headersCapability.resolve({
                        isStreamingSupported: fullReader.isStreamingSupported,
                        isRangeSupported: fullReader.isRangeSupported,
                        contentLength: fullReader.contentLength
                      });
                    }, headersCapability.reject);
                    return headersCapability.promise;
                  }, this);
                  messageHandler.on("GetRangeReader", function(data, sink) {
                    (0, _util.assert)(this._networkStream);
                    var _rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
                    sink.onPull = function() {
                      _rangeReader.read().then(function(_ref4) {
                        var value = _ref4.value, done = _ref4.done;
                        if (done) {
                          sink.close();
                          return;
                        }
                        (0, _util.assert)((0, _util.isArrayBuffer)(value));
                        sink.enqueue(new Uint8Array(value), 1, [value]);
                      }).catch(function(reason) {
                        sink.error(reason);
                      });
                    };
                    sink.onCancel = function(reason) {
                      _rangeReader.cancel(reason);
                    };
                  }, this);
                  messageHandler.on("GetDoc", function transportDoc(_ref5) {
                    var pdfInfo = _ref5.pdfInfo;
                    this.numPages = pdfInfo.numPages;
                    var loadingTask2 = this.loadingTask;
                    var pdfDocument = new PDFDocumentProxy(pdfInfo, this, loadingTask2);
                    this.pdfDocument = pdfDocument;
                    loadingTask2._capability.resolve(pdfDocument);
                  }, this);
                  messageHandler.on("PasswordRequest", function transportPasswordRequest(exception) {
                    var _this11 = this;
                    this._passwordCapability = (0, _util.createPromiseCapability)();
                    if (loadingTask.onPassword) {
                      var updatePassword = function updatePassword2(password) {
                        _this11._passwordCapability.resolve({ password });
                      };
                      try {
                        loadingTask.onPassword(updatePassword, exception.code);
                      } catch (ex) {
                        this._passwordCapability.reject(ex);
                      }
                    } else {
                      this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
                    }
                    return this._passwordCapability.promise;
                  }, this);
                  messageHandler.on("PasswordException", function transportPasswordException(exception) {
                    loadingTask._capability.reject(new _util.PasswordException(exception.message, exception.code));
                  }, this);
                  messageHandler.on("InvalidPDF", function transportInvalidPDF(exception) {
                    this.loadingTask._capability.reject(new _util.InvalidPDFException(exception.message));
                  }, this);
                  messageHandler.on("MissingPDF", function transportMissingPDF(exception) {
                    this.loadingTask._capability.reject(new _util.MissingPDFException(exception.message));
                  }, this);
                  messageHandler.on("UnexpectedResponse", function transportUnexpectedResponse(exception) {
                    this.loadingTask._capability.reject(new _util.UnexpectedResponseException(exception.message, exception.status));
                  }, this);
                  messageHandler.on("UnknownError", function transportUnknownError(exception) {
                    this.loadingTask._capability.reject(new _util.UnknownErrorException(exception.message, exception.details));
                  }, this);
                  messageHandler.on("DataLoaded", function transportPage(data) {
                    this.downloadInfoCapability.resolve(data);
                  }, this);
                  messageHandler.on("PDFManagerReady", function transportPage(data) {
                  }, this);
                  messageHandler.on("StartRenderPage", function transportRender(data) {
                    if (this.destroyed) {
                      return;
                    }
                    var page = this.pageCache[data.pageIndex];
                    page._stats.timeEnd("Page Request");
                    page._startRenderPage(data.transparency, data.intent);
                  }, this);
                  messageHandler.on("RenderPageChunk", function transportRender(data) {
                    if (this.destroyed) {
                      return;
                    }
                    var page = this.pageCache[data.pageIndex];
                    page._renderPageChunk(data.operatorList, data.intent);
                  }, this);
                  messageHandler.on("commonobj", function transportObj(data) {
                    var _this12 = this;
                    if (this.destroyed) {
                      return;
                    }
                    var id = data[0];
                    var type = data[1];
                    if (this.commonObjs.hasData(id)) {
                      return;
                    }
                    switch (type) {
                      case "Font":
                        var exportedData = data[2];
                        var params = this._params;
                        if ("error" in exportedData) {
                          var exportedError = exportedData.error;
                          (0, _util.warn)("Error during font loading: " + exportedError);
                          this.commonObjs.resolve(id, exportedError);
                          break;
                        }
                        var fontRegistry = null;
                        if (params.pdfBug && _global_scope2.default.FontInspector && _global_scope2.default.FontInspector.enabled) {
                          fontRegistry = {
                            registerFont: function registerFont(font2, url) {
                              _global_scope2.default["FontInspector"].fontAdded(font2, url);
                            }
                          };
                        }
                        var font = new _font_loader.FontFaceObject(exportedData, {
                          isEvalSupported: params.isEvalSupported,
                          disableFontFace: params.disableFontFace,
                          fontRegistry
                        });
                        var fontReady = function fontReady2(fontObjs) {
                          _this12.commonObjs.resolve(id, font);
                        };
                        this.fontLoader.bind([font], fontReady);
                        break;
                      case "FontPath":
                        this.commonObjs.resolve(id, data[2]);
                        break;
                      default:
                        throw new Error("Got unknown common object type " + type);
                    }
                  }, this);
                  messageHandler.on("obj", function transportObj(data) {
                    if (this.destroyed) {
                      return;
                    }
                    var id = data[0];
                    var pageIndex = data[1];
                    var type = data[2];
                    var pageProxy = this.pageCache[pageIndex];
                    var imageData;
                    if (pageProxy.objs.hasData(id)) {
                      return;
                    }
                    switch (type) {
                      case "JpegStream":
                        imageData = data[3];
                        return new Promise(function(resolve2, reject2) {
                          var img = new Image();
                          img.onload = function() {
                            resolve2(img);
                          };
                          img.onerror = function() {
                            reject2(new Error("Error during JPEG image loading"));
                          };
                          img.src = imageData;
                        }).then(function(img) {
                          pageProxy.objs.resolve(id, img);
                        });
                      case "Image":
                        imageData = data[3];
                        pageProxy.objs.resolve(id, imageData);
                        var MAX_IMAGE_SIZE_TO_STORE = 8e6;
                        if (imageData && "data" in imageData && imageData.data.length > MAX_IMAGE_SIZE_TO_STORE) {
                          pageProxy.cleanupAfterRender = true;
                        }
                        break;
                      default:
                        throw new Error("Got unknown object type " + type);
                    }
                  }, this);
                  messageHandler.on("DocProgress", function transportDocProgress(data) {
                    if (this.destroyed) {
                      return;
                    }
                    var loadingTask2 = this.loadingTask;
                    if (loadingTask2.onProgress) {
                      loadingTask2.onProgress({
                        loaded: data.loaded,
                        total: data.total
                      });
                    }
                  }, this);
                  messageHandler.on("PageError", function transportError(data) {
                    if (this.destroyed) {
                      return;
                    }
                    var page = this.pageCache[data.pageNum - 1];
                    var intentState = page.intentStates[data.intent];
                    if (intentState.displayReadyCapability) {
                      intentState.displayReadyCapability.reject(data.error);
                    } else {
                      throw new Error(data.error);
                    }
                    if (intentState.operatorList) {
                      intentState.operatorList.lastChunk = true;
                      for (var i = 0; i < intentState.renderTasks.length; i++) {
                        intentState.renderTasks[i].operatorListChanged();
                      }
                    }
                  }, this);
                  messageHandler.on("UnsupportedFeature", function(data) {
                    if (this.destroyed) {
                      return;
                    }
                    var loadingTask2 = this.loadingTask;
                    if (loadingTask2.onUnsupportedFeature) {
                      loadingTask2.onUnsupportedFeature(data.featureId);
                    }
                  }, this);
                  messageHandler.on("JpegDecode", function(data) {
                    if (this.destroyed) {
                      return Promise.reject(new Error("Worker was destroyed"));
                    }
                    if (typeof document === "undefined") {
                      return Promise.reject(new Error('"document" is not defined.'));
                    }
                    var imageUrl = data[0];
                    var components = data[1];
                    if (components !== 3 && components !== 1) {
                      return Promise.reject(new Error("Only 3 components or 1 component can be returned"));
                    }
                    return new Promise(function(resolve2, reject2) {
                      var img = new Image();
                      img.onload = function() {
                        var width = img.width;
                        var height = img.height;
                        var size = width * height;
                        var rgbaLength = size * 4;
                        var buf = new Uint8Array(size * components);
                        var tmpCanvas = document.createElement("canvas");
                        tmpCanvas.width = width;
                        tmpCanvas.height = height;
                        var tmpCtx = tmpCanvas.getContext("2d");
                        tmpCtx.drawImage(img, 0, 0);
                        var data2 = tmpCtx.getImageData(0, 0, width, height).data;
                        var i, j;
                        if (components === 3) {
                          for (i = 0, j = 0; i < rgbaLength; i += 4, j += 3) {
                            buf[j] = data2[i];
                            buf[j + 1] = data2[i + 1];
                            buf[j + 2] = data2[i + 2];
                          }
                        } else if (components === 1) {
                          for (i = 0, j = 0; i < rgbaLength; i += 4, j++) {
                            buf[j] = data2[i];
                          }
                        }
                        resolve2({
                          data: buf,
                          width,
                          height
                        });
                      };
                      img.onerror = function() {
                        reject2(new Error("JpegDecode failed to load image"));
                      };
                      img.src = imageUrl;
                    });
                  }, this);
                  messageHandler.on("FetchBuiltInCMap", function(data) {
                    if (this.destroyed) {
                      return Promise.reject(new Error("Worker was destroyed"));
                    }
                    return this.CMapReaderFactory.fetch({ name: data.name });
                  }, this);
                },
                getData: function WorkerTransport_getData() {
                  return this.messageHandler.sendWithPromise("GetData", null);
                },
                getPage: function getPage(pageNumber) {
                  var _this13 = this;
                  if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this.numPages) {
                    return Promise.reject(new Error("Invalid page request"));
                  }
                  var pageIndex = pageNumber - 1;
                  if (pageIndex in this.pagePromises) {
                    return this.pagePromises[pageIndex];
                  }
                  var promise = this.messageHandler.sendWithPromise("GetPage", { pageIndex }).then(function(pageInfo) {
                    if (_this13.destroyed) {
                      throw new Error("Transport destroyed");
                    }
                    var page = new PDFPageProxy(pageIndex, pageInfo, _this13, _this13._params.pdfBug);
                    _this13.pageCache[pageIndex] = page;
                    return page;
                  });
                  this.pagePromises[pageIndex] = promise;
                  return promise;
                },
                getPageIndex: function WorkerTransport_getPageIndexByRef(ref) {
                  return this.messageHandler.sendWithPromise("GetPageIndex", { ref }).catch(function(reason) {
                    return Promise.reject(new Error(reason));
                  });
                },
                getAnnotations: function WorkerTransport_getAnnotations(pageIndex, intent) {
                  return this.messageHandler.sendWithPromise("GetAnnotations", {
                    pageIndex,
                    intent
                  });
                },
                getDestinations: function WorkerTransport_getDestinations() {
                  return this.messageHandler.sendWithPromise("GetDestinations", null);
                },
                getDestination: function WorkerTransport_getDestination(id) {
                  return this.messageHandler.sendWithPromise("GetDestination", { id });
                },
                getPageLabels: function WorkerTransport_getPageLabels() {
                  return this.messageHandler.sendWithPromise("GetPageLabels", null);
                },
                getPageMode: function getPageMode() {
                  return this.messageHandler.sendWithPromise("GetPageMode", null);
                },
                getAttachments: function WorkerTransport_getAttachments() {
                  return this.messageHandler.sendWithPromise("GetAttachments", null);
                },
                getJavaScript: function WorkerTransport_getJavaScript() {
                  return this.messageHandler.sendWithPromise("GetJavaScript", null);
                },
                getOutline: function WorkerTransport_getOutline() {
                  return this.messageHandler.sendWithPromise("GetOutline", null);
                },
                getMetadata: function WorkerTransport_getMetadata() {
                  var _this14 = this;
                  return this.messageHandler.sendWithPromise("GetMetadata", null).then(function(results) {
                    return {
                      info: results[0],
                      metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
                      contentDispositionFilename: _this14._fullReader ? _this14._fullReader.filename : null
                    };
                  });
                },
                getStats: function WorkerTransport_getStats() {
                  return this.messageHandler.sendWithPromise("GetStats", null);
                },
                startCleanup: function WorkerTransport_startCleanup() {
                  var _this15 = this;
                  this.messageHandler.sendWithPromise("Cleanup", null).then(function() {
                    for (var i = 0, ii = _this15.pageCache.length; i < ii; i++) {
                      var page = _this15.pageCache[i];
                      if (page) {
                        page.cleanup();
                      }
                    }
                    _this15.commonObjs.clear();
                    _this15.fontLoader.clear();
                  });
                },
                get loadingParams() {
                  var params = this._params;
                  return (0, _util.shadow)(this, "loadingParams", {
                    disableRange: params.disableRange,
                    disableStream: params.disableStream,
                    disableAutoFetch: params.disableAutoFetch,
                    disableCreateObjectURL: params.disableCreateObjectURL,
                    disableFontFace: params.disableFontFace,
                    nativeImageDecoderSupport: params.nativeImageDecoderSupport
                  });
                }
              };
              return WorkerTransport2;
            }();
            var PDFObjects = function PDFObjectsClosure() {
              function PDFObjects2() {
                this.objs = /* @__PURE__ */ Object.create(null);
              }
              PDFObjects2.prototype = {
                ensureObj: function PDFObjects_ensureObj(objId) {
                  if (this.objs[objId]) {
                    return this.objs[objId];
                  }
                  var obj = {
                    capability: (0, _util.createPromiseCapability)(),
                    data: null,
                    resolved: false
                  };
                  this.objs[objId] = obj;
                  return obj;
                },
                get: function PDFObjects_get(objId, callback) {
                  if (callback) {
                    this.ensureObj(objId).capability.promise.then(callback);
                    return null;
                  }
                  var obj = this.objs[objId];
                  if (!obj || !obj.resolved) {
                    throw new Error("Requesting object that isn't resolved yet " + objId);
                  }
                  return obj.data;
                },
                resolve: function PDFObjects_resolve(objId, data) {
                  var obj = this.ensureObj(objId);
                  obj.resolved = true;
                  obj.data = data;
                  obj.capability.resolve(data);
                },
                isResolved: function PDFObjects_isResolved(objId) {
                  var objs = this.objs;
                  if (!objs[objId]) {
                    return false;
                  }
                  return objs[objId].resolved;
                },
                hasData: function PDFObjects_hasData(objId) {
                  return this.isResolved(objId);
                },
                getData: function PDFObjects_getData(objId) {
                  var objs = this.objs;
                  if (!objs[objId] || !objs[objId].resolved) {
                    return null;
                  }
                  return objs[objId].data;
                },
                clear: function PDFObjects_clear() {
                  this.objs = /* @__PURE__ */ Object.create(null);
                }
              };
              return PDFObjects2;
            }();
            var RenderTask = function RenderTaskClosure() {
              function RenderTask2(internalRenderTask) {
                this._internalRenderTask = internalRenderTask;
                this.onContinue = null;
              }
              RenderTask2.prototype = {
                get promise() {
                  return this._internalRenderTask.capability.promise;
                },
                cancel: function RenderTask_cancel() {
                  this._internalRenderTask.cancel();
                },
                then: function RenderTask_then(onFulfilled, onRejected) {
                  return this.promise.then.apply(this.promise, arguments);
                }
              };
              return RenderTask2;
            }();
            var InternalRenderTask = function InternalRenderTaskClosure() {
              var canvasInRendering = /* @__PURE__ */ new WeakMap();
              function InternalRenderTask2(callback, params, objs, commonObjs, operatorList, pageNumber, canvasFactory, webGLContext) {
                var pdfBug = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : false;
                this.callback = callback;
                this.params = params;
                this.objs = objs;
                this.commonObjs = commonObjs;
                this.operatorListIdx = null;
                this.operatorList = operatorList;
                this.pageNumber = pageNumber;
                this.canvasFactory = canvasFactory;
                this.webGLContext = webGLContext;
                this._pdfBug = pdfBug;
                this.running = false;
                this.graphicsReadyCallback = null;
                this.graphicsReady = false;
                this.useRequestAnimationFrame = false;
                this.cancelled = false;
                this.capability = (0, _util.createPromiseCapability)();
                this.task = new RenderTask(this);
                this._continueBound = this._continue.bind(this);
                this._scheduleNextBound = this._scheduleNext.bind(this);
                this._nextBound = this._next.bind(this);
                this._canvas = params.canvasContext.canvas;
              }
              InternalRenderTask2.prototype = {
                initializeGraphics: function InternalRenderTask_initializeGraphics(transparency) {
                  if (this._canvas) {
                    if (canvasInRendering.has(this._canvas)) {
                      throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                    }
                    canvasInRendering.set(this._canvas, this);
                  }
                  if (this.cancelled) {
                    return;
                  }
                  if (this._pdfBug && _global_scope2.default.StepperManager && _global_scope2.default.StepperManager.enabled) {
                    this.stepper = _global_scope2.default.StepperManager.create(this.pageNumber - 1);
                    this.stepper.init(this.operatorList);
                    this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
                  }
                  var params = this.params;
                  this.gfx = new _canvas.CanvasGraphics(params.canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, params.imageLayer);
                  this.gfx.beginDrawing({
                    transform: params.transform,
                    viewport: params.viewport,
                    transparency,
                    background: params.background
                  });
                  this.operatorListIdx = 0;
                  this.graphicsReady = true;
                  if (this.graphicsReadyCallback) {
                    this.graphicsReadyCallback();
                  }
                },
                cancel: function InternalRenderTask_cancel() {
                  this.running = false;
                  this.cancelled = true;
                  if (this._canvas) {
                    canvasInRendering.delete(this._canvas);
                  }
                  this.callback(new _dom_utils.RenderingCancelledException("Rendering cancelled, page " + this.pageNumber, "canvas"));
                },
                operatorListChanged: function InternalRenderTask_operatorListChanged() {
                  if (!this.graphicsReady) {
                    if (!this.graphicsReadyCallback) {
                      this.graphicsReadyCallback = this._continueBound;
                    }
                    return;
                  }
                  if (this.stepper) {
                    this.stepper.updateOperatorList(this.operatorList);
                  }
                  if (this.running) {
                    return;
                  }
                  this._continue();
                },
                _continue: function InternalRenderTask__continue() {
                  this.running = true;
                  if (this.cancelled) {
                    return;
                  }
                  if (this.task.onContinue) {
                    this.task.onContinue(this._scheduleNextBound);
                  } else {
                    this._scheduleNext();
                  }
                },
                _scheduleNext: function InternalRenderTask__scheduleNext() {
                  if (this.useRequestAnimationFrame && typeof window !== "undefined") {
                    window.requestAnimationFrame(this._nextBound);
                  } else {
                    Promise.resolve(void 0).then(this._nextBound);
                  }
                },
                _next: function InternalRenderTask__next() {
                  if (this.cancelled) {
                    return;
                  }
                  this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
                  if (this.operatorListIdx === this.operatorList.argsArray.length) {
                    this.running = false;
                    if (this.operatorList.lastChunk) {
                      this.gfx.endDrawing();
                      if (this._canvas) {
                        canvasInRendering.delete(this._canvas);
                      }
                      this.callback();
                    }
                  }
                }
              };
              return InternalRenderTask2;
            }();
            var version, build;
            {
              exports3.version = version = "2.0.550";
              exports3.build = build = "76337fdc";
            }
            exports3.getDocument = getDocument;
            exports3.LoopbackPort = LoopbackPort;
            exports3.PDFDataRangeTransport = PDFDataRangeTransport;
            exports3.PDFWorker = PDFWorker;
            exports3.PDFDocumentProxy = PDFDocumentProxy;
            exports3.PDFPageProxy = PDFPageProxy;
            exports3.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
            exports3.version = version;
            exports3.build = build;
          },
          /* 115 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.DummyStatTimer = exports3.StatTimer = exports3.DOMSVGFactory = exports3.DOMCMapReaderFactory = exports3.DOMCanvasFactory = exports3.DEFAULT_LINK_REL = exports3.LinkTarget = exports3.getFilenameFromUrl = exports3.addLinkAttributes = exports3.RenderingCancelledException = exports3.PageViewport = void 0;
            var _createClass = /* @__PURE__ */ function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _util = __w_pdfjs_require__(1);
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var DEFAULT_LINK_REL = "noopener noreferrer nofollow";
            var SVG_NS = "http://www.w3.org/2000/svg";
            var DOMCanvasFactory = function() {
              function DOMCanvasFactory2() {
                _classCallCheck(this, DOMCanvasFactory2);
              }
              _createClass(DOMCanvasFactory2, [{
                key: "create",
                value: function create(width, height) {
                  if (width <= 0 || height <= 0) {
                    throw new Error("invalid canvas size");
                  }
                  var canvas = document.createElement("canvas");
                  var context = canvas.getContext("2d");
                  canvas.width = width;
                  canvas.height = height;
                  return {
                    canvas,
                    context
                  };
                }
              }, {
                key: "reset",
                value: function reset(canvasAndContext, width, height) {
                  if (!canvasAndContext.canvas) {
                    throw new Error("canvas is not specified");
                  }
                  if (width <= 0 || height <= 0) {
                    throw new Error("invalid canvas size");
                  }
                  canvasAndContext.canvas.width = width;
                  canvasAndContext.canvas.height = height;
                }
              }, {
                key: "destroy",
                value: function destroy(canvasAndContext) {
                  if (!canvasAndContext.canvas) {
                    throw new Error("canvas is not specified");
                  }
                  canvasAndContext.canvas.width = 0;
                  canvasAndContext.canvas.height = 0;
                  canvasAndContext.canvas = null;
                  canvasAndContext.context = null;
                }
              }]);
              return DOMCanvasFactory2;
            }();
            var DOMCMapReaderFactory = function() {
              function DOMCMapReaderFactory2(_ref) {
                var _ref$baseUrl = _ref.baseUrl, baseUrl = _ref$baseUrl === void 0 ? null : _ref$baseUrl, _ref$isCompressed = _ref.isCompressed, isCompressed = _ref$isCompressed === void 0 ? false : _ref$isCompressed;
                _classCallCheck(this, DOMCMapReaderFactory2);
                this.baseUrl = baseUrl;
                this.isCompressed = isCompressed;
              }
              _createClass(DOMCMapReaderFactory2, [{
                key: "fetch",
                value: function fetch2(_ref2) {
                  var _this = this;
                  var name = _ref2.name;
                  if (!this.baseUrl) {
                    return Promise.reject(new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.'));
                  }
                  if (!name) {
                    return Promise.reject(new Error("CMap name must be specified."));
                  }
                  return new Promise(function(resolve2, reject2) {
                    var url = _this.baseUrl + name + (_this.isCompressed ? ".bcmap" : "");
                    var request = new XMLHttpRequest();
                    request.open("GET", url, true);
                    if (_this.isCompressed) {
                      request.responseType = "arraybuffer";
                    }
                    request.onreadystatechange = function() {
                      if (request.readyState !== XMLHttpRequest.DONE) {
                        return;
                      }
                      if (request.status === 200 || request.status === 0) {
                        var data = void 0;
                        if (_this.isCompressed && request.response) {
                          data = new Uint8Array(request.response);
                        } else if (!_this.isCompressed && request.responseText) {
                          data = (0, _util.stringToBytes)(request.responseText);
                        }
                        if (data) {
                          resolve2({
                            cMapData: data,
                            compressionType: _this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE
                          });
                          return;
                        }
                      }
                      reject2(new Error("Unable to load " + (_this.isCompressed ? "binary " : "") + "CMap at: " + url));
                    };
                    request.send(null);
                  });
                }
              }]);
              return DOMCMapReaderFactory2;
            }();
            var DOMSVGFactory = function() {
              function DOMSVGFactory2() {
                _classCallCheck(this, DOMSVGFactory2);
              }
              _createClass(DOMSVGFactory2, [{
                key: "create",
                value: function create(width, height) {
                  (0, _util.assert)(width > 0 && height > 0, "Invalid SVG dimensions");
                  var svg = document.createElementNS(SVG_NS, "svg:svg");
                  svg.setAttribute("version", "1.1");
                  svg.setAttribute("width", width + "px");
                  svg.setAttribute("height", height + "px");
                  svg.setAttribute("preserveAspectRatio", "none");
                  svg.setAttribute("viewBox", "0 0 " + width + " " + height);
                  return svg;
                }
              }, {
                key: "createElement",
                value: function createElement(type) {
                  (0, _util.assert)(typeof type === "string", "Invalid SVG element type");
                  return document.createElementNS(SVG_NS, type);
                }
              }]);
              return DOMSVGFactory2;
            }();
            var PageViewport = function() {
              function PageViewport2(_ref3) {
                var viewBox = _ref3.viewBox, scale = _ref3.scale, rotation = _ref3.rotation, _ref3$offsetX = _ref3.offsetX, offsetX = _ref3$offsetX === void 0 ? 0 : _ref3$offsetX, _ref3$offsetY = _ref3.offsetY, offsetY = _ref3$offsetY === void 0 ? 0 : _ref3$offsetY, _ref3$dontFlip = _ref3.dontFlip, dontFlip = _ref3$dontFlip === void 0 ? false : _ref3$dontFlip;
                _classCallCheck(this, PageViewport2);
                this.viewBox = viewBox;
                this.scale = scale;
                this.rotation = rotation;
                this.offsetX = offsetX;
                this.offsetY = offsetY;
                var centerX = (viewBox[2] + viewBox[0]) / 2;
                var centerY = (viewBox[3] + viewBox[1]) / 2;
                var rotateA = void 0, rotateB = void 0, rotateC = void 0, rotateD = void 0;
                rotation = rotation % 360;
                rotation = rotation < 0 ? rotation + 360 : rotation;
                switch (rotation) {
                  case 180:
                    rotateA = -1;
                    rotateB = 0;
                    rotateC = 0;
                    rotateD = 1;
                    break;
                  case 90:
                    rotateA = 0;
                    rotateB = 1;
                    rotateC = 1;
                    rotateD = 0;
                    break;
                  case 270:
                    rotateA = 0;
                    rotateB = -1;
                    rotateC = -1;
                    rotateD = 0;
                    break;
                  default:
                    rotateA = 1;
                    rotateB = 0;
                    rotateC = 0;
                    rotateD = -1;
                    break;
                }
                if (dontFlip) {
                  rotateC = -rotateC;
                  rotateD = -rotateD;
                }
                var offsetCanvasX = void 0, offsetCanvasY = void 0;
                var width = void 0, height = void 0;
                if (rotateA === 0) {
                  offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
                  offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
                  width = Math.abs(viewBox[3] - viewBox[1]) * scale;
                  height = Math.abs(viewBox[2] - viewBox[0]) * scale;
                } else {
                  offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
                  offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
                  width = Math.abs(viewBox[2] - viewBox[0]) * scale;
                  height = Math.abs(viewBox[3] - viewBox[1]) * scale;
                }
                this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
                this.width = width;
                this.height = height;
              }
              _createClass(PageViewport2, [{
                key: "clone",
                value: function clone() {
                  var _ref4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref4$scale = _ref4.scale, scale = _ref4$scale === void 0 ? this.scale : _ref4$scale, _ref4$rotation = _ref4.rotation, rotation = _ref4$rotation === void 0 ? this.rotation : _ref4$rotation, _ref4$dontFlip = _ref4.dontFlip, dontFlip = _ref4$dontFlip === void 0 ? false : _ref4$dontFlip;
                  return new PageViewport2({
                    viewBox: this.viewBox.slice(),
                    scale,
                    rotation,
                    offsetX: this.offsetX,
                    offsetY: this.offsetY,
                    dontFlip
                  });
                }
              }, {
                key: "convertToViewportPoint",
                value: function convertToViewportPoint(x, y) {
                  return _util.Util.applyTransform([x, y], this.transform);
                }
              }, {
                key: "convertToViewportRectangle",
                value: function convertToViewportRectangle(rect) {
                  var tl = _util.Util.applyTransform([rect[0], rect[1]], this.transform);
                  var br = _util.Util.applyTransform([rect[2], rect[3]], this.transform);
                  return [tl[0], tl[1], br[0], br[1]];
                }
              }, {
                key: "convertToPdfPoint",
                value: function convertToPdfPoint(x, y) {
                  return _util.Util.applyInverseTransform([x, y], this.transform);
                }
              }]);
              return PageViewport2;
            }();
            var RenderingCancelledException = function RenderingCancelledException2() {
              function RenderingCancelledException3(msg, type) {
                this.message = msg;
                this.type = type;
              }
              RenderingCancelledException3.prototype = new Error();
              RenderingCancelledException3.prototype.name = "RenderingCancelledException";
              RenderingCancelledException3.constructor = RenderingCancelledException3;
              return RenderingCancelledException3;
            }();
            var LinkTarget = {
              NONE: 0,
              SELF: 1,
              BLANK: 2,
              PARENT: 3,
              TOP: 4
            };
            var LinkTargetStringMap = ["", "_self", "_blank", "_parent", "_top"];
            function addLinkAttributes(link) {
              var _ref5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, url = _ref5.url, target = _ref5.target, rel = _ref5.rel;
              link.href = link.title = url ? (0, _util.removeNullCharacters)(url) : "";
              if (url) {
                var LinkTargetValues = Object.values(LinkTarget);
                var targetIndex = LinkTargetValues.includes(target) ? target : LinkTarget.NONE;
                link.target = LinkTargetStringMap[targetIndex];
                link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
              }
            }
            function getFilenameFromUrl(url) {
              var anchor = url.indexOf("#");
              var query = url.indexOf("?");
              var end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
              return url.substring(url.lastIndexOf("/", end) + 1, end);
            }
            var StatTimer = function() {
              function StatTimer2() {
                var enable = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                _classCallCheck(this, StatTimer2);
                this.enabled = !!enable;
                this.started = /* @__PURE__ */ Object.create(null);
                this.times = [];
              }
              _createClass(StatTimer2, [{
                key: "time",
                value: function time(name) {
                  if (!this.enabled) {
                    return;
                  }
                  if (name in this.started) {
                    (0, _util.warn)("Timer is already running for " + name);
                  }
                  this.started[name] = Date.now();
                }
              }, {
                key: "timeEnd",
                value: function timeEnd(name) {
                  if (!this.enabled) {
                    return;
                  }
                  if (!(name in this.started)) {
                    (0, _util.warn)("Timer has not been started for " + name);
                  }
                  this.times.push({
                    "name": name,
                    "start": this.started[name],
                    "end": Date.now()
                  });
                  delete this.started[name];
                }
              }, {
                key: "toString",
                value: function toString() {
                  var times = this.times;
                  var out = "", longest = 0;
                  for (var i = 0, ii = times.length; i < ii; ++i) {
                    var name = times[i]["name"];
                    if (name.length > longest) {
                      longest = name.length;
                    }
                  }
                  for (var _i = 0, _ii = times.length; _i < _ii; ++_i) {
                    var span = times[_i];
                    var duration = span.end - span.start;
                    out += span["name"].padEnd(longest) + " " + duration + "ms\n";
                  }
                  return out;
                }
              }]);
              return StatTimer2;
            }();
            var DummyStatTimer = function() {
              function DummyStatTimer2() {
                _classCallCheck(this, DummyStatTimer2);
                (0, _util.unreachable)("Cannot initialize DummyStatTimer.");
              }
              _createClass(DummyStatTimer2, null, [{
                key: "time",
                value: function time(name) {
                }
              }, {
                key: "timeEnd",
                value: function timeEnd(name) {
                }
              }, {
                key: "toString",
                value: function toString() {
                  return "";
                }
              }]);
              return DummyStatTimer2;
            }();
            exports3.PageViewport = PageViewport;
            exports3.RenderingCancelledException = RenderingCancelledException;
            exports3.addLinkAttributes = addLinkAttributes;
            exports3.getFilenameFromUrl = getFilenameFromUrl;
            exports3.LinkTarget = LinkTarget;
            exports3.DEFAULT_LINK_REL = DEFAULT_LINK_REL;
            exports3.DOMCanvasFactory = DOMCanvasFactory;
            exports3.DOMCMapReaderFactory = DOMCMapReaderFactory;
            exports3.DOMSVGFactory = DOMSVGFactory;
            exports3.StatTimer = StatTimer;
            exports3.DummyStatTimer = DummyStatTimer;
          },
          /* 116 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.FontLoader = exports3.FontFaceObject = void 0;
            var _util = __w_pdfjs_require__(1);
            function FontLoader(docId) {
              this.docId = docId;
              this.styleElement = null;
              this.nativeFontFaces = [];
              this.loadTestFontId = 0;
              this.loadingContext = {
                requests: [],
                nextRequestId: 0
              };
            }
            FontLoader.prototype = {
              insertRule: function fontLoaderInsertRule(rule) {
                var styleElement = this.styleElement;
                if (!styleElement) {
                  styleElement = this.styleElement = document.createElement("style");
                  styleElement.id = "PDFJS_FONT_STYLE_TAG_" + this.docId;
                  document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement);
                }
                var styleSheet = styleElement.sheet;
                styleSheet.insertRule(rule, styleSheet.cssRules.length);
              },
              clear: function fontLoaderClear() {
                if (this.styleElement) {
                  this.styleElement.remove();
                  this.styleElement = null;
                }
                this.nativeFontFaces.forEach(function(nativeFontFace) {
                  document.fonts.delete(nativeFontFace);
                });
                this.nativeFontFaces.length = 0;
              }
            };
            {
              var getLoadTestFont = function getLoadTestFont2() {
                return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
              };
              Object.defineProperty(FontLoader.prototype, "loadTestFont", {
                get: function get() {
                  return (0, _util.shadow)(this, "loadTestFont", getLoadTestFont());
                },
                configurable: true
              });
              FontLoader.prototype.addNativeFontFace = function fontLoader_addNativeFontFace(nativeFontFace) {
                this.nativeFontFaces.push(nativeFontFace);
                document.fonts.add(nativeFontFace);
              };
              FontLoader.prototype.bind = function fontLoaderBind(fonts, callback) {
                var rules = [];
                var fontsToLoad = [];
                var fontLoadPromises = [];
                var getNativeFontPromise = function getNativeFontPromise2(nativeFontFace2) {
                  return nativeFontFace2.loaded.catch(function(e) {
                    (0, _util.warn)('Failed to load font "' + nativeFontFace2.family + '": ' + e);
                  });
                };
                var isFontLoadingAPISupported = FontLoader.isFontLoadingAPISupported && !FontLoader.isSyncFontLoadingSupported;
                for (var i = 0, ii = fonts.length; i < ii; i++) {
                  var font = fonts[i];
                  if (font.attached || font.loading === false) {
                    continue;
                  }
                  font.attached = true;
                  if (isFontLoadingAPISupported) {
                    var nativeFontFace = font.createNativeFontFace();
                    if (nativeFontFace) {
                      this.addNativeFontFace(nativeFontFace);
                      fontLoadPromises.push(getNativeFontPromise(nativeFontFace));
                    }
                  } else {
                    var rule = font.createFontFaceRule();
                    if (rule) {
                      this.insertRule(rule);
                      rules.push(rule);
                      fontsToLoad.push(font);
                    }
                  }
                }
                var request = this.queueLoadingCallback(callback);
                if (isFontLoadingAPISupported) {
                  Promise.all(fontLoadPromises).then(function() {
                    request.complete();
                  });
                } else if (rules.length > 0 && !FontLoader.isSyncFontLoadingSupported) {
                  this.prepareFontLoadEvent(rules, fontsToLoad, request);
                } else {
                  request.complete();
                }
              };
              FontLoader.prototype.queueLoadingCallback = function FontLoader_queueLoadingCallback(callback) {
                function LoadLoader_completeRequest() {
                  (0, _util.assert)(!request.end, "completeRequest() cannot be called twice");
                  request.end = Date.now();
                  while (context.requests.length > 0 && context.requests[0].end) {
                    var otherRequest = context.requests.shift();
                    setTimeout(otherRequest.callback, 0);
                  }
                }
                var context = this.loadingContext;
                var requestId = "pdfjs-font-loading-" + context.nextRequestId++;
                var request = {
                  id: requestId,
                  complete: LoadLoader_completeRequest,
                  callback,
                  started: Date.now()
                };
                context.requests.push(request);
                return request;
              };
              FontLoader.prototype.prepareFontLoadEvent = function fontLoaderPrepareFontLoadEvent(rules, fonts, request) {
                function int32(data2, offset) {
                  return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
                }
                function spliceString(s, offset, remove, insert) {
                  var chunk1 = s.substr(0, offset);
                  var chunk2 = s.substr(offset + remove);
                  return chunk1 + insert + chunk2;
                }
                var i, ii;
                var canvas = document.createElement("canvas");
                canvas.width = 1;
                canvas.height = 1;
                var ctx = canvas.getContext("2d");
                var called = 0;
                function isFontReady(name, callback) {
                  called++;
                  if (called > 30) {
                    (0, _util.warn)("Load test font never loaded.");
                    callback();
                    return;
                  }
                  ctx.font = "30px " + name;
                  ctx.fillText(".", 0, 20);
                  var imageData = ctx.getImageData(0, 0, 1, 1);
                  if (imageData.data[3] > 0) {
                    callback();
                    return;
                  }
                  setTimeout(isFontReady.bind(null, name, callback));
                }
                var loadTestFontId = "lt" + Date.now() + this.loadTestFontId++;
                var data = this.loadTestFont;
                var COMMENT_OFFSET = 976;
                data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
                var CFF_CHECKSUM_OFFSET = 16;
                var XXXX_VALUE = 1482184792;
                var checksum = int32(data, CFF_CHECKSUM_OFFSET);
                for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
                  checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
                }
                if (i < loadTestFontId.length) {
                  checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
                }
                data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));
                var url = "url(data:font/opentype;base64," + btoa(data) + ");";
                var rule = '@font-face { font-family:"' + loadTestFontId + '";src:' + url + "}";
                this.insertRule(rule);
                var names = [];
                for (i = 0, ii = fonts.length; i < ii; i++) {
                  names.push(fonts[i].loadedName);
                }
                names.push(loadTestFontId);
                var div = document.createElement("div");
                div.setAttribute("style", "visibility: hidden;width: 10px; height: 10px;position: absolute; top: 0px; left: 0px;");
                for (i = 0, ii = names.length; i < ii; ++i) {
                  var span = document.createElement("span");
                  span.textContent = "Hi";
                  span.style.fontFamily = names[i];
                  div.appendChild(span);
                }
                document.body.appendChild(div);
                isFontReady(loadTestFontId, function() {
                  document.body.removeChild(div);
                  request.complete();
                });
              };
            }
            {
              FontLoader.isFontLoadingAPISupported = typeof document !== "undefined" && !!document.fonts;
            }
            {
              var isSyncFontLoadingSupported = function isSyncFontLoadingSupported2() {
                if (typeof navigator === "undefined") {
                  return true;
                }
                var supported2 = false;
                var m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
                if (m && m[1] >= 14) {
                  supported2 = true;
                }
                return supported2;
              };
              Object.defineProperty(FontLoader, "isSyncFontLoadingSupported", {
                get: function get() {
                  return (0, _util.shadow)(FontLoader, "isSyncFontLoadingSupported", isSyncFontLoadingSupported());
                },
                enumerable: true,
                configurable: true
              });
            }
            var IsEvalSupportedCached = {
              get value() {
                return (0, _util.shadow)(this, "value", (0, _util.isEvalSupported)());
              }
            };
            var FontFaceObject = function FontFaceObjectClosure() {
              function FontFaceObject2(translatedData, _ref) {
                var _ref$isEvalSupported = _ref.isEvalSupported, isEvalSupported = _ref$isEvalSupported === void 0 ? true : _ref$isEvalSupported, _ref$disableFontFace = _ref.disableFontFace, disableFontFace = _ref$disableFontFace === void 0 ? false : _ref$disableFontFace, _ref$fontRegistry = _ref.fontRegistry, fontRegistry = _ref$fontRegistry === void 0 ? null : _ref$fontRegistry;
                this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                for (var i in translatedData) {
                  this[i] = translatedData[i];
                }
                this.isEvalSupported = isEvalSupported !== false;
                this.disableFontFace = disableFontFace === true;
                this.fontRegistry = fontRegistry;
              }
              FontFaceObject2.prototype = {
                createNativeFontFace: function FontFaceObject_createNativeFontFace() {
                  if (!this.data || this.disableFontFace) {
                    return null;
                  }
                  var nativeFontFace = new FontFace(this.loadedName, this.data, {});
                  if (this.fontRegistry) {
                    this.fontRegistry.registerFont(this);
                  }
                  return nativeFontFace;
                },
                createFontFaceRule: function FontFaceObject_createFontFaceRule() {
                  if (!this.data || this.disableFontFace) {
                    return null;
                  }
                  var data = (0, _util.bytesToString)(new Uint8Array(this.data));
                  var fontName = this.loadedName;
                  var url = "url(data:" + this.mimetype + ";base64," + btoa(data) + ");";
                  var rule = '@font-face { font-family:"' + fontName + '";src:' + url + "}";
                  if (this.fontRegistry) {
                    this.fontRegistry.registerFont(this, url);
                  }
                  return rule;
                },
                getPathGenerator: function FontFaceObject_getPathGenerator(objs, character) {
                  if (!(character in this.compiledGlyphs)) {
                    var cmds = objs.get(this.loadedName + "_path_" + character);
                    var current, i, len;
                    if (this.isEvalSupported && IsEvalSupportedCached.value) {
                      var args, js = "";
                      for (i = 0, len = cmds.length; i < len; i++) {
                        current = cmds[i];
                        if (current.args !== void 0) {
                          args = current.args.join(",");
                        } else {
                          args = "";
                        }
                        js += "c." + current.cmd + "(" + args + ");\n";
                      }
                      this.compiledGlyphs[character] = new Function("c", "size", js);
                    } else {
                      this.compiledGlyphs[character] = function(c, size) {
                        for (i = 0, len = cmds.length; i < len; i++) {
                          current = cmds[i];
                          if (current.cmd === "scale") {
                            current.args = [size, -size];
                          }
                          c[current.cmd].apply(c, current.args);
                        }
                      };
                    }
                  }
                  return this.compiledGlyphs[character];
                }
              };
              return FontFaceObject2;
            }();
            exports3.FontFaceObject = FontFaceObject;
            exports3.FontLoader = FontLoader;
          },
          /* 117 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            var compatibilityParams = /* @__PURE__ */ Object.create(null);
            {
              var isNodeJS = __w_pdfjs_require__(4);
              var userAgent = typeof navigator !== "undefined" && navigator.userAgent || "";
              var isIE = /Trident/.test(userAgent);
              var isIOS = /\b(iPad|iPhone|iPod)(?=;)/.test(userAgent);
              var isIOSChrome = /CriOS/.test(userAgent);
              var isSafari = /Safari\//.test(userAgent) && !/(Chrome\/|Android\s)/.test(userAgent);
              (function checkOnBlobSupport() {
                if (isIE || isIOSChrome) {
                  compatibilityParams.disableCreateObjectURL = true;
                }
              })();
              (function checkRangeRequests() {
                if (isSafari || isIOS) {
                  compatibilityParams.disableRange = true;
                  compatibilityParams.disableStream = true;
                }
              })();
              (function checkFontFaceAndImage() {
                if (isNodeJS()) {
                  compatibilityParams.disableFontFace = true;
                  compatibilityParams.nativeImageDecoderSupport = "none";
                }
              })();
            }
            exports3.apiCompatibilityParams = Object.freeze(compatibilityParams);
          },
          /* 118 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.CanvasGraphics = void 0;
            var _util = __w_pdfjs_require__(1);
            var _pattern_helper = __w_pdfjs_require__(119);
            var MIN_FONT_SIZE = 16;
            var MAX_FONT_SIZE = 100;
            var MAX_GROUP_SIZE = 4096;
            var MIN_WIDTH_FACTOR = 0.65;
            var COMPILE_TYPE3_GLYPHS = true;
            var MAX_SIZE_TO_COMPILE = 1e3;
            var FULL_CHUNK_HEIGHT = 16;
            var IsLittleEndianCached = {
              get value() {
                return (0, _util.shadow)(IsLittleEndianCached, "value", (0, _util.isLittleEndian)());
              }
            };
            function addContextCurrentTransform(ctx) {
              if (!ctx.mozCurrentTransform) {
                ctx._originalSave = ctx.save;
                ctx._originalRestore = ctx.restore;
                ctx._originalRotate = ctx.rotate;
                ctx._originalScale = ctx.scale;
                ctx._originalTranslate = ctx.translate;
                ctx._originalTransform = ctx.transform;
                ctx._originalSetTransform = ctx.setTransform;
                ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
                ctx._transformStack = [];
                Object.defineProperty(ctx, "mozCurrentTransform", {
                  get: function getCurrentTransform() {
                    return this._transformMatrix;
                  }
                });
                Object.defineProperty(ctx, "mozCurrentTransformInverse", {
                  get: function getCurrentTransformInverse() {
                    var m = this._transformMatrix;
                    var a = m[0], b = m[1], c = m[2], d = m[3], e = m[4], f = m[5];
                    var ad_bc = a * d - b * c;
                    var bc_ad = b * c - a * d;
                    return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
                  }
                });
                ctx.save = function ctxSave() {
                  var old = this._transformMatrix;
                  this._transformStack.push(old);
                  this._transformMatrix = old.slice(0, 6);
                  this._originalSave();
                };
                ctx.restore = function ctxRestore() {
                  var prev = this._transformStack.pop();
                  if (prev) {
                    this._transformMatrix = prev;
                    this._originalRestore();
                  }
                };
                ctx.translate = function ctxTranslate(x, y) {
                  var m = this._transformMatrix;
                  m[4] = m[0] * x + m[2] * y + m[4];
                  m[5] = m[1] * x + m[3] * y + m[5];
                  this._originalTranslate(x, y);
                };
                ctx.scale = function ctxScale(x, y) {
                  var m = this._transformMatrix;
                  m[0] = m[0] * x;
                  m[1] = m[1] * x;
                  m[2] = m[2] * y;
                  m[3] = m[3] * y;
                  this._originalScale(x, y);
                };
                ctx.transform = function ctxTransform(a, b, c, d, e, f) {
                  var m = this._transformMatrix;
                  this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];
                  ctx._originalTransform(a, b, c, d, e, f);
                };
                ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
                  this._transformMatrix = [a, b, c, d, e, f];
                  ctx._originalSetTransform(a, b, c, d, e, f);
                };
                ctx.rotate = function ctxRotate(angle) {
                  var cosValue = Math.cos(angle);
                  var sinValue = Math.sin(angle);
                  var m = this._transformMatrix;
                  this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];
                  this._originalRotate(angle);
                };
              }
            }
            var CachedCanvases = function CachedCanvasesClosure() {
              function CachedCanvases2(canvasFactory) {
                this.canvasFactory = canvasFactory;
                this.cache = /* @__PURE__ */ Object.create(null);
              }
              CachedCanvases2.prototype = {
                getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {
                  var canvasEntry;
                  if (this.cache[id] !== void 0) {
                    canvasEntry = this.cache[id];
                    this.canvasFactory.reset(canvasEntry, width, height);
                    canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
                  } else {
                    canvasEntry = this.canvasFactory.create(width, height);
                    this.cache[id] = canvasEntry;
                  }
                  if (trackTransform) {
                    addContextCurrentTransform(canvasEntry.context);
                  }
                  return canvasEntry;
                },
                clear: function clear() {
                  for (var id in this.cache) {
                    var canvasEntry = this.cache[id];
                    this.canvasFactory.destroy(canvasEntry);
                    delete this.cache[id];
                  }
                }
              };
              return CachedCanvases2;
            }();
            function compileType3Glyph(imgData) {
              var POINT_TO_PROCESS_LIMIT = 1e3;
              var width = imgData.width, height = imgData.height;
              var i, j, j0, width1 = width + 1;
              var points = new Uint8Array(width1 * (height + 1));
              var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
              var lineSize = width + 7 & ~7, data0 = imgData.data;
              var data = new Uint8Array(lineSize * height), pos = 0, ii;
              for (i = 0, ii = data0.length; i < ii; i++) {
                var mask = 128, elem = data0[i];
                while (mask > 0) {
                  data[pos++] = elem & mask ? 0 : 255;
                  mask >>= 1;
                }
              }
              var count = 0;
              pos = 0;
              if (data[pos] !== 0) {
                points[0] = 1;
                ++count;
              }
              for (j = 1; j < width; j++) {
                if (data[pos] !== data[pos + 1]) {
                  points[j] = data[pos] ? 2 : 1;
                  ++count;
                }
                pos++;
              }
              if (data[pos] !== 0) {
                points[j] = 2;
                ++count;
              }
              for (i = 1; i < height; i++) {
                pos = i * lineSize;
                j0 = i * width1;
                if (data[pos - lineSize] !== data[pos]) {
                  points[j0] = data[pos] ? 1 : 8;
                  ++count;
                }
                var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
                for (j = 1; j < width; j++) {
                  sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
                  if (POINT_TYPES[sum]) {
                    points[j0 + j] = POINT_TYPES[sum];
                    ++count;
                  }
                  pos++;
                }
                if (data[pos - lineSize] !== data[pos]) {
                  points[j0 + j] = data[pos] ? 2 : 4;
                  ++count;
                }
                if (count > POINT_TO_PROCESS_LIMIT) {
                  return null;
                }
              }
              pos = lineSize * (height - 1);
              j0 = i * width1;
              if (data[pos] !== 0) {
                points[j0] = 8;
                ++count;
              }
              for (j = 1; j < width; j++) {
                if (data[pos] !== data[pos + 1]) {
                  points[j0 + j] = data[pos] ? 4 : 8;
                  ++count;
                }
                pos++;
              }
              if (data[pos] !== 0) {
                points[j0 + j] = 4;
                ++count;
              }
              if (count > POINT_TO_PROCESS_LIMIT) {
                return null;
              }
              var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
              var outlines = [];
              for (i = 0; count && i <= height; i++) {
                var p = i * width1;
                var end = p + width;
                while (p < end && !points[p]) {
                  p++;
                }
                if (p === end) {
                  continue;
                }
                var coords = [p % width1, i];
                var type = points[p], p0 = p, pp;
                do {
                  var step = steps[type];
                  do {
                    p += step;
                  } while (!points[p]);
                  pp = points[p];
                  if (pp !== 5 && pp !== 10) {
                    type = pp;
                    points[p] = 0;
                  } else {
                    type = pp & 51 * type >> 4;
                    points[p] &= type >> 2 | type << 2;
                  }
                  coords.push(p % width1);
                  coords.push(p / width1 | 0);
                  --count;
                } while (p0 !== p);
                outlines.push(coords);
                --i;
              }
              var drawOutline = function drawOutline2(c) {
                c.save();
                c.scale(1 / width, -1 / height);
                c.translate(0, -height);
                c.beginPath();
                for (var i2 = 0, ii2 = outlines.length; i2 < ii2; i2++) {
                  var o = outlines[i2];
                  c.moveTo(o[0], o[1]);
                  for (var j2 = 2, jj = o.length; j2 < jj; j2 += 2) {
                    c.lineTo(o[j2], o[j2 + 1]);
                  }
                }
                c.fill();
                c.beginPath();
                c.restore();
              };
              return drawOutline;
            }
            var CanvasExtraState = function CanvasExtraStateClosure() {
              function CanvasExtraState2() {
                this.alphaIsShape = false;
                this.fontSize = 0;
                this.fontSizeScale = 1;
                this.textMatrix = _util.IDENTITY_MATRIX;
                this.textMatrixScale = 1;
                this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
                this.leading = 0;
                this.x = 0;
                this.y = 0;
                this.lineX = 0;
                this.lineY = 0;
                this.charSpacing = 0;
                this.wordSpacing = 0;
                this.textHScale = 1;
                this.textRenderingMode = _util.TextRenderingMode.FILL;
                this.textRise = 0;
                this.fillColor = "#000000";
                this.strokeColor = "#000000";
                this.patternFill = false;
                this.fillAlpha = 1;
                this.strokeAlpha = 1;
                this.lineWidth = 1;
                this.activeSMask = null;
                this.resumeSMaskCtx = null;
              }
              CanvasExtraState2.prototype = {
                clone: function CanvasExtraState_clone() {
                  return Object.create(this);
                },
                setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {
                  this.x = x;
                  this.y = y;
                }
              };
              return CanvasExtraState2;
            }();
            var CanvasGraphics = function CanvasGraphicsClosure() {
              var EXECUTION_TIME = 15;
              var EXECUTION_STEPS = 10;
              function CanvasGraphics2(canvasCtx, commonObjs, objs, canvasFactory, webGLContext, imageLayer) {
                this.ctx = canvasCtx;
                this.current = new CanvasExtraState();
                this.stateStack = [];
                this.pendingClip = null;
                this.pendingEOFill = false;
                this.res = null;
                this.xobjs = null;
                this.commonObjs = commonObjs;
                this.objs = objs;
                this.canvasFactory = canvasFactory;
                this.webGLContext = webGLContext;
                this.imageLayer = imageLayer;
                this.groupStack = [];
                this.processingType3 = null;
                this.baseTransform = null;
                this.baseTransformStack = [];
                this.groupLevel = 0;
                this.smaskStack = [];
                this.smaskCounter = 0;
                this.tempSMask = null;
                this.cachedCanvases = new CachedCanvases(this.canvasFactory);
                if (canvasCtx) {
                  addContextCurrentTransform(canvasCtx);
                }
                this.cachedGetSinglePixelWidth = null;
              }
              function putBinaryImageData(ctx, imgData) {
                if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
                  ctx.putImageData(imgData, 0, 0);
                  return;
                }
                var height = imgData.height, width = imgData.width;
                var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                var srcPos = 0, destPos;
                var src = imgData.data;
                var dest = chunkImgData.data;
                var i, j, thisChunkHeight, elemsInThisChunk;
                if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {
                  var srcLength = src.byteLength;
                  var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
                  var dest32DataLength = dest32.length;
                  var fullSrcDiff = width + 7 >> 3;
                  var white = 4294967295;
                  var black = IsLittleEndianCached.value ? 4278190080 : 255;
                  for (i = 0; i < totalChunks; i++) {
                    thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                    destPos = 0;
                    for (j = 0; j < thisChunkHeight; j++) {
                      var srcDiff = srcLength - srcPos;
                      var k = 0;
                      var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
                      var kEndUnrolled = kEnd & ~7;
                      var mask = 0;
                      var srcByte = 0;
                      for (; k < kEndUnrolled; k += 8) {
                        srcByte = src[srcPos++];
                        dest32[destPos++] = srcByte & 128 ? white : black;
                        dest32[destPos++] = srcByte & 64 ? white : black;
                        dest32[destPos++] = srcByte & 32 ? white : black;
                        dest32[destPos++] = srcByte & 16 ? white : black;
                        dest32[destPos++] = srcByte & 8 ? white : black;
                        dest32[destPos++] = srcByte & 4 ? white : black;
                        dest32[destPos++] = srcByte & 2 ? white : black;
                        dest32[destPos++] = srcByte & 1 ? white : black;
                      }
                      for (; k < kEnd; k++) {
                        if (mask === 0) {
                          srcByte = src[srcPos++];
                          mask = 128;
                        }
                        dest32[destPos++] = srcByte & mask ? white : black;
                        mask >>= 1;
                      }
                    }
                    while (destPos < dest32DataLength) {
                      dest32[destPos++] = 0;
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {
                  j = 0;
                  elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
                  for (i = 0; i < fullChunks; i++) {
                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                    srcPos += elemsInThisChunk;
                    ctx.putImageData(chunkImgData, 0, j);
                    j += FULL_CHUNK_HEIGHT;
                  }
                  if (i < totalChunks) {
                    elemsInThisChunk = width * partialChunkHeight * 4;
                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                    ctx.putImageData(chunkImgData, 0, j);
                  }
                } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {
                  thisChunkHeight = FULL_CHUNK_HEIGHT;
                  elemsInThisChunk = width * thisChunkHeight;
                  for (i = 0; i < totalChunks; i++) {
                    if (i >= fullChunks) {
                      thisChunkHeight = partialChunkHeight;
                      elemsInThisChunk = width * thisChunkHeight;
                    }
                    destPos = 0;
                    for (j = elemsInThisChunk; j--; ) {
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = 255;
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else {
                  throw new Error("bad image kind: " + imgData.kind);
                }
              }
              function putBinaryImageMask(ctx, imgData) {
                var height = imgData.height, width = imgData.width;
                var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                var srcPos = 0;
                var src = imgData.data;
                var dest = chunkImgData.data;
                for (var i = 0; i < totalChunks; i++) {
                  var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                  var destPos = 3;
                  for (var j = 0; j < thisChunkHeight; j++) {
                    var mask = 0;
                    for (var k = 0; k < width; k++) {
                      if (!mask) {
                        var elem = src[srcPos++];
                        mask = 128;
                      }
                      dest[destPos] = elem & mask ? 0 : 255;
                      destPos += 4;
                      mask >>= 1;
                    }
                  }
                  ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                }
              }
              function copyCtxState(sourceCtx, destCtx) {
                var properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];
                for (var i = 0, ii = properties.length; i < ii; i++) {
                  var property = properties[i];
                  if (sourceCtx[property] !== void 0) {
                    destCtx[property] = sourceCtx[property];
                  }
                }
                if (sourceCtx.setLineDash !== void 0) {
                  destCtx.setLineDash(sourceCtx.getLineDash());
                  destCtx.lineDashOffset = sourceCtx.lineDashOffset;
                }
              }
              function resetCtxToDefault(ctx) {
                ctx.strokeStyle = "#000000";
                ctx.fillStyle = "#000000";
                ctx.fillRule = "nonzero";
                ctx.globalAlpha = 1;
                ctx.lineWidth = 1;
                ctx.lineCap = "butt";
                ctx.lineJoin = "miter";
                ctx.miterLimit = 10;
                ctx.globalCompositeOperation = "source-over";
                ctx.font = "10px sans-serif";
                if (ctx.setLineDash !== void 0) {
                  ctx.setLineDash([]);
                  ctx.lineDashOffset = 0;
                }
              }
              function composeSMaskBackdrop(bytes, r0, g0, b0) {
                var length = bytes.length;
                for (var i = 3; i < length; i += 4) {
                  var alpha = bytes[i];
                  if (alpha === 0) {
                    bytes[i - 3] = r0;
                    bytes[i - 2] = g0;
                    bytes[i - 1] = b0;
                  } else if (alpha < 255) {
                    var alpha_ = 255 - alpha;
                    bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
                    bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
                    bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
                  }
                }
              }
              function composeSMaskAlpha(maskData, layerData, transferMap) {
                var length = maskData.length;
                var scale = 1 / 255;
                for (var i = 3; i < length; i += 4) {
                  var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
                  layerData[i] = layerData[i] * alpha * scale | 0;
                }
              }
              function composeSMaskLuminosity(maskData, layerData, transferMap) {
                var length = maskData.length;
                for (var i = 3; i < length; i += 4) {
                  var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
                  layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
                }
              }
              function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {
                var hasBackdrop = !!backdrop;
                var r0 = hasBackdrop ? backdrop[0] : 0;
                var g0 = hasBackdrop ? backdrop[1] : 0;
                var b0 = hasBackdrop ? backdrop[2] : 0;
                var composeFn;
                if (subtype === "Luminosity") {
                  composeFn = composeSMaskLuminosity;
                } else {
                  composeFn = composeSMaskAlpha;
                }
                var PIXELS_TO_PROCESS = 1048576;
                var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
                for (var row = 0; row < height; row += chunkSize) {
                  var chunkHeight = Math.min(chunkSize, height - row);
                  var maskData = maskCtx.getImageData(0, row, width, chunkHeight);
                  var layerData = layerCtx.getImageData(0, row, width, chunkHeight);
                  if (hasBackdrop) {
                    composeSMaskBackdrop(maskData.data, r0, g0, b0);
                  }
                  composeFn(maskData.data, layerData.data, transferMap);
                  maskCtx.putImageData(layerData, 0, row);
                }
              }
              function composeSMask(ctx, smask, layerCtx, webGLContext) {
                var mask = smask.canvas;
                var maskCtx = smask.context;
                ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);
                var backdrop = smask.backdrop || null;
                if (!smask.transferMap && webGLContext.isEnabled) {
                  var composed = webGLContext.composeSMask({
                    layer: layerCtx.canvas,
                    mask,
                    properties: {
                      subtype: smask.subtype,
                      backdrop
                    }
                  });
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  ctx.drawImage(composed, smask.offsetX, smask.offsetY);
                  return;
                }
                genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);
                ctx.drawImage(mask, 0, 0);
              }
              var LINE_CAP_STYLES = ["butt", "round", "square"];
              var LINE_JOIN_STYLES = ["miter", "round", "bevel"];
              var NORMAL_CLIP = {};
              var EO_CLIP = {};
              CanvasGraphics2.prototype = {
                beginDrawing: function beginDrawing(_ref) {
                  var transform = _ref.transform, viewport = _ref.viewport, transparency = _ref.transparency, _ref$background = _ref.background, background = _ref$background === void 0 ? null : _ref$background;
                  var width = this.ctx.canvas.width;
                  var height = this.ctx.canvas.height;
                  this.ctx.save();
                  this.ctx.fillStyle = background || "rgb(255, 255, 255)";
                  this.ctx.fillRect(0, 0, width, height);
                  this.ctx.restore();
                  if (transparency) {
                    var transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true);
                    this.compositeCtx = this.ctx;
                    this.transparentCanvas = transparentCanvas.canvas;
                    this.ctx = transparentCanvas.context;
                    this.ctx.save();
                    this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
                  }
                  this.ctx.save();
                  resetCtxToDefault(this.ctx);
                  if (transform) {
                    this.ctx.transform.apply(this.ctx, transform);
                  }
                  this.ctx.transform.apply(this.ctx, viewport.transform);
                  this.baseTransform = this.ctx.mozCurrentTransform.slice();
                  if (this.imageLayer) {
                    this.imageLayer.beginLayout();
                  }
                },
                executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
                  var argsArray = operatorList.argsArray;
                  var fnArray = operatorList.fnArray;
                  var i = executionStartIdx || 0;
                  var argsArrayLen = argsArray.length;
                  if (argsArrayLen === i) {
                    return i;
                  }
                  var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
                  var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
                  var steps = 0;
                  var commonObjs = this.commonObjs;
                  var objs = this.objs;
                  var fnId;
                  while (true) {
                    if (stepper !== void 0 && i === stepper.nextBreakPoint) {
                      stepper.breakIt(i, continueCallback);
                      return i;
                    }
                    fnId = fnArray[i];
                    if (fnId !== _util.OPS.dependency) {
                      this[fnId].apply(this, argsArray[i]);
                    } else {
                      var deps = argsArray[i];
                      for (var n = 0, nn = deps.length; n < nn; n++) {
                        var depObjId = deps[n];
                        var common = depObjId[0] === "g" && depObjId[1] === "_";
                        var objsPool = common ? commonObjs : objs;
                        if (!objsPool.isResolved(depObjId)) {
                          objsPool.get(depObjId, continueCallback);
                          return i;
                        }
                      }
                    }
                    i++;
                    if (i === argsArrayLen) {
                      return i;
                    }
                    if (chunkOperations && ++steps > EXECUTION_STEPS) {
                      if (Date.now() > endTime) {
                        continueCallback();
                        return i;
                      }
                      steps = 0;
                    }
                  }
                },
                endDrawing: function CanvasGraphics_endDrawing() {
                  if (this.current.activeSMask !== null) {
                    this.endSMaskGroup();
                  }
                  this.ctx.restore();
                  if (this.transparentCanvas) {
                    this.ctx = this.compositeCtx;
                    this.ctx.save();
                    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                    this.ctx.drawImage(this.transparentCanvas, 0, 0);
                    this.ctx.restore();
                    this.transparentCanvas = null;
                  }
                  this.cachedCanvases.clear();
                  this.webGLContext.clear();
                  if (this.imageLayer) {
                    this.imageLayer.endLayout();
                  }
                },
                setLineWidth: function CanvasGraphics_setLineWidth(width) {
                  this.current.lineWidth = width;
                  this.ctx.lineWidth = width;
                },
                setLineCap: function CanvasGraphics_setLineCap(style) {
                  this.ctx.lineCap = LINE_CAP_STYLES[style];
                },
                setLineJoin: function CanvasGraphics_setLineJoin(style) {
                  this.ctx.lineJoin = LINE_JOIN_STYLES[style];
                },
                setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {
                  this.ctx.miterLimit = limit;
                },
                setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {
                  var ctx = this.ctx;
                  if (ctx.setLineDash !== void 0) {
                    ctx.setLineDash(dashArray);
                    ctx.lineDashOffset = dashPhase;
                  }
                },
                setRenderingIntent: function CanvasGraphics_setRenderingIntent(intent) {
                },
                setFlatness: function CanvasGraphics_setFlatness(flatness) {
                },
                setGState: function CanvasGraphics_setGState(states) {
                  for (var i = 0, ii = states.length; i < ii; i++) {
                    var state = states[i];
                    var key = state[0];
                    var value = state[1];
                    switch (key) {
                      case "LW":
                        this.setLineWidth(value);
                        break;
                      case "LC":
                        this.setLineCap(value);
                        break;
                      case "LJ":
                        this.setLineJoin(value);
                        break;
                      case "ML":
                        this.setMiterLimit(value);
                        break;
                      case "D":
                        this.setDash(value[0], value[1]);
                        break;
                      case "RI":
                        this.setRenderingIntent(value);
                        break;
                      case "FL":
                        this.setFlatness(value);
                        break;
                      case "Font":
                        this.setFont(value[0], value[1]);
                        break;
                      case "CA":
                        this.current.strokeAlpha = state[1];
                        break;
                      case "ca":
                        this.current.fillAlpha = state[1];
                        this.ctx.globalAlpha = state[1];
                        break;
                      case "BM":
                        this.ctx.globalCompositeOperation = value;
                        break;
                      case "SMask":
                        if (this.current.activeSMask) {
                          if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {
                            this.suspendSMaskGroup();
                          } else {
                            this.endSMaskGroup();
                          }
                        }
                        this.current.activeSMask = value ? this.tempSMask : null;
                        if (this.current.activeSMask) {
                          this.beginSMaskGroup();
                        }
                        this.tempSMask = null;
                        break;
                    }
                  }
                },
                beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {
                  var activeSMask = this.current.activeSMask;
                  var drawnWidth = activeSMask.canvas.width;
                  var drawnHeight = activeSMask.canvas.height;
                  var cacheId = "smaskGroupAt" + this.groupLevel;
                  var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                  var currentCtx = this.ctx;
                  var currentTransform = currentCtx.mozCurrentTransform;
                  this.ctx.save();
                  var groupCtx = scratchCanvas.context;
                  groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);
                  groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);
                  groupCtx.transform.apply(groupCtx, currentTransform);
                  activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;
                  copyCtxState(currentCtx, groupCtx);
                  this.ctx = groupCtx;
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                },
                suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                  var groupCtx = this.ctx;
                  this.groupLevel--;
                  this.ctx = this.groupStack.pop();
                  composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
                  this.ctx.restore();
                  this.ctx.save();
                  copyCtxState(groupCtx, this.ctx);
                  this.current.resumeSMaskCtx = groupCtx;
                  var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);
                  this.ctx.transform.apply(this.ctx, deltaTransform);
                  groupCtx.save();
                  groupCtx.setTransform(1, 0, 0, 1, 0, 0);
                  groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);
                  groupCtx.restore();
                },
                resumeSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                  var groupCtx = this.current.resumeSMaskCtx;
                  var currentCtx = this.ctx;
                  this.ctx = groupCtx;
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                },
                endSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                  var groupCtx = this.ctx;
                  this.groupLevel--;
                  this.ctx = this.groupStack.pop();
                  composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
                  this.ctx.restore();
                  copyCtxState(groupCtx, this.ctx);
                  var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);
                  this.ctx.transform.apply(this.ctx, deltaTransform);
                },
                save: function CanvasGraphics_save() {
                  this.ctx.save();
                  var old = this.current;
                  this.stateStack.push(old);
                  this.current = old.clone();
                  this.current.resumeSMaskCtx = null;
                },
                restore: function CanvasGraphics_restore() {
                  if (this.current.resumeSMaskCtx) {
                    this.resumeSMaskGroup();
                  }
                  if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {
                    this.endSMaskGroup();
                  }
                  if (this.stateStack.length !== 0) {
                    this.current = this.stateStack.pop();
                    this.ctx.restore();
                    this.pendingClip = null;
                    this.cachedGetSinglePixelWidth = null;
                  }
                },
                transform: function CanvasGraphics_transform(a, b, c, d, e, f) {
                  this.ctx.transform(a, b, c, d, e, f);
                  this.cachedGetSinglePixelWidth = null;
                },
                constructPath: function CanvasGraphics_constructPath(ops, args) {
                  var ctx = this.ctx;
                  var current = this.current;
                  var x = current.x, y = current.y;
                  for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {
                    switch (ops[i] | 0) {
                      case _util.OPS.rectangle:
                        x = args[j++];
                        y = args[j++];
                        var width = args[j++];
                        var height = args[j++];
                        if (width === 0) {
                          width = this.getSinglePixelWidth();
                        }
                        if (height === 0) {
                          height = this.getSinglePixelWidth();
                        }
                        var xw = x + width;
                        var yh = y + height;
                        this.ctx.moveTo(x, y);
                        this.ctx.lineTo(xw, y);
                        this.ctx.lineTo(xw, yh);
                        this.ctx.lineTo(x, yh);
                        this.ctx.lineTo(x, y);
                        this.ctx.closePath();
                        break;
                      case _util.OPS.moveTo:
                        x = args[j++];
                        y = args[j++];
                        ctx.moveTo(x, y);
                        break;
                      case _util.OPS.lineTo:
                        x = args[j++];
                        y = args[j++];
                        ctx.lineTo(x, y);
                        break;
                      case _util.OPS.curveTo:
                        x = args[j + 4];
                        y = args[j + 5];
                        ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
                        j += 6;
                        break;
                      case _util.OPS.curveTo2:
                        ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
                        x = args[j + 2];
                        y = args[j + 3];
                        j += 4;
                        break;
                      case _util.OPS.curveTo3:
                        x = args[j + 2];
                        y = args[j + 3];
                        ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
                        j += 4;
                        break;
                      case _util.OPS.closePath:
                        ctx.closePath();
                        break;
                    }
                  }
                  current.setCurrentPoint(x, y);
                },
                closePath: function CanvasGraphics_closePath() {
                  this.ctx.closePath();
                },
                stroke: function CanvasGraphics_stroke(consumePath) {
                  consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                  var ctx = this.ctx;
                  var strokeColor = this.current.strokeColor;
                  ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth);
                  ctx.globalAlpha = this.current.strokeAlpha;
                  if (strokeColor && strokeColor.hasOwnProperty("type") && strokeColor.type === "Pattern") {
                    ctx.save();
                    ctx.strokeStyle = strokeColor.getPattern(ctx, this);
                    ctx.stroke();
                    ctx.restore();
                  } else {
                    ctx.stroke();
                  }
                  if (consumePath) {
                    this.consumePath();
                  }
                  ctx.globalAlpha = this.current.fillAlpha;
                },
                closeStroke: function CanvasGraphics_closeStroke() {
                  this.closePath();
                  this.stroke();
                },
                fill: function CanvasGraphics_fill(consumePath) {
                  consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                  var ctx = this.ctx;
                  var fillColor = this.current.fillColor;
                  var isPatternFill = this.current.patternFill;
                  var needRestore = false;
                  if (isPatternFill) {
                    ctx.save();
                    if (this.baseTransform) {
                      ctx.setTransform.apply(ctx, this.baseTransform);
                    }
                    ctx.fillStyle = fillColor.getPattern(ctx, this);
                    needRestore = true;
                  }
                  if (this.pendingEOFill) {
                    ctx.fill("evenodd");
                    this.pendingEOFill = false;
                  } else {
                    ctx.fill();
                  }
                  if (needRestore) {
                    ctx.restore();
                  }
                  if (consumePath) {
                    this.consumePath();
                  }
                },
                eoFill: function CanvasGraphics_eoFill() {
                  this.pendingEOFill = true;
                  this.fill();
                },
                fillStroke: function CanvasGraphics_fillStroke() {
                  this.fill(false);
                  this.stroke(false);
                  this.consumePath();
                },
                eoFillStroke: function CanvasGraphics_eoFillStroke() {
                  this.pendingEOFill = true;
                  this.fillStroke();
                },
                closeFillStroke: function CanvasGraphics_closeFillStroke() {
                  this.closePath();
                  this.fillStroke();
                },
                closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {
                  this.pendingEOFill = true;
                  this.closePath();
                  this.fillStroke();
                },
                endPath: function CanvasGraphics_endPath() {
                  this.consumePath();
                },
                clip: function CanvasGraphics_clip() {
                  this.pendingClip = NORMAL_CLIP;
                },
                eoClip: function CanvasGraphics_eoClip() {
                  this.pendingClip = EO_CLIP;
                },
                beginText: function CanvasGraphics_beginText() {
                  this.current.textMatrix = _util.IDENTITY_MATRIX;
                  this.current.textMatrixScale = 1;
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                },
                endText: function CanvasGraphics_endText() {
                  var paths = this.pendingTextPaths;
                  var ctx = this.ctx;
                  if (paths === void 0) {
                    ctx.beginPath();
                    return;
                  }
                  ctx.save();
                  ctx.beginPath();
                  for (var i = 0; i < paths.length; i++) {
                    var path = paths[i];
                    ctx.setTransform.apply(ctx, path.transform);
                    ctx.translate(path.x, path.y);
                    path.addToPath(ctx, path.fontSize);
                  }
                  ctx.restore();
                  ctx.clip();
                  ctx.beginPath();
                  delete this.pendingTextPaths;
                },
                setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {
                  this.current.charSpacing = spacing;
                },
                setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {
                  this.current.wordSpacing = spacing;
                },
                setHScale: function CanvasGraphics_setHScale(scale) {
                  this.current.textHScale = scale / 100;
                },
                setLeading: function CanvasGraphics_setLeading(leading) {
                  this.current.leading = -leading;
                },
                setFont: function CanvasGraphics_setFont(fontRefName, size) {
                  var fontObj = this.commonObjs.get(fontRefName);
                  var current = this.current;
                  if (!fontObj) {
                    throw new Error("Can't find font for " + fontRefName);
                  }
                  current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX;
                  if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
                    (0, _util.warn)("Invalid font matrix for font " + fontRefName);
                  }
                  if (size < 0) {
                    size = -size;
                    current.fontDirection = -1;
                  } else {
                    current.fontDirection = 1;
                  }
                  this.current.font = fontObj;
                  this.current.fontSize = size;
                  if (fontObj.isType3Font) {
                    return;
                  }
                  var name = fontObj.loadedName || "sans-serif";
                  var bold = fontObj.black ? "900" : fontObj.bold ? "bold" : "normal";
                  var italic = fontObj.italic ? "italic" : "normal";
                  var typeface = '"' + name + '", ' + fontObj.fallbackName;
                  var browserFontSize = size < MIN_FONT_SIZE ? MIN_FONT_SIZE : size > MAX_FONT_SIZE ? MAX_FONT_SIZE : size;
                  this.current.fontSizeScale = size / browserFontSize;
                  var rule = italic + " " + bold + " " + browserFontSize + "px " + typeface;
                  this.ctx.font = rule;
                },
                setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {
                  this.current.textRenderingMode = mode;
                },
                setTextRise: function CanvasGraphics_setTextRise(rise) {
                  this.current.textRise = rise;
                },
                moveText: function CanvasGraphics_moveText(x, y) {
                  this.current.x = this.current.lineX += x;
                  this.current.y = this.current.lineY += y;
                },
                setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {
                  this.setLeading(-y);
                  this.moveText(x, y);
                },
                setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {
                  this.current.textMatrix = [a, b, c, d, e, f];
                  this.current.textMatrixScale = Math.sqrt(a * a + b * b);
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                },
                nextLine: function CanvasGraphics_nextLine() {
                  this.moveText(0, this.current.leading);
                },
                paintChar: function paintChar(character, x, y, patternTransform) {
                  var ctx = this.ctx;
                  var current = this.current;
                  var font = current.font;
                  var textRenderingMode = current.textRenderingMode;
                  var fontSize = current.fontSize / current.fontSizeScale;
                  var fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
                  var isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
                  var patternFill = current.patternFill && font.data;
                  var addToPath;
                  if (font.disableFontFace || isAddToPathSet || patternFill) {
                    addToPath = font.getPathGenerator(this.commonObjs, character);
                  }
                  if (font.disableFontFace || patternFill) {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.beginPath();
                    addToPath(ctx, fontSize);
                    if (patternTransform) {
                      ctx.setTransform.apply(ctx, patternTransform);
                    }
                    if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                      ctx.fill();
                    }
                    if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                      ctx.stroke();
                    }
                    ctx.restore();
                  } else {
                    if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                      ctx.fillText(character, x, y);
                    }
                    if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                      ctx.strokeText(character, x, y);
                    }
                  }
                  if (isAddToPathSet) {
                    var paths = this.pendingTextPaths || (this.pendingTextPaths = []);
                    paths.push({
                      transform: ctx.mozCurrentTransform,
                      x,
                      y,
                      fontSize,
                      addToPath
                    });
                  }
                },
                get isFontSubpixelAAEnabled() {
                  var ctx = this.canvasFactory.create(10, 10).context;
                  ctx.scale(1.5, 1);
                  ctx.fillText("I", 0, 10);
                  var data = ctx.getImageData(0, 0, 10, 10).data;
                  var enabled = false;
                  for (var i = 3; i < data.length; i += 4) {
                    if (data[i] > 0 && data[i] < 255) {
                      enabled = true;
                      break;
                    }
                  }
                  return (0, _util.shadow)(this, "isFontSubpixelAAEnabled", enabled);
                },
                showText: function CanvasGraphics_showText(glyphs) {
                  var current = this.current;
                  var font = current.font;
                  if (font.isType3Font) {
                    return this.showType3Text(glyphs);
                  }
                  var fontSize = current.fontSize;
                  if (fontSize === 0) {
                    return;
                  }
                  var ctx = this.ctx;
                  var fontSizeScale = current.fontSizeScale;
                  var charSpacing = current.charSpacing;
                  var wordSpacing = current.wordSpacing;
                  var fontDirection = current.fontDirection;
                  var textHScale = current.textHScale * fontDirection;
                  var glyphsLength = glyphs.length;
                  var vertical = font.vertical;
                  var spacingDir = vertical ? 1 : -1;
                  var defaultVMetrics = font.defaultVMetrics;
                  var widthAdvanceScale = fontSize * current.fontMatrix[0];
                  var simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
                  ctx.save();
                  var patternTransform = void 0;
                  if (current.patternFill) {
                    ctx.save();
                    var pattern = current.fillColor.getPattern(ctx, this);
                    patternTransform = ctx.mozCurrentTransform;
                    ctx.restore();
                    ctx.fillStyle = pattern;
                  }
                  ctx.transform.apply(ctx, current.textMatrix);
                  ctx.translate(current.x, current.y + current.textRise);
                  if (fontDirection > 0) {
                    ctx.scale(textHScale, -1);
                  } else {
                    ctx.scale(textHScale, 1);
                  }
                  var lineWidth = current.lineWidth;
                  var scale = current.textMatrixScale;
                  if (scale === 0 || lineWidth === 0) {
                    var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
                    if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                      this.cachedGetSinglePixelWidth = null;
                      lineWidth = this.getSinglePixelWidth() * MIN_WIDTH_FACTOR;
                    }
                  } else {
                    lineWidth /= scale;
                  }
                  if (fontSizeScale !== 1) {
                    ctx.scale(fontSizeScale, fontSizeScale);
                    lineWidth /= fontSizeScale;
                  }
                  ctx.lineWidth = lineWidth;
                  var x = 0, i;
                  for (i = 0; i < glyphsLength; ++i) {
                    var glyph = glyphs[i];
                    if ((0, _util.isNum)(glyph)) {
                      x += spacingDir * glyph * fontSize / 1e3;
                      continue;
                    }
                    var restoreNeeded = false;
                    var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    var character = glyph.fontChar;
                    var accent = glyph.accent;
                    var scaledX, scaledY, scaledAccentX, scaledAccentY;
                    var width = glyph.width;
                    if (vertical) {
                      var vmetric, vx, vy;
                      vmetric = glyph.vmetric || defaultVMetrics;
                      vx = glyph.vmetric ? vmetric[1] : width * 0.5;
                      vx = -vx * widthAdvanceScale;
                      vy = vmetric[2] * widthAdvanceScale;
                      width = vmetric ? -vmetric[0] : width;
                      scaledX = vx / fontSizeScale;
                      scaledY = (x + vy) / fontSizeScale;
                    } else {
                      scaledX = x / fontSizeScale;
                      scaledY = 0;
                    }
                    if (font.remeasure && width > 0) {
                      var measuredWidth = ctx.measureText(character).width * 1e3 / fontSize * fontSizeScale;
                      if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                        var characterScaleX = width / measuredWidth;
                        restoreNeeded = true;
                        ctx.save();
                        ctx.scale(characterScaleX, 1);
                        scaledX /= characterScaleX;
                      } else if (width !== measuredWidth) {
                        scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;
                      }
                    }
                    if (glyph.isInFont || font.missingFile) {
                      if (simpleFillText && !accent) {
                        ctx.fillText(character, scaledX, scaledY);
                      } else {
                        this.paintChar(character, scaledX, scaledY, patternTransform);
                        if (accent) {
                          scaledAccentX = scaledX + accent.offset.x / fontSizeScale;
                          scaledAccentY = scaledY - accent.offset.y / fontSizeScale;
                          this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
                        }
                      }
                    }
                    var charWidth = width * widthAdvanceScale + spacing * fontDirection;
                    x += charWidth;
                    if (restoreNeeded) {
                      ctx.restore();
                    }
                  }
                  if (vertical) {
                    current.y -= x * textHScale;
                  } else {
                    current.x += x * textHScale;
                  }
                  ctx.restore();
                },
                showType3Text: function CanvasGraphics_showType3Text(glyphs) {
                  var ctx = this.ctx;
                  var current = this.current;
                  var font = current.font;
                  var fontSize = current.fontSize;
                  var fontDirection = current.fontDirection;
                  var spacingDir = font.vertical ? 1 : -1;
                  var charSpacing = current.charSpacing;
                  var wordSpacing = current.wordSpacing;
                  var textHScale = current.textHScale * fontDirection;
                  var fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;
                  var glyphsLength = glyphs.length;
                  var isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;
                  var i, glyph, width, spacingLength;
                  if (isTextInvisible || fontSize === 0) {
                    return;
                  }
                  this.cachedGetSinglePixelWidth = null;
                  ctx.save();
                  ctx.transform.apply(ctx, current.textMatrix);
                  ctx.translate(current.x, current.y);
                  ctx.scale(textHScale, fontDirection);
                  for (i = 0; i < glyphsLength; ++i) {
                    glyph = glyphs[i];
                    if ((0, _util.isNum)(glyph)) {
                      spacingLength = spacingDir * glyph * fontSize / 1e3;
                      this.ctx.translate(spacingLength, 0);
                      current.x += spacingLength * textHScale;
                      continue;
                    }
                    var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    var operatorList = font.charProcOperatorList[glyph.operatorListId];
                    if (!operatorList) {
                      (0, _util.warn)('Type3 character "' + glyph.operatorListId + '" is not available.');
                      continue;
                    }
                    this.processingType3 = glyph;
                    this.save();
                    ctx.scale(fontSize, fontSize);
                    ctx.transform.apply(ctx, fontMatrix);
                    this.executeOperatorList(operatorList);
                    this.restore();
                    var transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);
                    width = transformed[0] * fontSize + spacing;
                    ctx.translate(width, 0);
                    current.x += width * textHScale;
                  }
                  ctx.restore();
                  this.processingType3 = null;
                },
                setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {
                },
                setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
                  this.ctx.rect(llx, lly, urx - llx, ury - lly);
                  this.clip();
                  this.endPath();
                },
                getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {
                  var _this = this;
                  var pattern;
                  if (IR[0] === "TilingPattern") {
                    var color = IR[1];
                    var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
                    var canvasGraphicsFactory = {
                      createCanvasGraphics: function createCanvasGraphics(ctx) {
                        return new CanvasGraphics2(ctx, _this.commonObjs, _this.objs, _this.canvasFactory, _this.webGLContext);
                      }
                    };
                    pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
                  } else {
                    pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR);
                  }
                  return pattern;
                },
                setStrokeColorN: function CanvasGraphics_setStrokeColorN() {
                  this.current.strokeColor = this.getColorN_Pattern(arguments);
                },
                setFillColorN: function CanvasGraphics_setFillColorN() {
                  this.current.fillColor = this.getColorN_Pattern(arguments);
                  this.current.patternFill = true;
                },
                setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {
                  var color = _util.Util.makeCssRgb(r, g, b);
                  this.ctx.strokeStyle = color;
                  this.current.strokeColor = color;
                },
                setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {
                  var color = _util.Util.makeCssRgb(r, g, b);
                  this.ctx.fillStyle = color;
                  this.current.fillColor = color;
                  this.current.patternFill = false;
                },
                shadingFill: function CanvasGraphics_shadingFill(patternIR) {
                  var ctx = this.ctx;
                  this.save();
                  var pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR);
                  ctx.fillStyle = pattern.getPattern(ctx, this, true);
                  var inv = ctx.mozCurrentTransformInverse;
                  if (inv) {
                    var canvas = ctx.canvas;
                    var width = canvas.width;
                    var height = canvas.height;
                    var bl = _util.Util.applyTransform([0, 0], inv);
                    var br = _util.Util.applyTransform([0, height], inv);
                    var ul = _util.Util.applyTransform([width, 0], inv);
                    var ur = _util.Util.applyTransform([width, height], inv);
                    var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                    var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                    var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                    var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                    this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
                  } else {
                    this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                  }
                  this.restore();
                },
                beginInlineImage: function CanvasGraphics_beginInlineImage() {
                  (0, _util.unreachable)("Should not call beginInlineImage");
                },
                beginImageData: function CanvasGraphics_beginImageData() {
                  (0, _util.unreachable)("Should not call beginImageData");
                },
                paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {
                  this.save();
                  this.baseTransformStack.push(this.baseTransform);
                  if (Array.isArray(matrix) && matrix.length === 6) {
                    this.transform.apply(this, matrix);
                  }
                  this.baseTransform = this.ctx.mozCurrentTransform;
                  if (Array.isArray(bbox) && bbox.length === 4) {
                    var width = bbox[2] - bbox[0];
                    var height = bbox[3] - bbox[1];
                    this.ctx.rect(bbox[0], bbox[1], width, height);
                    this.clip();
                    this.endPath();
                  }
                },
                paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {
                  this.restore();
                  this.baseTransform = this.baseTransformStack.pop();
                },
                beginGroup: function CanvasGraphics_beginGroup(group) {
                  this.save();
                  var currentCtx = this.ctx;
                  if (!group.isolated) {
                    (0, _util.info)("TODO: Support non-isolated groups.");
                  }
                  if (group.knockout) {
                    (0, _util.warn)("Knockout groups not supported.");
                  }
                  var currentTransform = currentCtx.mozCurrentTransform;
                  if (group.matrix) {
                    currentCtx.transform.apply(currentCtx, group.matrix);
                  }
                  if (!group.bbox) {
                    throw new Error("Bounding box is required.");
                  }
                  var bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);
                  var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
                  bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
                  var offsetX = Math.floor(bounds[0]);
                  var offsetY = Math.floor(bounds[1]);
                  var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
                  var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
                  var scaleX = 1, scaleY = 1;
                  if (drawnWidth > MAX_GROUP_SIZE) {
                    scaleX = drawnWidth / MAX_GROUP_SIZE;
                    drawnWidth = MAX_GROUP_SIZE;
                  }
                  if (drawnHeight > MAX_GROUP_SIZE) {
                    scaleY = drawnHeight / MAX_GROUP_SIZE;
                    drawnHeight = MAX_GROUP_SIZE;
                  }
                  var cacheId = "groupAt" + this.groupLevel;
                  if (group.smask) {
                    cacheId += "_smask_" + this.smaskCounter++ % 2;
                  }
                  var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                  var groupCtx = scratchCanvas.context;
                  groupCtx.scale(1 / scaleX, 1 / scaleY);
                  groupCtx.translate(-offsetX, -offsetY);
                  groupCtx.transform.apply(groupCtx, currentTransform);
                  if (group.smask) {
                    this.smaskStack.push({
                      canvas: scratchCanvas.canvas,
                      context: groupCtx,
                      offsetX,
                      offsetY,
                      scaleX,
                      scaleY,
                      subtype: group.smask.subtype,
                      backdrop: group.smask.backdrop,
                      transferMap: group.smask.transferMap || null,
                      startTransformInverse: null
                    });
                  } else {
                    currentCtx.setTransform(1, 0, 0, 1, 0, 0);
                    currentCtx.translate(offsetX, offsetY);
                    currentCtx.scale(scaleX, scaleY);
                  }
                  copyCtxState(currentCtx, groupCtx);
                  this.ctx = groupCtx;
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                  this.current.activeSMask = null;
                },
                endGroup: function CanvasGraphics_endGroup(group) {
                  this.groupLevel--;
                  var groupCtx = this.ctx;
                  this.ctx = this.groupStack.pop();
                  if (this.ctx.imageSmoothingEnabled !== void 0) {
                    this.ctx.imageSmoothingEnabled = false;
                  } else {
                    this.ctx.mozImageSmoothingEnabled = false;
                  }
                  if (group.smask) {
                    this.tempSMask = this.smaskStack.pop();
                  } else {
                    this.ctx.drawImage(groupCtx.canvas, 0, 0);
                  }
                  this.restore();
                },
                beginAnnotations: function CanvasGraphics_beginAnnotations() {
                  this.save();
                  if (this.baseTransform) {
                    this.ctx.setTransform.apply(this.ctx, this.baseTransform);
                  }
                },
                endAnnotations: function CanvasGraphics_endAnnotations() {
                  this.restore();
                },
                beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {
                  this.save();
                  resetCtxToDefault(this.ctx);
                  this.current = new CanvasExtraState();
                  if (Array.isArray(rect) && rect.length === 4) {
                    var width = rect[2] - rect[0];
                    var height = rect[3] - rect[1];
                    this.ctx.rect(rect[0], rect[1], width, height);
                    this.clip();
                    this.endPath();
                  }
                  this.transform.apply(this, transform);
                  this.transform.apply(this, matrix);
                },
                endAnnotation: function CanvasGraphics_endAnnotation() {
                  this.restore();
                },
                paintJpegXObject: function CanvasGraphics_paintJpegXObject(objId, w, h) {
                  var domImage = this.objs.get(objId);
                  if (!domImage) {
                    (0, _util.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  this.save();
                  var ctx = this.ctx;
                  ctx.scale(1 / w, -1 / h);
                  ctx.drawImage(domImage, 0, 0, domImage.width, domImage.height, 0, -h, w, h);
                  if (this.imageLayer) {
                    var currentTransform = ctx.mozCurrentTransformInverse;
                    var position = this.getCanvasPosition(0, 0);
                    this.imageLayer.appendImage({
                      objId,
                      left: position[0],
                      top: position[1],
                      width: w / currentTransform[0],
                      height: h / currentTransform[3]
                    });
                  }
                  this.restore();
                },
                paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {
                  var ctx = this.ctx;
                  var width = img.width, height = img.height;
                  var fillColor = this.current.fillColor;
                  var isPatternFill = this.current.patternFill;
                  var glyph = this.processingType3;
                  if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === void 0) {
                    if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {
                      glyph.compiled = compileType3Glyph({
                        data: img.data,
                        width,
                        height
                      });
                    } else {
                      glyph.compiled = null;
                    }
                  }
                  if (glyph && glyph.compiled) {
                    glyph.compiled(ctx);
                    return;
                  }
                  var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                  var maskCtx = maskCanvas.context;
                  maskCtx.save();
                  putBinaryImageMask(maskCtx, img);
                  maskCtx.globalCompositeOperation = "source-in";
                  maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                  maskCtx.fillRect(0, 0, width, height);
                  maskCtx.restore();
                  this.paintInlineImageXObject(maskCanvas.canvas);
                },
                paintImageMaskXObjectRepeat: function CanvasGraphics_paintImageMaskXObjectRepeat(imgData, scaleX, scaleY, positions) {
                  var width = imgData.width;
                  var height = imgData.height;
                  var fillColor = this.current.fillColor;
                  var isPatternFill = this.current.patternFill;
                  var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                  var maskCtx = maskCanvas.context;
                  maskCtx.save();
                  putBinaryImageMask(maskCtx, imgData);
                  maskCtx.globalCompositeOperation = "source-in";
                  maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                  maskCtx.fillRect(0, 0, width, height);
                  maskCtx.restore();
                  var ctx = this.ctx;
                  for (var i = 0, ii = positions.length; i < ii; i += 2) {
                    ctx.save();
                    ctx.transform(scaleX, 0, 0, scaleY, positions[i], positions[i + 1]);
                    ctx.scale(1, -1);
                    ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                    ctx.restore();
                  }
                },
                paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {
                  var ctx = this.ctx;
                  var fillColor = this.current.fillColor;
                  var isPatternFill = this.current.patternFill;
                  for (var i = 0, ii = images.length; i < ii; i++) {
                    var image = images[i];
                    var width = image.width, height = image.height;
                    var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                    var maskCtx = maskCanvas.context;
                    maskCtx.save();
                    putBinaryImageMask(maskCtx, image);
                    maskCtx.globalCompositeOperation = "source-in";
                    maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                    maskCtx.fillRect(0, 0, width, height);
                    maskCtx.restore();
                    ctx.save();
                    ctx.transform.apply(ctx, image.transform);
                    ctx.scale(1, -1);
                    ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                    ctx.restore();
                  }
                },
                paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {
                  var imgData = this.objs.get(objId);
                  if (!imgData) {
                    (0, _util.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  this.paintInlineImageXObject(imgData);
                },
                paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
                  var imgData = this.objs.get(objId);
                  if (!imgData) {
                    (0, _util.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  var width = imgData.width;
                  var height = imgData.height;
                  var map = [];
                  for (var i = 0, ii = positions.length; i < ii; i += 2) {
                    map.push({
                      transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
                      x: 0,
                      y: 0,
                      w: width,
                      h: height
                    });
                  }
                  this.paintInlineImageXObjectGroup(imgData, map);
                },
                paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {
                  var width = imgData.width;
                  var height = imgData.height;
                  var ctx = this.ctx;
                  this.save();
                  ctx.scale(1 / width, -1 / height);
                  var currentTransform = ctx.mozCurrentTransformInverse;
                  var a = currentTransform[0], b = currentTransform[1];
                  var widthScale = Math.max(Math.sqrt(a * a + b * b), 1);
                  var c = currentTransform[2], d = currentTransform[3];
                  var heightScale = Math.max(Math.sqrt(c * c + d * d), 1);
                  var imgToPaint, tmpCanvas;
                  if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
                    imgToPaint = imgData;
                  } else {
                    tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
                    var tmpCtx = tmpCanvas.context;
                    putBinaryImageData(tmpCtx, imgData);
                    imgToPaint = tmpCanvas.canvas;
                  }
                  var paintWidth = width, paintHeight = height;
                  var tmpCanvasId = "prescale1";
                  while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
                    var newWidth = paintWidth, newHeight = paintHeight;
                    if (widthScale > 2 && paintWidth > 1) {
                      newWidth = Math.ceil(paintWidth / 2);
                      widthScale /= paintWidth / newWidth;
                    }
                    if (heightScale > 2 && paintHeight > 1) {
                      newHeight = Math.ceil(paintHeight / 2);
                      heightScale /= paintHeight / newHeight;
                    }
                    tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
                    tmpCtx = tmpCanvas.context;
                    tmpCtx.clearRect(0, 0, newWidth, newHeight);
                    tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
                    imgToPaint = tmpCanvas.canvas;
                    paintWidth = newWidth;
                    paintHeight = newHeight;
                    tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
                  }
                  ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);
                  if (this.imageLayer) {
                    var position = this.getCanvasPosition(0, -height);
                    this.imageLayer.appendImage({
                      imgData,
                      left: position[0],
                      top: position[1],
                      width: width / currentTransform[0],
                      height: height / currentTransform[3]
                    });
                  }
                  this.restore();
                },
                paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {
                  var ctx = this.ctx;
                  var w = imgData.width;
                  var h = imgData.height;
                  var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
                  var tmpCtx = tmpCanvas.context;
                  putBinaryImageData(tmpCtx, imgData);
                  for (var i = 0, ii = map.length; i < ii; i++) {
                    var entry = map[i];
                    ctx.save();
                    ctx.transform.apply(ctx, entry.transform);
                    ctx.scale(1, -1);
                    ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
                    if (this.imageLayer) {
                      var position = this.getCanvasPosition(entry.x, entry.y);
                      this.imageLayer.appendImage({
                        imgData,
                        left: position[0],
                        top: position[1],
                        width: w,
                        height: h
                      });
                    }
                    ctx.restore();
                  }
                },
                paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {
                  this.ctx.fillRect(0, 0, 1, 1);
                },
                paintXObject: function CanvasGraphics_paintXObject() {
                  (0, _util.warn)("Unsupported 'paintXObject' command.");
                },
                markPoint: function CanvasGraphics_markPoint(tag) {
                },
                markPointProps: function CanvasGraphics_markPointProps(tag, properties) {
                },
                beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {
                },
                beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {
                },
                endMarkedContent: function CanvasGraphics_endMarkedContent() {
                },
                beginCompat: function CanvasGraphics_beginCompat() {
                },
                endCompat: function CanvasGraphics_endCompat() {
                },
                consumePath: function CanvasGraphics_consumePath() {
                  var ctx = this.ctx;
                  if (this.pendingClip) {
                    if (this.pendingClip === EO_CLIP) {
                      ctx.clip("evenodd");
                    } else {
                      ctx.clip();
                    }
                    this.pendingClip = null;
                  }
                  ctx.beginPath();
                },
                getSinglePixelWidth: function CanvasGraphics_getSinglePixelWidth(scale) {
                  if (this.cachedGetSinglePixelWidth === null) {
                    this.ctx.save();
                    var inverse = this.ctx.mozCurrentTransformInverse;
                    this.ctx.restore();
                    this.cachedGetSinglePixelWidth = Math.sqrt(Math.max(inverse[0] * inverse[0] + inverse[1] * inverse[1], inverse[2] * inverse[2] + inverse[3] * inverse[3]));
                  }
                  return this.cachedGetSinglePixelWidth;
                },
                getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {
                  var transform = this.ctx.mozCurrentTransform;
                  return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
                }
              };
              for (var op in _util.OPS) {
                CanvasGraphics2.prototype[_util.OPS[op]] = CanvasGraphics2.prototype[op];
              }
              return CanvasGraphics2;
            }();
            exports3.CanvasGraphics = CanvasGraphics;
          },
          /* 119 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.TilingPattern = exports3.getShadingPatternFromIR = void 0;
            var _util = __w_pdfjs_require__(1);
            var ShadingIRs = {};
            ShadingIRs.RadialAxial = {
              fromIR: function RadialAxial_fromIR(raw) {
                var type = raw[1];
                var colorStops = raw[2];
                var p0 = raw[3];
                var p1 = raw[4];
                var r0 = raw[5];
                var r1 = raw[6];
                return {
                  type: "Pattern",
                  getPattern: function RadialAxial_getPattern(ctx) {
                    var grad;
                    if (type === "axial") {
                      grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);
                    } else if (type === "radial") {
                      grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);
                    }
                    for (var i = 0, ii = colorStops.length; i < ii; ++i) {
                      var c = colorStops[i];
                      grad.addColorStop(c[0], c[1]);
                    }
                    return grad;
                  }
                };
              }
            };
            var createMeshCanvas = /* @__PURE__ */ function createMeshCanvasClosure() {
              function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
                var coords = context.coords, colors = context.colors;
                var bytes = data.data, rowSize = data.width * 4;
                var tmp;
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                if (coords[p2 + 1] > coords[p3 + 1]) {
                  tmp = p2;
                  p2 = p3;
                  p3 = tmp;
                  tmp = c2;
                  c2 = c3;
                  c3 = tmp;
                }
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                var x1 = (coords[p1] + context.offsetX) * context.scaleX;
                var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
                var x2 = (coords[p2] + context.offsetX) * context.scaleX;
                var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
                var x3 = (coords[p3] + context.offsetX) * context.scaleX;
                var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
                if (y1 >= y3) {
                  return;
                }
                var c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
                var c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
                var c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
                var minY = Math.round(y1), maxY = Math.round(y3);
                var xa, car, cag, cab;
                var xb, cbr, cbg, cbb;
                var k;
                for (var y = minY; y <= maxY; y++) {
                  if (y < y2) {
                    k = y < y1 ? 0 : y1 === y2 ? 1 : (y1 - y) / (y1 - y2);
                    xa = x1 - (x1 - x2) * k;
                    car = c1r - (c1r - c2r) * k;
                    cag = c1g - (c1g - c2g) * k;
                    cab = c1b - (c1b - c2b) * k;
                  } else {
                    k = y > y3 ? 1 : y2 === y3 ? 0 : (y2 - y) / (y2 - y3);
                    xa = x2 - (x2 - x3) * k;
                    car = c2r - (c2r - c3r) * k;
                    cag = c2g - (c2g - c3g) * k;
                    cab = c2b - (c2b - c3b) * k;
                  }
                  k = y < y1 ? 0 : y > y3 ? 1 : (y1 - y) / (y1 - y3);
                  xb = x1 - (x1 - x3) * k;
                  cbr = c1r - (c1r - c3r) * k;
                  cbg = c1g - (c1g - c3g) * k;
                  cbb = c1b - (c1b - c3b) * k;
                  var x1_ = Math.round(Math.min(xa, xb));
                  var x2_ = Math.round(Math.max(xa, xb));
                  var j = rowSize * y + x1_ * 4;
                  for (var x = x1_; x <= x2_; x++) {
                    k = (xa - x) / (xa - xb);
                    k = k < 0 ? 0 : k > 1 ? 1 : k;
                    bytes[j++] = car - (car - cbr) * k | 0;
                    bytes[j++] = cag - (cag - cbg) * k | 0;
                    bytes[j++] = cab - (cab - cbb) * k | 0;
                    bytes[j++] = 255;
                  }
                }
              }
              function drawFigure(data, figure, context) {
                var ps = figure.coords;
                var cs = figure.colors;
                var i, ii;
                switch (figure.type) {
                  case "lattice":
                    var verticesPerRow = figure.verticesPerRow;
                    var rows = Math.floor(ps.length / verticesPerRow) - 1;
                    var cols = verticesPerRow - 1;
                    for (i = 0; i < rows; i++) {
                      var q = i * verticesPerRow;
                      for (var j = 0; j < cols; j++, q++) {
                        drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                        drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
                      }
                    }
                    break;
                  case "triangles":
                    for (i = 0, ii = ps.length; i < ii; i += 3) {
                      drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
                    }
                    break;
                  default:
                    throw new Error("illegal figure");
                }
              }
              function createMeshCanvas2(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases, webGLContext) {
                var EXPECTED_SCALE = 1.1;
                var MAX_PATTERN_SIZE = 3e3;
                var BORDER_SIZE = 2;
                var offsetX = Math.floor(bounds[0]);
                var offsetY = Math.floor(bounds[1]);
                var boundsWidth = Math.ceil(bounds[2]) - offsetX;
                var boundsHeight = Math.ceil(bounds[3]) - offsetY;
                var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                var scaleX = boundsWidth / width;
                var scaleY = boundsHeight / height;
                var context = {
                  coords,
                  colors,
                  offsetX: -offsetX,
                  offsetY: -offsetY,
                  scaleX: 1 / scaleX,
                  scaleY: 1 / scaleY
                };
                var paddedWidth = width + BORDER_SIZE * 2;
                var paddedHeight = height + BORDER_SIZE * 2;
                var canvas, tmpCanvas, i, ii;
                if (webGLContext.isEnabled) {
                  canvas = webGLContext.drawFigures({
                    width,
                    height,
                    backgroundColor,
                    figures,
                    context
                  });
                  tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                  tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE);
                  canvas = tmpCanvas.canvas;
                } else {
                  tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                  var tmpCtx = tmpCanvas.context;
                  var data = tmpCtx.createImageData(width, height);
                  if (backgroundColor) {
                    var bytes = data.data;
                    for (i = 0, ii = bytes.length; i < ii; i += 4) {
                      bytes[i] = backgroundColor[0];
                      bytes[i + 1] = backgroundColor[1];
                      bytes[i + 2] = backgroundColor[2];
                      bytes[i + 3] = 255;
                    }
                  }
                  for (i = 0; i < figures.length; i++) {
                    drawFigure(data, figures[i], context);
                  }
                  tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
                  canvas = tmpCanvas.canvas;
                }
                return {
                  canvas,
                  offsetX: offsetX - BORDER_SIZE * scaleX,
                  offsetY: offsetY - BORDER_SIZE * scaleY,
                  scaleX,
                  scaleY
                };
              }
              return createMeshCanvas2;
            }();
            ShadingIRs.Mesh = {
              fromIR: function Mesh_fromIR(raw) {
                var coords = raw[2];
                var colors = raw[3];
                var figures = raw[4];
                var bounds = raw[5];
                var matrix = raw[6];
                var background = raw[8];
                return {
                  type: "Pattern",
                  getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {
                    var scale;
                    if (shadingFill) {
                      scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
                    } else {
                      scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);
                      if (matrix) {
                        var matrixScale = _util.Util.singularValueDecompose2dScale(matrix);
                        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
                      }
                    }
                    var temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases, owner.webGLContext);
                    if (!shadingFill) {
                      ctx.setTransform.apply(ctx, owner.baseTransform);
                      if (matrix) {
                        ctx.transform.apply(ctx, matrix);
                      }
                    }
                    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
                    return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
                  }
                };
              }
            };
            ShadingIRs.Dummy = {
              fromIR: function Dummy_fromIR() {
                return {
                  type: "Pattern",
                  getPattern: function Dummy_fromIR_getPattern() {
                    return "hotpink";
                  }
                };
              }
            };
            function getShadingPatternFromIR(raw) {
              var shadingIR = ShadingIRs[raw[0]];
              if (!shadingIR) {
                throw new Error("Unknown IR type: " + raw[0]);
              }
              return shadingIR.fromIR(raw);
            }
            var TilingPattern = function TilingPatternClosure() {
              var PaintType = {
                COLORED: 1,
                UNCOLORED: 2
              };
              var MAX_PATTERN_SIZE = 3e3;
              function TilingPattern2(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
                this.operatorList = IR[2];
                this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
                this.bbox = IR[4];
                this.xstep = IR[5];
                this.ystep = IR[6];
                this.paintType = IR[7];
                this.tilingType = IR[8];
                this.color = color;
                this.canvasGraphicsFactory = canvasGraphicsFactory;
                this.baseTransform = baseTransform;
                this.type = "Pattern";
                this.ctx = ctx;
              }
              TilingPattern2.prototype = {
                createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {
                  var operatorList = this.operatorList;
                  var bbox = this.bbox;
                  var xstep = this.xstep;
                  var ystep = this.ystep;
                  var paintType = this.paintType;
                  var tilingType = this.tilingType;
                  var color = this.color;
                  var canvasGraphicsFactory = this.canvasGraphicsFactory;
                  (0, _util.info)("TilingType: " + tilingType);
                  var x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
                  var topLeft = [x0, y0];
                  var botRight = [x0 + xstep, y0 + ystep];
                  var width = botRight[0] - topLeft[0];
                  var height = botRight[1] - topLeft[1];
                  var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);
                  var curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);
                  var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
                  width = Math.min(Math.ceil(Math.abs(width * combinedScale[0])), MAX_PATTERN_SIZE);
                  height = Math.min(Math.ceil(Math.abs(height * combinedScale[1])), MAX_PATTERN_SIZE);
                  var tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height, true);
                  var tmpCtx = tmpCanvas.context;
                  var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
                  graphics.groupLevel = owner.groupLevel;
                  this.setFillAndStrokeStyleToContext(graphics, paintType, color);
                  this.setScale(width, height, xstep, ystep);
                  this.transformToScale(graphics);
                  var tmpTranslate = [1, 0, 0, 1, -topLeft[0], -topLeft[1]];
                  graphics.transform.apply(graphics, tmpTranslate);
                  this.clipBbox(graphics, bbox, x0, y0, x1, y1);
                  graphics.executeOperatorList(operatorList);
                  return tmpCanvas.canvas;
                },
                setScale: function TilingPattern_setScale(width, height, xstep, ystep) {
                  this.scale = [width / xstep, height / ystep];
                },
                transformToScale: function TilingPattern_transformToScale(graphics) {
                  var scale = this.scale;
                  var tmpScale = [scale[0], 0, 0, scale[1], 0, 0];
                  graphics.transform.apply(graphics, tmpScale);
                },
                scaleToContext: function TilingPattern_scaleToContext() {
                  var scale = this.scale;
                  this.ctx.scale(1 / scale[0], 1 / scale[1]);
                },
                clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {
                  if (Array.isArray(bbox) && bbox.length === 4) {
                    var bboxWidth = x1 - x0;
                    var bboxHeight = y1 - y0;
                    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
                    graphics.clip();
                    graphics.endPath();
                  }
                },
                setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(graphics, paintType, color) {
                  var context = graphics.ctx, current = graphics.current;
                  switch (paintType) {
                    case PaintType.COLORED:
                      var ctx = this.ctx;
                      context.fillStyle = ctx.fillStyle;
                      context.strokeStyle = ctx.strokeStyle;
                      current.fillColor = ctx.fillStyle;
                      current.strokeColor = ctx.strokeStyle;
                      break;
                    case PaintType.UNCOLORED:
                      var cssColor = _util.Util.makeCssRgb(color[0], color[1], color[2]);
                      context.fillStyle = cssColor;
                      context.strokeStyle = cssColor;
                      current.fillColor = cssColor;
                      current.strokeColor = cssColor;
                      break;
                    default:
                      throw new _util.FormatError("Unsupported paint type: " + paintType);
                  }
                },
                getPattern: function TilingPattern_getPattern(ctx, owner) {
                  var temporaryPatternCanvas = this.createPatternCanvas(owner);
                  ctx = this.ctx;
                  ctx.setTransform.apply(ctx, this.baseTransform);
                  ctx.transform.apply(ctx, this.matrix);
                  this.scaleToContext();
                  return ctx.createPattern(temporaryPatternCanvas, "repeat");
                }
              };
              return TilingPattern2;
            }();
            exports3.getShadingPatternFromIR = getShadingPatternFromIR;
            exports3.TilingPattern = TilingPattern;
          },
          /* 120 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            var GlobalWorkerOptions = /* @__PURE__ */ Object.create(null);
            GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === void 0 ? null : GlobalWorkerOptions.workerPort;
            GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === void 0 ? "" : GlobalWorkerOptions.workerSrc;
            exports3.GlobalWorkerOptions = GlobalWorkerOptions;
          },
          /* 121 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.MessageHandler = void 0;
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var _util = __w_pdfjs_require__(1);
            function resolveCall(fn, args) {
              var thisArg = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              if (!fn) {
                return Promise.resolve(void 0);
              }
              return new Promise(function(resolve2, reject2) {
                resolve2(fn.apply(thisArg, args));
              });
            }
            function wrapReason(reason) {
              if ((typeof reason === "undefined" ? "undefined" : _typeof(reason)) !== "object") {
                return reason;
              }
              switch (reason.name) {
                case "AbortException":
                  return new _util.AbortException(reason.message);
                case "MissingPDFException":
                  return new _util.MissingPDFException(reason.message);
                case "UnexpectedResponseException":
                  return new _util.UnexpectedResponseException(reason.message, reason.status);
                default:
                  return new _util.UnknownErrorException(reason.message, reason.details);
              }
            }
            function makeReasonSerializable(reason) {
              if (!(reason instanceof Error) || reason instanceof _util.AbortException || reason instanceof _util.MissingPDFException || reason instanceof _util.UnexpectedResponseException || reason instanceof _util.UnknownErrorException) {
                return reason;
              }
              return new _util.UnknownErrorException(reason.message, reason.toString());
            }
            function resolveOrReject(capability, success, reason) {
              if (success) {
                capability.resolve();
              } else {
                capability.reject(reason);
              }
            }
            function finalize(promise) {
              return Promise.resolve(promise).catch(function() {
              });
            }
            function MessageHandler(sourceName, targetName, comObj) {
              var _this = this;
              this.sourceName = sourceName;
              this.targetName = targetName;
              this.comObj = comObj;
              this.callbackId = 1;
              this.streamId = 1;
              this.postMessageTransfers = true;
              this.streamSinks = /* @__PURE__ */ Object.create(null);
              this.streamControllers = /* @__PURE__ */ Object.create(null);
              var callbacksCapabilities = this.callbacksCapabilities = /* @__PURE__ */ Object.create(null);
              var ah = this.actionHandler = /* @__PURE__ */ Object.create(null);
              this._onComObjOnMessage = function(event) {
                var data = event.data;
                if (data.targetName !== _this.sourceName) {
                  return;
                }
                if (data.stream) {
                  _this._processStreamMessage(data);
                } else if (data.isReply) {
                  var callbackId = data.callbackId;
                  if (data.callbackId in callbacksCapabilities) {
                    var callback = callbacksCapabilities[callbackId];
                    delete callbacksCapabilities[callbackId];
                    if ("error" in data) {
                      callback.reject(wrapReason(data.error));
                    } else {
                      callback.resolve(data.data);
                    }
                  } else {
                    throw new Error("Cannot resolve callback " + callbackId);
                  }
                } else if (data.action in ah) {
                  var action = ah[data.action];
                  if (data.callbackId) {
                    var _sourceName = _this.sourceName;
                    var _targetName = data.sourceName;
                    Promise.resolve().then(function() {
                      return action[0].call(action[1], data.data);
                    }).then(function(result) {
                      comObj.postMessage({
                        sourceName: _sourceName,
                        targetName: _targetName,
                        isReply: true,
                        callbackId: data.callbackId,
                        data: result
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName: _sourceName,
                        targetName: _targetName,
                        isReply: true,
                        callbackId: data.callbackId,
                        error: makeReasonSerializable(reason)
                      });
                    });
                  } else if (data.streamId) {
                    _this._createStreamSink(data);
                  } else {
                    action[0].call(action[1], data.data);
                  }
                } else {
                  throw new Error("Unknown action from worker: " + data.action);
                }
              };
              comObj.addEventListener("message", this._onComObjOnMessage);
            }
            MessageHandler.prototype = {
              on: function on(actionName, handler, scope) {
                var ah = this.actionHandler;
                if (ah[actionName]) {
                  throw new Error('There is already an actionName called "' + actionName + '"');
                }
                ah[actionName] = [handler, scope];
              },
              send: function send(actionName, data, transfers) {
                var message = {
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: actionName,
                  data
                };
                this.postMessage(message, transfers);
              },
              sendWithPromise: function sendWithPromise(actionName, data, transfers) {
                var callbackId = this.callbackId++;
                var message = {
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: actionName,
                  data,
                  callbackId
                };
                var capability = (0, _util.createPromiseCapability)();
                this.callbacksCapabilities[callbackId] = capability;
                try {
                  this.postMessage(message, transfers);
                } catch (e) {
                  capability.reject(e);
                }
                return capability.promise;
              },
              sendWithStream: function sendWithStream(actionName, data, queueingStrategy, transfers) {
                var _this2 = this;
                var streamId = this.streamId++;
                var sourceName = this.sourceName;
                var targetName = this.targetName;
                return new _util.ReadableStream({
                  start: function start(controller) {
                    var startCapability = (0, _util.createPromiseCapability)();
                    _this2.streamControllers[streamId] = {
                      controller,
                      startCall: startCapability,
                      isClosed: false
                    };
                    _this2.postMessage({
                      sourceName,
                      targetName,
                      action: actionName,
                      streamId,
                      data,
                      desiredSize: controller.desiredSize
                    });
                    return startCapability.promise;
                  },
                  pull: function pull(controller) {
                    var pullCapability = (0, _util.createPromiseCapability)();
                    _this2.streamControllers[streamId].pullCall = pullCapability;
                    _this2.postMessage({
                      sourceName,
                      targetName,
                      stream: "pull",
                      streamId,
                      desiredSize: controller.desiredSize
                    });
                    return pullCapability.promise;
                  },
                  cancel: function cancel(reason) {
                    var cancelCapability = (0, _util.createPromiseCapability)();
                    _this2.streamControllers[streamId].cancelCall = cancelCapability;
                    _this2.streamControllers[streamId].isClosed = true;
                    _this2.postMessage({
                      sourceName,
                      targetName,
                      stream: "cancel",
                      reason,
                      streamId
                    });
                    return cancelCapability.promise;
                  }
                }, queueingStrategy);
              },
              _createStreamSink: function _createStreamSink(data) {
                var _this3 = this;
                var self2 = this;
                var action = this.actionHandler[data.action];
                var streamId = data.streamId;
                var desiredSize = data.desiredSize;
                var sourceName = this.sourceName;
                var targetName = data.sourceName;
                var capability = (0, _util.createPromiseCapability)();
                var sendStreamRequest = function sendStreamRequest2(_ref) {
                  var stream2 = _ref.stream, chunk = _ref.chunk, transfers = _ref.transfers, success = _ref.success, reason = _ref.reason;
                  _this3.postMessage({
                    sourceName,
                    targetName,
                    stream: stream2,
                    streamId,
                    chunk,
                    success,
                    reason
                  }, transfers);
                };
                var streamSink = {
                  enqueue: function enqueue(chunk) {
                    var size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
                    var transfers = arguments[2];
                    if (this.isCancelled) {
                      return;
                    }
                    var lastDesiredSize = this.desiredSize;
                    this.desiredSize -= size;
                    if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                      this.sinkCapability = (0, _util.createPromiseCapability)();
                      this.ready = this.sinkCapability.promise;
                    }
                    sendStreamRequest({
                      stream: "enqueue",
                      chunk,
                      transfers
                    });
                  },
                  close: function close() {
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    sendStreamRequest({ stream: "close" });
                    delete self2.streamSinks[streamId];
                  },
                  error: function error(reason) {
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    sendStreamRequest({
                      stream: "error",
                      reason
                    });
                  },
                  sinkCapability: capability,
                  onPull: null,
                  onCancel: null,
                  isCancelled: false,
                  desiredSize,
                  ready: null
                };
                streamSink.sinkCapability.resolve();
                streamSink.ready = streamSink.sinkCapability.promise;
                this.streamSinks[streamId] = streamSink;
                resolveCall(action[0], [data.data, streamSink], action[1]).then(function() {
                  sendStreamRequest({
                    stream: "start_complete",
                    success: true
                  });
                }, function(reason) {
                  sendStreamRequest({
                    stream: "start_complete",
                    success: false,
                    reason
                  });
                });
              },
              _processStreamMessage: function _processStreamMessage(data) {
                var _this4 = this;
                var sourceName = this.sourceName;
                var targetName = data.sourceName;
                var streamId = data.streamId;
                var sendStreamResponse = function sendStreamResponse2(_ref2) {
                  var stream2 = _ref2.stream, success = _ref2.success, reason = _ref2.reason;
                  _this4.comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: stream2,
                    success,
                    streamId,
                    reason
                  });
                };
                var deleteStreamController = function deleteStreamController2() {
                  Promise.all([_this4.streamControllers[data.streamId].startCall, _this4.streamControllers[data.streamId].pullCall, _this4.streamControllers[data.streamId].cancelCall].map(function(capability) {
                    return capability && finalize(capability.promise);
                  })).then(function() {
                    delete _this4.streamControllers[data.streamId];
                  });
                };
                switch (data.stream) {
                  case "start_complete":
                    resolveOrReject(this.streamControllers[data.streamId].startCall, data.success, wrapReason(data.reason));
                    break;
                  case "pull_complete":
                    resolveOrReject(this.streamControllers[data.streamId].pullCall, data.success, wrapReason(data.reason));
                    break;
                  case "pull":
                    if (!this.streamSinks[data.streamId]) {
                      sendStreamResponse({
                        stream: "pull_complete",
                        success: true
                      });
                      break;
                    }
                    if (this.streamSinks[data.streamId].desiredSize <= 0 && data.desiredSize > 0) {
                      this.streamSinks[data.streamId].sinkCapability.resolve();
                    }
                    this.streamSinks[data.streamId].desiredSize = data.desiredSize;
                    resolveCall(this.streamSinks[data.streamId].onPull).then(function() {
                      sendStreamResponse({
                        stream: "pull_complete",
                        success: true
                      });
                    }, function(reason) {
                      sendStreamResponse({
                        stream: "pull_complete",
                        success: false,
                        reason
                      });
                    });
                    break;
                  case "enqueue":
                    (0, _util.assert)(this.streamControllers[data.streamId], "enqueue should have stream controller");
                    if (!this.streamControllers[data.streamId].isClosed) {
                      this.streamControllers[data.streamId].controller.enqueue(data.chunk);
                    }
                    break;
                  case "close":
                    (0, _util.assert)(this.streamControllers[data.streamId], "close should have stream controller");
                    if (this.streamControllers[data.streamId].isClosed) {
                      break;
                    }
                    this.streamControllers[data.streamId].isClosed = true;
                    this.streamControllers[data.streamId].controller.close();
                    deleteStreamController();
                    break;
                  case "error":
                    (0, _util.assert)(this.streamControllers[data.streamId], "error should have stream controller");
                    this.streamControllers[data.streamId].controller.error(wrapReason(data.reason));
                    deleteStreamController();
                    break;
                  case "cancel_complete":
                    resolveOrReject(this.streamControllers[data.streamId].cancelCall, data.success, wrapReason(data.reason));
                    deleteStreamController();
                    break;
                  case "cancel":
                    if (!this.streamSinks[data.streamId]) {
                      break;
                    }
                    resolveCall(this.streamSinks[data.streamId].onCancel, [wrapReason(data.reason)]).then(function() {
                      sendStreamResponse({
                        stream: "cancel_complete",
                        success: true
                      });
                    }, function(reason) {
                      sendStreamResponse({
                        stream: "cancel_complete",
                        success: false,
                        reason
                      });
                    });
                    this.streamSinks[data.streamId].sinkCapability.reject(wrapReason(data.reason));
                    this.streamSinks[data.streamId].isCancelled = true;
                    delete this.streamSinks[data.streamId];
                    break;
                  default:
                    throw new Error("Unexpected stream case");
                }
              },
              postMessage: function postMessage2(message, transfers) {
                if (transfers && this.postMessageTransfers) {
                  this.comObj.postMessage(message, transfers);
                } else {
                  this.comObj.postMessage(message);
                }
              },
              destroy: function destroy() {
                this.comObj.removeEventListener("message", this._onComObjOnMessage);
              }
            };
            exports3.MessageHandler = MessageHandler;
          },
          /* 122 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.Metadata = void 0;
            var _createClass = /* @__PURE__ */ function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _util = __w_pdfjs_require__(1);
            var _xml_parser = __w_pdfjs_require__(123);
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var Metadata = function() {
              function Metadata2(data) {
                _classCallCheck(this, Metadata2);
                (0, _util.assert)(typeof data === "string", "Metadata: input is not a string");
                data = this._repair(data);
                var parser = new _xml_parser.SimpleXMLParser();
                var xmlDocument = parser.parseFromString(data);
                this._metadata = /* @__PURE__ */ Object.create(null);
                if (xmlDocument) {
                  this._parse(xmlDocument);
                }
              }
              _createClass(Metadata2, [{
                key: "_repair",
                value: function _repair(data) {
                  return data.replace(/>\\376\\377([^<]+)/g, function(all, codes) {
                    var bytes = codes.replace(/\\([0-3])([0-7])([0-7])/g, function(code2, d1, d2, d3) {
                      return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);
                    }).replace(/&(amp|apos|gt|lt|quot);/g, function(str, name) {
                      switch (name) {
                        case "amp":
                          return "&";
                        case "apos":
                          return "'";
                        case "gt":
                          return ">";
                        case "lt":
                          return "<";
                        case "quot":
                          return '"';
                      }
                      throw new Error("_repair: " + name + " isn't defined.");
                    });
                    var chars = "";
                    for (var i = 0, ii = bytes.length; i < ii; i += 2) {
                      var code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);
                      if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {
                        chars += String.fromCharCode(code);
                      } else {
                        chars += "&#x" + (65536 + code).toString(16).substring(1) + ";";
                      }
                    }
                    return ">" + chars;
                  });
                }
              }, {
                key: "_parse",
                value: function _parse(xmlDocument) {
                  var rdf = xmlDocument.documentElement;
                  if (rdf.nodeName.toLowerCase() !== "rdf:rdf") {
                    rdf = rdf.firstChild;
                    while (rdf && rdf.nodeName.toLowerCase() !== "rdf:rdf") {
                      rdf = rdf.nextSibling;
                    }
                  }
                  var nodeName = rdf ? rdf.nodeName.toLowerCase() : null;
                  if (!rdf || nodeName !== "rdf:rdf" || !rdf.hasChildNodes()) {
                    return;
                  }
                  var children = rdf.childNodes;
                  for (var i = 0, ii = children.length; i < ii; i++) {
                    var desc = children[i];
                    if (desc.nodeName.toLowerCase() !== "rdf:description") {
                      continue;
                    }
                    for (var j = 0, jj = desc.childNodes.length; j < jj; j++) {
                      if (desc.childNodes[j].nodeName.toLowerCase() !== "#text") {
                        var entry = desc.childNodes[j];
                        var name = entry.nodeName.toLowerCase();
                        this._metadata[name] = entry.textContent.trim();
                      }
                    }
                  }
                }
              }, {
                key: "get",
                value: function get(name) {
                  return this._metadata[name] || null;
                }
              }, {
                key: "getAll",
                value: function getAll() {
                  return this._metadata;
                }
              }, {
                key: "has",
                value: function has(name) {
                  return typeof this._metadata[name] !== "undefined";
                }
              }]);
              return Metadata2;
            }();
            exports3.Metadata = Metadata;
          },
          /* 123 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null) object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _createClass = /* @__PURE__ */ function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var XMLParserErrorCode = {
              NoError: 0,
              EndOfDocument: -1,
              UnterminatedCdat: -2,
              UnterminatedXmlDeclaration: -3,
              UnterminatedDoctypeDeclaration: -4,
              UnterminatedComment: -5,
              MalformedElement: -6,
              OutOfMemory: -7,
              UnterminatedAttributeValue: -8,
              UnterminatedElement: -9,
              ElementNeverBegun: -10
            };
            function isWhitespace(s, index) {
              var ch = s[index];
              return ch === " " || ch === "\n" || ch === "\r" || ch === "	";
            }
            function isWhitespaceString(s) {
              for (var i = 0, ii = s.length; i < ii; i++) {
                if (!isWhitespace(s, i)) {
                  return false;
                }
              }
              return true;
            }
            var XMLParserBase = function() {
              function XMLParserBase2() {
                _classCallCheck(this, XMLParserBase2);
              }
              _createClass(XMLParserBase2, [{
                key: "_resolveEntities",
                value: function _resolveEntities(s) {
                  return s.replace(/&([^;]+);/g, function(all, entity) {
                    if (entity.substring(0, 2) === "#x") {
                      return String.fromCharCode(parseInt(entity.substring(2), 16));
                    } else if (entity.substring(0, 1) === "#") {
                      return String.fromCharCode(parseInt(entity.substring(1), 10));
                    }
                    switch (entity) {
                      case "lt":
                        return "<";
                      case "gt":
                        return ">";
                      case "amp":
                        return "&";
                      case "quot":
                        return '"';
                    }
                    return this.onResolveEntity(entity);
                  });
                }
              }, {
                key: "_parseContent",
                value: function _parseContent(s, start) {
                  var pos = start, name = void 0, attributes = [];
                  function skipWs() {
                    while (pos < s.length && isWhitespace(s, pos)) {
                      ++pos;
                    }
                  }
                  while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
                    ++pos;
                  }
                  name = s.substring(start, pos);
                  skipWs();
                  while (pos < s.length && s[pos] !== ">" && s[pos] !== "/" && s[pos] !== "?") {
                    skipWs();
                    var attrName = "", attrValue = "";
                    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== "=") {
                      attrName += s[pos];
                      ++pos;
                    }
                    skipWs();
                    if (s[pos] !== "=") {
                      return null;
                    }
                    ++pos;
                    skipWs();
                    var attrEndChar = s[pos];
                    if (attrEndChar !== '"' && attrEndChar !== "'") {
                      return null;
                    }
                    var attrEndIndex = s.indexOf(attrEndChar, ++pos);
                    if (attrEndIndex < 0) {
                      return null;
                    }
                    attrValue = s.substring(pos, attrEndIndex);
                    attributes.push({
                      name: attrName,
                      value: this._resolveEntities(attrValue)
                    });
                    pos = attrEndIndex + 1;
                    skipWs();
                  }
                  return {
                    name,
                    attributes,
                    parsed: pos - start
                  };
                }
              }, {
                key: "_parseProcessingInstruction",
                value: function _parseProcessingInstruction(s, start) {
                  var pos = start, name = void 0, value = void 0;
                  function skipWs() {
                    while (pos < s.length && isWhitespace(s, pos)) {
                      ++pos;
                    }
                  }
                  while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
                    ++pos;
                  }
                  name = s.substring(start, pos);
                  skipWs();
                  var attrStart = pos;
                  while (pos < s.length && (s[pos] !== "?" || s[pos + 1] !== ">")) {
                    ++pos;
                  }
                  value = s.substring(attrStart, pos);
                  return {
                    name,
                    value,
                    parsed: pos - start
                  };
                }
              }, {
                key: "parseXml",
                value: function parseXml(s) {
                  var i = 0;
                  while (i < s.length) {
                    var ch = s[i];
                    var j = i;
                    if (ch === "<") {
                      ++j;
                      var ch2 = s[j];
                      var q = void 0;
                      switch (ch2) {
                        case "/":
                          ++j;
                          q = s.indexOf(">", j);
                          if (q < 0) {
                            this.onError(XMLParserErrorCode.UnterminatedElement);
                            return;
                          }
                          this.onEndElement(s.substring(j, q));
                          j = q + 1;
                          break;
                        case "?":
                          ++j;
                          var pi = this._parseProcessingInstruction(s, j);
                          if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== "?>") {
                            this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);
                            return;
                          }
                          this.onPi(pi.name, pi.value);
                          j += pi.parsed + 2;
                          break;
                        case "!":
                          if (s.substring(j + 1, j + 3) === "--") {
                            q = s.indexOf("-->", j + 3);
                            if (q < 0) {
                              this.onError(XMLParserErrorCode.UnterminatedComment);
                              return;
                            }
                            this.onComment(s.substring(j + 3, q));
                            j = q + 3;
                          } else if (s.substring(j + 1, j + 8) === "[CDATA[") {
                            q = s.indexOf("]]>", j + 8);
                            if (q < 0) {
                              this.onError(XMLParserErrorCode.UnterminatedCdat);
                              return;
                            }
                            this.onCdata(s.substring(j + 8, q));
                            j = q + 3;
                          } else if (s.substring(j + 1, j + 8) === "DOCTYPE") {
                            var q2 = s.indexOf("[", j + 8);
                            var complexDoctype = false;
                            q = s.indexOf(">", j + 8);
                            if (q < 0) {
                              this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                              return;
                            }
                            if (q2 > 0 && q > q2) {
                              q = s.indexOf("]>", j + 8);
                              if (q < 0) {
                                this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                                return;
                              }
                              complexDoctype = true;
                            }
                            var doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));
                            this.onDoctype(doctypeContent);
                            j = q + (complexDoctype ? 2 : 1);
                          } else {
                            this.onError(XMLParserErrorCode.MalformedElement);
                            return;
                          }
                          break;
                        default:
                          var content = this._parseContent(s, j);
                          if (content === null) {
                            this.onError(XMLParserErrorCode.MalformedElement);
                            return;
                          }
                          var isClosed = false;
                          if (s.substring(j + content.parsed, j + content.parsed + 2) === "/>") {
                            isClosed = true;
                          } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== ">") {
                            this.onError(XMLParserErrorCode.UnterminatedElement);
                            return;
                          }
                          this.onBeginElement(content.name, content.attributes, isClosed);
                          j += content.parsed + (isClosed ? 2 : 1);
                          break;
                      }
                    } else {
                      while (j < s.length && s[j] !== "<") {
                        j++;
                      }
                      var text = s.substring(i, j);
                      this.onText(this._resolveEntities(text));
                    }
                    i = j;
                  }
                }
              }, {
                key: "onResolveEntity",
                value: function onResolveEntity(name) {
                  return "&" + name + ";";
                }
              }, {
                key: "onPi",
                value: function onPi(name, value) {
                }
              }, {
                key: "onComment",
                value: function onComment(text) {
                }
              }, {
                key: "onCdata",
                value: function onCdata(text) {
                }
              }, {
                key: "onDoctype",
                value: function onDoctype(doctypeContent) {
                }
              }, {
                key: "onText",
                value: function onText(text) {
                }
              }, {
                key: "onBeginElement",
                value: function onBeginElement(name, attributes, isEmpty) {
                }
              }, {
                key: "onEndElement",
                value: function onEndElement(name) {
                }
              }, {
                key: "onError",
                value: function onError(code) {
                }
              }]);
              return XMLParserBase2;
            }();
            var SimpleDOMNode = function() {
              function SimpleDOMNode2(nodeName, nodeValue) {
                _classCallCheck(this, SimpleDOMNode2);
                this.nodeName = nodeName;
                this.nodeValue = nodeValue;
                Object.defineProperty(this, "parentNode", {
                  value: null,
                  writable: true
                });
              }
              _createClass(SimpleDOMNode2, [{
                key: "hasChildNodes",
                value: function hasChildNodes() {
                  return this.childNodes && this.childNodes.length > 0;
                }
              }, {
                key: "firstChild",
                get: function get() {
                  return this.childNodes[0];
                }
              }, {
                key: "nextSibling",
                get: function get() {
                  var index = this.parentNode.childNodes.indexOf(this);
                  return this.parentNode.childNodes[index + 1];
                }
              }, {
                key: "textContent",
                get: function get() {
                  if (!this.childNodes) {
                    return this.nodeValue || "";
                  }
                  return this.childNodes.map(function(child) {
                    return child.textContent;
                  }).join("");
                }
              }]);
              return SimpleDOMNode2;
            }();
            var SimpleXMLParser = function(_XMLParserBase) {
              _inherits(SimpleXMLParser2, _XMLParserBase);
              function SimpleXMLParser2() {
                _classCallCheck(this, SimpleXMLParser2);
                var _this = _possibleConstructorReturn(this, (SimpleXMLParser2.__proto__ || Object.getPrototypeOf(SimpleXMLParser2)).call(this));
                _this._currentFragment = null;
                _this._stack = null;
                _this._errorCode = XMLParserErrorCode.NoError;
                return _this;
              }
              _createClass(SimpleXMLParser2, [{
                key: "parseFromString",
                value: function parseFromString(data) {
                  this._currentFragment = [];
                  this._stack = [];
                  this._errorCode = XMLParserErrorCode.NoError;
                  this.parseXml(data);
                  if (this._errorCode !== XMLParserErrorCode.NoError) {
                    return void 0;
                  }
                  var _currentFragment = _slicedToArray(this._currentFragment, 1), documentElement = _currentFragment[0];
                  return { documentElement };
                }
              }, {
                key: "onResolveEntity",
                value: function onResolveEntity(name) {
                  switch (name) {
                    case "apos":
                      return "'";
                  }
                  return _get(SimpleXMLParser2.prototype.__proto__ || Object.getPrototypeOf(SimpleXMLParser2.prototype), "onResolveEntity", this).call(this, name);
                }
              }, {
                key: "onText",
                value: function onText(text) {
                  if (isWhitespaceString(text)) {
                    return;
                  }
                  var node = new SimpleDOMNode("#text", text);
                  this._currentFragment.push(node);
                }
              }, {
                key: "onCdata",
                value: function onCdata(text) {
                  var node = new SimpleDOMNode("#text", text);
                  this._currentFragment.push(node);
                }
              }, {
                key: "onBeginElement",
                value: function onBeginElement(name, attributes, isEmpty) {
                  var node = new SimpleDOMNode(name);
                  node.childNodes = [];
                  this._currentFragment.push(node);
                  if (isEmpty) {
                    return;
                  }
                  this._stack.push(this._currentFragment);
                  this._currentFragment = node.childNodes;
                }
              }, {
                key: "onEndElement",
                value: function onEndElement(name) {
                  this._currentFragment = this._stack.pop();
                  var lastElement = this._currentFragment[this._currentFragment.length - 1];
                  for (var i = 0, ii = lastElement.childNodes.length; i < ii; i++) {
                    lastElement.childNodes[i].parentNode = lastElement;
                  }
                }
              }, {
                key: "onError",
                value: function onError(code) {
                  this._errorCode = code;
                }
              }]);
              return SimpleXMLParser2;
            }(XMLParserBase);
            exports3.SimpleXMLParser = SimpleXMLParser;
          },
          /* 124 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.PDFDataTransportStream = void 0;
            var _util = __w_pdfjs_require__(1);
            var PDFDataTransportStream = function PDFDataTransportStreamClosure() {
              function PDFDataTransportStream2(params, pdfDataRangeTransport) {
                var _this = this;
                (0, _util.assert)(pdfDataRangeTransport);
                this._queuedChunks = [];
                var initialData = params.initialData;
                if (initialData && initialData.length > 0) {
                  var buffer = new Uint8Array(initialData).buffer;
                  this._queuedChunks.push(buffer);
                }
                this._pdfDataRangeTransport = pdfDataRangeTransport;
                this._isStreamingSupported = !params.disableStream;
                this._isRangeSupported = !params.disableRange;
                this._contentLength = params.length;
                this._fullRequestReader = null;
                this._rangeReaders = [];
                this._pdfDataRangeTransport.addRangeListener(function(begin, chunk) {
                  _this._onReceiveData({
                    begin,
                    chunk
                  });
                });
                this._pdfDataRangeTransport.addProgressListener(function(loaded) {
                  _this._onProgress({ loaded });
                });
                this._pdfDataRangeTransport.addProgressiveReadListener(function(chunk) {
                  _this._onReceiveData({ chunk });
                });
                this._pdfDataRangeTransport.transportReady();
              }
              PDFDataTransportStream2.prototype = {
                _onReceiveData: function PDFDataTransportStream_onReceiveData(args) {
                  var buffer = new Uint8Array(args.chunk).buffer;
                  if (args.begin === void 0) {
                    if (this._fullRequestReader) {
                      this._fullRequestReader._enqueue(buffer);
                    } else {
                      this._queuedChunks.push(buffer);
                    }
                  } else {
                    var found = this._rangeReaders.some(function(rangeReader) {
                      if (rangeReader._begin !== args.begin) {
                        return false;
                      }
                      rangeReader._enqueue(buffer);
                      return true;
                    });
                    (0, _util.assert)(found);
                  }
                },
                _onProgress: function PDFDataTransportStream_onDataProgress(evt) {
                  if (this._rangeReaders.length > 0) {
                    var firstReader = this._rangeReaders[0];
                    if (firstReader.onProgress) {
                      firstReader.onProgress({ loaded: evt.loaded });
                    }
                  }
                },
                _removeRangeReader: function PDFDataTransportStream_removeRangeReader(reader) {
                  var i = this._rangeReaders.indexOf(reader);
                  if (i >= 0) {
                    this._rangeReaders.splice(i, 1);
                  }
                },
                getFullReader: function PDFDataTransportStream_getFullReader() {
                  (0, _util.assert)(!this._fullRequestReader);
                  var queuedChunks = this._queuedChunks;
                  this._queuedChunks = null;
                  return new PDFDataTransportStreamReader(this, queuedChunks);
                },
                getRangeReader: function PDFDataTransportStream_getRangeReader(begin, end) {
                  var reader = new PDFDataTransportStreamRangeReader(this, begin, end);
                  this._pdfDataRangeTransport.requestDataRange(begin, end);
                  this._rangeReaders.push(reader);
                  return reader;
                },
                cancelAllRequests: function PDFDataTransportStream_cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  var readers = this._rangeReaders.slice(0);
                  readers.forEach(function(rangeReader) {
                    rangeReader.cancel(reason);
                  });
                  this._pdfDataRangeTransport.abort();
                }
              };
              function PDFDataTransportStreamReader(stream2, queuedChunks) {
                this._stream = stream2;
                this._done = false;
                this._filename = null;
                this._queuedChunks = queuedChunks || [];
                this._requests = [];
                this._headersReady = Promise.resolve();
                stream2._fullRequestReader = this;
                this.onProgress = null;
              }
              PDFDataTransportStreamReader.prototype = {
                _enqueue: function PDFDataTransportStreamReader_enqueue(chunk) {
                  if (this._done) {
                    return;
                  }
                  if (this._requests.length > 0) {
                    var requestCapability = this._requests.shift();
                    requestCapability.resolve({
                      value: chunk,
                      done: false
                    });
                    return;
                  }
                  this._queuedChunks.push(chunk);
                },
                get headersReady() {
                  return this._headersReady;
                },
                get filename() {
                  return this._filename;
                },
                get isRangeSupported() {
                  return this._stream._isRangeSupported;
                },
                get isStreamingSupported() {
                  return this._stream._isStreamingSupported;
                },
                get contentLength() {
                  return this._stream._contentLength;
                },
                read: function PDFDataTransportStreamReader_read() {
                  if (this._queuedChunks.length > 0) {
                    var chunk = this._queuedChunks.shift();
                    return Promise.resolve({
                      value: chunk,
                      done: false
                    });
                  }
                  if (this._done) {
                    return Promise.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  var requestCapability = (0, _util.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                },
                cancel: function PDFDataTransportStreamReader_cancel(reason) {
                  this._done = true;
                  this._requests.forEach(function(requestCapability) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  });
                  this._requests = [];
                }
              };
              function PDFDataTransportStreamRangeReader(stream2, begin, end) {
                this._stream = stream2;
                this._begin = begin;
                this._end = end;
                this._queuedChunk = null;
                this._requests = [];
                this._done = false;
                this.onProgress = null;
              }
              PDFDataTransportStreamRangeReader.prototype = {
                _enqueue: function PDFDataTransportStreamRangeReader_enqueue(chunk) {
                  if (this._done) {
                    return;
                  }
                  if (this._requests.length === 0) {
                    this._queuedChunk = chunk;
                  } else {
                    var requestsCapability = this._requests.shift();
                    requestsCapability.resolve({
                      value: chunk,
                      done: false
                    });
                    this._requests.forEach(function(requestCapability) {
                      requestCapability.resolve({
                        value: void 0,
                        done: true
                      });
                    });
                    this._requests = [];
                  }
                  this._done = true;
                  this._stream._removeRangeReader(this);
                },
                get isStreamingSupported() {
                  return false;
                },
                read: function PDFDataTransportStreamRangeReader_read() {
                  if (this._queuedChunk) {
                    var chunk = this._queuedChunk;
                    this._queuedChunk = null;
                    return Promise.resolve({
                      value: chunk,
                      done: false
                    });
                  }
                  if (this._done) {
                    return Promise.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  var requestCapability = (0, _util.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                },
                cancel: function PDFDataTransportStreamRangeReader_cancel(reason) {
                  this._done = true;
                  this._requests.forEach(function(requestCapability) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  });
                  this._requests = [];
                  this._stream._removeRangeReader(this);
                }
              };
              return PDFDataTransportStream2;
            }();
            exports3.PDFDataTransportStream = PDFDataTransportStream;
          },
          /* 125 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.WebGLContext = void 0;
            var _createClass = /* @__PURE__ */ function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _util = __w_pdfjs_require__(1);
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var WebGLContext = function() {
              function WebGLContext2(_ref) {
                var _ref$enable = _ref.enable, enable = _ref$enable === void 0 ? false : _ref$enable;
                _classCallCheck(this, WebGLContext2);
                this._enabled = enable === true;
              }
              _createClass(WebGLContext2, [{
                key: "composeSMask",
                value: function composeSMask(_ref2) {
                  var layer = _ref2.layer, mask = _ref2.mask, properties = _ref2.properties;
                  return WebGLUtils.composeSMask(layer, mask, properties);
                }
              }, {
                key: "drawFigures",
                value: function drawFigures(_ref3) {
                  var width = _ref3.width, height = _ref3.height, backgroundColor = _ref3.backgroundColor, figures = _ref3.figures, context = _ref3.context;
                  return WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);
                }
              }, {
                key: "clear",
                value: function clear() {
                  WebGLUtils.cleanup();
                }
              }, {
                key: "isEnabled",
                get: function get() {
                  var enabled = this._enabled;
                  if (enabled) {
                    enabled = WebGLUtils.tryInitGL();
                  }
                  return (0, _util.shadow)(this, "isEnabled", enabled);
                }
              }]);
              return WebGLContext2;
            }();
            var WebGLUtils = /* @__PURE__ */ function WebGLUtilsClosure() {
              function loadShader(gl, code, shaderType) {
                var shader = gl.createShader(shaderType);
                gl.shaderSource(shader, code);
                gl.compileShader(shader);
                var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
                if (!compiled) {
                  var errorMsg = gl.getShaderInfoLog(shader);
                  throw new Error("Error during shader compilation: " + errorMsg);
                }
                return shader;
              }
              function createVertexShader(gl, code) {
                return loadShader(gl, code, gl.VERTEX_SHADER);
              }
              function createFragmentShader(gl, code) {
                return loadShader(gl, code, gl.FRAGMENT_SHADER);
              }
              function createProgram(gl, shaders) {
                var program = gl.createProgram();
                for (var i = 0, ii = shaders.length; i < ii; ++i) {
                  gl.attachShader(program, shaders[i]);
                }
                gl.linkProgram(program);
                var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
                if (!linked) {
                  var errorMsg = gl.getProgramInfoLog(program);
                  throw new Error("Error during program linking: " + errorMsg);
                }
                return program;
              }
              function createTexture(gl, image, textureId) {
                gl.activeTexture(textureId);
                var texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                return texture;
              }
              var currentGL, currentCanvas;
              function generateGL() {
                if (currentGL) {
                  return;
                }
                currentCanvas = document.createElement("canvas");
                currentGL = currentCanvas.getContext("webgl", { premultipliedalpha: false });
              }
              var smaskVertexShaderCode = "  attribute vec2 a_position;                                      attribute vec2 a_texCoord;                                                                                                      uniform vec2 u_resolution;                                                                                                      varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;       gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_texCoord = a_texCoord;                                      }                                                             ";
              var smaskFragmentShaderCode = "  precision mediump float;                                                                                                        uniform vec4 u_backdrop;                                        uniform int u_subtype;                                          uniform sampler2D u_image;                                      uniform sampler2D u_mask;                                                                                                       varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec4 imageColor = texture2D(u_image, v_texCoord);               vec4 maskColor = texture2D(u_mask, v_texCoord);                 if (u_backdrop.a > 0.0) {                                         maskColor.rgb = maskColor.rgb * maskColor.a +                                   u_backdrop.rgb * (1.0 - maskColor.a);         }                                                               float lum;                                                      if (u_subtype == 0) {                                             lum = maskColor.a;                                            } else {                                                          lum = maskColor.r * 0.3 + maskColor.g * 0.59 +                        maskColor.b * 0.11;                                     }                                                               imageColor.a *= lum;                                            imageColor.rgb *= imageColor.a;                                 gl_FragColor = imageColor;                                    }                                                             ";
              var smaskCache = null;
              function initSmaskGL() {
                var canvas, gl;
                generateGL();
                canvas = currentCanvas;
                currentCanvas = null;
                gl = currentGL;
                currentGL = null;
                var vertexShader = createVertexShader(gl, smaskVertexShaderCode);
                var fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);
                var program = createProgram(gl, [vertexShader, fragmentShader]);
                gl.useProgram(program);
                var cache = {};
                cache.gl = gl;
                cache.canvas = canvas;
                cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");
                cache.positionLocation = gl.getAttribLocation(program, "a_position");
                cache.backdropLocation = gl.getUniformLocation(program, "u_backdrop");
                cache.subtypeLocation = gl.getUniformLocation(program, "u_subtype");
                var texCoordLocation = gl.getAttribLocation(program, "a_texCoord");
                var texLayerLocation = gl.getUniformLocation(program, "u_image");
                var texMaskLocation = gl.getUniformLocation(program, "u_mask");
                var texCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(texCoordLocation);
                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
                gl.uniform1i(texLayerLocation, 0);
                gl.uniform1i(texMaskLocation, 1);
                smaskCache = cache;
              }
              function composeSMask(layer, mask, properties) {
                var width = layer.width, height = layer.height;
                if (!smaskCache) {
                  initSmaskGL();
                }
                var cache = smaskCache, canvas = cache.canvas, gl = cache.gl;
                canvas.width = width;
                canvas.height = height;
                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                gl.uniform2f(cache.resolutionLocation, width, height);
                if (properties.backdrop) {
                  gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);
                } else {
                  gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);
                }
                gl.uniform1i(cache.subtypeLocation, properties.subtype === "Luminosity" ? 1 : 0);
                var texture = createTexture(gl, layer, gl.TEXTURE0);
                var maskTexture = createTexture(gl, mask, gl.TEXTURE1);
                var buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(cache.positionLocation);
                gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
                gl.clearColor(0, 0, 0, 0);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.flush();
                gl.deleteTexture(texture);
                gl.deleteTexture(maskTexture);
                gl.deleteBuffer(buffer);
                return canvas;
              }
              var figuresVertexShaderCode = "  attribute vec2 a_position;                                      attribute vec3 a_color;                                                                                                         uniform vec2 u_resolution;                                      uniform vec2 u_scale;                                           uniform vec2 u_offset;                                                                                                          varying vec4 v_color;                                                                                                           void main() {                                                     vec2 position = (a_position + u_offset) * u_scale;              vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;         gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_color = vec4(a_color / 255.0, 1.0);                         }                                                             ";
              var figuresFragmentShaderCode = "  precision mediump float;                                                                                                        varying vec4 v_color;                                                                                                           void main() {                                                     gl_FragColor = v_color;                                       }                                                             ";
              var figuresCache = null;
              function initFiguresGL() {
                var canvas, gl;
                generateGL();
                canvas = currentCanvas;
                currentCanvas = null;
                gl = currentGL;
                currentGL = null;
                var vertexShader = createVertexShader(gl, figuresVertexShaderCode);
                var fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);
                var program = createProgram(gl, [vertexShader, fragmentShader]);
                gl.useProgram(program);
                var cache = {};
                cache.gl = gl;
                cache.canvas = canvas;
                cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");
                cache.scaleLocation = gl.getUniformLocation(program, "u_scale");
                cache.offsetLocation = gl.getUniformLocation(program, "u_offset");
                cache.positionLocation = gl.getAttribLocation(program, "a_position");
                cache.colorLocation = gl.getAttribLocation(program, "a_color");
                figuresCache = cache;
              }
              function drawFigures(width, height, backgroundColor, figures, context) {
                if (!figuresCache) {
                  initFiguresGL();
                }
                var cache = figuresCache, canvas = cache.canvas, gl = cache.gl;
                canvas.width = width;
                canvas.height = height;
                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                gl.uniform2f(cache.resolutionLocation, width, height);
                var count = 0;
                var i, ii, rows;
                for (i = 0, ii = figures.length; i < ii; i++) {
                  switch (figures[i].type) {
                    case "lattice":
                      rows = figures[i].coords.length / figures[i].verticesPerRow | 0;
                      count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;
                      break;
                    case "triangles":
                      count += figures[i].coords.length;
                      break;
                  }
                }
                var coords = new Float32Array(count * 2);
                var colors = new Uint8Array(count * 3);
                var coordsMap = context.coords, colorsMap = context.colors;
                var pIndex = 0, cIndex = 0;
                for (i = 0, ii = figures.length; i < ii; i++) {
                  var figure = figures[i], ps = figure.coords, cs = figure.colors;
                  switch (figure.type) {
                    case "lattice":
                      var cols = figure.verticesPerRow;
                      rows = ps.length / cols | 0;
                      for (var row = 1; row < rows; row++) {
                        var offset = row * cols + 1;
                        for (var col = 1; col < cols; col++, offset++) {
                          coords[pIndex] = coordsMap[ps[offset - cols - 1]];
                          coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];
                          coords[pIndex + 2] = coordsMap[ps[offset - cols]];
                          coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];
                          coords[pIndex + 4] = coordsMap[ps[offset - 1]];
                          coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];
                          colors[cIndex] = colorsMap[cs[offset - cols - 1]];
                          colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];
                          colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];
                          colors[cIndex + 3] = colorsMap[cs[offset - cols]];
                          colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];
                          colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];
                          colors[cIndex + 6] = colorsMap[cs[offset - 1]];
                          colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];
                          colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];
                          coords[pIndex + 6] = coords[pIndex + 2];
                          coords[pIndex + 7] = coords[pIndex + 3];
                          coords[pIndex + 8] = coords[pIndex + 4];
                          coords[pIndex + 9] = coords[pIndex + 5];
                          coords[pIndex + 10] = coordsMap[ps[offset]];
                          coords[pIndex + 11] = coordsMap[ps[offset] + 1];
                          colors[cIndex + 9] = colors[cIndex + 3];
                          colors[cIndex + 10] = colors[cIndex + 4];
                          colors[cIndex + 11] = colors[cIndex + 5];
                          colors[cIndex + 12] = colors[cIndex + 6];
                          colors[cIndex + 13] = colors[cIndex + 7];
                          colors[cIndex + 14] = colors[cIndex + 8];
                          colors[cIndex + 15] = colorsMap[cs[offset]];
                          colors[cIndex + 16] = colorsMap[cs[offset] + 1];
                          colors[cIndex + 17] = colorsMap[cs[offset] + 2];
                          pIndex += 12;
                          cIndex += 18;
                        }
                      }
                      break;
                    case "triangles":
                      for (var j = 0, jj = ps.length; j < jj; j++) {
                        coords[pIndex] = coordsMap[ps[j]];
                        coords[pIndex + 1] = coordsMap[ps[j] + 1];
                        colors[cIndex] = colorsMap[cs[j]];
                        colors[cIndex + 1] = colorsMap[cs[j] + 1];
                        colors[cIndex + 2] = colorsMap[cs[j] + 2];
                        pIndex += 2;
                        cIndex += 3;
                      }
                      break;
                  }
                }
                if (backgroundColor) {
                  gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1);
                } else {
                  gl.clearColor(0, 0, 0, 0);
                }
                gl.clear(gl.COLOR_BUFFER_BIT);
                var coordsBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(cache.positionLocation);
                gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
                var colorsBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(cache.colorLocation);
                gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);
                gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);
                gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);
                gl.drawArrays(gl.TRIANGLES, 0, count);
                gl.flush();
                gl.deleteBuffer(coordsBuffer);
                gl.deleteBuffer(colorsBuffer);
                return canvas;
              }
              return {
                tryInitGL: function tryInitGL() {
                  try {
                    generateGL();
                    return !!currentGL;
                  } catch (ex) {
                  }
                  return false;
                },
                composeSMask,
                drawFigures,
                cleanup: function cleanup() {
                  if (smaskCache && smaskCache.canvas) {
                    smaskCache.canvas.width = 0;
                    smaskCache.canvas.height = 0;
                  }
                  if (figuresCache && figuresCache.canvas) {
                    figuresCache.canvas.width = 0;
                    figuresCache.canvas.height = 0;
                  }
                  smaskCache = null;
                  figuresCache = null;
                }
              };
            }();
            exports3.WebGLContext = WebGLContext;
          },
          /* 126 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.renderTextLayer = void 0;
            var _util = __w_pdfjs_require__(1);
            var _global_scope = __w_pdfjs_require__(3);
            var _global_scope2 = _interopRequireDefault(_global_scope);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            var renderTextLayer = function renderTextLayerClosure() {
              var MAX_TEXT_DIVS_TO_RENDER = 1e5;
              var NonWhitespaceRegexp = /\S/;
              function isAllWhitespace(str) {
                return !NonWhitespaceRegexp.test(str);
              }
              var styleBuf = ["left: ", 0, "px; top: ", 0, "px; font-size: ", 0, "px; font-family: ", "", ";"];
              function appendText(task, geom, styles) {
                var textDiv = document.createElement("div");
                var textDivProperties = {
                  style: null,
                  angle: 0,
                  canvasWidth: 0,
                  isWhitespace: false,
                  originalTransform: null,
                  paddingBottom: 0,
                  paddingLeft: 0,
                  paddingRight: 0,
                  paddingTop: 0,
                  scale: 1
                };
                task._textDivs.push(textDiv);
                if (isAllWhitespace(geom.str)) {
                  textDivProperties.isWhitespace = true;
                  task._textDivProperties.set(textDiv, textDivProperties);
                  return;
                }
                var tx = _util.Util.transform(task._viewport.transform, geom.transform);
                var angle = Math.atan2(tx[1], tx[0]);
                var style = styles[geom.fontName];
                if (style.vertical) {
                  angle += Math.PI / 2;
                }
                var fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]);
                var fontAscent = fontHeight;
                if (style.ascent) {
                  fontAscent = style.ascent * fontAscent;
                } else if (style.descent) {
                  fontAscent = (1 + style.descent) * fontAscent;
                }
                var left;
                var top;
                if (angle === 0) {
                  left = tx[4];
                  top = tx[5] - fontAscent;
                } else {
                  left = tx[4] + fontAscent * Math.sin(angle);
                  top = tx[5] - fontAscent * Math.cos(angle);
                }
                styleBuf[1] = left;
                styleBuf[3] = top;
                styleBuf[5] = fontHeight;
                styleBuf[7] = style.fontFamily;
                textDivProperties.style = styleBuf.join("");
                textDiv.setAttribute("style", textDivProperties.style);
                textDiv.textContent = geom.str;
                if (task._fontInspectorEnabled) {
                  textDiv.dataset.fontName = geom.fontName;
                }
                if (angle !== 0) {
                  textDivProperties.angle = angle * (180 / Math.PI);
                }
                if (geom.str.length > 1) {
                  if (style.vertical) {
                    textDivProperties.canvasWidth = geom.height * task._viewport.scale;
                  } else {
                    textDivProperties.canvasWidth = geom.width * task._viewport.scale;
                  }
                }
                task._textDivProperties.set(textDiv, textDivProperties);
                if (task._textContentStream) {
                  task._layoutText(textDiv);
                }
                if (task._enhanceTextSelection) {
                  var angleCos = 1, angleSin = 0;
                  if (angle !== 0) {
                    angleCos = Math.cos(angle);
                    angleSin = Math.sin(angle);
                  }
                  var divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
                  var divHeight = fontHeight;
                  var m, b;
                  if (angle !== 0) {
                    m = [angleCos, angleSin, -angleSin, angleCos, left, top];
                    b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
                  } else {
                    b = [left, top, left + divWidth, top + divHeight];
                  }
                  task._bounds.push({
                    left: b[0],
                    top: b[1],
                    right: b[2],
                    bottom: b[3],
                    div: textDiv,
                    size: [divWidth, divHeight],
                    m
                  });
                }
              }
              function render(task) {
                if (task._canceled) {
                  return;
                }
                var textDivs = task._textDivs;
                var capability = task._capability;
                var textDivsLength = textDivs.length;
                if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
                  task._renderingDone = true;
                  capability.resolve();
                  return;
                }
                if (!task._textContentStream) {
                  for (var i = 0; i < textDivsLength; i++) {
                    task._layoutText(textDivs[i]);
                  }
                }
                task._renderingDone = true;
                capability.resolve();
              }
              function expand(task) {
                var bounds = task._bounds;
                var viewport = task._viewport;
                var expanded = expandBounds(viewport.width, viewport.height, bounds);
                for (var i = 0; i < expanded.length; i++) {
                  var div = bounds[i].div;
                  var divProperties = task._textDivProperties.get(div);
                  if (divProperties.angle === 0) {
                    divProperties.paddingLeft = bounds[i].left - expanded[i].left;
                    divProperties.paddingTop = bounds[i].top - expanded[i].top;
                    divProperties.paddingRight = expanded[i].right - bounds[i].right;
                    divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;
                    task._textDivProperties.set(div, divProperties);
                    continue;
                  }
                  var e = expanded[i], b = bounds[i];
                  var m = b.m, c = m[0], s = m[1];
                  var points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
                  var ts = new Float64Array(64);
                  points.forEach(function(p, i2) {
                    var t = _util.Util.applyTransform(p, m);
                    ts[i2 + 0] = c && (e.left - t[0]) / c;
                    ts[i2 + 4] = s && (e.top - t[1]) / s;
                    ts[i2 + 8] = c && (e.right - t[0]) / c;
                    ts[i2 + 12] = s && (e.bottom - t[1]) / s;
                    ts[i2 + 16] = s && (e.left - t[0]) / -s;
                    ts[i2 + 20] = c && (e.top - t[1]) / c;
                    ts[i2 + 24] = s && (e.right - t[0]) / -s;
                    ts[i2 + 28] = c && (e.bottom - t[1]) / c;
                    ts[i2 + 32] = c && (e.left - t[0]) / -c;
                    ts[i2 + 36] = s && (e.top - t[1]) / -s;
                    ts[i2 + 40] = c && (e.right - t[0]) / -c;
                    ts[i2 + 44] = s && (e.bottom - t[1]) / -s;
                    ts[i2 + 48] = s && (e.left - t[0]) / s;
                    ts[i2 + 52] = c && (e.top - t[1]) / -c;
                    ts[i2 + 56] = s && (e.right - t[0]) / s;
                    ts[i2 + 60] = c && (e.bottom - t[1]) / -c;
                  });
                  var findPositiveMin = function findPositiveMin2(ts2, offset, count) {
                    var result = 0;
                    for (var i2 = 0; i2 < count; i2++) {
                      var t = ts2[offset++];
                      if (t > 0) {
                        result = result ? Math.min(t, result) : t;
                      }
                    }
                    return result;
                  };
                  var boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
                  divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
                  divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
                  divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
                  divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;
                  task._textDivProperties.set(div, divProperties);
                }
              }
              function expandBounds(width, height, boxes) {
                var bounds = boxes.map(function(box, i) {
                  return {
                    x1: box.left,
                    y1: box.top,
                    x2: box.right,
                    y2: box.bottom,
                    index: i,
                    x1New: void 0,
                    x2New: void 0
                  };
                });
                expandBoundsLTR(width, bounds);
                var expanded = new Array(boxes.length);
                bounds.forEach(function(b) {
                  var i = b.index;
                  expanded[i] = {
                    left: b.x1New,
                    top: 0,
                    right: b.x2New,
                    bottom: 0
                  };
                });
                boxes.map(function(box, i) {
                  var e = expanded[i], b = bounds[i];
                  b.x1 = box.top;
                  b.y1 = width - e.right;
                  b.x2 = box.bottom;
                  b.y2 = width - e.left;
                  b.index = i;
                  b.x1New = void 0;
                  b.x2New = void 0;
                });
                expandBoundsLTR(height, bounds);
                bounds.forEach(function(b) {
                  var i = b.index;
                  expanded[i].top = b.x1New;
                  expanded[i].bottom = b.x2New;
                });
                return expanded;
              }
              function expandBoundsLTR(width, bounds) {
                bounds.sort(function(a, b) {
                  return a.x1 - b.x1 || a.index - b.index;
                });
                var fakeBoundary = {
                  x1: -Infinity,
                  y1: -Infinity,
                  x2: 0,
                  y2: Infinity,
                  index: -1,
                  x1New: 0,
                  x2New: 0
                };
                var horizon = [{
                  start: -Infinity,
                  end: Infinity,
                  boundary: fakeBoundary
                }];
                bounds.forEach(function(boundary) {
                  var i = 0;
                  while (i < horizon.length && horizon[i].end <= boundary.y1) {
                    i++;
                  }
                  var j = horizon.length - 1;
                  while (j >= 0 && horizon[j].start >= boundary.y2) {
                    j--;
                  }
                  var horizonPart, affectedBoundary;
                  var q, k, maxXNew = -Infinity;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    var xNew;
                    if (affectedBoundary.x2 > boundary.x1) {
                      xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
                    } else if (affectedBoundary.x2New === void 0) {
                      xNew = (affectedBoundary.x2 + boundary.x1) / 2;
                    } else {
                      xNew = affectedBoundary.x2New;
                    }
                    if (xNew > maxXNew) {
                      maxXNew = xNew;
                    }
                  }
                  boundary.x1New = maxXNew;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    if (affectedBoundary.x2New === void 0) {
                      if (affectedBoundary.x2 > boundary.x1) {
                        if (affectedBoundary.index > boundary.index) {
                          affectedBoundary.x2New = affectedBoundary.x2;
                        }
                      } else {
                        affectedBoundary.x2New = maxXNew;
                      }
                    } else if (affectedBoundary.x2New > maxXNew) {
                      affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
                    }
                  }
                  var changedHorizon = [], lastBoundary = null;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    var useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;
                    if (lastBoundary === useBoundary) {
                      changedHorizon[changedHorizon.length - 1].end = horizonPart.end;
                    } else {
                      changedHorizon.push({
                        start: horizonPart.start,
                        end: horizonPart.end,
                        boundary: useBoundary
                      });
                      lastBoundary = useBoundary;
                    }
                  }
                  if (horizon[i].start < boundary.y1) {
                    changedHorizon[0].start = boundary.y1;
                    changedHorizon.unshift({
                      start: horizon[i].start,
                      end: boundary.y1,
                      boundary: horizon[i].boundary
                    });
                  }
                  if (boundary.y2 < horizon[j].end) {
                    changedHorizon[changedHorizon.length - 1].end = boundary.y2;
                    changedHorizon.push({
                      start: boundary.y2,
                      end: horizon[j].end,
                      boundary: horizon[j].boundary
                    });
                  }
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    if (affectedBoundary.x2New !== void 0) {
                      continue;
                    }
                    var used = false;
                    for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
                      used = horizon[k].boundary === affectedBoundary;
                    }
                    for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
                      used = horizon[k].boundary === affectedBoundary;
                    }
                    for (k = 0; !used && k < changedHorizon.length; k++) {
                      used = changedHorizon[k].boundary === affectedBoundary;
                    }
                    if (!used) {
                      affectedBoundary.x2New = maxXNew;
                    }
                  }
                  Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));
                });
                horizon.forEach(function(horizonPart) {
                  var affectedBoundary = horizonPart.boundary;
                  if (affectedBoundary.x2New === void 0) {
                    affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
                  }
                });
              }
              function TextLayerRenderTask(_ref) {
                var textContent = _ref.textContent, textContentStream = _ref.textContentStream, container = _ref.container, viewport = _ref.viewport, textDivs = _ref.textDivs, textContentItemsStr = _ref.textContentItemsStr, enhanceTextSelection = _ref.enhanceTextSelection;
                this._textContent = textContent;
                this._textContentStream = textContentStream;
                this._container = container;
                this._viewport = viewport;
                this._textDivs = textDivs || [];
                this._textContentItemsStr = textContentItemsStr || [];
                this._enhanceTextSelection = !!enhanceTextSelection;
                this._fontInspectorEnabled = !!(_global_scope2.default.FontInspector && _global_scope2.default.FontInspector.enabled);
                this._reader = null;
                this._layoutTextLastFontSize = null;
                this._layoutTextLastFontFamily = null;
                this._layoutTextCtx = null;
                this._textDivProperties = /* @__PURE__ */ new WeakMap();
                this._renderingDone = false;
                this._canceled = false;
                this._capability = (0, _util.createPromiseCapability)();
                this._renderTimer = null;
                this._bounds = [];
              }
              TextLayerRenderTask.prototype = {
                get promise() {
                  return this._capability.promise;
                },
                cancel: function TextLayer_cancel() {
                  if (this._reader) {
                    this._reader.cancel(new _util.AbortException("text layer task cancelled"));
                    this._reader = null;
                  }
                  this._canceled = true;
                  if (this._renderTimer !== null) {
                    clearTimeout(this._renderTimer);
                    this._renderTimer = null;
                  }
                  this._capability.reject("canceled");
                },
                _processItems: function _processItems(items, styleCache) {
                  for (var i = 0, len = items.length; i < len; i++) {
                    this._textContentItemsStr.push(items[i].str);
                    appendText(this, items[i], styleCache);
                  }
                },
                _layoutText: function _layoutText(textDiv) {
                  var textLayerFrag = this._container;
                  var textDivProperties = this._textDivProperties.get(textDiv);
                  if (textDivProperties.isWhitespace) {
                    return;
                  }
                  var fontSize = textDiv.style.fontSize;
                  var fontFamily = textDiv.style.fontFamily;
                  if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
                    this._layoutTextCtx.font = fontSize + " " + fontFamily;
                    this._lastFontSize = fontSize;
                    this._lastFontFamily = fontFamily;
                  }
                  var width = this._layoutTextCtx.measureText(textDiv.textContent).width;
                  var transform = "";
                  if (textDivProperties.canvasWidth !== 0 && width > 0) {
                    textDivProperties.scale = textDivProperties.canvasWidth / width;
                    transform = "scaleX(" + textDivProperties.scale + ")";
                  }
                  if (textDivProperties.angle !== 0) {
                    transform = "rotate(" + textDivProperties.angle + "deg) " + transform;
                  }
                  if (transform !== "") {
                    textDivProperties.originalTransform = transform;
                    textDiv.style.transform = transform;
                  }
                  this._textDivProperties.set(textDiv, textDivProperties);
                  textLayerFrag.appendChild(textDiv);
                },
                _render: function TextLayer_render(timeout) {
                  var _this = this;
                  var capability = (0, _util.createPromiseCapability)();
                  var styleCache = /* @__PURE__ */ Object.create(null);
                  var canvas = document.createElement("canvas");
                  canvas.mozOpaque = true;
                  this._layoutTextCtx = canvas.getContext("2d", { alpha: false });
                  if (this._textContent) {
                    var textItems = this._textContent.items;
                    var textStyles = this._textContent.styles;
                    this._processItems(textItems, textStyles);
                    capability.resolve();
                  } else if (this._textContentStream) {
                    var pump = function pump2() {
                      _this._reader.read().then(function(_ref2) {
                        var value = _ref2.value, done = _ref2.done;
                        if (done) {
                          capability.resolve();
                          return;
                        }
                        _util.Util.extendObj(styleCache, value.styles);
                        _this._processItems(value.items, styleCache);
                        pump2();
                      }, capability.reject);
                    };
                    this._reader = this._textContentStream.getReader();
                    pump();
                  } else {
                    throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
                  }
                  capability.promise.then(function() {
                    styleCache = null;
                    if (!timeout) {
                      render(_this);
                    } else {
                      _this._renderTimer = setTimeout(function() {
                        render(_this);
                        _this._renderTimer = null;
                      }, timeout);
                    }
                  }, this._capability.reject);
                },
                expandTextDivs: function TextLayer_expandTextDivs(expandDivs) {
                  if (!this._enhanceTextSelection || !this._renderingDone) {
                    return;
                  }
                  if (this._bounds !== null) {
                    expand(this);
                    this._bounds = null;
                  }
                  for (var i = 0, ii = this._textDivs.length; i < ii; i++) {
                    var div = this._textDivs[i];
                    var divProperties = this._textDivProperties.get(div);
                    if (divProperties.isWhitespace) {
                      continue;
                    }
                    if (expandDivs) {
                      var transform = "", padding = "";
                      if (divProperties.scale !== 1) {
                        transform = "scaleX(" + divProperties.scale + ")";
                      }
                      if (divProperties.angle !== 0) {
                        transform = "rotate(" + divProperties.angle + "deg) " + transform;
                      }
                      if (divProperties.paddingLeft !== 0) {
                        padding += " padding-left: " + divProperties.paddingLeft / divProperties.scale + "px;";
                        transform += " translateX(" + -divProperties.paddingLeft / divProperties.scale + "px)";
                      }
                      if (divProperties.paddingTop !== 0) {
                        padding += " padding-top: " + divProperties.paddingTop + "px;";
                        transform += " translateY(" + -divProperties.paddingTop + "px)";
                      }
                      if (divProperties.paddingRight !== 0) {
                        padding += " padding-right: " + divProperties.paddingRight / divProperties.scale + "px;";
                      }
                      if (divProperties.paddingBottom !== 0) {
                        padding += " padding-bottom: " + divProperties.paddingBottom + "px;";
                      }
                      if (padding !== "") {
                        div.setAttribute("style", divProperties.style + padding);
                      }
                      if (transform !== "") {
                        div.style.transform = transform;
                      }
                    } else {
                      div.style.padding = 0;
                      div.style.transform = divProperties.originalTransform || "";
                    }
                  }
                }
              };
              function renderTextLayer2(renderParameters) {
                var task = new TextLayerRenderTask({
                  textContent: renderParameters.textContent,
                  textContentStream: renderParameters.textContentStream,
                  container: renderParameters.container,
                  viewport: renderParameters.viewport,
                  textDivs: renderParameters.textDivs,
                  textContentItemsStr: renderParameters.textContentItemsStr,
                  enhanceTextSelection: renderParameters.enhanceTextSelection
                });
                task._render(renderParameters.timeout);
                return task;
              }
              return renderTextLayer2;
            }();
            exports3.renderTextLayer = renderTextLayer;
          },
          /* 127 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.AnnotationLayer = void 0;
            var _get = function get(object, property, receiver) {
              if (object === null) object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _createClass = /* @__PURE__ */ function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _dom_utils = __w_pdfjs_require__(115);
            var _util = __w_pdfjs_require__(1);
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var AnnotationElementFactory = function() {
              function AnnotationElementFactory2() {
                _classCallCheck(this, AnnotationElementFactory2);
              }
              _createClass(AnnotationElementFactory2, null, [{
                key: "create",
                value: function create(parameters) {
                  var subtype = parameters.data.annotationType;
                  switch (subtype) {
                    case _util.AnnotationType.LINK:
                      return new LinkAnnotationElement(parameters);
                    case _util.AnnotationType.TEXT:
                      return new TextAnnotationElement(parameters);
                    case _util.AnnotationType.WIDGET:
                      var fieldType = parameters.data.fieldType;
                      switch (fieldType) {
                        case "Tx":
                          return new TextWidgetAnnotationElement(parameters);
                        case "Btn":
                          if (parameters.data.radioButton) {
                            return new RadioButtonWidgetAnnotationElement(parameters);
                          } else if (parameters.data.checkBox) {
                            return new CheckboxWidgetAnnotationElement(parameters);
                          }
                          return new PushButtonWidgetAnnotationElement(parameters);
                        case "Ch":
                          return new ChoiceWidgetAnnotationElement(parameters);
                      }
                      return new WidgetAnnotationElement(parameters);
                    case _util.AnnotationType.POPUP:
                      return new PopupAnnotationElement(parameters);
                    case _util.AnnotationType.LINE:
                      return new LineAnnotationElement(parameters);
                    case _util.AnnotationType.SQUARE:
                      return new SquareAnnotationElement(parameters);
                    case _util.AnnotationType.CIRCLE:
                      return new CircleAnnotationElement(parameters);
                    case _util.AnnotationType.POLYLINE:
                      return new PolylineAnnotationElement(parameters);
                    case _util.AnnotationType.POLYGON:
                      return new PolygonAnnotationElement(parameters);
                    case _util.AnnotationType.HIGHLIGHT:
                      return new HighlightAnnotationElement(parameters);
                    case _util.AnnotationType.UNDERLINE:
                      return new UnderlineAnnotationElement(parameters);
                    case _util.AnnotationType.SQUIGGLY:
                      return new SquigglyAnnotationElement(parameters);
                    case _util.AnnotationType.STRIKEOUT:
                      return new StrikeOutAnnotationElement(parameters);
                    case _util.AnnotationType.STAMP:
                      return new StampAnnotationElement(parameters);
                    case _util.AnnotationType.FILEATTACHMENT:
                      return new FileAttachmentAnnotationElement(parameters);
                    default:
                      return new AnnotationElement(parameters);
                  }
                }
              }]);
              return AnnotationElementFactory2;
            }();
            var AnnotationElement = function() {
              function AnnotationElement2(parameters) {
                var isRenderable = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                var ignoreBorder = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                _classCallCheck(this, AnnotationElement2);
                this.isRenderable = isRenderable;
                this.data = parameters.data;
                this.layer = parameters.layer;
                this.page = parameters.page;
                this.viewport = parameters.viewport;
                this.linkService = parameters.linkService;
                this.downloadManager = parameters.downloadManager;
                this.imageResourcesPath = parameters.imageResourcesPath;
                this.renderInteractiveForms = parameters.renderInteractiveForms;
                this.svgFactory = parameters.svgFactory;
                if (isRenderable) {
                  this.container = this._createContainer(ignoreBorder);
                }
              }
              _createClass(AnnotationElement2, [{
                key: "_createContainer",
                value: function _createContainer() {
                  var ignoreBorder = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  var data = this.data, page = this.page, viewport = this.viewport;
                  var container = document.createElement("section");
                  var width = data.rect[2] - data.rect[0];
                  var height = data.rect[3] - data.rect[1];
                  container.setAttribute("data-annotation-id", data.id);
                  var rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
                  container.style.transform = "matrix(" + viewport.transform.join(",") + ")";
                  container.style.transformOrigin = -rect[0] + "px " + -rect[1] + "px";
                  if (!ignoreBorder && data.borderStyle.width > 0) {
                    container.style.borderWidth = data.borderStyle.width + "px";
                    if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {
                      width = width - 2 * data.borderStyle.width;
                      height = height - 2 * data.borderStyle.width;
                    }
                    var horizontalRadius = data.borderStyle.horizontalCornerRadius;
                    var verticalRadius = data.borderStyle.verticalCornerRadius;
                    if (horizontalRadius > 0 || verticalRadius > 0) {
                      var radius = horizontalRadius + "px / " + verticalRadius + "px";
                      container.style.borderRadius = radius;
                    }
                    switch (data.borderStyle.style) {
                      case _util.AnnotationBorderStyleType.SOLID:
                        container.style.borderStyle = "solid";
                        break;
                      case _util.AnnotationBorderStyleType.DASHED:
                        container.style.borderStyle = "dashed";
                        break;
                      case _util.AnnotationBorderStyleType.BEVELED:
                        (0, _util.warn)("Unimplemented border style: beveled");
                        break;
                      case _util.AnnotationBorderStyleType.INSET:
                        (0, _util.warn)("Unimplemented border style: inset");
                        break;
                      case _util.AnnotationBorderStyleType.UNDERLINE:
                        container.style.borderBottomStyle = "solid";
                        break;
                      default:
                        break;
                    }
                    if (data.color) {
                      container.style.borderColor = _util.Util.makeCssRgb(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
                    } else {
                      container.style.borderWidth = 0;
                    }
                  }
                  container.style.left = rect[0] + "px";
                  container.style.top = rect[1] + "px";
                  container.style.width = width + "px";
                  container.style.height = height + "px";
                  return container;
                }
              }, {
                key: "_createPopup",
                value: function _createPopup(container, trigger, data) {
                  if (!trigger) {
                    trigger = document.createElement("div");
                    trigger.style.height = container.style.height;
                    trigger.style.width = container.style.width;
                    container.appendChild(trigger);
                  }
                  var popupElement = new PopupElement({
                    container,
                    trigger,
                    color: data.color,
                    title: data.title,
                    contents: data.contents,
                    hideWrapper: true
                  });
                  var popup = popupElement.render();
                  popup.style.left = container.style.width;
                  container.appendChild(popup);
                }
              }, {
                key: "render",
                value: function render() {
                  (0, _util.unreachable)("Abstract method `AnnotationElement.render` called");
                }
              }]);
              return AnnotationElement2;
            }();
            var LinkAnnotationElement = function(_AnnotationElement) {
              _inherits(LinkAnnotationElement2, _AnnotationElement);
              function LinkAnnotationElement2(parameters) {
                _classCallCheck(this, LinkAnnotationElement2);
                var isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action);
                return _possibleConstructorReturn(this, (LinkAnnotationElement2.__proto__ || Object.getPrototypeOf(LinkAnnotationElement2)).call(this, parameters, isRenderable));
              }
              _createClass(LinkAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "linkAnnotation";
                  var data = this.data, linkService = this.linkService;
                  var link = document.createElement("a");
                  (0, _dom_utils.addLinkAttributes)(link, {
                    url: data.url,
                    target: data.newWindow ? _dom_utils.LinkTarget.BLANK : linkService.externalLinkTarget,
                    rel: linkService.externalLinkRel
                  });
                  if (!data.url) {
                    if (data.action) {
                      this._bindNamedAction(link, data.action);
                    } else {
                      this._bindLink(link, data.dest);
                    }
                  }
                  this.container.appendChild(link);
                  return this.container;
                }
              }, {
                key: "_bindLink",
                value: function _bindLink(link, destination) {
                  var _this2 = this;
                  link.href = this.linkService.getDestinationHash(destination);
                  link.onclick = function() {
                    if (destination) {
                      _this2.linkService.navigateTo(destination);
                    }
                    return false;
                  };
                  if (destination) {
                    link.className = "internalLink";
                  }
                }
              }, {
                key: "_bindNamedAction",
                value: function _bindNamedAction(link, action) {
                  var _this3 = this;
                  link.href = this.linkService.getAnchorUrl("");
                  link.onclick = function() {
                    _this3.linkService.executeNamedAction(action);
                    return false;
                  };
                  link.className = "internalLink";
                }
              }]);
              return LinkAnnotationElement2;
            }(AnnotationElement);
            var TextAnnotationElement = function(_AnnotationElement2) {
              _inherits(TextAnnotationElement2, _AnnotationElement2);
              function TextAnnotationElement2(parameters) {
                _classCallCheck(this, TextAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _possibleConstructorReturn(this, (TextAnnotationElement2.__proto__ || Object.getPrototypeOf(TextAnnotationElement2)).call(this, parameters, isRenderable));
              }
              _createClass(TextAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "textAnnotation";
                  var image = document.createElement("img");
                  image.style.height = this.container.style.height;
                  image.style.width = this.container.style.width;
                  image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
                  image.alt = "[{{type}} Annotation]";
                  image.dataset.l10nId = "text_annotation_type";
                  image.dataset.l10nArgs = JSON.stringify({ type: this.data.name });
                  if (!this.data.hasPopup) {
                    this._createPopup(this.container, image, this.data);
                  }
                  this.container.appendChild(image);
                  return this.container;
                }
              }]);
              return TextAnnotationElement2;
            }(AnnotationElement);
            var WidgetAnnotationElement = function(_AnnotationElement3) {
              _inherits(WidgetAnnotationElement2, _AnnotationElement3);
              function WidgetAnnotationElement2() {
                _classCallCheck(this, WidgetAnnotationElement2);
                return _possibleConstructorReturn(this, (WidgetAnnotationElement2.__proto__ || Object.getPrototypeOf(WidgetAnnotationElement2)).apply(this, arguments));
              }
              _createClass(WidgetAnnotationElement2, [{
                key: "render",
                value: function render() {
                  return this.container;
                }
              }]);
              return WidgetAnnotationElement2;
            }(AnnotationElement);
            var TextWidgetAnnotationElement = function(_WidgetAnnotationElem) {
              _inherits(TextWidgetAnnotationElement2, _WidgetAnnotationElem);
              function TextWidgetAnnotationElement2(parameters) {
                _classCallCheck(this, TextWidgetAnnotationElement2);
                var isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
                return _possibleConstructorReturn(this, (TextWidgetAnnotationElement2.__proto__ || Object.getPrototypeOf(TextWidgetAnnotationElement2)).call(this, parameters, isRenderable));
              }
              _createClass(TextWidgetAnnotationElement2, [{
                key: "render",
                value: function render() {
                  var TEXT_ALIGNMENT = ["left", "center", "right"];
                  this.container.className = "textWidgetAnnotation";
                  var element = null;
                  if (this.renderInteractiveForms) {
                    if (this.data.multiLine) {
                      element = document.createElement("textarea");
                      element.textContent = this.data.fieldValue;
                    } else {
                      element = document.createElement("input");
                      element.type = "text";
                      element.setAttribute("value", this.data.fieldValue);
                    }
                    element.disabled = this.data.readOnly;
                    if (this.data.maxLen !== null) {
                      element.maxLength = this.data.maxLen;
                    }
                    if (this.data.comb) {
                      var fieldWidth = this.data.rect[2] - this.data.rect[0];
                      var combWidth = fieldWidth / this.data.maxLen;
                      element.classList.add("comb");
                      element.style.letterSpacing = "calc(" + combWidth + "px - 1ch)";
                    }
                  } else {
                    element = document.createElement("div");
                    element.textContent = this.data.fieldValue;
                    element.style.verticalAlign = "middle";
                    element.style.display = "table-cell";
                    var font = null;
                    if (this.data.fontRefName) {
                      font = this.page.commonObjs.getData(this.data.fontRefName);
                    }
                    this._setTextStyle(element, font);
                  }
                  if (this.data.textAlignment !== null) {
                    element.style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
                  }
                  this.container.appendChild(element);
                  return this.container;
                }
              }, {
                key: "_setTextStyle",
                value: function _setTextStyle(element, font) {
                  var style = element.style;
                  style.fontSize = this.data.fontSize + "px";
                  style.direction = this.data.fontDirection < 0 ? "rtl" : "ltr";
                  if (!font) {
                    return;
                  }
                  style.fontWeight = font.black ? font.bold ? "900" : "bold" : font.bold ? "bold" : "normal";
                  style.fontStyle = font.italic ? "italic" : "normal";
                  var fontFamily = font.loadedName ? '"' + font.loadedName + '", ' : "";
                  var fallbackName = font.fallbackName || "Helvetica, sans-serif";
                  style.fontFamily = fontFamily + fallbackName;
                }
              }]);
              return TextWidgetAnnotationElement2;
            }(WidgetAnnotationElement);
            var CheckboxWidgetAnnotationElement = function(_WidgetAnnotationElem2) {
              _inherits(CheckboxWidgetAnnotationElement2, _WidgetAnnotationElem2);
              function CheckboxWidgetAnnotationElement2(parameters) {
                _classCallCheck(this, CheckboxWidgetAnnotationElement2);
                return _possibleConstructorReturn(this, (CheckboxWidgetAnnotationElement2.__proto__ || Object.getPrototypeOf(CheckboxWidgetAnnotationElement2)).call(this, parameters, parameters.renderInteractiveForms));
              }
              _createClass(CheckboxWidgetAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "buttonWidgetAnnotation checkBox";
                  var element = document.createElement("input");
                  element.disabled = this.data.readOnly;
                  element.type = "checkbox";
                  if (this.data.fieldValue && this.data.fieldValue !== "Off") {
                    element.setAttribute("checked", true);
                  }
                  this.container.appendChild(element);
                  return this.container;
                }
              }]);
              return CheckboxWidgetAnnotationElement2;
            }(WidgetAnnotationElement);
            var RadioButtonWidgetAnnotationElement = function(_WidgetAnnotationElem3) {
              _inherits(RadioButtonWidgetAnnotationElement2, _WidgetAnnotationElem3);
              function RadioButtonWidgetAnnotationElement2(parameters) {
                _classCallCheck(this, RadioButtonWidgetAnnotationElement2);
                return _possibleConstructorReturn(this, (RadioButtonWidgetAnnotationElement2.__proto__ || Object.getPrototypeOf(RadioButtonWidgetAnnotationElement2)).call(this, parameters, parameters.renderInteractiveForms));
              }
              _createClass(RadioButtonWidgetAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "buttonWidgetAnnotation radioButton";
                  var element = document.createElement("input");
                  element.disabled = this.data.readOnly;
                  element.type = "radio";
                  element.name = this.data.fieldName;
                  if (this.data.fieldValue === this.data.buttonValue) {
                    element.setAttribute("checked", true);
                  }
                  this.container.appendChild(element);
                  return this.container;
                }
              }]);
              return RadioButtonWidgetAnnotationElement2;
            }(WidgetAnnotationElement);
            var PushButtonWidgetAnnotationElement = function(_LinkAnnotationElemen) {
              _inherits(PushButtonWidgetAnnotationElement2, _LinkAnnotationElemen);
              function PushButtonWidgetAnnotationElement2() {
                _classCallCheck(this, PushButtonWidgetAnnotationElement2);
                return _possibleConstructorReturn(this, (PushButtonWidgetAnnotationElement2.__proto__ || Object.getPrototypeOf(PushButtonWidgetAnnotationElement2)).apply(this, arguments));
              }
              _createClass(PushButtonWidgetAnnotationElement2, [{
                key: "render",
                value: function render() {
                  var container = _get(PushButtonWidgetAnnotationElement2.prototype.__proto__ || Object.getPrototypeOf(PushButtonWidgetAnnotationElement2.prototype), "render", this).call(this);
                  container.className = "buttonWidgetAnnotation pushButton";
                  return container;
                }
              }]);
              return PushButtonWidgetAnnotationElement2;
            }(LinkAnnotationElement);
            var ChoiceWidgetAnnotationElement = function(_WidgetAnnotationElem4) {
              _inherits(ChoiceWidgetAnnotationElement2, _WidgetAnnotationElem4);
              function ChoiceWidgetAnnotationElement2(parameters) {
                _classCallCheck(this, ChoiceWidgetAnnotationElement2);
                return _possibleConstructorReturn(this, (ChoiceWidgetAnnotationElement2.__proto__ || Object.getPrototypeOf(ChoiceWidgetAnnotationElement2)).call(this, parameters, parameters.renderInteractiveForms));
              }
              _createClass(ChoiceWidgetAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "choiceWidgetAnnotation";
                  var selectElement = document.createElement("select");
                  selectElement.disabled = this.data.readOnly;
                  if (!this.data.combo) {
                    selectElement.size = this.data.options.length;
                    if (this.data.multiSelect) {
                      selectElement.multiple = true;
                    }
                  }
                  for (var i = 0, ii = this.data.options.length; i < ii; i++) {
                    var option = this.data.options[i];
                    var optionElement = document.createElement("option");
                    optionElement.textContent = option.displayValue;
                    optionElement.value = option.exportValue;
                    if (this.data.fieldValue.includes(option.displayValue)) {
                      optionElement.setAttribute("selected", true);
                    }
                    selectElement.appendChild(optionElement);
                  }
                  this.container.appendChild(selectElement);
                  return this.container;
                }
              }]);
              return ChoiceWidgetAnnotationElement2;
            }(WidgetAnnotationElement);
            var PopupAnnotationElement = function(_AnnotationElement4) {
              _inherits(PopupAnnotationElement2, _AnnotationElement4);
              function PopupAnnotationElement2(parameters) {
                _classCallCheck(this, PopupAnnotationElement2);
                var isRenderable = !!(parameters.data.title || parameters.data.contents);
                return _possibleConstructorReturn(this, (PopupAnnotationElement2.__proto__ || Object.getPrototypeOf(PopupAnnotationElement2)).call(this, parameters, isRenderable));
              }
              _createClass(PopupAnnotationElement2, [{
                key: "render",
                value: function render() {
                  var IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon"];
                  this.container.className = "popupAnnotation";
                  if (IGNORE_TYPES.includes(this.data.parentType)) {
                    return this.container;
                  }
                  var selector = '[data-annotation-id="' + this.data.parentId + '"]';
                  var parentElement = this.layer.querySelector(selector);
                  if (!parentElement) {
                    return this.container;
                  }
                  var popup = new PopupElement({
                    container: this.container,
                    trigger: parentElement,
                    color: this.data.color,
                    title: this.data.title,
                    contents: this.data.contents
                  });
                  var parentLeft = parseFloat(parentElement.style.left);
                  var parentWidth = parseFloat(parentElement.style.width);
                  this.container.style.transformOrigin = -(parentLeft + parentWidth) + "px -" + parentElement.style.top;
                  this.container.style.left = parentLeft + parentWidth + "px";
                  this.container.appendChild(popup.render());
                  return this.container;
                }
              }]);
              return PopupAnnotationElement2;
            }(AnnotationElement);
            var PopupElement = function() {
              function PopupElement2(parameters) {
                _classCallCheck(this, PopupElement2);
                this.container = parameters.container;
                this.trigger = parameters.trigger;
                this.color = parameters.color;
                this.title = parameters.title;
                this.contents = parameters.contents;
                this.hideWrapper = parameters.hideWrapper || false;
                this.pinned = false;
              }
              _createClass(PopupElement2, [{
                key: "render",
                value: function render() {
                  var BACKGROUND_ENLIGHT = 0.7;
                  var wrapper = document.createElement("div");
                  wrapper.className = "popupWrapper";
                  this.hideElement = this.hideWrapper ? wrapper : this.container;
                  this.hideElement.setAttribute("hidden", true);
                  var popup = document.createElement("div");
                  popup.className = "popup";
                  var color = this.color;
                  if (color) {
                    var r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
                    var g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
                    var b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
                    popup.style.backgroundColor = _util.Util.makeCssRgb(r | 0, g | 0, b | 0);
                  }
                  var contents = this._formatContents(this.contents);
                  var title = document.createElement("h1");
                  title.textContent = this.title;
                  this.trigger.addEventListener("click", this._toggle.bind(this));
                  this.trigger.addEventListener("mouseover", this._show.bind(this, false));
                  this.trigger.addEventListener("mouseout", this._hide.bind(this, false));
                  popup.addEventListener("click", this._hide.bind(this, true));
                  popup.appendChild(title);
                  popup.appendChild(contents);
                  wrapper.appendChild(popup);
                  return wrapper;
                }
              }, {
                key: "_formatContents",
                value: function _formatContents(contents) {
                  var p = document.createElement("p");
                  var lines = contents.split(/(?:\r\n?|\n)/);
                  for (var i = 0, ii = lines.length; i < ii; ++i) {
                    var line = lines[i];
                    p.appendChild(document.createTextNode(line));
                    if (i < ii - 1) {
                      p.appendChild(document.createElement("br"));
                    }
                  }
                  return p;
                }
              }, {
                key: "_toggle",
                value: function _toggle() {
                  if (this.pinned) {
                    this._hide(true);
                  } else {
                    this._show(true);
                  }
                }
              }, {
                key: "_show",
                value: function _show() {
                  var pin = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  if (pin) {
                    this.pinned = true;
                  }
                  if (this.hideElement.hasAttribute("hidden")) {
                    this.hideElement.removeAttribute("hidden");
                    this.container.style.zIndex += 1;
                  }
                }
              }, {
                key: "_hide",
                value: function _hide() {
                  var unpin = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                  if (unpin) {
                    this.pinned = false;
                  }
                  if (!this.hideElement.hasAttribute("hidden") && !this.pinned) {
                    this.hideElement.setAttribute("hidden", true);
                    this.container.style.zIndex -= 1;
                  }
                }
              }]);
              return PopupElement2;
            }();
            var LineAnnotationElement = function(_AnnotationElement5) {
              _inherits(LineAnnotationElement2, _AnnotationElement5);
              function LineAnnotationElement2(parameters) {
                _classCallCheck(this, LineAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _possibleConstructorReturn(this, (LineAnnotationElement2.__proto__ || Object.getPrototypeOf(LineAnnotationElement2)).call(this, parameters, isRenderable, true));
              }
              _createClass(LineAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "lineAnnotation";
                  var data = this.data;
                  var width = data.rect[2] - data.rect[0];
                  var height = data.rect[3] - data.rect[1];
                  var svg = this.svgFactory.create(width, height);
                  var line = this.svgFactory.createElement("svg:line");
                  line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
                  line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
                  line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
                  line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
                  line.setAttribute("stroke-width", data.borderStyle.width);
                  line.setAttribute("stroke", "transparent");
                  svg.appendChild(line);
                  this.container.append(svg);
                  this._createPopup(this.container, line, data);
                  return this.container;
                }
              }]);
              return LineAnnotationElement2;
            }(AnnotationElement);
            var SquareAnnotationElement = function(_AnnotationElement6) {
              _inherits(SquareAnnotationElement2, _AnnotationElement6);
              function SquareAnnotationElement2(parameters) {
                _classCallCheck(this, SquareAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _possibleConstructorReturn(this, (SquareAnnotationElement2.__proto__ || Object.getPrototypeOf(SquareAnnotationElement2)).call(this, parameters, isRenderable, true));
              }
              _createClass(SquareAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "squareAnnotation";
                  var data = this.data;
                  var width = data.rect[2] - data.rect[0];
                  var height = data.rect[3] - data.rect[1];
                  var svg = this.svgFactory.create(width, height);
                  var borderWidth = data.borderStyle.width;
                  var square = this.svgFactory.createElement("svg:rect");
                  square.setAttribute("x", borderWidth / 2);
                  square.setAttribute("y", borderWidth / 2);
                  square.setAttribute("width", width - borderWidth);
                  square.setAttribute("height", height - borderWidth);
                  square.setAttribute("stroke-width", borderWidth);
                  square.setAttribute("stroke", "transparent");
                  square.setAttribute("fill", "none");
                  svg.appendChild(square);
                  this.container.append(svg);
                  this._createPopup(this.container, square, data);
                  return this.container;
                }
              }]);
              return SquareAnnotationElement2;
            }(AnnotationElement);
            var CircleAnnotationElement = function(_AnnotationElement7) {
              _inherits(CircleAnnotationElement2, _AnnotationElement7);
              function CircleAnnotationElement2(parameters) {
                _classCallCheck(this, CircleAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _possibleConstructorReturn(this, (CircleAnnotationElement2.__proto__ || Object.getPrototypeOf(CircleAnnotationElement2)).call(this, parameters, isRenderable, true));
              }
              _createClass(CircleAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "circleAnnotation";
                  var data = this.data;
                  var width = data.rect[2] - data.rect[0];
                  var height = data.rect[3] - data.rect[1];
                  var svg = this.svgFactory.create(width, height);
                  var borderWidth = data.borderStyle.width;
                  var circle = this.svgFactory.createElement("svg:ellipse");
                  circle.setAttribute("cx", width / 2);
                  circle.setAttribute("cy", height / 2);
                  circle.setAttribute("rx", width / 2 - borderWidth / 2);
                  circle.setAttribute("ry", height / 2 - borderWidth / 2);
                  circle.setAttribute("stroke-width", borderWidth);
                  circle.setAttribute("stroke", "transparent");
                  circle.setAttribute("fill", "none");
                  svg.appendChild(circle);
                  this.container.append(svg);
                  this._createPopup(this.container, circle, data);
                  return this.container;
                }
              }]);
              return CircleAnnotationElement2;
            }(AnnotationElement);
            var PolylineAnnotationElement = function(_AnnotationElement8) {
              _inherits(PolylineAnnotationElement2, _AnnotationElement8);
              function PolylineAnnotationElement2(parameters) {
                _classCallCheck(this, PolylineAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                var _this15 = _possibleConstructorReturn(this, (PolylineAnnotationElement2.__proto__ || Object.getPrototypeOf(PolylineAnnotationElement2)).call(this, parameters, isRenderable, true));
                _this15.containerClassName = "polylineAnnotation";
                _this15.svgElementName = "svg:polyline";
                return _this15;
              }
              _createClass(PolylineAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = this.containerClassName;
                  var data = this.data;
                  var width = data.rect[2] - data.rect[0];
                  var height = data.rect[3] - data.rect[1];
                  var svg = this.svgFactory.create(width, height);
                  var vertices = data.vertices;
                  var points = [];
                  for (var i = 0, ii = vertices.length; i < ii; i++) {
                    var x = vertices[i].x - data.rect[0];
                    var y = data.rect[3] - vertices[i].y;
                    points.push(x + "," + y);
                  }
                  points = points.join(" ");
                  var borderWidth = data.borderStyle.width;
                  var polyline = this.svgFactory.createElement(this.svgElementName);
                  polyline.setAttribute("points", points);
                  polyline.setAttribute("stroke-width", borderWidth);
                  polyline.setAttribute("stroke", "transparent");
                  polyline.setAttribute("fill", "none");
                  svg.appendChild(polyline);
                  this.container.append(svg);
                  this._createPopup(this.container, polyline, data);
                  return this.container;
                }
              }]);
              return PolylineAnnotationElement2;
            }(AnnotationElement);
            var PolygonAnnotationElement = function(_PolylineAnnotationEl) {
              _inherits(PolygonAnnotationElement2, _PolylineAnnotationEl);
              function PolygonAnnotationElement2(parameters) {
                _classCallCheck(this, PolygonAnnotationElement2);
                var _this16 = _possibleConstructorReturn(this, (PolygonAnnotationElement2.__proto__ || Object.getPrototypeOf(PolygonAnnotationElement2)).call(this, parameters));
                _this16.containerClassName = "polygonAnnotation";
                _this16.svgElementName = "svg:polygon";
                return _this16;
              }
              return PolygonAnnotationElement2;
            }(PolylineAnnotationElement);
            var HighlightAnnotationElement = function(_AnnotationElement9) {
              _inherits(HighlightAnnotationElement2, _AnnotationElement9);
              function HighlightAnnotationElement2(parameters) {
                _classCallCheck(this, HighlightAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _possibleConstructorReturn(this, (HighlightAnnotationElement2.__proto__ || Object.getPrototypeOf(HighlightAnnotationElement2)).call(this, parameters, isRenderable, true));
              }
              _createClass(HighlightAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "highlightAnnotation";
                  if (!this.data.hasPopup) {
                    this._createPopup(this.container, null, this.data);
                  }
                  return this.container;
                }
              }]);
              return HighlightAnnotationElement2;
            }(AnnotationElement);
            var UnderlineAnnotationElement = function(_AnnotationElement10) {
              _inherits(UnderlineAnnotationElement2, _AnnotationElement10);
              function UnderlineAnnotationElement2(parameters) {
                _classCallCheck(this, UnderlineAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _possibleConstructorReturn(this, (UnderlineAnnotationElement2.__proto__ || Object.getPrototypeOf(UnderlineAnnotationElement2)).call(this, parameters, isRenderable, true));
              }
              _createClass(UnderlineAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "underlineAnnotation";
                  if (!this.data.hasPopup) {
                    this._createPopup(this.container, null, this.data);
                  }
                  return this.container;
                }
              }]);
              return UnderlineAnnotationElement2;
            }(AnnotationElement);
            var SquigglyAnnotationElement = function(_AnnotationElement11) {
              _inherits(SquigglyAnnotationElement2, _AnnotationElement11);
              function SquigglyAnnotationElement2(parameters) {
                _classCallCheck(this, SquigglyAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _possibleConstructorReturn(this, (SquigglyAnnotationElement2.__proto__ || Object.getPrototypeOf(SquigglyAnnotationElement2)).call(this, parameters, isRenderable, true));
              }
              _createClass(SquigglyAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "squigglyAnnotation";
                  if (!this.data.hasPopup) {
                    this._createPopup(this.container, null, this.data);
                  }
                  return this.container;
                }
              }]);
              return SquigglyAnnotationElement2;
            }(AnnotationElement);
            var StrikeOutAnnotationElement = function(_AnnotationElement12) {
              _inherits(StrikeOutAnnotationElement2, _AnnotationElement12);
              function StrikeOutAnnotationElement2(parameters) {
                _classCallCheck(this, StrikeOutAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _possibleConstructorReturn(this, (StrikeOutAnnotationElement2.__proto__ || Object.getPrototypeOf(StrikeOutAnnotationElement2)).call(this, parameters, isRenderable, true));
              }
              _createClass(StrikeOutAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "strikeoutAnnotation";
                  if (!this.data.hasPopup) {
                    this._createPopup(this.container, null, this.data);
                  }
                  return this.container;
                }
              }]);
              return StrikeOutAnnotationElement2;
            }(AnnotationElement);
            var StampAnnotationElement = function(_AnnotationElement13) {
              _inherits(StampAnnotationElement2, _AnnotationElement13);
              function StampAnnotationElement2(parameters) {
                _classCallCheck(this, StampAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _possibleConstructorReturn(this, (StampAnnotationElement2.__proto__ || Object.getPrototypeOf(StampAnnotationElement2)).call(this, parameters, isRenderable, true));
              }
              _createClass(StampAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "stampAnnotation";
                  if (!this.data.hasPopup) {
                    this._createPopup(this.container, null, this.data);
                  }
                  return this.container;
                }
              }]);
              return StampAnnotationElement2;
            }(AnnotationElement);
            var FileAttachmentAnnotationElement = function(_AnnotationElement14) {
              _inherits(FileAttachmentAnnotationElement2, _AnnotationElement14);
              function FileAttachmentAnnotationElement2(parameters) {
                _classCallCheck(this, FileAttachmentAnnotationElement2);
                var _this22 = _possibleConstructorReturn(this, (FileAttachmentAnnotationElement2.__proto__ || Object.getPrototypeOf(FileAttachmentAnnotationElement2)).call(this, parameters, true));
                var file = _this22.data.file;
                _this22.filename = (0, _dom_utils.getFilenameFromUrl)(file.filename);
                _this22.content = file.content;
                _this22.linkService.onFileAttachmentAnnotation({
                  id: (0, _util.stringToPDFString)(file.filename),
                  filename: file.filename,
                  content: file.content
                });
                return _this22;
              }
              _createClass(FileAttachmentAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "fileAttachmentAnnotation";
                  var trigger = document.createElement("div");
                  trigger.style.height = this.container.style.height;
                  trigger.style.width = this.container.style.width;
                  trigger.addEventListener("dblclick", this._download.bind(this));
                  if (!this.data.hasPopup && (this.data.title || this.data.contents)) {
                    this._createPopup(this.container, trigger, this.data);
                  }
                  this.container.appendChild(trigger);
                  return this.container;
                }
              }, {
                key: "_download",
                value: function _download() {
                  if (!this.downloadManager) {
                    (0, _util.warn)("Download cannot be started due to unavailable download manager");
                    return;
                  }
                  this.downloadManager.downloadData(this.content, this.filename, "");
                }
              }]);
              return FileAttachmentAnnotationElement2;
            }(AnnotationElement);
            var AnnotationLayer = function() {
              function AnnotationLayer2() {
                _classCallCheck(this, AnnotationLayer2);
              }
              _createClass(AnnotationLayer2, null, [{
                key: "render",
                value: function render(parameters) {
                  for (var i = 0, ii = parameters.annotations.length; i < ii; i++) {
                    var data = parameters.annotations[i];
                    if (!data) {
                      continue;
                    }
                    var element = AnnotationElementFactory.create({
                      data,
                      layer: parameters.div,
                      page: parameters.page,
                      viewport: parameters.viewport,
                      linkService: parameters.linkService,
                      downloadManager: parameters.downloadManager,
                      imageResourcesPath: parameters.imageResourcesPath || "",
                      renderInteractiveForms: parameters.renderInteractiveForms || false,
                      svgFactory: new _dom_utils.DOMSVGFactory()
                    });
                    if (element.isRenderable) {
                      parameters.div.appendChild(element.render());
                    }
                  }
                }
              }, {
                key: "update",
                value: function update(parameters) {
                  for (var i = 0, ii = parameters.annotations.length; i < ii; i++) {
                    var data = parameters.annotations[i];
                    var element = parameters.div.querySelector('[data-annotation-id="' + data.id + '"]');
                    if (element) {
                      element.style.transform = "matrix(" + parameters.viewport.transform.join(",") + ")";
                    }
                  }
                  parameters.div.removeAttribute("hidden");
                }
              }]);
              return AnnotationLayer2;
            }();
            exports3.AnnotationLayer = AnnotationLayer;
          },
          /* 128 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.SVGGraphics = void 0;
            var _util = __w_pdfjs_require__(1);
            var _dom_utils = __w_pdfjs_require__(115);
            var _is_node = __w_pdfjs_require__(4);
            var _is_node2 = _interopRequireDefault(_is_node);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            var SVGGraphics = function SVGGraphics2() {
              throw new Error("Not implemented: SVGGraphics");
            };
            {
              var SVG_DEFAULTS = {
                fontStyle: "normal",
                fontWeight: "normal",
                fillColor: "#000000"
              };
              var convertImgDataToPng = function convertImgDataToPngClosure() {
                var PNG_HEADER = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);
                var CHUNK_WRAPPER_SIZE = 12;
                var crcTable = new Int32Array(256);
                for (var i = 0; i < 256; i++) {
                  var c = i;
                  for (var h = 0; h < 8; h++) {
                    if (c & 1) {
                      c = 3988292384 ^ c >> 1 & 2147483647;
                    } else {
                      c = c >> 1 & 2147483647;
                    }
                  }
                  crcTable[i] = c;
                }
                function crc32(data, start, end) {
                  var crc = -1;
                  for (var i2 = start; i2 < end; i2++) {
                    var a = (crc ^ data[i2]) & 255;
                    var b = crcTable[a];
                    crc = crc >>> 8 ^ b;
                  }
                  return crc ^ -1;
                }
                function writePngChunk(type, body, data, offset) {
                  var p = offset;
                  var len = body.length;
                  data[p] = len >> 24 & 255;
                  data[p + 1] = len >> 16 & 255;
                  data[p + 2] = len >> 8 & 255;
                  data[p + 3] = len & 255;
                  p += 4;
                  data[p] = type.charCodeAt(0) & 255;
                  data[p + 1] = type.charCodeAt(1) & 255;
                  data[p + 2] = type.charCodeAt(2) & 255;
                  data[p + 3] = type.charCodeAt(3) & 255;
                  p += 4;
                  data.set(body, p);
                  p += body.length;
                  var crc = crc32(data, offset + 4, p);
                  data[p] = crc >> 24 & 255;
                  data[p + 1] = crc >> 16 & 255;
                  data[p + 2] = crc >> 8 & 255;
                  data[p + 3] = crc & 255;
                }
                function adler32(data, start, end) {
                  var a = 1;
                  var b = 0;
                  for (var i2 = start; i2 < end; ++i2) {
                    a = (a + (data[i2] & 255)) % 65521;
                    b = (b + a) % 65521;
                  }
                  return b << 16 | a;
                }
                function deflateSync(literals) {
                  if (!(0, _is_node2.default)()) {
                    return deflateSyncUncompressed(literals);
                  }
                  try {
                    var input;
                    if (parseInt(process.versions.node) >= 8) {
                      input = literals;
                    } else {
                      input = new Buffer(literals);
                    }
                    var output = require_zlib().deflateSync(input, { level: 9 });
                    return output instanceof Uint8Array ? output : new Uint8Array(output);
                  } catch (e) {
                    (0, _util.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
                  }
                  return deflateSyncUncompressed(literals);
                }
                function deflateSyncUncompressed(literals) {
                  var len = literals.length;
                  var maxBlockLength = 65535;
                  var deflateBlocks = Math.ceil(len / maxBlockLength);
                  var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
                  var pi = 0;
                  idat[pi++] = 120;
                  idat[pi++] = 156;
                  var pos = 0;
                  while (len > maxBlockLength) {
                    idat[pi++] = 0;
                    idat[pi++] = 255;
                    idat[pi++] = 255;
                    idat[pi++] = 0;
                    idat[pi++] = 0;
                    idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
                    pi += maxBlockLength;
                    pos += maxBlockLength;
                    len -= maxBlockLength;
                  }
                  idat[pi++] = 1;
                  idat[pi++] = len & 255;
                  idat[pi++] = len >> 8 & 255;
                  idat[pi++] = ~len & 65535 & 255;
                  idat[pi++] = (~len & 65535) >> 8 & 255;
                  idat.set(literals.subarray(pos), pi);
                  pi += literals.length - pos;
                  var adler = adler32(literals, 0, literals.length);
                  idat[pi++] = adler >> 24 & 255;
                  idat[pi++] = adler >> 16 & 255;
                  idat[pi++] = adler >> 8 & 255;
                  idat[pi++] = adler & 255;
                  return idat;
                }
                function encode(imgData, kind, forceDataSchema, isMask) {
                  var width = imgData.width;
                  var height = imgData.height;
                  var bitDepth, colorType, lineSize;
                  var bytes = imgData.data;
                  switch (kind) {
                    case _util.ImageKind.GRAYSCALE_1BPP:
                      colorType = 0;
                      bitDepth = 1;
                      lineSize = width + 7 >> 3;
                      break;
                    case _util.ImageKind.RGB_24BPP:
                      colorType = 2;
                      bitDepth = 8;
                      lineSize = width * 3;
                      break;
                    case _util.ImageKind.RGBA_32BPP:
                      colorType = 6;
                      bitDepth = 8;
                      lineSize = width * 4;
                      break;
                    default:
                      throw new Error("invalid format");
                  }
                  var literals = new Uint8Array((1 + lineSize) * height);
                  var offsetLiterals = 0, offsetBytes = 0;
                  var y, i2;
                  for (y = 0; y < height; ++y) {
                    literals[offsetLiterals++] = 0;
                    literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
                    offsetBytes += lineSize;
                    offsetLiterals += lineSize;
                  }
                  if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {
                    offsetLiterals = 0;
                    for (y = 0; y < height; y++) {
                      offsetLiterals++;
                      for (i2 = 0; i2 < lineSize; i2++) {
                        literals[offsetLiterals++] ^= 255;
                      }
                    }
                  }
                  var ihdr = new Uint8Array([width >> 24 & 255, width >> 16 & 255, width >> 8 & 255, width & 255, height >> 24 & 255, height >> 16 & 255, height >> 8 & 255, height & 255, bitDepth, colorType, 0, 0, 0]);
                  var idat = deflateSync(literals);
                  var pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
                  var data = new Uint8Array(pngLength);
                  var offset = 0;
                  data.set(PNG_HEADER, offset);
                  offset += PNG_HEADER.length;
                  writePngChunk("IHDR", ihdr, data, offset);
                  offset += CHUNK_WRAPPER_SIZE + ihdr.length;
                  writePngChunk("IDATA", idat, data, offset);
                  offset += CHUNK_WRAPPER_SIZE + idat.length;
                  writePngChunk("IEND", new Uint8Array(0), data, offset);
                  return (0, _util.createObjectURL)(data, "image/png", forceDataSchema);
                }
                return function convertImgDataToPng2(imgData, forceDataSchema, isMask) {
                  var kind = imgData.kind === void 0 ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;
                  return encode(imgData, kind, forceDataSchema, isMask);
                };
              }();
              var SVGExtraState = function SVGExtraStateClosure() {
                function SVGExtraState2() {
                  this.fontSizeScale = 1;
                  this.fontWeight = SVG_DEFAULTS.fontWeight;
                  this.fontSize = 0;
                  this.textMatrix = _util.IDENTITY_MATRIX;
                  this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
                  this.leading = 0;
                  this.x = 0;
                  this.y = 0;
                  this.lineX = 0;
                  this.lineY = 0;
                  this.charSpacing = 0;
                  this.wordSpacing = 0;
                  this.textHScale = 1;
                  this.textRise = 0;
                  this.fillColor = SVG_DEFAULTS.fillColor;
                  this.strokeColor = "#000000";
                  this.fillAlpha = 1;
                  this.strokeAlpha = 1;
                  this.lineWidth = 1;
                  this.lineJoin = "";
                  this.lineCap = "";
                  this.miterLimit = 0;
                  this.dashArray = [];
                  this.dashPhase = 0;
                  this.dependencies = [];
                  this.activeClipUrl = null;
                  this.clipGroup = null;
                  this.maskId = "";
                }
                SVGExtraState2.prototype = {
                  clone: function SVGExtraState_clone() {
                    return Object.create(this);
                  },
                  setCurrentPoint: function SVGExtraState_setCurrentPoint(x, y) {
                    this.x = x;
                    this.y = y;
                  }
                };
                return SVGExtraState2;
              }();
              exports3.SVGGraphics = SVGGraphics = function SVGGraphicsClosure() {
                function opListToTree(opList) {
                  var opTree = [];
                  var tmp = [];
                  var opListLen = opList.length;
                  for (var x = 0; x < opListLen; x++) {
                    if (opList[x].fn === "save") {
                      opTree.push({
                        "fnId": 92,
                        "fn": "group",
                        "items": []
                      });
                      tmp.push(opTree);
                      opTree = opTree[opTree.length - 1].items;
                      continue;
                    }
                    if (opList[x].fn === "restore") {
                      opTree = tmp.pop();
                    } else {
                      opTree.push(opList[x]);
                    }
                  }
                  return opTree;
                }
                function pf(value) {
                  if (Number.isInteger(value)) {
                    return value.toString();
                  }
                  var s = value.toFixed(10);
                  var i = s.length - 1;
                  if (s[i] !== "0") {
                    return s;
                  }
                  do {
                    i--;
                  } while (s[i] === "0");
                  return s.substr(0, s[i] === "." ? i : i + 1);
                }
                function pm(m) {
                  if (m[4] === 0 && m[5] === 0) {
                    if (m[1] === 0 && m[2] === 0) {
                      if (m[0] === 1 && m[3] === 1) {
                        return "";
                      }
                      return "scale(" + pf(m[0]) + " " + pf(m[3]) + ")";
                    }
                    if (m[0] === m[3] && m[1] === -m[2]) {
                      var a = Math.acos(m[0]) * 180 / Math.PI;
                      return "rotate(" + pf(a) + ")";
                    }
                  } else {
                    if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
                      return "translate(" + pf(m[4]) + " " + pf(m[5]) + ")";
                    }
                  }
                  return "matrix(" + pf(m[0]) + " " + pf(m[1]) + " " + pf(m[2]) + " " + pf(m[3]) + " " + pf(m[4]) + " " + pf(m[5]) + ")";
                }
                function SVGGraphics2(commonObjs, objs, forceDataSchema) {
                  this.svgFactory = new _dom_utils.DOMSVGFactory();
                  this.current = new SVGExtraState();
                  this.transformMatrix = _util.IDENTITY_MATRIX;
                  this.transformStack = [];
                  this.extraStack = [];
                  this.commonObjs = commonObjs;
                  this.objs = objs;
                  this.pendingClip = null;
                  this.pendingEOFill = false;
                  this.embedFonts = false;
                  this.embeddedFonts = /* @__PURE__ */ Object.create(null);
                  this.cssStyle = null;
                  this.forceDataSchema = !!forceDataSchema;
                }
                var XML_NS = "http://www.w3.org/XML/1998/namespace";
                var XLINK_NS = "http://www.w3.org/1999/xlink";
                var LINE_CAP_STYLES = ["butt", "round", "square"];
                var LINE_JOIN_STYLES = ["miter", "round", "bevel"];
                var clipCount = 0;
                var maskCount = 0;
                SVGGraphics2.prototype = {
                  save: function SVGGraphics_save() {
                    this.transformStack.push(this.transformMatrix);
                    var old = this.current;
                    this.extraStack.push(old);
                    this.current = old.clone();
                  },
                  restore: function SVGGraphics_restore() {
                    this.transformMatrix = this.transformStack.pop();
                    this.current = this.extraStack.pop();
                    this.pendingClip = null;
                    this.tgrp = null;
                  },
                  group: function SVGGraphics_group(items) {
                    this.save();
                    this.executeOpTree(items);
                    this.restore();
                  },
                  loadDependencies: function SVGGraphics_loadDependencies(operatorList) {
                    var _this = this;
                    var fnArray = operatorList.fnArray;
                    var fnArrayLen = fnArray.length;
                    var argsArray = operatorList.argsArray;
                    for (var i = 0; i < fnArrayLen; i++) {
                      if (_util.OPS.dependency === fnArray[i]) {
                        var deps = argsArray[i];
                        for (var n = 0, nn = deps.length; n < nn; n++) {
                          var obj = deps[n];
                          var common = obj.substring(0, 2) === "g_";
                          var promise;
                          if (common) {
                            promise = new Promise(function(resolve2) {
                              _this.commonObjs.get(obj, resolve2);
                            });
                          } else {
                            promise = new Promise(function(resolve2) {
                              _this.objs.get(obj, resolve2);
                            });
                          }
                          this.current.dependencies.push(promise);
                        }
                      }
                    }
                    return Promise.all(this.current.dependencies);
                  },
                  transform: function SVGGraphics_transform(a, b, c, d, e, f) {
                    var transformMatrix = [a, b, c, d, e, f];
                    this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);
                    this.tgrp = null;
                  },
                  getSVG: function SVGGraphics_getSVG(operatorList, viewport) {
                    var _this2 = this;
                    this.viewport = viewport;
                    var svgElement = this._initialize(viewport);
                    return this.loadDependencies(operatorList).then(function() {
                      _this2.transformMatrix = _util.IDENTITY_MATRIX;
                      var opTree = _this2.convertOpList(operatorList);
                      _this2.executeOpTree(opTree);
                      return svgElement;
                    });
                  },
                  convertOpList: function SVGGraphics_convertOpList(operatorList) {
                    var argsArray = operatorList.argsArray;
                    var fnArray = operatorList.fnArray;
                    var fnArrayLen = fnArray.length;
                    var REVOPS = [];
                    var opList = [];
                    for (var op in _util.OPS) {
                      REVOPS[_util.OPS[op]] = op;
                    }
                    for (var x = 0; x < fnArrayLen; x++) {
                      var fnId = fnArray[x];
                      opList.push({
                        "fnId": fnId,
                        "fn": REVOPS[fnId],
                        "args": argsArray[x]
                      });
                    }
                    return opListToTree(opList);
                  },
                  executeOpTree: function SVGGraphics_executeOpTree(opTree) {
                    var opTreeLen = opTree.length;
                    for (var x = 0; x < opTreeLen; x++) {
                      var fn = opTree[x].fn;
                      var fnId = opTree[x].fnId;
                      var args = opTree[x].args;
                      switch (fnId | 0) {
                        case _util.OPS.beginText:
                          this.beginText();
                          break;
                        case _util.OPS.dependency:
                          break;
                        case _util.OPS.setLeading:
                          this.setLeading(args);
                          break;
                        case _util.OPS.setLeadingMoveText:
                          this.setLeadingMoveText(args[0], args[1]);
                          break;
                        case _util.OPS.setFont:
                          this.setFont(args);
                          break;
                        case _util.OPS.showText:
                          this.showText(args[0]);
                          break;
                        case _util.OPS.showSpacedText:
                          this.showText(args[0]);
                          break;
                        case _util.OPS.endText:
                          this.endText();
                          break;
                        case _util.OPS.moveText:
                          this.moveText(args[0], args[1]);
                          break;
                        case _util.OPS.setCharSpacing:
                          this.setCharSpacing(args[0]);
                          break;
                        case _util.OPS.setWordSpacing:
                          this.setWordSpacing(args[0]);
                          break;
                        case _util.OPS.setHScale:
                          this.setHScale(args[0]);
                          break;
                        case _util.OPS.setTextMatrix:
                          this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                          break;
                        case _util.OPS.setTextRise:
                          this.setTextRise(args[0]);
                          break;
                        case _util.OPS.setLineWidth:
                          this.setLineWidth(args[0]);
                          break;
                        case _util.OPS.setLineJoin:
                          this.setLineJoin(args[0]);
                          break;
                        case _util.OPS.setLineCap:
                          this.setLineCap(args[0]);
                          break;
                        case _util.OPS.setMiterLimit:
                          this.setMiterLimit(args[0]);
                          break;
                        case _util.OPS.setFillRGBColor:
                          this.setFillRGBColor(args[0], args[1], args[2]);
                          break;
                        case _util.OPS.setStrokeRGBColor:
                          this.setStrokeRGBColor(args[0], args[1], args[2]);
                          break;
                        case _util.OPS.setDash:
                          this.setDash(args[0], args[1]);
                          break;
                        case _util.OPS.setGState:
                          this.setGState(args[0]);
                          break;
                        case _util.OPS.fill:
                          this.fill();
                          break;
                        case _util.OPS.eoFill:
                          this.eoFill();
                          break;
                        case _util.OPS.stroke:
                          this.stroke();
                          break;
                        case _util.OPS.fillStroke:
                          this.fillStroke();
                          break;
                        case _util.OPS.eoFillStroke:
                          this.eoFillStroke();
                          break;
                        case _util.OPS.clip:
                          this.clip("nonzero");
                          break;
                        case _util.OPS.eoClip:
                          this.clip("evenodd");
                          break;
                        case _util.OPS.paintSolidColorImageMask:
                          this.paintSolidColorImageMask();
                          break;
                        case _util.OPS.paintJpegXObject:
                          this.paintJpegXObject(args[0], args[1], args[2]);
                          break;
                        case _util.OPS.paintImageXObject:
                          this.paintImageXObject(args[0]);
                          break;
                        case _util.OPS.paintInlineImageXObject:
                          this.paintInlineImageXObject(args[0]);
                          break;
                        case _util.OPS.paintImageMaskXObject:
                          this.paintImageMaskXObject(args[0]);
                          break;
                        case _util.OPS.paintFormXObjectBegin:
                          this.paintFormXObjectBegin(args[0], args[1]);
                          break;
                        case _util.OPS.paintFormXObjectEnd:
                          this.paintFormXObjectEnd();
                          break;
                        case _util.OPS.closePath:
                          this.closePath();
                          break;
                        case _util.OPS.closeStroke:
                          this.closeStroke();
                          break;
                        case _util.OPS.closeFillStroke:
                          this.closeFillStroke();
                          break;
                        case _util.OPS.closeEOFillStroke:
                          this.closeEOFillStroke();
                          break;
                        case _util.OPS.nextLine:
                          this.nextLine();
                          break;
                        case _util.OPS.transform:
                          this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                          break;
                        case _util.OPS.constructPath:
                          this.constructPath(args[0], args[1]);
                          break;
                        case _util.OPS.endPath:
                          this.endPath();
                          break;
                        case 92:
                          this.group(opTree[x].items);
                          break;
                        default:
                          (0, _util.warn)("Unimplemented operator " + fn);
                          break;
                      }
                    }
                  },
                  setWordSpacing: function SVGGraphics_setWordSpacing(wordSpacing) {
                    this.current.wordSpacing = wordSpacing;
                  },
                  setCharSpacing: function SVGGraphics_setCharSpacing(charSpacing) {
                    this.current.charSpacing = charSpacing;
                  },
                  nextLine: function SVGGraphics_nextLine() {
                    this.moveText(0, this.current.leading);
                  },
                  setTextMatrix: function SVGGraphics_setTextMatrix(a, b, c, d, e, f) {
                    var current = this.current;
                    this.current.textMatrix = this.current.lineMatrix = [a, b, c, d, e, f];
                    this.current.x = this.current.lineX = 0;
                    this.current.y = this.current.lineY = 0;
                    current.xcoords = [];
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                    current.tspan.setAttributeNS(null, "font-size", pf(current.fontSize) + "px");
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    current.txtElement = this.svgFactory.createElement("svg:text");
                    current.txtElement.appendChild(current.tspan);
                  },
                  beginText: function SVGGraphics_beginText() {
                    this.current.x = this.current.lineX = 0;
                    this.current.y = this.current.lineY = 0;
                    this.current.textMatrix = _util.IDENTITY_MATRIX;
                    this.current.lineMatrix = _util.IDENTITY_MATRIX;
                    this.current.tspan = this.svgFactory.createElement("svg:tspan");
                    this.current.txtElement = this.svgFactory.createElement("svg:text");
                    this.current.txtgrp = this.svgFactory.createElement("svg:g");
                    this.current.xcoords = [];
                  },
                  moveText: function SVGGraphics_moveText(x, y) {
                    var current = this.current;
                    this.current.x = this.current.lineX += x;
                    this.current.y = this.current.lineY += y;
                    current.xcoords = [];
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                    current.tspan.setAttributeNS(null, "font-size", pf(current.fontSize) + "px");
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  },
                  showText: function SVGGraphics_showText(glyphs) {
                    var current = this.current;
                    var font = current.font;
                    var fontSize = current.fontSize;
                    if (fontSize === 0) {
                      return;
                    }
                    var charSpacing = current.charSpacing;
                    var wordSpacing = current.wordSpacing;
                    var fontDirection = current.fontDirection;
                    var textHScale = current.textHScale * fontDirection;
                    var glyphsLength = glyphs.length;
                    var vertical = font.vertical;
                    var widthAdvanceScale = fontSize * current.fontMatrix[0];
                    var x = 0, i;
                    for (i = 0; i < glyphsLength; ++i) {
                      var glyph = glyphs[i];
                      if (glyph === null) {
                        x += fontDirection * wordSpacing;
                        continue;
                      } else if ((0, _util.isNum)(glyph)) {
                        x += -glyph * fontSize * 1e-3;
                        continue;
                      }
                      var width = glyph.width;
                      var character = glyph.fontChar;
                      var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                      var charWidth = width * widthAdvanceScale + spacing * fontDirection;
                      if (!glyph.isInFont && !font.missingFile) {
                        x += charWidth;
                        continue;
                      }
                      current.xcoords.push(current.x + x * textHScale);
                      current.tspan.textContent += character;
                      x += charWidth;
                    }
                    if (vertical) {
                      current.y -= x * textHScale;
                    } else {
                      current.x += x * textHScale;
                    }
                    current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                    current.tspan.setAttributeNS(null, "font-size", pf(current.fontSize) + "px");
                    if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
                      current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
                    }
                    if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
                      current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
                    }
                    if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                      current.tspan.setAttributeNS(null, "fill", current.fillColor);
                    }
                    var textMatrix = current.textMatrix;
                    if (current.textRise !== 0) {
                      textMatrix = textMatrix.slice();
                      textMatrix[5] += current.textRise;
                    }
                    current.txtElement.setAttributeNS(null, "transform", pm(textMatrix) + " scale(1, -1)");
                    current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
                    current.txtElement.appendChild(current.tspan);
                    current.txtgrp.appendChild(current.txtElement);
                    this._ensureTransformGroup().appendChild(current.txtElement);
                  },
                  setLeadingMoveText: function SVGGraphics_setLeadingMoveText(x, y) {
                    this.setLeading(-y);
                    this.moveText(x, y);
                  },
                  addFontStyle: function SVGGraphics_addFontStyle(fontObj) {
                    if (!this.cssStyle) {
                      this.cssStyle = this.svgFactory.createElement("svg:style");
                      this.cssStyle.setAttributeNS(null, "type", "text/css");
                      this.defs.appendChild(this.cssStyle);
                    }
                    var url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);
                    this.cssStyle.textContent += '@font-face { font-family: "' + fontObj.loadedName + '"; src: url(' + url + "); }\n";
                  },
                  setFont: function SVGGraphics_setFont(details) {
                    var current = this.current;
                    var fontObj = this.commonObjs.get(details[0]);
                    var size = details[1];
                    this.current.font = fontObj;
                    if (this.embedFonts && fontObj.data && !this.embeddedFonts[fontObj.loadedName]) {
                      this.addFontStyle(fontObj);
                      this.embeddedFonts[fontObj.loadedName] = fontObj;
                    }
                    current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX;
                    var bold = fontObj.black ? fontObj.bold ? "bolder" : "bold" : fontObj.bold ? "bold" : "normal";
                    var italic = fontObj.italic ? "italic" : "normal";
                    if (size < 0) {
                      size = -size;
                      current.fontDirection = -1;
                    } else {
                      current.fontDirection = 1;
                    }
                    current.fontSize = size;
                    current.fontFamily = fontObj.loadedName;
                    current.fontWeight = bold;
                    current.fontStyle = italic;
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    current.xcoords = [];
                  },
                  endText: function SVGGraphics_endText() {
                  },
                  setLineWidth: function SVGGraphics_setLineWidth(width) {
                    this.current.lineWidth = width;
                  },
                  setLineCap: function SVGGraphics_setLineCap(style) {
                    this.current.lineCap = LINE_CAP_STYLES[style];
                  },
                  setLineJoin: function SVGGraphics_setLineJoin(style) {
                    this.current.lineJoin = LINE_JOIN_STYLES[style];
                  },
                  setMiterLimit: function SVGGraphics_setMiterLimit(limit) {
                    this.current.miterLimit = limit;
                  },
                  setStrokeAlpha: function SVGGraphics_setStrokeAlpha(strokeAlpha) {
                    this.current.strokeAlpha = strokeAlpha;
                  },
                  setStrokeRGBColor: function SVGGraphics_setStrokeRGBColor(r, g, b) {
                    var color = _util.Util.makeCssRgb(r, g, b);
                    this.current.strokeColor = color;
                  },
                  setFillAlpha: function SVGGraphics_setFillAlpha(fillAlpha) {
                    this.current.fillAlpha = fillAlpha;
                  },
                  setFillRGBColor: function SVGGraphics_setFillRGBColor(r, g, b) {
                    var color = _util.Util.makeCssRgb(r, g, b);
                    this.current.fillColor = color;
                    this.current.tspan = this.svgFactory.createElement("svg:tspan");
                    this.current.xcoords = [];
                  },
                  setDash: function SVGGraphics_setDash(dashArray, dashPhase) {
                    this.current.dashArray = dashArray;
                    this.current.dashPhase = dashPhase;
                  },
                  constructPath: function SVGGraphics_constructPath(ops, args) {
                    var current = this.current;
                    var x = current.x, y = current.y;
                    current.path = this.svgFactory.createElement("svg:path");
                    var d = [];
                    var opLength = ops.length;
                    for (var i = 0, j = 0; i < opLength; i++) {
                      switch (ops[i] | 0) {
                        case _util.OPS.rectangle:
                          x = args[j++];
                          y = args[j++];
                          var width = args[j++];
                          var height = args[j++];
                          var xw = x + width;
                          var yh = y + height;
                          d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
                          break;
                        case _util.OPS.moveTo:
                          x = args[j++];
                          y = args[j++];
                          d.push("M", pf(x), pf(y));
                          break;
                        case _util.OPS.lineTo:
                          x = args[j++];
                          y = args[j++];
                          d.push("L", pf(x), pf(y));
                          break;
                        case _util.OPS.curveTo:
                          x = args[j + 4];
                          y = args[j + 5];
                          d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
                          j += 6;
                          break;
                        case _util.OPS.curveTo2:
                          x = args[j + 2];
                          y = args[j + 3];
                          d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
                          j += 4;
                          break;
                        case _util.OPS.curveTo3:
                          x = args[j + 2];
                          y = args[j + 3];
                          d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
                          j += 4;
                          break;
                        case _util.OPS.closePath:
                          d.push("Z");
                          break;
                      }
                    }
                    current.path.setAttributeNS(null, "d", d.join(" "));
                    current.path.setAttributeNS(null, "fill", "none");
                    this._ensureTransformGroup().appendChild(current.path);
                    current.element = current.path;
                    current.setCurrentPoint(x, y);
                  },
                  endPath: function SVGGraphics_endPath() {
                    if (!this.pendingClip) {
                      return;
                    }
                    var current = this.current;
                    var clipId = "clippath" + clipCount;
                    clipCount++;
                    var clipPath = this.svgFactory.createElement("svg:clipPath");
                    clipPath.setAttributeNS(null, "id", clipId);
                    clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
                    var clipElement = current.element.cloneNode();
                    if (this.pendingClip === "evenodd") {
                      clipElement.setAttributeNS(null, "clip-rule", "evenodd");
                    } else {
                      clipElement.setAttributeNS(null, "clip-rule", "nonzero");
                    }
                    this.pendingClip = null;
                    clipPath.appendChild(clipElement);
                    this.defs.appendChild(clipPath);
                    if (current.activeClipUrl) {
                      current.clipGroup = null;
                      this.extraStack.forEach(function(prev) {
                        prev.clipGroup = null;
                      });
                      clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
                    }
                    current.activeClipUrl = "url(#" + clipId + ")";
                    this.tgrp = null;
                  },
                  clip: function SVGGraphics_clip(type) {
                    this.pendingClip = type;
                  },
                  closePath: function SVGGraphics_closePath() {
                    var current = this.current;
                    if (current.path) {
                      var d = current.path.getAttributeNS(null, "d");
                      d += "Z";
                      current.path.setAttributeNS(null, "d", d);
                    }
                  },
                  setLeading: function SVGGraphics_setLeading(leading) {
                    this.current.leading = -leading;
                  },
                  setTextRise: function SVGGraphics_setTextRise(textRise) {
                    this.current.textRise = textRise;
                  },
                  setHScale: function SVGGraphics_setHScale(scale) {
                    this.current.textHScale = scale / 100;
                  },
                  setGState: function SVGGraphics_setGState(states) {
                    for (var i = 0, ii = states.length; i < ii; i++) {
                      var state = states[i];
                      var key = state[0];
                      var value = state[1];
                      switch (key) {
                        case "LW":
                          this.setLineWidth(value);
                          break;
                        case "LC":
                          this.setLineCap(value);
                          break;
                        case "LJ":
                          this.setLineJoin(value);
                          break;
                        case "ML":
                          this.setMiterLimit(value);
                          break;
                        case "D":
                          this.setDash(value[0], value[1]);
                          break;
                        case "Font":
                          this.setFont(value);
                          break;
                        case "CA":
                          this.setStrokeAlpha(value);
                          break;
                        case "ca":
                          this.setFillAlpha(value);
                          break;
                        default:
                          (0, _util.warn)("Unimplemented graphic state " + key);
                          break;
                      }
                    }
                  },
                  fill: function SVGGraphics_fill() {
                    var current = this.current;
                    if (current.element) {
                      current.element.setAttributeNS(null, "fill", current.fillColor);
                      current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                      this.endPath();
                    }
                  },
                  stroke: function SVGGraphics_stroke() {
                    var current = this.current;
                    if (current.element) {
                      current.element.setAttributeNS(null, "stroke", current.strokeColor);
                      current.element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
                      current.element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
                      current.element.setAttributeNS(null, "stroke-linecap", current.lineCap);
                      current.element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
                      current.element.setAttributeNS(null, "stroke-width", pf(current.lineWidth) + "px");
                      current.element.setAttributeNS(null, "stroke-dasharray", current.dashArray.map(pf).join(" "));
                      current.element.setAttributeNS(null, "stroke-dashoffset", pf(current.dashPhase) + "px");
                      current.element.setAttributeNS(null, "fill", "none");
                      this.endPath();
                    }
                  },
                  eoFill: function SVGGraphics_eoFill() {
                    if (this.current.element) {
                      this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                    }
                    this.fill();
                  },
                  fillStroke: function SVGGraphics_fillStroke() {
                    this.stroke();
                    this.fill();
                  },
                  eoFillStroke: function SVGGraphics_eoFillStroke() {
                    if (this.current.element) {
                      this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                    }
                    this.fillStroke();
                  },
                  closeStroke: function SVGGraphics_closeStroke() {
                    this.closePath();
                    this.stroke();
                  },
                  closeFillStroke: function SVGGraphics_closeFillStroke() {
                    this.closePath();
                    this.fillStroke();
                  },
                  closeEOFillStroke: function closeEOFillStroke() {
                    this.closePath();
                    this.eoFillStroke();
                  },
                  paintSolidColorImageMask: function SVGGraphics_paintSolidColorImageMask() {
                    var current = this.current;
                    var rect = this.svgFactory.createElement("svg:rect");
                    rect.setAttributeNS(null, "x", "0");
                    rect.setAttributeNS(null, "y", "0");
                    rect.setAttributeNS(null, "width", "1px");
                    rect.setAttributeNS(null, "height", "1px");
                    rect.setAttributeNS(null, "fill", current.fillColor);
                    this._ensureTransformGroup().appendChild(rect);
                  },
                  paintJpegXObject: function SVGGraphics_paintJpegXObject(objId, w, h) {
                    var imgObj = this.objs.get(objId);
                    var imgEl = this.svgFactory.createElement("svg:image");
                    imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgObj.src);
                    imgEl.setAttributeNS(null, "width", pf(w));
                    imgEl.setAttributeNS(null, "height", pf(h));
                    imgEl.setAttributeNS(null, "x", "0");
                    imgEl.setAttributeNS(null, "y", pf(-h));
                    imgEl.setAttributeNS(null, "transform", "scale(" + pf(1 / w) + " " + pf(-1 / h) + ")");
                    this._ensureTransformGroup().appendChild(imgEl);
                  },
                  paintImageXObject: function SVGGraphics_paintImageXObject(objId) {
                    var imgData = this.objs.get(objId);
                    if (!imgData) {
                      (0, _util.warn)("Dependent image isn't ready yet");
                      return;
                    }
                    this.paintInlineImageXObject(imgData);
                  },
                  paintInlineImageXObject: function SVGGraphics_paintInlineImageXObject(imgData, mask) {
                    var width = imgData.width;
                    var height = imgData.height;
                    var imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
                    var cliprect = this.svgFactory.createElement("svg:rect");
                    cliprect.setAttributeNS(null, "x", "0");
                    cliprect.setAttributeNS(null, "y", "0");
                    cliprect.setAttributeNS(null, "width", pf(width));
                    cliprect.setAttributeNS(null, "height", pf(height));
                    this.current.element = cliprect;
                    this.clip("nonzero");
                    var imgEl = this.svgFactory.createElement("svg:image");
                    imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
                    imgEl.setAttributeNS(null, "x", "0");
                    imgEl.setAttributeNS(null, "y", pf(-height));
                    imgEl.setAttributeNS(null, "width", pf(width) + "px");
                    imgEl.setAttributeNS(null, "height", pf(height) + "px");
                    imgEl.setAttributeNS(null, "transform", "scale(" + pf(1 / width) + " " + pf(-1 / height) + ")");
                    if (mask) {
                      mask.appendChild(imgEl);
                    } else {
                      this._ensureTransformGroup().appendChild(imgEl);
                    }
                  },
                  paintImageMaskXObject: function SVGGraphics_paintImageMaskXObject(imgData) {
                    var current = this.current;
                    var width = imgData.width;
                    var height = imgData.height;
                    var fillColor = current.fillColor;
                    current.maskId = "mask" + maskCount++;
                    var mask = this.svgFactory.createElement("svg:mask");
                    mask.setAttributeNS(null, "id", current.maskId);
                    var rect = this.svgFactory.createElement("svg:rect");
                    rect.setAttributeNS(null, "x", "0");
                    rect.setAttributeNS(null, "y", "0");
                    rect.setAttributeNS(null, "width", pf(width));
                    rect.setAttributeNS(null, "height", pf(height));
                    rect.setAttributeNS(null, "fill", fillColor);
                    rect.setAttributeNS(null, "mask", "url(#" + current.maskId + ")");
                    this.defs.appendChild(mask);
                    this._ensureTransformGroup().appendChild(rect);
                    this.paintInlineImageXObject(imgData, mask);
                  },
                  paintFormXObjectBegin: function SVGGraphics_paintFormXObjectBegin(matrix, bbox) {
                    if (Array.isArray(matrix) && matrix.length === 6) {
                      this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                    }
                    if (Array.isArray(bbox) && bbox.length === 4) {
                      var width = bbox[2] - bbox[0];
                      var height = bbox[3] - bbox[1];
                      var cliprect = this.svgFactory.createElement("svg:rect");
                      cliprect.setAttributeNS(null, "x", bbox[0]);
                      cliprect.setAttributeNS(null, "y", bbox[1]);
                      cliprect.setAttributeNS(null, "width", pf(width));
                      cliprect.setAttributeNS(null, "height", pf(height));
                      this.current.element = cliprect;
                      this.clip("nonzero");
                      this.endPath();
                    }
                  },
                  paintFormXObjectEnd: function SVGGraphics_paintFormXObjectEnd() {
                  },
                  _initialize: function _initialize(viewport) {
                    var svg = this.svgFactory.create(viewport.width, viewport.height);
                    var definitions = this.svgFactory.createElement("svg:defs");
                    svg.appendChild(definitions);
                    this.defs = definitions;
                    var rootGroup = this.svgFactory.createElement("svg:g");
                    rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
                    svg.appendChild(rootGroup);
                    this.svg = rootGroup;
                    return svg;
                  },
                  _ensureClipGroup: function SVGGraphics_ensureClipGroup() {
                    if (!this.current.clipGroup) {
                      var clipGroup = this.svgFactory.createElement("svg:g");
                      clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
                      this.svg.appendChild(clipGroup);
                      this.current.clipGroup = clipGroup;
                    }
                    return this.current.clipGroup;
                  },
                  _ensureTransformGroup: function SVGGraphics_ensureTransformGroup() {
                    if (!this.tgrp) {
                      this.tgrp = this.svgFactory.createElement("svg:g");
                      this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));
                      if (this.current.activeClipUrl) {
                        this._ensureClipGroup().appendChild(this.tgrp);
                      } else {
                        this.svg.appendChild(this.tgrp);
                      }
                    }
                    return this.tgrp;
                  }
                };
                return SVGGraphics2;
              }();
            }
            exports3.SVGGraphics = SVGGraphics;
          },
          /* 129 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.PDFNodeStream = void 0;
            var _createClass = /* @__PURE__ */ function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _util = __w_pdfjs_require__(1);
            var _network_utils = __w_pdfjs_require__(130);
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var fs = require_fs();
            var http = require_http();
            var https = require_https();
            var url = require_url();
            var fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
            function parseUrl(sourceUrl) {
              var parsedUrl = url.parse(sourceUrl);
              if (parsedUrl.protocol === "file:" || parsedUrl.host) {
                return parsedUrl;
              }
              if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
                return url.parse("file:///" + sourceUrl);
              }
              if (!parsedUrl.host) {
                parsedUrl.protocol = "file:";
              }
              return parsedUrl;
            }
            var PDFNodeStream = function() {
              function PDFNodeStream2(source) {
                _classCallCheck(this, PDFNodeStream2);
                this.source = source;
                this.url = parseUrl(source.url);
                this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
                this.isFsUrl = this.url.protocol === "file:";
                this.httpHeaders = this.isHttp && source.httpHeaders || {};
                this._fullRequest = null;
                this._rangeRequestReaders = [];
              }
              _createClass(PDFNodeStream2, [{
                key: "getFullReader",
                value: function getFullReader() {
                  (0, _util.assert)(!this._fullRequest);
                  this._fullRequest = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
                  return this._fullRequest;
                }
              }, {
                key: "getRangeReader",
                value: function getRangeReader(start, end) {
                  var rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);
                  this._rangeRequestReaders.push(rangeReader);
                  return rangeReader;
                }
              }, {
                key: "cancelAllRequests",
                value: function cancelAllRequests(reason) {
                  if (this._fullRequest) {
                    this._fullRequest.cancel(reason);
                  }
                  var readers = this._rangeRequestReaders.slice(0);
                  readers.forEach(function(reader) {
                    reader.cancel(reason);
                  });
                }
              }]);
              return PDFNodeStream2;
            }();
            var BaseFullReader = function() {
              function BaseFullReader2(stream2) {
                _classCallCheck(this, BaseFullReader2);
                this._url = stream2.url;
                this._done = false;
                this._errored = false;
                this._reason = null;
                this.onProgress = null;
                var source = stream2.source;
                this._contentLength = source.length;
                this._loaded = 0;
                this._filename = null;
                this._disableRange = source.disableRange || false;
                this._rangeChunkSize = source.rangeChunkSize;
                if (!this._rangeChunkSize && !this._disableRange) {
                  this._disableRange = true;
                }
                this._isStreamingSupported = !source.disableStream;
                this._isRangeSupported = !source.disableRange;
                this._readableStream = null;
                this._readCapability = (0, _util.createPromiseCapability)();
                this._headersCapability = (0, _util.createPromiseCapability)();
              }
              _createClass(BaseFullReader2, [{
                key: "read",
                value: function read() {
                  var _this = this;
                  return this._readCapability.promise.then(function() {
                    if (_this._done) {
                      return Promise.resolve({
                        value: void 0,
                        done: true
                      });
                    }
                    if (_this._errored) {
                      return Promise.reject(_this._reason);
                    }
                    var chunk = _this._readableStream.read();
                    if (chunk === null) {
                      _this._readCapability = (0, _util.createPromiseCapability)();
                      return _this.read();
                    }
                    _this._loaded += chunk.length;
                    if (_this.onProgress) {
                      _this.onProgress({
                        loaded: _this._loaded,
                        total: _this._contentLength
                      });
                    }
                    var buffer = new Uint8Array(chunk).buffer;
                    return Promise.resolve({
                      value: buffer,
                      done: false
                    });
                  });
                }
              }, {
                key: "cancel",
                value: function cancel(reason) {
                  if (!this._readableStream) {
                    this._error(reason);
                    return;
                  }
                  this._readableStream.destroy(reason);
                }
              }, {
                key: "_error",
                value: function _error(reason) {
                  this._errored = true;
                  this._reason = reason;
                  this._readCapability.resolve();
                }
              }, {
                key: "_setReadableStream",
                value: function _setReadableStream(readableStream2) {
                  var _this2 = this;
                  this._readableStream = readableStream2;
                  readableStream2.on("readable", function() {
                    _this2._readCapability.resolve();
                  });
                  readableStream2.on("end", function() {
                    readableStream2.destroy();
                    _this2._done = true;
                    _this2._readCapability.resolve();
                  });
                  readableStream2.on("error", function(reason) {
                    _this2._error(reason);
                  });
                  if (!this._isStreamingSupported && this._isRangeSupported) {
                    this._error(new _util.AbortException("streaming is disabled"));
                  }
                  if (this._errored) {
                    this._readableStream.destroy(this._reason);
                  }
                }
              }, {
                key: "headersReady",
                get: function get() {
                  return this._headersCapability.promise;
                }
              }, {
                key: "filename",
                get: function get() {
                  return this._filename;
                }
              }, {
                key: "contentLength",
                get: function get() {
                  return this._contentLength;
                }
              }, {
                key: "isRangeSupported",
                get: function get() {
                  return this._isRangeSupported;
                }
              }, {
                key: "isStreamingSupported",
                get: function get() {
                  return this._isStreamingSupported;
                }
              }]);
              return BaseFullReader2;
            }();
            var BaseRangeReader = function() {
              function BaseRangeReader2(stream2) {
                _classCallCheck(this, BaseRangeReader2);
                this._url = stream2.url;
                this._done = false;
                this._errored = false;
                this._reason = null;
                this.onProgress = null;
                this._loaded = 0;
                this._readableStream = null;
                this._readCapability = (0, _util.createPromiseCapability)();
                var source = stream2.source;
                this._isStreamingSupported = !source.disableStream;
              }
              _createClass(BaseRangeReader2, [{
                key: "read",
                value: function read() {
                  var _this3 = this;
                  return this._readCapability.promise.then(function() {
                    if (_this3._done) {
                      return Promise.resolve({
                        value: void 0,
                        done: true
                      });
                    }
                    if (_this3._errored) {
                      return Promise.reject(_this3._reason);
                    }
                    var chunk = _this3._readableStream.read();
                    if (chunk === null) {
                      _this3._readCapability = (0, _util.createPromiseCapability)();
                      return _this3.read();
                    }
                    _this3._loaded += chunk.length;
                    if (_this3.onProgress) {
                      _this3.onProgress({ loaded: _this3._loaded });
                    }
                    var buffer = new Uint8Array(chunk).buffer;
                    return Promise.resolve({
                      value: buffer,
                      done: false
                    });
                  });
                }
              }, {
                key: "cancel",
                value: function cancel(reason) {
                  if (!this._readableStream) {
                    this._error(reason);
                    return;
                  }
                  this._readableStream.destroy(reason);
                }
              }, {
                key: "_error",
                value: function _error(reason) {
                  this._errored = true;
                  this._reason = reason;
                  this._readCapability.resolve();
                }
              }, {
                key: "_setReadableStream",
                value: function _setReadableStream(readableStream2) {
                  var _this4 = this;
                  this._readableStream = readableStream2;
                  readableStream2.on("readable", function() {
                    _this4._readCapability.resolve();
                  });
                  readableStream2.on("end", function() {
                    readableStream2.destroy();
                    _this4._done = true;
                    _this4._readCapability.resolve();
                  });
                  readableStream2.on("error", function(reason) {
                    _this4._error(reason);
                  });
                  if (this._errored) {
                    this._readableStream.destroy(this._reason);
                  }
                }
              }, {
                key: "isStreamingSupported",
                get: function get() {
                  return this._isStreamingSupported;
                }
              }]);
              return BaseRangeReader2;
            }();
            function createRequestOptions(url2, headers) {
              return {
                protocol: url2.protocol,
                auth: url2.auth,
                host: url2.hostname,
                port: url2.port,
                path: url2.path,
                method: "GET",
                headers
              };
            }
            var PDFNodeStreamFullReader = function(_BaseFullReader) {
              _inherits(PDFNodeStreamFullReader2, _BaseFullReader);
              function PDFNodeStreamFullReader2(stream2) {
                _classCallCheck(this, PDFNodeStreamFullReader2);
                var _this5 = _possibleConstructorReturn(this, (PDFNodeStreamFullReader2.__proto__ || Object.getPrototypeOf(PDFNodeStreamFullReader2)).call(this, stream2));
                var handleResponse = function handleResponse2(response) {
                  _this5._headersCapability.resolve();
                  _this5._setReadableStream(response);
                  var getResponseHeader = function getResponseHeader2(name) {
                    return _this5._readableStream.headers[name.toLowerCase()];
                  };
                  var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({
                    getResponseHeader,
                    isHttp: stream2.isHttp,
                    rangeChunkSize: _this5._rangeChunkSize,
                    disableRange: _this5._disableRange
                  }), allowRangeRequests = _validateRangeRequest.allowRangeRequests, suggestedLength = _validateRangeRequest.suggestedLength;
                  _this5._isRangeSupported = allowRangeRequests;
                  _this5._contentLength = suggestedLength || _this5._contentLength;
                  _this5._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                };
                _this5._request = null;
                if (_this5._url.protocol === "http:") {
                  _this5._request = http.request(createRequestOptions(_this5._url, stream2.httpHeaders), handleResponse);
                } else {
                  _this5._request = https.request(createRequestOptions(_this5._url, stream2.httpHeaders), handleResponse);
                }
                _this5._request.on("error", function(reason) {
                  _this5._errored = true;
                  _this5._reason = reason;
                  _this5._headersCapability.reject(reason);
                });
                _this5._request.end();
                return _this5;
              }
              return PDFNodeStreamFullReader2;
            }(BaseFullReader);
            var PDFNodeStreamRangeReader = function(_BaseRangeReader) {
              _inherits(PDFNodeStreamRangeReader2, _BaseRangeReader);
              function PDFNodeStreamRangeReader2(stream2, start, end) {
                _classCallCheck(this, PDFNodeStreamRangeReader2);
                var _this6 = _possibleConstructorReturn(this, (PDFNodeStreamRangeReader2.__proto__ || Object.getPrototypeOf(PDFNodeStreamRangeReader2)).call(this, stream2));
                _this6._httpHeaders = {};
                for (var property in stream2.httpHeaders) {
                  var value = stream2.httpHeaders[property];
                  if (typeof value === "undefined") {
                    continue;
                  }
                  _this6._httpHeaders[property] = value;
                }
                _this6._httpHeaders["Range"] = "bytes=" + start + "-" + (end - 1);
                _this6._request = null;
                if (_this6._url.protocol === "http:") {
                  _this6._request = http.request(createRequestOptions(_this6._url, _this6._httpHeaders), function(response) {
                    _this6._setReadableStream(response);
                  });
                } else {
                  _this6._request = https.request(createRequestOptions(_this6._url, _this6._httpHeaders), function(response) {
                    _this6._setReadableStream(response);
                  });
                }
                _this6._request.on("error", function(reason) {
                  _this6._errored = true;
                  _this6._reason = reason;
                });
                _this6._request.end();
                return _this6;
              }
              return PDFNodeStreamRangeReader2;
            }(BaseRangeReader);
            var PDFNodeStreamFsFullReader = function(_BaseFullReader2) {
              _inherits(PDFNodeStreamFsFullReader2, _BaseFullReader2);
              function PDFNodeStreamFsFullReader2(stream2) {
                _classCallCheck(this, PDFNodeStreamFsFullReader2);
                var _this7 = _possibleConstructorReturn(this, (PDFNodeStreamFsFullReader2.__proto__ || Object.getPrototypeOf(PDFNodeStreamFsFullReader2)).call(this, stream2));
                var path = decodeURIComponent(_this7._url.path);
                if (fileUriRegex.test(_this7._url.href)) {
                  path = path.replace(/^\//, "");
                }
                fs.lstat(path, function(error, stat) {
                  if (error) {
                    _this7._errored = true;
                    _this7._reason = error;
                    _this7._headersCapability.reject(error);
                    return;
                  }
                  _this7._contentLength = stat.size;
                  _this7._setReadableStream(fs.createReadStream(path));
                  _this7._headersCapability.resolve();
                });
                return _this7;
              }
              return PDFNodeStreamFsFullReader2;
            }(BaseFullReader);
            var PDFNodeStreamFsRangeReader = function(_BaseRangeReader2) {
              _inherits(PDFNodeStreamFsRangeReader2, _BaseRangeReader2);
              function PDFNodeStreamFsRangeReader2(stream2, start, end) {
                _classCallCheck(this, PDFNodeStreamFsRangeReader2);
                var _this8 = _possibleConstructorReturn(this, (PDFNodeStreamFsRangeReader2.__proto__ || Object.getPrototypeOf(PDFNodeStreamFsRangeReader2)).call(this, stream2));
                var path = decodeURIComponent(_this8._url.path);
                if (fileUriRegex.test(_this8._url.href)) {
                  path = path.replace(/^\//, "");
                }
                _this8._setReadableStream(fs.createReadStream(path, {
                  start,
                  end: end - 1
                }));
                return _this8;
              }
              return PDFNodeStreamFsRangeReader2;
            }(BaseRangeReader);
            exports3.PDFNodeStream = PDFNodeStream;
          },
          /* 130 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.validateResponseStatus = exports3.validateRangeRequestCapabilities = exports3.extractFilenameFromHeader = exports3.createResponseStatusError = void 0;
            var _util = __w_pdfjs_require__(1);
            var _content_disposition = __w_pdfjs_require__(131);
            function validateRangeRequestCapabilities(_ref) {
              var getResponseHeader = _ref.getResponseHeader, isHttp = _ref.isHttp, rangeChunkSize = _ref.rangeChunkSize, disableRange = _ref.disableRange;
              (0, _util.assert)(rangeChunkSize > 0, "Range chunk size must be larger than zero");
              var returnValues = {
                allowRangeRequests: false,
                suggestedLength: void 0
              };
              if (disableRange || !isHttp) {
                return returnValues;
              }
              if (getResponseHeader("Accept-Ranges") !== "bytes") {
                return returnValues;
              }
              var contentEncoding = getResponseHeader("Content-Encoding") || "identity";
              if (contentEncoding !== "identity") {
                return returnValues;
              }
              var length = parseInt(getResponseHeader("Content-Length"), 10);
              if (!Number.isInteger(length)) {
                return returnValues;
              }
              returnValues.suggestedLength = length;
              if (length <= 2 * rangeChunkSize) {
                return returnValues;
              }
              returnValues.allowRangeRequests = true;
              return returnValues;
            }
            function extractFilenameFromHeader(getResponseHeader) {
              var contentDisposition = getResponseHeader("Content-Disposition");
              if (contentDisposition) {
                var filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);
                if (/\.pdf$/i.test(filename)) {
                  return filename;
                }
              }
              return null;
            }
            function createResponseStatusError(status, url) {
              if (status === 404 || status === 0 && /^file:/.test(url)) {
                return new _util.MissingPDFException('Missing PDF "' + url + '".');
              }
              return new _util.UnexpectedResponseException("Unexpected server response (" + status + ') while retrieving PDF "' + url + '".', status);
            }
            function validateResponseStatus(status) {
              return status === 200 || status === 206;
            }
            exports3.createResponseStatusError = createResponseStatusError;
            exports3.extractFilenameFromHeader = extractFilenameFromHeader;
            exports3.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
            exports3.validateResponseStatus = validateResponseStatus;
          },
          /* 131 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            function getFilenameFromContentDispositionHeader(contentDisposition) {
              var needsEncodingFixup = true;
              var tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
              if (tmp) {
                tmp = tmp[1];
                var filename = rfc2616unquote(tmp);
                filename = unescape(filename);
                filename = rfc5987decode(filename);
                filename = rfc2047decode(filename);
                return fixupEncoding(filename);
              }
              tmp = rfc2231getparam(contentDisposition);
              if (tmp) {
                var _filename = rfc2047decode(tmp);
                return fixupEncoding(_filename);
              }
              tmp = toParamRegExp("filename", "i").exec(contentDisposition);
              if (tmp) {
                tmp = tmp[1];
                var _filename2 = rfc2616unquote(tmp);
                _filename2 = rfc2047decode(_filename2);
                return fixupEncoding(_filename2);
              }
              function toParamRegExp(attributePattern, flags) {
                return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
              }
              function textdecode(encoding, value) {
                if (encoding) {
                  if (!/^[\x00-\xFF]+$/.test(value)) {
                    return value;
                  }
                  try {
                    var decoder = new TextDecoder(encoding, { fatal: true });
                    var bytes = new Array(value.length);
                    for (var i = 0; i < value.length; ++i) {
                      bytes[i] = value.charCodeAt(i);
                    }
                    value = decoder.decode(new Uint8Array(bytes));
                    needsEncodingFixup = false;
                  } catch (e) {
                    if (/^utf-?8$/i.test(encoding)) {
                      try {
                        value = decodeURIComponent(escape(value));
                        needsEncodingFixup = false;
                      } catch (err) {
                      }
                    }
                  }
                }
                return value;
              }
              function fixupEncoding(value) {
                if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
                  value = textdecode("utf-8", value);
                  if (needsEncodingFixup) {
                    value = textdecode("iso-8859-1", value);
                  }
                }
                return value;
              }
              function rfc2231getparam(contentDisposition2) {
                var matches = [], match = void 0;
                var iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                while ((match = iter.exec(contentDisposition2)) !== null) {
                  var _match = match, _match2 = _slicedToArray(_match, 4), n = _match2[1], quot = _match2[2], part = _match2[3];
                  n = parseInt(n, 10);
                  if (n in matches) {
                    if (n === 0) {
                      break;
                    }
                    continue;
                  }
                  matches[n] = [quot, part];
                }
                var parts = [];
                for (var _n = 0; _n < matches.length; ++_n) {
                  if (!(_n in matches)) {
                    break;
                  }
                  var _matches$_n = _slicedToArray(matches[_n], 2), _quot = _matches$_n[0], _part = _matches$_n[1];
                  _part = rfc2616unquote(_part);
                  if (_quot) {
                    _part = unescape(_part);
                    if (_n === 0) {
                      _part = rfc5987decode(_part);
                    }
                  }
                  parts.push(_part);
                }
                return parts.join("");
              }
              function rfc2616unquote(value) {
                if (value.charAt(0) === '"') {
                  var parts = value.slice(1).split('\\"');
                  for (var i = 0; i < parts.length; ++i) {
                    var quotindex = parts[i].indexOf('"');
                    if (quotindex !== -1) {
                      parts[i] = parts[i].slice(0, quotindex);
                      parts.length = i + 1;
                    }
                    parts[i] = parts[i].replace(/\\(.)/g, "$1");
                  }
                  value = parts.join('"');
                }
                return value;
              }
              function rfc5987decode(extvalue) {
                var encodingend = extvalue.indexOf("'");
                if (encodingend === -1) {
                  return extvalue;
                }
                var encoding = extvalue.slice(0, encodingend);
                var langvalue = extvalue.slice(encodingend + 1);
                var value = langvalue.replace(/^[^']*'/, "");
                return textdecode(encoding, value);
              }
              function rfc2047decode(value) {
                if (value.slice(0, 2) !== "=?" || /[\x00-\x19\x80-\xff]/.test(value)) {
                  return value;
                }
                return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(_, charset, encoding, text) {
                  if (encoding === "q" || encoding === "Q") {
                    text = text.replace(/_/g, " ");
                    text = text.replace(/=([0-9a-fA-F]{2})/g, function(_2, hex) {
                      return String.fromCharCode(parseInt(hex, 16));
                    });
                    return textdecode(charset, text);
                  }
                  try {
                    text = atob(text);
                  } catch (e) {
                  }
                  return textdecode(charset, text);
                });
              }
              return "";
            }
            exports3.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;
          },
          /* 132 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.PDFFetchStream = void 0;
            var _createClass = /* @__PURE__ */ function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _util = __w_pdfjs_require__(1);
            var _network_utils = __w_pdfjs_require__(130);
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function createFetchOptions(headers, withCredentials, abortController) {
              return {
                method: "GET",
                headers,
                signal: abortController && abortController.signal,
                mode: "cors",
                credentials: withCredentials ? "include" : "same-origin",
                redirect: "follow"
              };
            }
            var PDFFetchStream = function() {
              function PDFFetchStream2(source) {
                _classCallCheck(this, PDFFetchStream2);
                this.source = source;
                this.isHttp = /^https?:/i.test(source.url);
                this.httpHeaders = this.isHttp && source.httpHeaders || {};
                this._fullRequestReader = null;
                this._rangeRequestReaders = [];
              }
              _createClass(PDFFetchStream2, [{
                key: "getFullReader",
                value: function getFullReader() {
                  (0, _util.assert)(!this._fullRequestReader);
                  this._fullRequestReader = new PDFFetchStreamReader(this);
                  return this._fullRequestReader;
                }
              }, {
                key: "getRangeReader",
                value: function getRangeReader(begin, end) {
                  var reader = new PDFFetchStreamRangeReader(this, begin, end);
                  this._rangeRequestReaders.push(reader);
                  return reader;
                }
              }, {
                key: "cancelAllRequests",
                value: function cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  var readers = this._rangeRequestReaders.slice(0);
                  readers.forEach(function(reader) {
                    reader.cancel(reason);
                  });
                }
              }]);
              return PDFFetchStream2;
            }();
            var PDFFetchStreamReader = function() {
              function PDFFetchStreamReader2(stream2) {
                var _this = this;
                _classCallCheck(this, PDFFetchStreamReader2);
                this._stream = stream2;
                this._reader = null;
                this._loaded = 0;
                this._filename = null;
                var source = stream2.source;
                this._withCredentials = source.withCredentials;
                this._contentLength = source.length;
                this._headersCapability = (0, _util.createPromiseCapability)();
                this._disableRange = source.disableRange || false;
                this._rangeChunkSize = source.rangeChunkSize;
                if (!this._rangeChunkSize && !this._disableRange) {
                  this._disableRange = true;
                }
                if (typeof AbortController !== "undefined") {
                  this._abortController = new AbortController();
                }
                this._isStreamingSupported = !source.disableStream;
                this._isRangeSupported = !source.disableRange;
                this._headers = new Headers();
                for (var property in this._stream.httpHeaders) {
                  var value = this._stream.httpHeaders[property];
                  if (typeof value === "undefined") {
                    continue;
                  }
                  this._headers.append(property, value);
                }
                var url = source.url;
                fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function(response) {
                  if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                    throw (0, _network_utils.createResponseStatusError)(response.status, url);
                  }
                  _this._reader = response.body.getReader();
                  _this._headersCapability.resolve();
                  var getResponseHeader = function getResponseHeader2(name) {
                    return response.headers.get(name);
                  };
                  var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({
                    getResponseHeader,
                    isHttp: _this._stream.isHttp,
                    rangeChunkSize: _this._rangeChunkSize,
                    disableRange: _this._disableRange
                  }), allowRangeRequests = _validateRangeRequest.allowRangeRequests, suggestedLength = _validateRangeRequest.suggestedLength;
                  _this._isRangeSupported = allowRangeRequests;
                  _this._contentLength = suggestedLength || _this._contentLength;
                  _this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  if (!_this._isStreamingSupported && _this._isRangeSupported) {
                    _this.cancel(new _util.AbortException("streaming is disabled"));
                  }
                }).catch(this._headersCapability.reject);
                this.onProgress = null;
              }
              _createClass(PDFFetchStreamReader2, [{
                key: "read",
                value: function read() {
                  var _this2 = this;
                  return this._headersCapability.promise.then(function() {
                    return _this2._reader.read().then(function(_ref) {
                      var value = _ref.value, done = _ref.done;
                      if (done) {
                        return Promise.resolve({
                          value,
                          done
                        });
                      }
                      _this2._loaded += value.byteLength;
                      if (_this2.onProgress) {
                        _this2.onProgress({
                          loaded: _this2._loaded,
                          total: _this2._contentLength
                        });
                      }
                      var buffer = new Uint8Array(value).buffer;
                      return Promise.resolve({
                        value: buffer,
                        done: false
                      });
                    });
                  });
                }
              }, {
                key: "cancel",
                value: function cancel(reason) {
                  if (this._reader) {
                    this._reader.cancel(reason);
                  }
                  if (this._abortController) {
                    this._abortController.abort();
                  }
                }
              }, {
                key: "headersReady",
                get: function get() {
                  return this._headersCapability.promise;
                }
              }, {
                key: "filename",
                get: function get() {
                  return this._filename;
                }
              }, {
                key: "contentLength",
                get: function get() {
                  return this._contentLength;
                }
              }, {
                key: "isRangeSupported",
                get: function get() {
                  return this._isRangeSupported;
                }
              }, {
                key: "isStreamingSupported",
                get: function get() {
                  return this._isStreamingSupported;
                }
              }]);
              return PDFFetchStreamReader2;
            }();
            var PDFFetchStreamRangeReader = function() {
              function PDFFetchStreamRangeReader2(stream2, begin, end) {
                var _this3 = this;
                _classCallCheck(this, PDFFetchStreamRangeReader2);
                this._stream = stream2;
                this._reader = null;
                this._loaded = 0;
                var source = stream2.source;
                this._withCredentials = source.withCredentials;
                this._readCapability = (0, _util.createPromiseCapability)();
                this._isStreamingSupported = !source.disableStream;
                if (typeof AbortController !== "undefined") {
                  this._abortController = new AbortController();
                }
                this._headers = new Headers();
                for (var property in this._stream.httpHeaders) {
                  var value = this._stream.httpHeaders[property];
                  if (typeof value === "undefined") {
                    continue;
                  }
                  this._headers.append(property, value);
                }
                var rangeStr = begin + "-" + (end - 1);
                this._headers.append("Range", "bytes=" + rangeStr);
                var url = source.url;
                fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function(response) {
                  if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                    throw (0, _network_utils.createResponseStatusError)(response.status, url);
                  }
                  _this3._readCapability.resolve();
                  _this3._reader = response.body.getReader();
                });
                this.onProgress = null;
              }
              _createClass(PDFFetchStreamRangeReader2, [{
                key: "read",
                value: function read() {
                  var _this4 = this;
                  return this._readCapability.promise.then(function() {
                    return _this4._reader.read().then(function(_ref2) {
                      var value = _ref2.value, done = _ref2.done;
                      if (done) {
                        return Promise.resolve({
                          value,
                          done
                        });
                      }
                      _this4._loaded += value.byteLength;
                      if (_this4.onProgress) {
                        _this4.onProgress({ loaded: _this4._loaded });
                      }
                      var buffer = new Uint8Array(value).buffer;
                      return Promise.resolve({
                        value: buffer,
                        done: false
                      });
                    });
                  });
                }
              }, {
                key: "cancel",
                value: function cancel(reason) {
                  if (this._reader) {
                    this._reader.cancel(reason);
                  }
                  if (this._abortController) {
                    this._abortController.abort();
                  }
                }
              }, {
                key: "isStreamingSupported",
                get: function get() {
                  return this._isStreamingSupported;
                }
              }]);
              return PDFFetchStreamRangeReader2;
            }();
            exports3.PDFFetchStream = PDFFetchStream;
          },
          /* 133 */
          /***/
          function(module3, exports3, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.NetworkManager = exports3.PDFNetworkStream = void 0;
            var _util = __w_pdfjs_require__(1);
            var _network_utils = __w_pdfjs_require__(130);
            var _global_scope = __w_pdfjs_require__(3);
            var _global_scope2 = _interopRequireDefault(_global_scope);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            ;
            var OK_RESPONSE = 200;
            var PARTIAL_CONTENT_RESPONSE = 206;
            function NetworkManager(url, args) {
              this.url = url;
              args = args || {};
              this.isHttp = /^https?:/i.test(url);
              this.httpHeaders = this.isHttp && args.httpHeaders || {};
              this.withCredentials = args.withCredentials || false;
              this.getXhr = args.getXhr || function NetworkManager_getXhr() {
                return new XMLHttpRequest();
              };
              this.currXhrId = 0;
              this.pendingRequests = /* @__PURE__ */ Object.create(null);
              this.loadedRequests = /* @__PURE__ */ Object.create(null);
            }
            function getArrayBuffer(xhr) {
              var data = xhr.response;
              if (typeof data !== "string") {
                return data;
              }
              var array = (0, _util.stringToBytes)(data);
              return array.buffer;
            }
            var supportsMozChunked = function supportsMozChunkedClosure() {
              try {
                var x = new XMLHttpRequest();
                x.open("GET", _global_scope2.default.location.href);
                x.responseType = "moz-chunked-arraybuffer";
                return x.responseType === "moz-chunked-arraybuffer";
              } catch (e) {
                return false;
              }
            }();
            NetworkManager.prototype = {
              requestRange: function NetworkManager_requestRange(begin, end, listeners) {
                var args = {
                  begin,
                  end
                };
                for (var prop in listeners) {
                  args[prop] = listeners[prop];
                }
                return this.request(args);
              },
              requestFull: function NetworkManager_requestFull(listeners) {
                return this.request(listeners);
              },
              request: function NetworkManager_request(args) {
                var xhr = this.getXhr();
                var xhrId = this.currXhrId++;
                var pendingRequest = this.pendingRequests[xhrId] = { xhr };
                xhr.open("GET", this.url);
                xhr.withCredentials = this.withCredentials;
                for (var property in this.httpHeaders) {
                  var value = this.httpHeaders[property];
                  if (typeof value === "undefined") {
                    continue;
                  }
                  xhr.setRequestHeader(property, value);
                }
                if (this.isHttp && "begin" in args && "end" in args) {
                  var rangeStr = args.begin + "-" + (args.end - 1);
                  xhr.setRequestHeader("Range", "bytes=" + rangeStr);
                  pendingRequest.expectedStatus = 206;
                } else {
                  pendingRequest.expectedStatus = 200;
                }
                var useMozChunkedLoading = supportsMozChunked && !!args.onProgressiveData;
                if (useMozChunkedLoading) {
                  xhr.responseType = "moz-chunked-arraybuffer";
                  pendingRequest.onProgressiveData = args.onProgressiveData;
                  pendingRequest.mozChunked = true;
                } else {
                  xhr.responseType = "arraybuffer";
                }
                if (args.onError) {
                  xhr.onerror = function(evt) {
                    args.onError(xhr.status);
                  };
                }
                xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
                xhr.onprogress = this.onProgress.bind(this, xhrId);
                pendingRequest.onHeadersReceived = args.onHeadersReceived;
                pendingRequest.onDone = args.onDone;
                pendingRequest.onError = args.onError;
                pendingRequest.onProgress = args.onProgress;
                xhr.send(null);
                return xhrId;
              },
              onProgress: function NetworkManager_onProgress(xhrId, evt) {
                var pendingRequest = this.pendingRequests[xhrId];
                if (!pendingRequest) {
                  return;
                }
                if (pendingRequest.mozChunked) {
                  var chunk = getArrayBuffer(pendingRequest.xhr);
                  pendingRequest.onProgressiveData(chunk);
                }
                var onProgress = pendingRequest.onProgress;
                if (onProgress) {
                  onProgress(evt);
                }
              },
              onStateChange: function NetworkManager_onStateChange(xhrId, evt) {
                var pendingRequest = this.pendingRequests[xhrId];
                if (!pendingRequest) {
                  return;
                }
                var xhr = pendingRequest.xhr;
                if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
                  pendingRequest.onHeadersReceived();
                  delete pendingRequest.onHeadersReceived;
                }
                if (xhr.readyState !== 4) {
                  return;
                }
                if (!(xhrId in this.pendingRequests)) {
                  return;
                }
                delete this.pendingRequests[xhrId];
                if (xhr.status === 0 && this.isHttp) {
                  if (pendingRequest.onError) {
                    pendingRequest.onError(xhr.status);
                  }
                  return;
                }
                var xhrStatus = xhr.status || OK_RESPONSE;
                var ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
                if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
                  if (pendingRequest.onError) {
                    pendingRequest.onError(xhr.status);
                  }
                  return;
                }
                this.loadedRequests[xhrId] = true;
                var chunk = getArrayBuffer(xhr);
                if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
                  var rangeHeader = xhr.getResponseHeader("Content-Range");
                  var matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
                  var begin = parseInt(matches[1], 10);
                  pendingRequest.onDone({
                    begin,
                    chunk
                  });
                } else if (pendingRequest.onProgressiveData) {
                  pendingRequest.onDone(null);
                } else if (chunk) {
                  pendingRequest.onDone({
                    begin: 0,
                    chunk
                  });
                } else if (pendingRequest.onError) {
                  pendingRequest.onError(xhr.status);
                }
              },
              hasPendingRequests: function NetworkManager_hasPendingRequests() {
                for (var xhrId in this.pendingRequests) {
                  return true;
                }
                return false;
              },
              getRequestXhr: function NetworkManager_getXhr(xhrId) {
                return this.pendingRequests[xhrId].xhr;
              },
              isStreamingRequest: function NetworkManager_isStreamingRequest(xhrId) {
                return !!this.pendingRequests[xhrId].onProgressiveData;
              },
              isPendingRequest: function NetworkManager_isPendingRequest(xhrId) {
                return xhrId in this.pendingRequests;
              },
              isLoadedRequest: function NetworkManager_isLoadedRequest(xhrId) {
                return xhrId in this.loadedRequests;
              },
              abortAllRequests: function NetworkManager_abortAllRequests() {
                for (var xhrId in this.pendingRequests) {
                  this.abortRequest(xhrId | 0);
                }
              },
              abortRequest: function NetworkManager_abortRequest(xhrId) {
                var xhr = this.pendingRequests[xhrId].xhr;
                delete this.pendingRequests[xhrId];
                xhr.abort();
              }
            };
            function PDFNetworkStream(source) {
              this._source = source;
              this._manager = new NetworkManager(source.url, {
                httpHeaders: source.httpHeaders,
                withCredentials: source.withCredentials
              });
              this._rangeChunkSize = source.rangeChunkSize;
              this._fullRequestReader = null;
              this._rangeRequestReaders = [];
            }
            PDFNetworkStream.prototype = {
              _onRangeRequestReaderClosed: function PDFNetworkStream_onRangeRequestReaderClosed(reader) {
                var i = this._rangeRequestReaders.indexOf(reader);
                if (i >= 0) {
                  this._rangeRequestReaders.splice(i, 1);
                }
              },
              getFullReader: function PDFNetworkStream_getFullReader() {
                (0, _util.assert)(!this._fullRequestReader);
                this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
                return this._fullRequestReader;
              },
              getRangeReader: function PDFNetworkStream_getRangeReader(begin, end) {
                var reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
                reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
                this._rangeRequestReaders.push(reader);
                return reader;
              },
              cancelAllRequests: function PDFNetworkStream_cancelAllRequests(reason) {
                if (this._fullRequestReader) {
                  this._fullRequestReader.cancel(reason);
                }
                var readers = this._rangeRequestReaders.slice(0);
                readers.forEach(function(reader) {
                  reader.cancel(reason);
                });
              }
            };
            function PDFNetworkStreamFullRequestReader(manager, source) {
              this._manager = manager;
              var args = {
                onHeadersReceived: this._onHeadersReceived.bind(this),
                onProgressiveData: source.disableStream ? null : this._onProgressiveData.bind(this),
                onDone: this._onDone.bind(this),
                onError: this._onError.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._url = source.url;
              this._fullRequestId = manager.requestFull(args);
              this._headersReceivedCapability = (0, _util.createPromiseCapability)();
              this._disableRange = source.disableRange || false;
              this._contentLength = source.length;
              this._rangeChunkSize = source.rangeChunkSize;
              if (!this._rangeChunkSize && !this._disableRange) {
                this._disableRange = true;
              }
              this._isStreamingSupported = false;
              this._isRangeSupported = false;
              this._cachedChunks = [];
              this._requests = [];
              this._done = false;
              this._storedError = void 0;
              this._filename = null;
              this.onProgress = null;
            }
            PDFNetworkStreamFullRequestReader.prototype = {
              _onHeadersReceived: function PDFNetworkStreamFullRequestReader_onHeadersReceived() {
                var fullRequestXhrId = this._fullRequestId;
                var fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
                var getResponseHeader = function getResponseHeader2(name) {
                  return fullRequestXhr.getResponseHeader(name);
                };
                var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({
                  getResponseHeader,
                  isHttp: this._manager.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                }), allowRangeRequests = _validateRangeRequest.allowRangeRequests, suggestedLength = _validateRangeRequest.suggestedLength;
                if (allowRangeRequests) {
                  this._isRangeSupported = true;
                }
                this._contentLength = suggestedLength || this._contentLength;
                this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                var networkManager = this._manager;
                if (networkManager.isStreamingRequest(fullRequestXhrId)) {
                  this._isStreamingSupported = true;
                } else if (this._isRangeSupported) {
                  networkManager.abortRequest(fullRequestXhrId);
                }
                this._headersReceivedCapability.resolve();
              },
              _onProgressiveData: function PDFNetworkStreamFullRequestReader_onProgressiveData(chunk) {
                if (this._requests.length > 0) {
                  var requestCapability = this._requests.shift();
                  requestCapability.resolve({
                    value: chunk,
                    done: false
                  });
                } else {
                  this._cachedChunks.push(chunk);
                }
              },
              _onDone: function PDFNetworkStreamFullRequestReader_onDone(args) {
                if (args) {
                  this._onProgressiveData(args.chunk);
                }
                this._done = true;
                if (this._cachedChunks.length > 0) {
                  return;
                }
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
              },
              _onError: function PDFNetworkStreamFullRequestReader_onError(status) {
                var url = this._url;
                var exception = (0, _network_utils.createResponseStatusError)(status, url);
                this._storedError = exception;
                this._headersReceivedCapability.reject(exception);
                this._requests.forEach(function(requestCapability) {
                  requestCapability.reject(exception);
                });
                this._requests = [];
                this._cachedChunks = [];
              },
              _onProgress: function PDFNetworkStreamFullRequestReader_onProgress(data) {
                if (this.onProgress) {
                  this.onProgress({
                    loaded: data.loaded,
                    total: data.lengthComputable ? data.total : this._contentLength
                  });
                }
              },
              get filename() {
                return this._filename;
              },
              get isRangeSupported() {
                return this._isRangeSupported;
              },
              get isStreamingSupported() {
                return this._isStreamingSupported;
              },
              get contentLength() {
                return this._contentLength;
              },
              get headersReady() {
                return this._headersReceivedCapability.promise;
              },
              read: function PDFNetworkStreamFullRequestReader_read() {
                if (this._storedError) {
                  return Promise.reject(this._storedError);
                }
                if (this._cachedChunks.length > 0) {
                  var chunk = this._cachedChunks.shift();
                  return Promise.resolve({
                    value: chunk,
                    done: false
                  });
                }
                if (this._done) {
                  return Promise.resolve({
                    value: void 0,
                    done: true
                  });
                }
                var requestCapability = (0, _util.createPromiseCapability)();
                this._requests.push(requestCapability);
                return requestCapability.promise;
              },
              cancel: function PDFNetworkStreamFullRequestReader_cancel(reason) {
                this._done = true;
                this._headersReceivedCapability.reject(reason);
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
                if (this._manager.isPendingRequest(this._fullRequestId)) {
                  this._manager.abortRequest(this._fullRequestId);
                }
                this._fullRequestReader = null;
              }
            };
            function PDFNetworkStreamRangeRequestReader(manager, begin, end) {
              this._manager = manager;
              var args = {
                onDone: this._onDone.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._requestId = manager.requestRange(begin, end, args);
              this._requests = [];
              this._queuedChunk = null;
              this._done = false;
              this.onProgress = null;
              this.onClosed = null;
            }
            PDFNetworkStreamRangeRequestReader.prototype = {
              _close: function PDFNetworkStreamRangeRequestReader_close() {
                if (this.onClosed) {
                  this.onClosed(this);
                }
              },
              _onDone: function PDFNetworkStreamRangeRequestReader_onDone(data) {
                var chunk = data.chunk;
                if (this._requests.length > 0) {
                  var requestCapability = this._requests.shift();
                  requestCapability.resolve({
                    value: chunk,
                    done: false
                  });
                } else {
                  this._queuedChunk = chunk;
                }
                this._done = true;
                this._requests.forEach(function(requestCapability2) {
                  requestCapability2.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
                this._close();
              },
              _onProgress: function PDFNetworkStreamRangeRequestReader_onProgress(evt) {
                if (!this.isStreamingSupported && this.onProgress) {
                  this.onProgress({ loaded: evt.loaded });
                }
              },
              get isStreamingSupported() {
                return false;
              },
              read: function PDFNetworkStreamRangeRequestReader_read() {
                if (this._queuedChunk !== null) {
                  var chunk = this._queuedChunk;
                  this._queuedChunk = null;
                  return Promise.resolve({
                    value: chunk,
                    done: false
                  });
                }
                if (this._done) {
                  return Promise.resolve({
                    value: void 0,
                    done: true
                  });
                }
                var requestCapability = (0, _util.createPromiseCapability)();
                this._requests.push(requestCapability);
                return requestCapability.promise;
              },
              cancel: function PDFNetworkStreamRangeRequestReader_cancel(reason) {
                this._done = true;
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
                if (this._manager.isPendingRequest(this._requestId)) {
                  this._manager.abortRequest(this._requestId);
                }
                this._close();
              }
            };
            exports3.PDFNetworkStream = PDFNetworkStream;
            exports3.NetworkManager = NetworkManager;
          }
          /******/
        ])
      );
    });
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/pend/index.js
var require_pend = __commonJS({
  "node_modules/pend/index.js"(exports2, module2) {
    module2.exports = Pend;
    function Pend() {
      this.pending = 0;
      this.max = Infinity;
      this.listeners = [];
      this.waiting = [];
      this.error = null;
    }
    Pend.prototype.go = function(fn) {
      if (this.pending < this.max) {
        pendGo(this, fn);
      } else {
        this.waiting.push(fn);
      }
    };
    Pend.prototype.wait = function(cb) {
      if (this.pending === 0) {
        cb(this.error);
      } else {
        this.listeners.push(cb);
      }
    };
    Pend.prototype.hold = function() {
      return pendHold(this);
    };
    function pendHold(self2) {
      self2.pending += 1;
      var called = false;
      return onCb;
      function onCb(err) {
        if (called) throw new Error("callback called twice");
        called = true;
        self2.error = self2.error || err;
        self2.pending -= 1;
        if (self2.waiting.length > 0 && self2.pending < self2.max) {
          pendGo(self2, self2.waiting.shift());
        } else if (self2.pending === 0) {
          var listeners = self2.listeners;
          self2.listeners = [];
          listeners.forEach(cbListener);
        }
      }
      function cbListener(listener) {
        listener(self2.error);
      }
    }
    function pendGo(self2, fn) {
      fn(pendHold(self2));
    }
  }
});

// node_modules/yauzl/fd-slicer.js
var require_fd_slicer = __commonJS({
  "node_modules/yauzl/fd-slicer.js"(exports2) {
    var fs = require_fs();
    var util = require_util();
    var stream2 = require_stream();
    var Readable = stream2.Readable;
    var Writable = stream2.Writable;
    var PassThrough = stream2.PassThrough;
    var Pend = require_pend();
    var EventEmitter = require_events().EventEmitter;
    exports2.createFromBuffer = createFromBuffer;
    exports2.createFromFd = createFromFd;
    exports2.BufferSlicer = BufferSlicer;
    exports2.FdSlicer = FdSlicer;
    util.inherits(FdSlicer, EventEmitter);
    function FdSlicer(fd, options2) {
      options2 = options2 || {};
      EventEmitter.call(this);
      this.fd = fd;
      this.pend = new Pend();
      this.pend.max = 1;
      this.refCount = 0;
      this.autoClose = !!options2.autoClose;
    }
    FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs.read(self2.fd, buffer, offset, length, position, function(err, bytesRead, buffer2) {
          cb();
          callback(err, bytesRead, buffer2);
        });
      });
    };
    FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs.write(self2.fd, buffer, offset, length, position, function(err, written, buffer2) {
          cb();
          callback(err, written, buffer2);
        });
      });
    };
    FdSlicer.prototype.createReadStream = function(options2) {
      return new ReadStream(this, options2);
    };
    FdSlicer.prototype.createWriteStream = function(options2) {
      return new WriteStream(this, options2);
    };
    FdSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    FdSlicer.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0) return;
      if (self2.refCount < 0) throw new Error("invalid unref");
      if (self2.autoClose) {
        fs.close(self2.fd, onCloseDone);
      }
      function onCloseDone(err) {
        if (err) {
          self2.emit("error", err);
        } else {
          self2.emit("close");
        }
      }
    };
    util.inherits(ReadStream, Readable);
    function ReadStream(context, options2) {
      options2 = options2 || {};
      Readable.call(this, options2);
      this.context = context;
      this.context.ref();
      this.start = options2.start || 0;
      this.endOffset = options2.end;
      this.pos = this.start;
      this.destroyed = false;
    }
    ReadStream.prototype._read = function(n) {
      var self2 = this;
      if (self2.destroyed) return;
      var toRead = Math.min(self2._readableState.highWaterMark, n);
      if (self2.endOffset != null) {
        toRead = Math.min(toRead, self2.endOffset - self2.pos);
      }
      if (toRead <= 0) {
        self2.destroyed = true;
        self2.push(null);
        self2.context.unref();
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed) return cb();
        var buffer = Buffer.allocUnsafe(toRead);
        fs.read(self2.context.fd, buffer, 0, toRead, self2.pos, function(err, bytesRead) {
          if (err) {
            self2.destroy(err);
          } else if (bytesRead === 0) {
            self2.destroyed = true;
            self2.push(null);
            self2.context.unref();
          } else {
            self2.pos += bytesRead;
            self2.push(buffer.slice(0, bytesRead));
          }
          cb();
        });
      });
    };
    ReadStream.prototype.destroy = function(err) {
      if (this.destroyed) return;
      err = err || new Error("stream destroyed");
      this.destroyed = true;
      this.emit("error", err);
      this.context.unref();
    };
    util.inherits(WriteStream, Writable);
    function WriteStream(context, options2) {
      options2 = options2 || {};
      Writable.call(this, options2);
      this.context = context;
      this.context.ref();
      this.start = options2.start || 0;
      this.endOffset = options2.end == null ? Infinity : +options2.end;
      this.bytesWritten = 0;
      this.pos = this.start;
      this.destroyed = false;
      this.on("finish", this.destroy.bind(this));
    }
    WriteStream.prototype._write = function(buffer, encoding, callback) {
      var self2 = this;
      if (self2.destroyed) return;
      if (self2.pos + buffer.length > self2.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        self2.destroy();
        callback(err);
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed) return cb();
        fs.write(self2.context.fd, buffer, 0, buffer.length, self2.pos, function(err2, bytes) {
          if (err2) {
            self2.destroy();
            cb();
            callback(err2);
          } else {
            self2.bytesWritten += bytes;
            self2.pos += bytes;
            self2.emit("progress");
            cb();
            callback();
          }
        });
      });
    };
    WriteStream.prototype.destroy = function() {
      if (this.destroyed) return;
      this.destroyed = true;
      this.context.unref();
    };
    util.inherits(BufferSlicer, EventEmitter);
    function BufferSlicer(buffer, options2) {
      EventEmitter.call(this);
      options2 = options2 || {};
      this.refCount = 0;
      this.buffer = buffer;
      this.maxChunkSize = options2.maxChunkSize || Number.MAX_SAFE_INTEGER;
    }
    BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      if (!(0 <= offset && offset <= buffer.length)) throw new RangeError("offset outside buffer: 0 <= " + offset + " <= " + buffer.length);
      if (position < 0) throw new RangeError("position is negative: " + position);
      if (offset + length > buffer.length) {
        length = buffer.length - offset;
      }
      if (position + length > this.buffer.length) {
        length = this.buffer.length - position;
      }
      if (length <= 0) {
        setImmediate(function() {
          callback(null, 0);
        });
        return;
      }
      this.buffer.copy(buffer, offset, position, position + length);
      setImmediate(function() {
        callback(null, length);
      });
    };
    BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      buffer.copy(this.buffer, position, offset, offset + length);
      setImmediate(function() {
        callback(null, length, buffer);
      });
    };
    BufferSlicer.prototype.createReadStream = function(options2) {
      options2 = options2 || {};
      var readStream = new PassThrough(options2);
      readStream.destroyed = false;
      readStream.start = options2.start || 0;
      readStream.endOffset = options2.end;
      readStream.pos = readStream.endOffset || this.buffer.length;
      var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
      var offset = 0;
      while (true) {
        var nextOffset = offset + this.maxChunkSize;
        if (nextOffset >= entireSlice.length) {
          if (offset < entireSlice.length) {
            readStream.write(entireSlice.slice(offset, entireSlice.length));
          }
          break;
        }
        readStream.write(entireSlice.slice(offset, nextOffset));
        offset = nextOffset;
      }
      readStream.end();
      readStream.destroy = function() {
        readStream.destroyed = true;
      };
      return readStream;
    };
    BufferSlicer.prototype.createWriteStream = function(options2) {
      var bufferSlicer = this;
      options2 = options2 || {};
      var writeStream = new Writable(options2);
      writeStream.start = options2.start || 0;
      writeStream.endOffset = options2.end == null ? this.buffer.length : +options2.end;
      writeStream.bytesWritten = 0;
      writeStream.pos = writeStream.start;
      writeStream.destroyed = false;
      writeStream._write = function(buffer, encoding, callback) {
        if (writeStream.destroyed) return;
        var end = writeStream.pos + buffer.length;
        if (end > writeStream.endOffset) {
          var err = new Error("maximum file length exceeded");
          err.code = "ETOOBIG";
          writeStream.destroyed = true;
          callback(err);
          return;
        }
        buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
        writeStream.bytesWritten += buffer.length;
        writeStream.pos = end;
        writeStream.emit("progress");
        callback();
      };
      writeStream.destroy = function() {
        writeStream.destroyed = true;
      };
      return writeStream;
    };
    BufferSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    BufferSlicer.prototype.unref = function() {
      this.refCount -= 1;
      if (this.refCount < 0) {
        throw new Error("invalid unref");
      }
    };
    function createFromBuffer(buffer, options2) {
      return new BufferSlicer(buffer, options2);
    }
    function createFromFd(fd, options2) {
      return new FdSlicer(fd, options2);
    }
  }
});

// node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS({
  "node_modules/buffer-crc32/index.js"(exports2, module2) {
    var Buffer2 = require_buffer().Buffer;
    var CRC_TABLE = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    if (typeof Int32Array !== "undefined") {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    function ensureBuffer(input) {
      if (Buffer2.isBuffer(input)) {
        return input;
      }
      var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
      } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer2.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc32.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    module2.exports = crc32;
  }
});

// node_modules/yauzl/index.js
var require_yauzl = __commonJS({
  "node_modules/yauzl/index.js"(exports2) {
    var fs = require_fs();
    var zlib = require_zlib();
    var fd_slicer = require_fd_slicer();
    var crc32 = require_buffer_crc32();
    var util = require_util();
    var EventEmitter = require_events().EventEmitter;
    var Transform = require_stream().Transform;
    var PassThrough = require_stream().PassThrough;
    var Writable = require_stream().Writable;
    exports2.open = open;
    exports2.fromFd = fromFd;
    exports2.fromBuffer = fromBuffer2;
    exports2.fromRandomAccessReader = fromRandomAccessReader;
    exports2.dosDateTimeToDate = dosDateTimeToDate;
    exports2.getFileNameLowLevel = getFileNameLowLevel;
    exports2.validateFileName = validateFileName;
    exports2.parseExtraFields = parseExtraFields;
    exports2.ZipFile = ZipFile;
    exports2.Entry = Entry;
    exports2.LocalFileHeader = LocalFileHeader;
    exports2.RandomAccessReader = RandomAccessReader;
    function open(path, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      if (options2 == null) options2 = {};
      if (options2.autoClose == null) options2.autoClose = true;
      if (options2.lazyEntries == null) options2.lazyEntries = false;
      if (options2.decodeStrings == null) options2.decodeStrings = true;
      if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
      if (options2.strictFileNames == null) options2.strictFileNames = false;
      if (callback == null) callback = defaultCallback;
      fs.open(path, "r", function(err, fd) {
        if (err) return callback(err);
        fromFd(fd, options2, function(err2, zipfile) {
          if (err2) fs.close(fd, defaultCallback);
          callback(err2, zipfile);
        });
      });
    }
    function fromFd(fd, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      if (options2 == null) options2 = {};
      if (options2.autoClose == null) options2.autoClose = false;
      if (options2.lazyEntries == null) options2.lazyEntries = false;
      if (options2.decodeStrings == null) options2.decodeStrings = true;
      if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
      if (options2.strictFileNames == null) options2.strictFileNames = false;
      if (callback == null) callback = defaultCallback;
      fs.fstat(fd, function(err, stats) {
        if (err) return callback(err);
        var reader = fd_slicer.createFromFd(fd, { autoClose: true });
        fromRandomAccessReader(reader, stats.size, options2, callback);
      });
    }
    function fromBuffer2(buffer, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      if (options2 == null) options2 = {};
      options2.autoClose = false;
      if (options2.lazyEntries == null) options2.lazyEntries = false;
      if (options2.decodeStrings == null) options2.decodeStrings = true;
      if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
      if (options2.strictFileNames == null) options2.strictFileNames = false;
      var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 65536 });
      fromRandomAccessReader(reader, buffer.length, options2, callback);
    }
    function fromRandomAccessReader(reader, totalSize, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      if (options2 == null) options2 = {};
      if (options2.autoClose == null) options2.autoClose = true;
      if (options2.lazyEntries == null) options2.lazyEntries = false;
      if (options2.decodeStrings == null) options2.decodeStrings = true;
      var decodeStrings = !!options2.decodeStrings;
      if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
      if (options2.strictFileNames == null) options2.strictFileNames = false;
      if (callback == null) callback = defaultCallback;
      if (typeof totalSize !== "number") throw new Error("expected totalSize parameter to be a number");
      if (totalSize > Number.MAX_SAFE_INTEGER) {
        throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
      }
      reader.ref();
      var eocdrWithoutCommentSize = 22;
      var zip64EocdlSize = 20;
      var maxCommentSize = 65535;
      var bufferSize = Math.min(zip64EocdlSize + eocdrWithoutCommentSize + maxCommentSize, totalSize);
      var buffer = newBuffer(bufferSize);
      var bufferReadStart = totalSize - buffer.length;
      readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
        if (err) return callback(err);
        for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
          if (buffer.readUInt32LE(i) !== 101010256) continue;
          var eocdrBuffer = buffer.subarray(i);
          var diskNumber = eocdrBuffer.readUInt16LE(4);
          var entryCount = eocdrBuffer.readUInt16LE(10);
          var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
          var commentLength = eocdrBuffer.readUInt16LE(20);
          var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
          if (commentLength !== expectedCommentLength) {
            return callback(new Error("Invalid comment length. Expected: " + expectedCommentLength + ". Found: " + commentLength + ". Are there extra bytes at the end of the file? Or is the end of central dir signature `PK☺☻` in the comment?"));
          }
          var comment = decodeStrings ? decodeBuffer(eocdrBuffer.subarray(22), false) : eocdrBuffer.subarray(22);
          if (i - zip64EocdlSize >= 0 && buffer.readUInt32LE(i - zip64EocdlSize) === 117853008) {
            var zip64EocdlBuffer = buffer.subarray(i - zip64EocdlSize, i - zip64EocdlSize + zip64EocdlSize);
            var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
            var zip64EocdrBuffer = newBuffer(56);
            return readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err2) {
              if (err2) return callback(err2);
              if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
                return callback(new Error("invalid zip64 end of central directory record signature"));
              }
              diskNumber = zip64EocdrBuffer.readUInt32LE(16);
              if (diskNumber !== 0) {
                return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
              }
              entryCount = readUInt64LE(zip64EocdrBuffer, 32);
              centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
              return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options2.autoClose, options2.lazyEntries, decodeStrings, options2.validateEntrySizes, options2.strictFileNames));
            });
          }
          if (diskNumber !== 0) {
            return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
          }
          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options2.autoClose, options2.lazyEntries, decodeStrings, options2.validateEntrySizes, options2.strictFileNames));
        }
        callback(new Error("End of central directory record signature not found. Either not a zip file, or file is truncated."));
      });
    }
    util.inherits(ZipFile, EventEmitter);
    function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
      var self2 = this;
      EventEmitter.call(self2);
      self2.reader = reader;
      self2.reader.on("error", function(err) {
        emitError(self2, err);
      });
      self2.reader.once("close", function() {
        self2.emit("close");
      });
      self2.readEntryCursor = centralDirectoryOffset;
      self2.fileSize = fileSize;
      self2.entryCount = entryCount;
      self2.comment = comment;
      self2.entriesRead = 0;
      self2.autoClose = !!autoClose;
      self2.lazyEntries = !!lazyEntries;
      self2.decodeStrings = !!decodeStrings;
      self2.validateEntrySizes = !!validateEntrySizes;
      self2.strictFileNames = !!strictFileNames;
      self2.isOpen = true;
      self2.emittedError = false;
      if (!self2.lazyEntries) self2._readEntry();
    }
    ZipFile.prototype.close = function() {
      if (!this.isOpen) return;
      this.isOpen = false;
      this.reader.unref();
    };
    function emitErrorAndAutoClose(self2, err) {
      if (self2.autoClose) self2.close();
      emitError(self2, err);
    }
    function emitError(self2, err) {
      if (self2.emittedError) return;
      self2.emittedError = true;
      self2.emit("error", err);
    }
    ZipFile.prototype.readEntry = function() {
      if (!this.lazyEntries) throw new Error("readEntry() called without lazyEntries:true");
      this._readEntry();
    };
    ZipFile.prototype._readEntry = function() {
      var self2 = this;
      if (self2.entryCount === self2.entriesRead) {
        setImmediate(function() {
          if (self2.autoClose) self2.close();
          if (self2.emittedError) return;
          self2.emit("end");
        });
        return;
      }
      if (self2.emittedError) return;
      var buffer = newBuffer(46);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err) {
        if (err) return emitErrorAndAutoClose(self2, err);
        if (self2.emittedError) return;
        var entry = new Entry();
        var signature = buffer.readUInt32LE(0);
        if (signature !== 33639248) return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
        entry.versionMadeBy = buffer.readUInt16LE(4);
        entry.versionNeededToExtract = buffer.readUInt16LE(6);
        entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
        entry.compressionMethod = buffer.readUInt16LE(10);
        entry.lastModFileTime = buffer.readUInt16LE(12);
        entry.lastModFileDate = buffer.readUInt16LE(14);
        entry.crc32 = buffer.readUInt32LE(16);
        entry.compressedSize = buffer.readUInt32LE(20);
        entry.uncompressedSize = buffer.readUInt32LE(24);
        entry.fileNameLength = buffer.readUInt16LE(28);
        entry.extraFieldLength = buffer.readUInt16LE(30);
        entry.fileCommentLength = buffer.readUInt16LE(32);
        entry.internalFileAttributes = buffer.readUInt16LE(36);
        entry.externalFileAttributes = buffer.readUInt32LE(38);
        entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
        if (entry.generalPurposeBitFlag & 64) return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
        self2.readEntryCursor += 46;
        buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
        readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err2) {
          if (err2) return emitErrorAndAutoClose(self2, err2);
          if (self2.emittedError) return;
          entry.fileNameRaw = buffer.subarray(0, entry.fileNameLength);
          var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
          entry.extraFieldRaw = buffer.subarray(entry.fileNameLength, fileCommentStart);
          entry.fileCommentRaw = buffer.subarray(fileCommentStart, fileCommentStart + entry.fileCommentLength);
          try {
            entry.extraFields = parseExtraFields(entry.extraFieldRaw);
          } catch (err3) {
            return emitErrorAndAutoClose(self2, err3);
          }
          if (self2.decodeStrings) {
            var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
            entry.fileComment = decodeBuffer(entry.fileCommentRaw, isUtf8);
            entry.fileName = getFileNameLowLevel(entry.generalPurposeBitFlag, entry.fileNameRaw, entry.extraFields, self2.strictFileNames);
            var errorMessage = validateFileName(entry.fileName);
            if (errorMessage != null) return emitErrorAndAutoClose(self2, new Error(errorMessage));
          } else {
            entry.fileComment = entry.fileCommentRaw;
            entry.fileName = entry.fileNameRaw;
          }
          entry.comment = entry.fileComment;
          self2.readEntryCursor += buffer.length;
          self2.entriesRead += 1;
          for (var i = 0; i < entry.extraFields.length; i++) {
            var extraField = entry.extraFields[i];
            if (extraField.id !== 1) continue;
            var zip64EiefBuffer = extraField.data;
            var index = 0;
            if (entry.uncompressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
              }
              entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.compressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
              }
              entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.relativeOffsetOfLocalHeader === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
              }
              entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            break;
          }
          if (self2.validateEntrySizes && entry.compressionMethod === 0) {
            var expectedCompressedSize = entry.uncompressedSize;
            if (entry.isEncrypted()) {
              expectedCompressedSize += 12;
            }
            if (entry.compressedSize !== expectedCompressedSize) {
              var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
              return emitErrorAndAutoClose(self2, new Error(msg));
            }
          }
          self2.emit("entry", entry);
          if (!self2.lazyEntries) self2._readEntry();
        });
      });
    };
    ZipFile.prototype.openReadStream = function(entry, options2, callback) {
      var self2 = this;
      var relativeStart = 0;
      var relativeEnd = entry.compressedSize;
      if (callback == null) {
        callback = options2;
        options2 = null;
      }
      if (options2 == null) {
        options2 = {};
      } else {
        if (options2.decrypt != null) {
          if (!entry.isEncrypted()) {
            throw new Error("options.decrypt can only be specified for encrypted entries");
          }
          if (options2.decrypt !== false) throw new Error("invalid options.decrypt value: " + options2.decrypt);
          if (entry.isCompressed()) {
            if (options2.decompress !== false) throw new Error("entry is encrypted and compressed, and options.decompress !== false");
          }
        }
        if (options2.decompress != null) {
          if (!entry.isCompressed()) {
            throw new Error("options.decompress can only be specified for compressed entries");
          }
          if (!(options2.decompress === false || options2.decompress === true)) {
            throw new Error("invalid options.decompress value: " + options2.decompress);
          }
        }
        if (options2.start != null || options2.end != null) {
          if (entry.isCompressed() && options2.decompress !== false) {
            throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
          }
          if (entry.isEncrypted() && options2.decrypt !== false) {
            throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
          }
        }
        if (options2.start != null) {
          relativeStart = options2.start;
          if (relativeStart < 0) throw new Error("options.start < 0");
          if (relativeStart > entry.compressedSize) throw new Error("options.start > entry.compressedSize");
        }
        if (options2.end != null) {
          relativeEnd = options2.end;
          if (relativeEnd < 0) throw new Error("options.end < 0");
          if (relativeEnd > entry.compressedSize) throw new Error("options.end > entry.compressedSize");
          if (relativeEnd < relativeStart) throw new Error("options.end < options.start");
        }
      }
      if (!self2.isOpen) return callback(new Error("closed"));
      if (entry.isEncrypted()) {
        if (options2.decrypt !== false) return callback(new Error("entry is encrypted, and options.decrypt !== false"));
      }
      var decompress;
      if (entry.compressionMethod === 0) {
        decompress = false;
      } else if (entry.compressionMethod === 8) {
        decompress = options2.decompress != null ? options2.decompress : true;
      } else {
        return callback(new Error("unsupported compression method: " + entry.compressionMethod));
      }
      self2.readLocalFileHeader(entry, { minimal: true }, function(err, localFileHeader) {
        if (err) return callback(err);
        self2.openReadStreamLowLevel(
          localFileHeader.fileDataStart,
          entry.compressedSize,
          relativeStart,
          relativeEnd,
          decompress,
          entry.uncompressedSize,
          callback
        );
      });
    };
    ZipFile.prototype.openReadStreamLowLevel = function(fileDataStart, compressedSize, relativeStart, relativeEnd, decompress, uncompressedSize, callback) {
      var self2 = this;
      var fileDataEnd = fileDataStart + compressedSize;
      var readStream = self2.reader.createReadStream({
        start: fileDataStart + relativeStart,
        end: fileDataStart + relativeEnd
      });
      var endpointStream = readStream;
      if (decompress) {
        var destroyed = false;
        var inflateFilter = zlib.createInflateRaw();
        readStream.on("error", function(err) {
          setImmediate(function() {
            if (!destroyed) inflateFilter.emit("error", err);
          });
        });
        readStream.pipe(inflateFilter);
        if (self2.validateEntrySizes) {
          endpointStream = new AssertByteCountStream(uncompressedSize);
          inflateFilter.on("error", function(err) {
            setImmediate(function() {
              if (!destroyed) endpointStream.emit("error", err);
            });
          });
          inflateFilter.pipe(endpointStream);
        } else {
          endpointStream = inflateFilter;
        }
        installDestroyFn(endpointStream, function() {
          destroyed = true;
          if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);
          readStream.unpipe(inflateFilter);
          readStream.destroy();
        });
      }
      callback(null, endpointStream);
    };
    ZipFile.prototype.readLocalFileHeader = function(entry, options2, callback) {
      var self2 = this;
      if (callback == null) {
        callback = options2;
        options2 = null;
      }
      if (options2 == null) options2 = {};
      self2.reader.ref();
      var buffer = newBuffer(30);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
        try {
          if (err) return callback(err);
          var signature = buffer.readUInt32LE(0);
          if (signature !== 67324752) {
            return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
          }
          var fileNameLength = buffer.readUInt16LE(26);
          var extraFieldLength = buffer.readUInt16LE(28);
          var fileDataStart = entry.relativeOffsetOfLocalHeader + 30 + fileNameLength + extraFieldLength;
          if (fileDataStart + entry.compressedSize > self2.fileSize) {
            return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
          }
          if (options2.minimal) {
            return callback(null, { fileDataStart });
          }
          var localFileHeader = new LocalFileHeader();
          localFileHeader.fileDataStart = fileDataStart;
          localFileHeader.versionNeededToExtract = buffer.readUInt16LE(4);
          localFileHeader.generalPurposeBitFlag = buffer.readUInt16LE(6);
          localFileHeader.compressionMethod = buffer.readUInt16LE(8);
          localFileHeader.lastModFileTime = buffer.readUInt16LE(10);
          localFileHeader.lastModFileDate = buffer.readUInt16LE(12);
          localFileHeader.crc32 = buffer.readUInt32LE(14);
          localFileHeader.compressedSize = buffer.readUInt32LE(18);
          localFileHeader.uncompressedSize = buffer.readUInt32LE(22);
          localFileHeader.fileNameLength = fileNameLength;
          localFileHeader.extraFieldLength = extraFieldLength;
          buffer = newBuffer(fileNameLength + extraFieldLength);
          self2.reader.ref();
          readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader + 30, function(err2) {
            try {
              if (err2) return callback(err2);
              localFileHeader.fileName = buffer.subarray(0, fileNameLength);
              localFileHeader.extraField = buffer.subarray(fileNameLength);
              return callback(null, localFileHeader);
            } finally {
              self2.reader.unref();
            }
          });
        } finally {
          self2.reader.unref();
        }
      });
    };
    function Entry() {
    }
    Entry.prototype.getLastModDate = function(options2) {
      if (options2 == null) options2 = {};
      if (!options2.forceDosFormat) {
        for (var i = 0; i < this.extraFields.length; i++) {
          var extraField = this.extraFields[i];
          if (extraField.id === 21589) {
            var data = extraField.data;
            if (data.length < 5) continue;
            var flags = data[0];
            var HAS_MTIME = 1;
            if (!(flags & HAS_MTIME)) continue;
            var posixTimestamp = data.readInt32LE(1);
            return new Date(posixTimestamp * 1e3);
          } else if (extraField.id === 10) {
            var data = extraField.data;
            var cursor = 4;
            while (cursor < data.length + 4) {
              var tag = data.readUInt16LE(cursor);
              cursor += 2;
              var size = data.readUInt16LE(cursor);
              cursor += 2;
              if (tag !== 1) {
                cursor += size;
                continue;
              }
              if (size < 8 || cursor + size > data.length) break;
              var hundredNanoSecondsSince1601 = 4294967296 * data.readInt32LE(cursor + 4) + data.readUInt32LE(cursor);
              var millisecondsSince1970 = hundredNanoSecondsSince1601 / 1e4 - 116444736e5;
              return new Date(millisecondsSince1970);
            }
          }
        }
      }
      return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime, options2.timezone);
    };
    Entry.prototype.isEncrypted = function() {
      return (this.generalPurposeBitFlag & 1) !== 0;
    };
    Entry.prototype.isCompressed = function() {
      return this.compressionMethod === 8;
    };
    function LocalFileHeader() {
    }
    function dosDateTimeToDate(date, time, timezone) {
      var day = date & 31;
      var month = (date >> 5 & 15) - 1;
      var year = (date >> 9 & 127) + 1980;
      var millisecond = 0;
      var second = (time & 31) * 2;
      var minute = time >> 5 & 63;
      var hour = time >> 11 & 31;
      if (timezone == null || timezone === "local") {
        return new Date(year, month, day, hour, minute, second, millisecond);
      } else if (timezone === "UTC") {
        return new Date(Date.UTC(year, month, day, hour, minute, second, millisecond));
      } else {
        throw new Error("unrecognized options.timezone: " + options.timezone);
      }
    }
    function getFileNameLowLevel(generalPurposeBitFlag, fileNameBuffer, extraFields, strictFileNames) {
      var fileName = null;
      for (var i = 0; i < extraFields.length; i++) {
        var extraField = extraFields[i];
        if (extraField.id === 28789) {
          if (extraField.data.length < 6) {
            continue;
          }
          if (extraField.data.readUInt8(0) !== 1) {
            continue;
          }
          var oldNameCrc32 = extraField.data.readUInt32LE(1);
          if (crc32.unsigned(fileNameBuffer) !== oldNameCrc32) {
            continue;
          }
          fileName = decodeBuffer(extraField.data.subarray(5), true);
          break;
        }
      }
      if (fileName == null) {
        var isUtf8 = (generalPurposeBitFlag & 2048) !== 0;
        fileName = decodeBuffer(fileNameBuffer, isUtf8);
      }
      if (!strictFileNames) {
        fileName = fileName.replace(/\\/g, "/");
      }
      return fileName;
    }
    function validateFileName(fileName) {
      if (fileName.indexOf("\\") !== -1) {
        return "invalid characters in fileName: " + fileName;
      }
      if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
        return "absolute path: " + fileName;
      }
      if (fileName.split("/").indexOf("..") !== -1) {
        return "invalid relative path: " + fileName;
      }
      return null;
    }
    function parseExtraFields(extraFieldBuffer) {
      var extraFields = [];
      var i = 0;
      while (i < extraFieldBuffer.length - 3) {
        var headerId = extraFieldBuffer.readUInt16LE(i + 0);
        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
        var dataStart = i + 4;
        var dataEnd = dataStart + dataSize;
        if (dataEnd > extraFieldBuffer.length) throw new Error("extra field length exceeds extra field buffer size");
        var dataBuffer = extraFieldBuffer.subarray(dataStart, dataEnd);
        extraFields.push({
          id: headerId,
          data: dataBuffer
        });
        i = dataEnd;
      }
      return extraFields;
    }
    function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
      if (length === 0) {
        return setImmediate(function() {
          callback(null, newBuffer(0));
        });
      }
      reader.read(buffer, offset, length, position, function(err, bytesRead) {
        if (err) return callback(err);
        if (bytesRead < length) {
          return callback(new Error("unexpected EOF"));
        }
        callback();
      });
    }
    util.inherits(AssertByteCountStream, Transform);
    function AssertByteCountStream(byteCount) {
      Transform.call(this);
      this.actualByteCount = 0;
      this.expectedByteCount = byteCount;
    }
    AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
      this.actualByteCount += chunk.length;
      if (this.actualByteCount > this.expectedByteCount) {
        var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb(null, chunk);
    };
    AssertByteCountStream.prototype._flush = function(cb) {
      if (this.actualByteCount < this.expectedByteCount) {
        var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb();
    };
    util.inherits(RandomAccessReader, EventEmitter);
    function RandomAccessReader() {
      EventEmitter.call(this);
      this.refCount = 0;
    }
    RandomAccessReader.prototype.ref = function() {
      this.refCount += 1;
    };
    RandomAccessReader.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0) return;
      if (self2.refCount < 0) throw new Error("invalid unref");
      self2.close(onCloseDone);
      function onCloseDone(err) {
        if (err) return self2.emit("error", err);
        self2.emit("close");
      }
    };
    RandomAccessReader.prototype.createReadStream = function(options2) {
      if (options2 == null) options2 = {};
      var start = options2.start;
      var end = options2.end;
      if (start === end) {
        var emptyStream = new PassThrough();
        setImmediate(function() {
          emptyStream.end();
        });
        return emptyStream;
      }
      var stream2 = this._readStreamForRange(start, end);
      var destroyed = false;
      var refUnrefFilter = new RefUnrefFilter(this);
      stream2.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed) refUnrefFilter.emit("error", err);
        });
      });
      installDestroyFn(refUnrefFilter, function() {
        stream2.unpipe(refUnrefFilter);
        refUnrefFilter.unref();
        stream2.destroy();
      });
      var byteCounter = new AssertByteCountStream(end - start);
      refUnrefFilter.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed) byteCounter.emit("error", err);
        });
      });
      installDestroyFn(byteCounter, function() {
        destroyed = true;
        refUnrefFilter.unpipe(byteCounter);
        refUnrefFilter.destroy();
      });
      return stream2.pipe(refUnrefFilter).pipe(byteCounter);
    };
    RandomAccessReader.prototype._readStreamForRange = function(start, end) {
      throw new Error("not implemented");
    };
    RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
      var readStream = this.createReadStream({ start: position, end: position + length });
      var writeStream = new Writable();
      var written = 0;
      writeStream._write = function(chunk, encoding, cb) {
        chunk.copy(buffer, offset + written, 0, chunk.length);
        written += chunk.length;
        cb();
      };
      writeStream.on("finish", callback);
      readStream.on("error", function(error) {
        callback(error);
      });
      readStream.pipe(writeStream);
    };
    RandomAccessReader.prototype.close = function(callback) {
      setImmediate(callback);
    };
    util.inherits(RefUnrefFilter, PassThrough);
    function RefUnrefFilter(context) {
      PassThrough.call(this);
      this.context = context;
      this.context.ref();
      this.unreffedYet = false;
    }
    RefUnrefFilter.prototype._flush = function(cb) {
      this.unref();
      cb();
    };
    RefUnrefFilter.prototype.unref = function(cb) {
      if (this.unreffedYet) return;
      this.unreffedYet = true;
      this.context.unref();
    };
    var cp437 = "\0☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ";
    function decodeBuffer(buffer, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8");
      } else {
        var result = "";
        for (var i = 0; i < buffer.length; i++) {
          result += cp437[buffer[i]];
        }
        return result;
      }
    }
    function readUInt64LE(buffer, offset) {
      var lower32 = buffer.readUInt32LE(offset);
      var upper32 = buffer.readUInt32LE(offset + 4);
      return upper32 * 4294967296 + lower32;
    }
    var newBuffer;
    if (typeof Buffer.allocUnsafe === "function") {
      newBuffer = function(len) {
        return Buffer.allocUnsafe(len);
      };
    } else {
      newBuffer = function(len) {
        return new Buffer(len);
      };
    }
    function installDestroyFn(stream2, fn) {
      if (typeof stream2.destroy === "function") {
        stream2._destroy = function(err, cb) {
          fn();
          if (cb != null) cb(err);
        };
      } else {
        stream2.destroy = fn;
      }
    }
    function defaultCallback(err) {
      if (err) throw err;
    }
  }
});

// node_modules/officeparser/officeParser.js
var require_officeParser = __commonJS({
  "node_modules/officeparser/officeParser.js"(exports2, module2) {
    var concat = require_concat_stream();
    var { DOMParser } = require_lib();
    var fileType2 = require_file_type();
    var fs = require_fs();
    var pdfjs = require_pdf();
    var yauzl = require_yauzl();
    var ERRORHEADER = "[OfficeParser]: ";
    var ERRORMSG = {
      extensionUnsupported: (ext) => `Sorry, OfficeParser currently support docx, pptx, xlsx, odt, odp, ods, pdf files only. Create a ticket in Issues on github to add support for ${ext} files. Stay tuned for further updates.`,
      fileCorrupted: (filepath) => `Your file ${filepath} seems to be corrupted. If you are sure it is fine, please create a ticket in Issues on github with the file to reproduce error.`,
      fileDoesNotExist: (filepath) => `File ${filepath} could not be found! Check if the file exists or verify if the relative path to the file is correct from your terminal's location.`,
      locationNotFound: (location) => `Entered location ${location} is not reachable! Please make sure that the entered directory location exists. Check relative paths and reenter.`,
      improperArguments: `Improper arguments`,
      improperBuffers: `Error occured while reading the file buffers`,
      invalidInput: `Invalid input type: Expected a Buffer or a valid file path`
    };
    var parseString = (xml) => {
      let parser = new DOMParser();
      return parser.parseFromString(xml, "text/xml");
    };
    function parseWord(file, callback, config) {
      const mainContentFileRegex = /word\/document[\d+]?.xml/g;
      const footnotesFileRegex = /word\/footnotes[\d+]?.xml/g;
      const endnotesFileRegex = /word\/endnotes[\d+]?.xml/g;
      extractFiles(file, (x) => [mainContentFileRegex, footnotesFileRegex, endnotesFileRegex].some((fileRegex) => x.match(fileRegex))).then((files) => {
        if (!files.some((file2) => file2.path.match(mainContentFileRegex)))
          throw ERRORMSG.fileCorrupted(file);
        return files.filter((file2) => file2.path.match(mainContentFileRegex) || file2.path.match(footnotesFileRegex) || file2.path.match(endnotesFileRegex)).map((file2) => file2.content);
      }).then((xmlContentArray) => {
        let responseText = [];
        xmlContentArray.forEach((xmlContent) => {
          const xmlParagraphNodesList = parseString(xmlContent).getElementsByTagName("w:p");
          responseText.push(
            Array.from(xmlParagraphNodesList).filter((paragraphNode) => paragraphNode.getElementsByTagName("w:t").length != 0).map((paragraphNode) => {
              const xmlTextNodeList = paragraphNode.getElementsByTagName("w:t");
              return Array.from(xmlTextNodeList).filter((textNode) => textNode.childNodes[0] && textNode.childNodes[0].nodeValue).map((textNode) => textNode.childNodes[0].nodeValue).join("");
            }).join(config.newlineDelimiter ?? "\n")
          );
        });
        callback(responseText.join(config.newlineDelimiter ?? "\n"), void 0);
      }).catch((e) => callback(void 0, e));
    }
    function parsePowerPoint(file, callback, config) {
      const allFilesRegex = /ppt\/(notesSlides|slides)\/(notesSlide|slide)\d+.xml/g;
      const slidesRegex = /ppt\/slides\/slide\d+.xml/g;
      const slideNumberRegex = /lide(\d+)\.xml/;
      extractFiles(file, (x) => !!x.match(config.ignoreNotes ? slidesRegex : allFilesRegex)).then((files) => {
        files.sort((a, b) => {
          var _a, _b;
          const matchedANumber = parseInt((_a = a.path.match(slideNumberRegex)) == null ? void 0 : _a.at(1), 10);
          const matchedBNumber = parseInt((_b = b.path.match(slideNumberRegex)) == null ? void 0 : _b.at(1), 10);
          const aNumber = isNaN(matchedANumber) ? Infinity : matchedANumber;
          const bNumber = isNaN(matchedBNumber) ? Infinity : matchedBNumber;
          return aNumber - bNumber || Number(a.path.includes("notes")) - Number(b.path.includes("notes"));
        });
        if (files.length == 0 || !files.map((file2) => file2.path).some((filename) => filename.match(slidesRegex)))
          throw ERRORMSG.fileCorrupted(file);
        if (!config.ignoreNotes && config.putNotesAtLast)
          files.sort((a, b) => a.path.indexOf("notes") - b.path.indexOf("notes"));
        return files.map((file2) => file2.content);
      }).then((xmlContentArray) => {
        let responseText = [];
        xmlContentArray.forEach((xmlContent) => {
          const xmlParagraphNodesList = parseString(xmlContent).getElementsByTagName("a:p");
          responseText.push(
            Array.from(xmlParagraphNodesList).filter((paragraphNode) => paragraphNode.getElementsByTagName("a:t").length != 0).map((paragraphNode) => {
              const xmlTextNodeList = paragraphNode.getElementsByTagName("a:t");
              return Array.from(xmlTextNodeList).filter((textNode) => textNode.childNodes[0] && textNode.childNodes[0].nodeValue).map((textNode) => textNode.childNodes[0].nodeValue).join("");
            }).join(config.newlineDelimiter ?? "\n")
          );
        });
        callback(responseText.join(config.newlineDelimiter ?? "\n"), void 0);
      }).catch((e) => callback(void 0, e));
    }
    function parseExcel(file, callback, config) {
      const sheetsRegex = /xl\/worksheets\/sheet\d+.xml/g;
      const drawingsRegex = /xl\/drawings\/drawing\d+.xml/g;
      const chartsRegex = /xl\/charts\/chart\d+.xml/g;
      const stringsFilePath = "xl/sharedStrings.xml";
      extractFiles(file, (x) => [sheetsRegex, drawingsRegex, chartsRegex].some((fileRegex) => x.match(fileRegex)) || x == stringsFilePath).then((files) => {
        if (files.length == 0 || !files.map((file2) => file2.path).some((filename) => filename.match(sheetsRegex)))
          throw ERRORMSG.fileCorrupted(file);
        return {
          sheetFiles: files.filter((file2) => file2.path.match(sheetsRegex)).map((file2) => file2.content),
          drawingFiles: files.filter((file2) => file2.path.match(drawingsRegex)).map((file2) => file2.content),
          chartFiles: files.filter((file2) => file2.path.match(chartsRegex)).map((file2) => file2.content),
          sharedStringsFile: files.filter((file2) => file2.path == stringsFilePath).map((file2) => file2.content)[0]
        };
      }).then((xmlContentFilesObject) => {
        let responseText = [];
        function isValidInlineStringCNode(cNode) {
          if (cNode.tagName.toLowerCase() != "c")
            return false;
          if (cNode.getAttribute("t") != "inlineStr")
            return false;
          const childNodesNamedIs = cNode.getElementsByTagName("is");
          if (childNodesNamedIs.length != 1)
            return false;
          const childNodesNamedT = childNodesNamedIs[0].getElementsByTagName("t");
          if (childNodesNamedT.length != 1)
            return false;
          return childNodesNamedT[0].childNodes[0] && childNodesNamedT[0].childNodes[0].nodeValue != "";
        }
        function hasValidVNodeInCNode(cNode) {
          return cNode.getElementsByTagName("v")[0] && cNode.getElementsByTagName("v")[0].childNodes[0] && cNode.getElementsByTagName("v")[0].childNodes[0].nodeValue != "";
        }
        const sharedStringsXmlTNodesList = xmlContentFilesObject.sharedStringsFile != void 0 ? parseString(xmlContentFilesObject.sharedStringsFile).getElementsByTagName("t") : [];
        const sharedStrings = Array.from(sharedStringsXmlTNodesList).map((tNode) => {
          var _a;
          return ((_a = tNode.childNodes[0]) == null ? void 0 : _a.nodeValue) ?? "";
        });
        xmlContentFilesObject.sheetFiles.forEach((sheetXmlContent) => {
          const sheetsXmlCNodesList = parseString(sheetXmlContent).getElementsByTagName("c");
          responseText.push(
            Array.from(sheetsXmlCNodesList).filter((cNode) => isValidInlineStringCNode(cNode) || hasValidVNodeInCNode(cNode)).map((cNode) => {
              if (isValidInlineStringCNode(cNode))
                return cNode.getElementsByTagName("is")[0].getElementsByTagName("t")[0].childNodes[0].nodeValue;
              if (hasValidVNodeInCNode(cNode)) {
                const isIndexInSharedStrings = cNode.getAttribute("t") == "s";
                const value = parseInt(cNode.getElementsByTagName("v")[0].childNodes[0].nodeValue, 10);
                if (isIndexInSharedStrings && value >= sharedStrings.length)
                  throw ERRORMSG.fileCorrupted(file);
                return isIndexInSharedStrings ? sharedStrings[value] : value;
              }
              return "";
            }).join(config.newlineDelimiter ?? "\n")
          );
        });
        xmlContentFilesObject.drawingFiles.forEach((drawingXmlContent) => {
          const drawingsXmlParagraphNodesList = parseString(drawingXmlContent).getElementsByTagName("a:p");
          responseText.push(
            Array.from(drawingsXmlParagraphNodesList).filter((paragraphNode) => paragraphNode.getElementsByTagName("a:t").length != 0).map((paragraphNode) => {
              const xmlTextNodeList = paragraphNode.getElementsByTagName("a:t");
              return Array.from(xmlTextNodeList).filter((textNode) => textNode.childNodes[0] && textNode.childNodes[0].nodeValue).map((textNode) => textNode.childNodes[0].nodeValue).join("");
            }).join(config.newlineDelimiter ?? "\n")
          );
        });
        xmlContentFilesObject.chartFiles.forEach((chartXmlContent) => {
          const chartsXmlCVNodesList = parseString(chartXmlContent).getElementsByTagName("c:v");
          responseText.push(
            Array.from(chartsXmlCVNodesList).filter((cVNode) => cVNode.childNodes[0] && cVNode.childNodes[0].nodeValue).map((cVNode) => cVNode.childNodes[0].nodeValue).join(config.newlineDelimiter ?? "\n")
          );
        });
        callback(responseText.join(config.newlineDelimiter ?? "\n"), void 0);
      }).catch((e) => callback(void 0, e));
    }
    function parseOpenOffice(file, callback, config) {
      const mainContentFilePath = "content.xml";
      const objectContentFilesRegex = /Object \d+\/content.xml/g;
      extractFiles(file, (x) => x == mainContentFilePath || !!x.match(objectContentFilesRegex)).then((files) => {
        if (!files.map((file2) => file2.path).includes(mainContentFilePath))
          throw ERRORMSG.fileCorrupted(file);
        return {
          mainContentFile: files.filter((file2) => file2.path == mainContentFilePath).map((file2) => file2.content)[0],
          objectContentFiles: files.filter((file2) => file2.path.match(objectContentFilesRegex)).map((file2) => file2.content)
        };
      }).then((xmlContentFilesObject) => {
        let notesText = [];
        let responseText = [];
        const allowedTextTags = ["text:p", "text:h"];
        const notesTag = "presentation:notes";
        function extractAllTextsFromNode(root) {
          let xmlTextArray = [];
          for (let i = 0; i < root.childNodes.length; i++)
            traversal(root.childNodes[i], xmlTextArray, true);
          return xmlTextArray.join("");
        }
        function traversal(node, xmlTextArray, isFirstRecursion) {
          if (!node.childNodes || node.childNodes.length == 0) {
            if (node.parentNode.tagName.indexOf("text") == 0 && node.nodeValue) {
              if (isNotesNode(node.parentNode) && (config.putNotesAtLast || config.ignoreNotes)) {
                notesText.push(node.nodeValue);
                if (allowedTextTags.includes(node.parentNode.tagName) && !isFirstRecursion)
                  notesText.push(config.newlineDelimiter ?? "\n");
              } else {
                xmlTextArray.push(node.nodeValue);
                if (allowedTextTags.includes(node.parentNode.tagName) && !isFirstRecursion)
                  xmlTextArray.push(config.newlineDelimiter ?? "\n");
              }
            }
            return;
          }
          for (let i = 0; i < node.childNodes.length; i++)
            traversal(node.childNodes[i], xmlTextArray, false);
        }
        function isNotesNode(node) {
          if (node.tagName == notesTag)
            return true;
          if (node.parentNode)
            return isNotesNode(node.parentNode);
          return false;
        }
        function isInvalidTextNode(node) {
          if (allowedTextTags.includes(node.tagName))
            return true;
          if (node.parentNode)
            return isInvalidTextNode(node.parentNode);
          return false;
        }
        const xmlContentArray = [xmlContentFilesObject.mainContentFile, ...xmlContentFilesObject.objectContentFiles].map((xmlContent) => parseString(xmlContent));
        xmlContentArray.forEach((xmlContent) => {
          const xmlTextNodesList = [
            ...Array.from(xmlContent.getElementsByTagName("*")).filter((node) => allowedTextTags.includes(node.tagName) && !isInvalidTextNode(node.parentNode))
          ];
          responseText.push(
            xmlTextNodesList.map((textNode) => extractAllTextsFromNode(textNode)).filter((text) => text != "").join(config.newlineDelimiter ?? "\n")
          );
        });
        if (!config.ignoreNotes && config.putNotesAtLast)
          responseText = [...responseText, ...notesText];
        callback(responseText.join(config.newlineDelimiter ?? "\n"), void 0);
      }).catch((e) => callback(void 0, e));
    }
    function parsePdf(file, callback, config) {
      pdfjs.getDocument(file).promise.then((document2) => Promise.all(Array.from({ length: document2.numPages }, (_, index) => index + 1).map((pageNr) => document2.getPage(pageNr).then((page) => page.getTextContent())))).then((textContentArray) => {
        const responseText = textContentArray.map((textContent) => textContent.items).flat().filter((item) => item.str != "").reduce(
          (a, v) => ({
            text: a.text + (v.transform[5] != a.transform5 ? config.newlineDelimiter ?? "\n" : "") + v.str,
            transform5: v.transform[5]
          }),
          {
            text: "",
            transform5: void 0
          }
        ).text;
        callback(responseText, void 0);
      }).catch((e) => callback(void 0, e));
    }
    function parseOffice(srcFile, callback, config = {}) {
      const internalConfig = {
        ignoreNotes: false,
        newlineDelimiter: "\n",
        putNotesAtLast: false,
        outputErrorToConsole: false,
        ...config
      };
      let file = srcFile instanceof ArrayBuffer ? Buffer.from(srcFile) : srcFile;
      const filePreparedPromise = new Promise((res, rej) => {
        if (Buffer.isBuffer(file))
          return fileType2.fromBuffer(file).then((data) => res({ file, ext: data.ext.toLowerCase() })).catch(() => rej(ERRORMSG.improperBuffers));
        else if (typeof file === "string") {
          if (!fs.existsSync(file))
            throw ERRORMSG.fileDoesNotExist(file);
          res({ file, ext: file.split(".").pop() });
        } else
          rej(ERRORMSG.invalidInput);
      });
      filePreparedPromise.then(({ file: file2, ext }) => {
        switch (ext) {
          case "docx":
            parseWord(file2, internalCallback, internalConfig);
            break;
          case "pptx":
            parsePowerPoint(file2, internalCallback, internalConfig);
            break;
          case "xlsx":
            parseExcel(file2, internalCallback, internalConfig);
            break;
          case "odt":
          case "odp":
          case "ods":
            parseOpenOffice(file2, internalCallback, internalConfig);
            break;
          case "pdf":
            parsePdf(file2, internalCallback, internalConfig);
            break;
          default:
            internalCallback(void 0, ERRORMSG.extensionUnsupported(ext));
        }
        function internalCallback(data, err) {
          if (err)
            return handleError(err, callback, internalConfig.outputErrorToConsole);
          callback(data, void 0);
        }
      }).catch((error) => handleError(error, callback, internalConfig.outputErrorToConsole));
    }
    function parseOfficeAsync(srcFile, config = {}) {
      return new Promise((res, rej) => {
        parseOffice(srcFile, function(data, err) {
          if (err)
            return rej(err);
          return res(data);
        }, config);
      });
    }
    function extractFiles(zipInput, filterFn) {
      return new Promise((res, rej) => {
        const processZipfile = (zipfile) => {
          const extractedFiles = [];
          zipfile.readEntry();
          function processEntry(entry) {
            if (filterFn(entry.fileName)) {
              zipfile.openReadStream(entry, (err, readStream) => {
                if (err)
                  return rej(err);
                readStream.pipe(concat((data) => {
                  extractedFiles.push({
                    path: entry.fileName,
                    content: data.toString()
                  });
                  zipfile.readEntry();
                }));
              });
            } else
              zipfile.readEntry();
          }
          zipfile.on("entry", processEntry);
          zipfile.on("end", () => res(extractedFiles));
          zipfile.on("error", rej);
        };
        if (Buffer.isBuffer(zipInput)) {
          yauzl.fromBuffer(zipInput, { lazyEntries: true }, (err, zipfile) => {
            if (err) return rej(err);
            processZipfile(zipfile);
          });
        } else if (typeof zipInput === "string") {
          yauzl.open(zipInput, { lazyEntries: true }, (err, zipfile) => {
            if (err) return rej(err);
            processZipfile(zipfile);
          });
        } else
          rej(ERRORMSG.invalidInput);
      });
    }
    function handleError(error, callback, outputErrorToConsole) {
      if (error && outputErrorToConsole)
        console.error(ERRORHEADER + error);
      callback(void 0, new Error(ERRORHEADER + error));
    }
    module2.exports.parseOffice = parseOffice;
    module2.exports.parseOfficeAsync = parseOfficeAsync;
    if (typeof process.argv[0] == "string" && (process.argv[0].split("/").pop() == "node" || process.argv[0].split("/").pop() == "npx") && (typeof process.argv[1] == "string" && (process.argv[1].split("/").pop() == "officeParser.js" || process.argv[1].split("/").pop().toLowerCase() == "officeparser"))) {
      let isConfigOption2 = function(arg) {
        return arg.startsWith("--") && arg.includes("=");
      };
      isConfigOption = isConfigOption2;
      const args = process.argv.slice(2);
      let fileArg = void 0;
      const configArgs = [];
      args.forEach((arg) => {
        if (isConfigOption2(arg))
          configArgs.push(arg);
        else if (!fileArg)
          fileArg = arg;
      });
      if (fileArg != void 0) {
        let parseCLIConfigArgs2 = function(args2) {
          const config2 = {};
          args2.forEach((arg) => {
            const [key, value] = arg.split("=");
            switch (key) {
              case "--ignoreNotes":
                config2.ignoreNotes = value.toLowerCase() === "true";
                break;
              case "--newlineDelimiter":
                config2.newlineDelimiter = value;
                break;
              case "--putNotesAtLast":
                config2.putNotesAtLast = value.toLowerCase() === "true";
                break;
              case "--outputErrorToConsole":
                config2.outputErrorToConsole = value.toLowerCase() === "true";
                break;
            }
          });
          return config2;
        };
        parseCLIConfigArgs = parseCLIConfigArgs2;
        const config = parseCLIConfigArgs2(configArgs);
        parseOfficeAsync(fileArg, config).then((text) => console.log(text)).catch((error) => console.error(ERRORHEADER + error));
      } else {
        console.error(ERRORMSG.improperArguments);
        const CLI_INSTRUCTIONS = `
=== How to Use officeParser CLI ===

Usage:
    node officeparser [--configOption=value] [FILE_PATH]

Example:
    node officeparser --ignoreNotes=true --putNotesAtLast=true ./example.docx

Config Options:
    --ignoreNotes=[true|false]          Flag to ignore notes from files like PowerPoint. Default is false.
    --newlineDelimiter=[delimiter]      The delimiter to use for new lines. Default is '\\n'.
    --putNotesAtLast=[true|false]       Flag to collect notes at the end of files like PowerPoint. Default is false.
    --outputErrorToConsole=[true|false] Flag to output errors to the console. Default is false.

Note:
    The order of file path and config options doesn't matter.
`;
        console.log(CLI_INSTRUCTIONS);
      }
    }
    var parseCLIConfigArgs;
    var isConfigOption;
  }
});
export default require_officeParser();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=officeparser.js.map
